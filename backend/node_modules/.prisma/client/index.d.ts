
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model CenterUser
 * 
 */
export type CenterUser = $Result.DefaultSelection<Prisma.$CenterUserPayload>
/**
 * Model HealthcareUser
 * 
 */
export type HealthcareUser = $Result.DefaultSelection<Prisma.$HealthcareUserPayload>
/**
 * Model HealthcareLocation
 * 
 */
export type HealthcareLocation = $Result.DefaultSelection<Prisma.$HealthcareLocationPayload>
/**
 * Model Hospital
 * 
 */
export type Hospital = $Result.DefaultSelection<Prisma.$HospitalPayload>
/**
 * Model EMSUser
 * 
 */
export type EMSUser = $Result.DefaultSelection<Prisma.$EMSUserPayload>
/**
 * Model EMSAgency
 * 
 */
export type EMSAgency = $Result.DefaultSelection<Prisma.$EMSAgencyPayload>
/**
 * Model Trip
 * 
 */
export type Trip = $Result.DefaultSelection<Prisma.$TripPayload>
/**
 * Model AgencyResponse
 * 
 */
export type AgencyResponse = $Result.DefaultSelection<Prisma.$AgencyResponsePayload>
/**
 * Model SystemAnalytics
 * 
 */
export type SystemAnalytics = $Result.DefaultSelection<Prisma.$SystemAnalyticsPayload>
/**
 * Model TripCostBreakdown
 * 
 */
export type TripCostBreakdown = $Result.DefaultSelection<Prisma.$TripCostBreakdownPayload>
/**
 * Model CostCenter
 * 
 */
export type CostCenter = $Result.DefaultSelection<Prisma.$CostCenterPayload>
/**
 * Model backhaul_opportunities
 * 
 */
export type backhaul_opportunities = $Result.DefaultSelection<Prisma.$backhaul_opportunitiesPayload>
/**
 * Model pickup_locations
 * 
 */
export type pickup_locations = $Result.DefaultSelection<Prisma.$pickup_locationsPayload>
/**
 * Model pricing_models
 * 
 */
export type pricing_models = $Result.DefaultSelection<Prisma.$pricing_modelsPayload>
/**
 * Model route_optimization_settings
 * 
 */
export type route_optimization_settings = $Result.DefaultSelection<Prisma.$route_optimization_settingsPayload>
/**
 * Model Unit
 * 
 */
export type Unit = $Result.DefaultSelection<Prisma.$UnitPayload>
/**
 * Model unit_analytics
 * 
 */
export type unit_analytics = $Result.DefaultSelection<Prisma.$unit_analyticsPayload>
/**
 * Model NotificationPreference
 * 
 */
export type NotificationPreference = $Result.DefaultSelection<Prisma.$NotificationPreferencePayload>
/**
 * Model NotificationLog
 * 
 */
export type NotificationLog = $Result.DefaultSelection<Prisma.$NotificationLogPayload>
/**
 * Model DropdownOption
 * 
 */
export type DropdownOption = $Result.DefaultSelection<Prisma.$DropdownOptionPayload>
/**
 * Model CategoryDefault
 * 
 */
export type CategoryDefault = $Result.DefaultSelection<Prisma.$CategoryDefaultPayload>
/**
 * Model TransportRequest
 * 
 */
export type TransportRequest = $Result.DefaultSelection<Prisma.$TransportRequestPayload>
/**
 * Model Facility
 * 
 */
export type Facility = $Result.DefaultSelection<Prisma.$FacilityPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more CenterUsers
 * const centerUsers = await prisma.centerUser.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more CenterUsers
   * const centerUsers = await prisma.centerUser.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.centerUser`: Exposes CRUD operations for the **CenterUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CenterUsers
    * const centerUsers = await prisma.centerUser.findMany()
    * ```
    */
  get centerUser(): Prisma.CenterUserDelegate<ExtArgs>;

  /**
   * `prisma.healthcareUser`: Exposes CRUD operations for the **HealthcareUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HealthcareUsers
    * const healthcareUsers = await prisma.healthcareUser.findMany()
    * ```
    */
  get healthcareUser(): Prisma.HealthcareUserDelegate<ExtArgs>;

  /**
   * `prisma.healthcareLocation`: Exposes CRUD operations for the **HealthcareLocation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HealthcareLocations
    * const healthcareLocations = await prisma.healthcareLocation.findMany()
    * ```
    */
  get healthcareLocation(): Prisma.HealthcareLocationDelegate<ExtArgs>;

  /**
   * `prisma.hospital`: Exposes CRUD operations for the **Hospital** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Hospitals
    * const hospitals = await prisma.hospital.findMany()
    * ```
    */
  get hospital(): Prisma.HospitalDelegate<ExtArgs>;

  /**
   * `prisma.eMSUser`: Exposes CRUD operations for the **EMSUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EMSUsers
    * const eMSUsers = await prisma.eMSUser.findMany()
    * ```
    */
  get eMSUser(): Prisma.EMSUserDelegate<ExtArgs>;

  /**
   * `prisma.eMSAgency`: Exposes CRUD operations for the **EMSAgency** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EMSAgencies
    * const eMSAgencies = await prisma.eMSAgency.findMany()
    * ```
    */
  get eMSAgency(): Prisma.EMSAgencyDelegate<ExtArgs>;

  /**
   * `prisma.trip`: Exposes CRUD operations for the **Trip** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Trips
    * const trips = await prisma.trip.findMany()
    * ```
    */
  get trip(): Prisma.TripDelegate<ExtArgs>;

  /**
   * `prisma.agencyResponse`: Exposes CRUD operations for the **AgencyResponse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgencyResponses
    * const agencyResponses = await prisma.agencyResponse.findMany()
    * ```
    */
  get agencyResponse(): Prisma.AgencyResponseDelegate<ExtArgs>;

  /**
   * `prisma.systemAnalytics`: Exposes CRUD operations for the **SystemAnalytics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemAnalytics
    * const systemAnalytics = await prisma.systemAnalytics.findMany()
    * ```
    */
  get systemAnalytics(): Prisma.SystemAnalyticsDelegate<ExtArgs>;

  /**
   * `prisma.tripCostBreakdown`: Exposes CRUD operations for the **TripCostBreakdown** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TripCostBreakdowns
    * const tripCostBreakdowns = await prisma.tripCostBreakdown.findMany()
    * ```
    */
  get tripCostBreakdown(): Prisma.TripCostBreakdownDelegate<ExtArgs>;

  /**
   * `prisma.costCenter`: Exposes CRUD operations for the **CostCenter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CostCenters
    * const costCenters = await prisma.costCenter.findMany()
    * ```
    */
  get costCenter(): Prisma.CostCenterDelegate<ExtArgs>;

  /**
   * `prisma.backhaul_opportunities`: Exposes CRUD operations for the **backhaul_opportunities** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Backhaul_opportunities
    * const backhaul_opportunities = await prisma.backhaul_opportunities.findMany()
    * ```
    */
  get backhaul_opportunities(): Prisma.backhaul_opportunitiesDelegate<ExtArgs>;

  /**
   * `prisma.pickup_locations`: Exposes CRUD operations for the **pickup_locations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pickup_locations
    * const pickup_locations = await prisma.pickup_locations.findMany()
    * ```
    */
  get pickup_locations(): Prisma.pickup_locationsDelegate<ExtArgs>;

  /**
   * `prisma.pricing_models`: Exposes CRUD operations for the **pricing_models** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pricing_models
    * const pricing_models = await prisma.pricing_models.findMany()
    * ```
    */
  get pricing_models(): Prisma.pricing_modelsDelegate<ExtArgs>;

  /**
   * `prisma.route_optimization_settings`: Exposes CRUD operations for the **route_optimization_settings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Route_optimization_settings
    * const route_optimization_settings = await prisma.route_optimization_settings.findMany()
    * ```
    */
  get route_optimization_settings(): Prisma.route_optimization_settingsDelegate<ExtArgs>;

  /**
   * `prisma.unit`: Exposes CRUD operations for the **Unit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Units
    * const units = await prisma.unit.findMany()
    * ```
    */
  get unit(): Prisma.UnitDelegate<ExtArgs>;

  /**
   * `prisma.unit_analytics`: Exposes CRUD operations for the **unit_analytics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Unit_analytics
    * const unit_analytics = await prisma.unit_analytics.findMany()
    * ```
    */
  get unit_analytics(): Prisma.unit_analyticsDelegate<ExtArgs>;

  /**
   * `prisma.notificationPreference`: Exposes CRUD operations for the **NotificationPreference** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationPreferences
    * const notificationPreferences = await prisma.notificationPreference.findMany()
    * ```
    */
  get notificationPreference(): Prisma.NotificationPreferenceDelegate<ExtArgs>;

  /**
   * `prisma.notificationLog`: Exposes CRUD operations for the **NotificationLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationLogs
    * const notificationLogs = await prisma.notificationLog.findMany()
    * ```
    */
  get notificationLog(): Prisma.NotificationLogDelegate<ExtArgs>;

  /**
   * `prisma.dropdownOption`: Exposes CRUD operations for the **DropdownOption** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DropdownOptions
    * const dropdownOptions = await prisma.dropdownOption.findMany()
    * ```
    */
  get dropdownOption(): Prisma.DropdownOptionDelegate<ExtArgs>;

  /**
   * `prisma.categoryDefault`: Exposes CRUD operations for the **CategoryDefault** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CategoryDefaults
    * const categoryDefaults = await prisma.categoryDefault.findMany()
    * ```
    */
  get categoryDefault(): Prisma.CategoryDefaultDelegate<ExtArgs>;

  /**
   * `prisma.transportRequest`: Exposes CRUD operations for the **TransportRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TransportRequests
    * const transportRequests = await prisma.transportRequest.findMany()
    * ```
    */
  get transportRequest(): Prisma.TransportRequestDelegate<ExtArgs>;

  /**
   * `prisma.facility`: Exposes CRUD operations for the **Facility** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Facilities
    * const facilities = await prisma.facility.findMany()
    * ```
    */
  get facility(): Prisma.FacilityDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    CenterUser: 'CenterUser',
    HealthcareUser: 'HealthcareUser',
    HealthcareLocation: 'HealthcareLocation',
    Hospital: 'Hospital',
    EMSUser: 'EMSUser',
    EMSAgency: 'EMSAgency',
    Trip: 'Trip',
    AgencyResponse: 'AgencyResponse',
    SystemAnalytics: 'SystemAnalytics',
    TripCostBreakdown: 'TripCostBreakdown',
    CostCenter: 'CostCenter',
    backhaul_opportunities: 'backhaul_opportunities',
    pickup_locations: 'pickup_locations',
    pricing_models: 'pricing_models',
    route_optimization_settings: 'route_optimization_settings',
    Unit: 'Unit',
    unit_analytics: 'unit_analytics',
    NotificationPreference: 'NotificationPreference',
    NotificationLog: 'NotificationLog',
    DropdownOption: 'DropdownOption',
    CategoryDefault: 'CategoryDefault',
    TransportRequest: 'TransportRequest',
    Facility: 'Facility'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "centerUser" | "healthcareUser" | "healthcareLocation" | "hospital" | "eMSUser" | "eMSAgency" | "trip" | "agencyResponse" | "systemAnalytics" | "tripCostBreakdown" | "costCenter" | "backhaul_opportunities" | "pickup_locations" | "pricing_models" | "route_optimization_settings" | "unit" | "unit_analytics" | "notificationPreference" | "notificationLog" | "dropdownOption" | "categoryDefault" | "transportRequest" | "facility"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      CenterUser: {
        payload: Prisma.$CenterUserPayload<ExtArgs>
        fields: Prisma.CenterUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CenterUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CenterUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CenterUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CenterUserPayload>
          }
          findFirst: {
            args: Prisma.CenterUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CenterUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CenterUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CenterUserPayload>
          }
          findMany: {
            args: Prisma.CenterUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CenterUserPayload>[]
          }
          create: {
            args: Prisma.CenterUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CenterUserPayload>
          }
          createMany: {
            args: Prisma.CenterUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CenterUserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CenterUserPayload>[]
          }
          delete: {
            args: Prisma.CenterUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CenterUserPayload>
          }
          update: {
            args: Prisma.CenterUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CenterUserPayload>
          }
          deleteMany: {
            args: Prisma.CenterUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CenterUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CenterUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CenterUserPayload>
          }
          aggregate: {
            args: Prisma.CenterUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCenterUser>
          }
          groupBy: {
            args: Prisma.CenterUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<CenterUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.CenterUserCountArgs<ExtArgs>
            result: $Utils.Optional<CenterUserCountAggregateOutputType> | number
          }
        }
      }
      HealthcareUser: {
        payload: Prisma.$HealthcareUserPayload<ExtArgs>
        fields: Prisma.HealthcareUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HealthcareUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthcareUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HealthcareUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthcareUserPayload>
          }
          findFirst: {
            args: Prisma.HealthcareUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthcareUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HealthcareUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthcareUserPayload>
          }
          findMany: {
            args: Prisma.HealthcareUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthcareUserPayload>[]
          }
          create: {
            args: Prisma.HealthcareUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthcareUserPayload>
          }
          createMany: {
            args: Prisma.HealthcareUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HealthcareUserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthcareUserPayload>[]
          }
          delete: {
            args: Prisma.HealthcareUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthcareUserPayload>
          }
          update: {
            args: Prisma.HealthcareUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthcareUserPayload>
          }
          deleteMany: {
            args: Prisma.HealthcareUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HealthcareUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HealthcareUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthcareUserPayload>
          }
          aggregate: {
            args: Prisma.HealthcareUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHealthcareUser>
          }
          groupBy: {
            args: Prisma.HealthcareUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<HealthcareUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.HealthcareUserCountArgs<ExtArgs>
            result: $Utils.Optional<HealthcareUserCountAggregateOutputType> | number
          }
        }
      }
      HealthcareLocation: {
        payload: Prisma.$HealthcareLocationPayload<ExtArgs>
        fields: Prisma.HealthcareLocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HealthcareLocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthcareLocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HealthcareLocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthcareLocationPayload>
          }
          findFirst: {
            args: Prisma.HealthcareLocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthcareLocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HealthcareLocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthcareLocationPayload>
          }
          findMany: {
            args: Prisma.HealthcareLocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthcareLocationPayload>[]
          }
          create: {
            args: Prisma.HealthcareLocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthcareLocationPayload>
          }
          createMany: {
            args: Prisma.HealthcareLocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HealthcareLocationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthcareLocationPayload>[]
          }
          delete: {
            args: Prisma.HealthcareLocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthcareLocationPayload>
          }
          update: {
            args: Prisma.HealthcareLocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthcareLocationPayload>
          }
          deleteMany: {
            args: Prisma.HealthcareLocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HealthcareLocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HealthcareLocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthcareLocationPayload>
          }
          aggregate: {
            args: Prisma.HealthcareLocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHealthcareLocation>
          }
          groupBy: {
            args: Prisma.HealthcareLocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<HealthcareLocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.HealthcareLocationCountArgs<ExtArgs>
            result: $Utils.Optional<HealthcareLocationCountAggregateOutputType> | number
          }
        }
      }
      Hospital: {
        payload: Prisma.$HospitalPayload<ExtArgs>
        fields: Prisma.HospitalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HospitalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HospitalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalPayload>
          }
          findFirst: {
            args: Prisma.HospitalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HospitalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalPayload>
          }
          findMany: {
            args: Prisma.HospitalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalPayload>[]
          }
          create: {
            args: Prisma.HospitalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalPayload>
          }
          createMany: {
            args: Prisma.HospitalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HospitalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalPayload>[]
          }
          delete: {
            args: Prisma.HospitalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalPayload>
          }
          update: {
            args: Prisma.HospitalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalPayload>
          }
          deleteMany: {
            args: Prisma.HospitalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HospitalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HospitalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalPayload>
          }
          aggregate: {
            args: Prisma.HospitalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHospital>
          }
          groupBy: {
            args: Prisma.HospitalGroupByArgs<ExtArgs>
            result: $Utils.Optional<HospitalGroupByOutputType>[]
          }
          count: {
            args: Prisma.HospitalCountArgs<ExtArgs>
            result: $Utils.Optional<HospitalCountAggregateOutputType> | number
          }
        }
      }
      EMSUser: {
        payload: Prisma.$EMSUserPayload<ExtArgs>
        fields: Prisma.EMSUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EMSUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EMSUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EMSUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EMSUserPayload>
          }
          findFirst: {
            args: Prisma.EMSUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EMSUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EMSUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EMSUserPayload>
          }
          findMany: {
            args: Prisma.EMSUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EMSUserPayload>[]
          }
          create: {
            args: Prisma.EMSUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EMSUserPayload>
          }
          createMany: {
            args: Prisma.EMSUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EMSUserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EMSUserPayload>[]
          }
          delete: {
            args: Prisma.EMSUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EMSUserPayload>
          }
          update: {
            args: Prisma.EMSUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EMSUserPayload>
          }
          deleteMany: {
            args: Prisma.EMSUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EMSUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EMSUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EMSUserPayload>
          }
          aggregate: {
            args: Prisma.EMSUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEMSUser>
          }
          groupBy: {
            args: Prisma.EMSUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<EMSUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.EMSUserCountArgs<ExtArgs>
            result: $Utils.Optional<EMSUserCountAggregateOutputType> | number
          }
        }
      }
      EMSAgency: {
        payload: Prisma.$EMSAgencyPayload<ExtArgs>
        fields: Prisma.EMSAgencyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EMSAgencyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EMSAgencyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EMSAgencyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EMSAgencyPayload>
          }
          findFirst: {
            args: Prisma.EMSAgencyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EMSAgencyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EMSAgencyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EMSAgencyPayload>
          }
          findMany: {
            args: Prisma.EMSAgencyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EMSAgencyPayload>[]
          }
          create: {
            args: Prisma.EMSAgencyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EMSAgencyPayload>
          }
          createMany: {
            args: Prisma.EMSAgencyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EMSAgencyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EMSAgencyPayload>[]
          }
          delete: {
            args: Prisma.EMSAgencyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EMSAgencyPayload>
          }
          update: {
            args: Prisma.EMSAgencyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EMSAgencyPayload>
          }
          deleteMany: {
            args: Prisma.EMSAgencyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EMSAgencyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EMSAgencyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EMSAgencyPayload>
          }
          aggregate: {
            args: Prisma.EMSAgencyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEMSAgency>
          }
          groupBy: {
            args: Prisma.EMSAgencyGroupByArgs<ExtArgs>
            result: $Utils.Optional<EMSAgencyGroupByOutputType>[]
          }
          count: {
            args: Prisma.EMSAgencyCountArgs<ExtArgs>
            result: $Utils.Optional<EMSAgencyCountAggregateOutputType> | number
          }
        }
      }
      Trip: {
        payload: Prisma.$TripPayload<ExtArgs>
        fields: Prisma.TripFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TripFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TripFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>
          }
          findFirst: {
            args: Prisma.TripFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TripFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>
          }
          findMany: {
            args: Prisma.TripFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>[]
          }
          create: {
            args: Prisma.TripCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>
          }
          createMany: {
            args: Prisma.TripCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TripCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>[]
          }
          delete: {
            args: Prisma.TripDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>
          }
          update: {
            args: Prisma.TripUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>
          }
          deleteMany: {
            args: Prisma.TripDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TripUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TripUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>
          }
          aggregate: {
            args: Prisma.TripAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrip>
          }
          groupBy: {
            args: Prisma.TripGroupByArgs<ExtArgs>
            result: $Utils.Optional<TripGroupByOutputType>[]
          }
          count: {
            args: Prisma.TripCountArgs<ExtArgs>
            result: $Utils.Optional<TripCountAggregateOutputType> | number
          }
        }
      }
      AgencyResponse: {
        payload: Prisma.$AgencyResponsePayload<ExtArgs>
        fields: Prisma.AgencyResponseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgencyResponseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyResponsePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgencyResponseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyResponsePayload>
          }
          findFirst: {
            args: Prisma.AgencyResponseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyResponsePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgencyResponseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyResponsePayload>
          }
          findMany: {
            args: Prisma.AgencyResponseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyResponsePayload>[]
          }
          create: {
            args: Prisma.AgencyResponseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyResponsePayload>
          }
          createMany: {
            args: Prisma.AgencyResponseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgencyResponseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyResponsePayload>[]
          }
          delete: {
            args: Prisma.AgencyResponseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyResponsePayload>
          }
          update: {
            args: Prisma.AgencyResponseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyResponsePayload>
          }
          deleteMany: {
            args: Prisma.AgencyResponseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgencyResponseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AgencyResponseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyResponsePayload>
          }
          aggregate: {
            args: Prisma.AgencyResponseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgencyResponse>
          }
          groupBy: {
            args: Prisma.AgencyResponseGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgencyResponseGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgencyResponseCountArgs<ExtArgs>
            result: $Utils.Optional<AgencyResponseCountAggregateOutputType> | number
          }
        }
      }
      SystemAnalytics: {
        payload: Prisma.$SystemAnalyticsPayload<ExtArgs>
        fields: Prisma.SystemAnalyticsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemAnalyticsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemAnalyticsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemAnalyticsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemAnalyticsPayload>
          }
          findFirst: {
            args: Prisma.SystemAnalyticsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemAnalyticsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemAnalyticsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemAnalyticsPayload>
          }
          findMany: {
            args: Prisma.SystemAnalyticsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemAnalyticsPayload>[]
          }
          create: {
            args: Prisma.SystemAnalyticsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemAnalyticsPayload>
          }
          createMany: {
            args: Prisma.SystemAnalyticsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemAnalyticsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemAnalyticsPayload>[]
          }
          delete: {
            args: Prisma.SystemAnalyticsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemAnalyticsPayload>
          }
          update: {
            args: Prisma.SystemAnalyticsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemAnalyticsPayload>
          }
          deleteMany: {
            args: Prisma.SystemAnalyticsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemAnalyticsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SystemAnalyticsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemAnalyticsPayload>
          }
          aggregate: {
            args: Prisma.SystemAnalyticsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemAnalytics>
          }
          groupBy: {
            args: Prisma.SystemAnalyticsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemAnalyticsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemAnalyticsCountArgs<ExtArgs>
            result: $Utils.Optional<SystemAnalyticsCountAggregateOutputType> | number
          }
        }
      }
      TripCostBreakdown: {
        payload: Prisma.$TripCostBreakdownPayload<ExtArgs>
        fields: Prisma.TripCostBreakdownFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TripCostBreakdownFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripCostBreakdownPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TripCostBreakdownFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripCostBreakdownPayload>
          }
          findFirst: {
            args: Prisma.TripCostBreakdownFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripCostBreakdownPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TripCostBreakdownFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripCostBreakdownPayload>
          }
          findMany: {
            args: Prisma.TripCostBreakdownFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripCostBreakdownPayload>[]
          }
          create: {
            args: Prisma.TripCostBreakdownCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripCostBreakdownPayload>
          }
          createMany: {
            args: Prisma.TripCostBreakdownCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TripCostBreakdownCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripCostBreakdownPayload>[]
          }
          delete: {
            args: Prisma.TripCostBreakdownDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripCostBreakdownPayload>
          }
          update: {
            args: Prisma.TripCostBreakdownUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripCostBreakdownPayload>
          }
          deleteMany: {
            args: Prisma.TripCostBreakdownDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TripCostBreakdownUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TripCostBreakdownUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripCostBreakdownPayload>
          }
          aggregate: {
            args: Prisma.TripCostBreakdownAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTripCostBreakdown>
          }
          groupBy: {
            args: Prisma.TripCostBreakdownGroupByArgs<ExtArgs>
            result: $Utils.Optional<TripCostBreakdownGroupByOutputType>[]
          }
          count: {
            args: Prisma.TripCostBreakdownCountArgs<ExtArgs>
            result: $Utils.Optional<TripCostBreakdownCountAggregateOutputType> | number
          }
        }
      }
      CostCenter: {
        payload: Prisma.$CostCenterPayload<ExtArgs>
        fields: Prisma.CostCenterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CostCenterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostCenterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CostCenterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostCenterPayload>
          }
          findFirst: {
            args: Prisma.CostCenterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostCenterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CostCenterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostCenterPayload>
          }
          findMany: {
            args: Prisma.CostCenterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostCenterPayload>[]
          }
          create: {
            args: Prisma.CostCenterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostCenterPayload>
          }
          createMany: {
            args: Prisma.CostCenterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CostCenterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostCenterPayload>[]
          }
          delete: {
            args: Prisma.CostCenterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostCenterPayload>
          }
          update: {
            args: Prisma.CostCenterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostCenterPayload>
          }
          deleteMany: {
            args: Prisma.CostCenterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CostCenterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CostCenterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostCenterPayload>
          }
          aggregate: {
            args: Prisma.CostCenterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCostCenter>
          }
          groupBy: {
            args: Prisma.CostCenterGroupByArgs<ExtArgs>
            result: $Utils.Optional<CostCenterGroupByOutputType>[]
          }
          count: {
            args: Prisma.CostCenterCountArgs<ExtArgs>
            result: $Utils.Optional<CostCenterCountAggregateOutputType> | number
          }
        }
      }
      backhaul_opportunities: {
        payload: Prisma.$backhaul_opportunitiesPayload<ExtArgs>
        fields: Prisma.backhaul_opportunitiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.backhaul_opportunitiesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$backhaul_opportunitiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.backhaul_opportunitiesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$backhaul_opportunitiesPayload>
          }
          findFirst: {
            args: Prisma.backhaul_opportunitiesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$backhaul_opportunitiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.backhaul_opportunitiesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$backhaul_opportunitiesPayload>
          }
          findMany: {
            args: Prisma.backhaul_opportunitiesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$backhaul_opportunitiesPayload>[]
          }
          create: {
            args: Prisma.backhaul_opportunitiesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$backhaul_opportunitiesPayload>
          }
          createMany: {
            args: Prisma.backhaul_opportunitiesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.backhaul_opportunitiesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$backhaul_opportunitiesPayload>[]
          }
          delete: {
            args: Prisma.backhaul_opportunitiesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$backhaul_opportunitiesPayload>
          }
          update: {
            args: Prisma.backhaul_opportunitiesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$backhaul_opportunitiesPayload>
          }
          deleteMany: {
            args: Prisma.backhaul_opportunitiesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.backhaul_opportunitiesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.backhaul_opportunitiesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$backhaul_opportunitiesPayload>
          }
          aggregate: {
            args: Prisma.Backhaul_opportunitiesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBackhaul_opportunities>
          }
          groupBy: {
            args: Prisma.backhaul_opportunitiesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Backhaul_opportunitiesGroupByOutputType>[]
          }
          count: {
            args: Prisma.backhaul_opportunitiesCountArgs<ExtArgs>
            result: $Utils.Optional<Backhaul_opportunitiesCountAggregateOutputType> | number
          }
        }
      }
      pickup_locations: {
        payload: Prisma.$pickup_locationsPayload<ExtArgs>
        fields: Prisma.pickup_locationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.pickup_locationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pickup_locationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.pickup_locationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pickup_locationsPayload>
          }
          findFirst: {
            args: Prisma.pickup_locationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pickup_locationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.pickup_locationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pickup_locationsPayload>
          }
          findMany: {
            args: Prisma.pickup_locationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pickup_locationsPayload>[]
          }
          create: {
            args: Prisma.pickup_locationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pickup_locationsPayload>
          }
          createMany: {
            args: Prisma.pickup_locationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.pickup_locationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pickup_locationsPayload>[]
          }
          delete: {
            args: Prisma.pickup_locationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pickup_locationsPayload>
          }
          update: {
            args: Prisma.pickup_locationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pickup_locationsPayload>
          }
          deleteMany: {
            args: Prisma.pickup_locationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.pickup_locationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.pickup_locationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pickup_locationsPayload>
          }
          aggregate: {
            args: Prisma.Pickup_locationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePickup_locations>
          }
          groupBy: {
            args: Prisma.pickup_locationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Pickup_locationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.pickup_locationsCountArgs<ExtArgs>
            result: $Utils.Optional<Pickup_locationsCountAggregateOutputType> | number
          }
        }
      }
      pricing_models: {
        payload: Prisma.$pricing_modelsPayload<ExtArgs>
        fields: Prisma.pricing_modelsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.pricing_modelsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pricing_modelsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.pricing_modelsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pricing_modelsPayload>
          }
          findFirst: {
            args: Prisma.pricing_modelsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pricing_modelsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.pricing_modelsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pricing_modelsPayload>
          }
          findMany: {
            args: Prisma.pricing_modelsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pricing_modelsPayload>[]
          }
          create: {
            args: Prisma.pricing_modelsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pricing_modelsPayload>
          }
          createMany: {
            args: Prisma.pricing_modelsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.pricing_modelsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pricing_modelsPayload>[]
          }
          delete: {
            args: Prisma.pricing_modelsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pricing_modelsPayload>
          }
          update: {
            args: Prisma.pricing_modelsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pricing_modelsPayload>
          }
          deleteMany: {
            args: Prisma.pricing_modelsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.pricing_modelsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.pricing_modelsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pricing_modelsPayload>
          }
          aggregate: {
            args: Prisma.Pricing_modelsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePricing_models>
          }
          groupBy: {
            args: Prisma.pricing_modelsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Pricing_modelsGroupByOutputType>[]
          }
          count: {
            args: Prisma.pricing_modelsCountArgs<ExtArgs>
            result: $Utils.Optional<Pricing_modelsCountAggregateOutputType> | number
          }
        }
      }
      route_optimization_settings: {
        payload: Prisma.$route_optimization_settingsPayload<ExtArgs>
        fields: Prisma.route_optimization_settingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.route_optimization_settingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$route_optimization_settingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.route_optimization_settingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$route_optimization_settingsPayload>
          }
          findFirst: {
            args: Prisma.route_optimization_settingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$route_optimization_settingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.route_optimization_settingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$route_optimization_settingsPayload>
          }
          findMany: {
            args: Prisma.route_optimization_settingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$route_optimization_settingsPayload>[]
          }
          create: {
            args: Prisma.route_optimization_settingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$route_optimization_settingsPayload>
          }
          createMany: {
            args: Prisma.route_optimization_settingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.route_optimization_settingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$route_optimization_settingsPayload>[]
          }
          delete: {
            args: Prisma.route_optimization_settingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$route_optimization_settingsPayload>
          }
          update: {
            args: Prisma.route_optimization_settingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$route_optimization_settingsPayload>
          }
          deleteMany: {
            args: Prisma.route_optimization_settingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.route_optimization_settingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.route_optimization_settingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$route_optimization_settingsPayload>
          }
          aggregate: {
            args: Prisma.Route_optimization_settingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoute_optimization_settings>
          }
          groupBy: {
            args: Prisma.route_optimization_settingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Route_optimization_settingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.route_optimization_settingsCountArgs<ExtArgs>
            result: $Utils.Optional<Route_optimization_settingsCountAggregateOutputType> | number
          }
        }
      }
      Unit: {
        payload: Prisma.$UnitPayload<ExtArgs>
        fields: Prisma.UnitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          findFirst: {
            args: Prisma.UnitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          findMany: {
            args: Prisma.UnitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>[]
          }
          create: {
            args: Prisma.UnitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          createMany: {
            args: Prisma.UnitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UnitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>[]
          }
          delete: {
            args: Prisma.UnitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          update: {
            args: Prisma.UnitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          deleteMany: {
            args: Prisma.UnitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UnitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          aggregate: {
            args: Prisma.UnitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnit>
          }
          groupBy: {
            args: Prisma.UnitGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnitGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnitCountArgs<ExtArgs>
            result: $Utils.Optional<UnitCountAggregateOutputType> | number
          }
        }
      }
      unit_analytics: {
        payload: Prisma.$unit_analyticsPayload<ExtArgs>
        fields: Prisma.unit_analyticsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.unit_analyticsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$unit_analyticsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.unit_analyticsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$unit_analyticsPayload>
          }
          findFirst: {
            args: Prisma.unit_analyticsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$unit_analyticsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.unit_analyticsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$unit_analyticsPayload>
          }
          findMany: {
            args: Prisma.unit_analyticsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$unit_analyticsPayload>[]
          }
          create: {
            args: Prisma.unit_analyticsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$unit_analyticsPayload>
          }
          createMany: {
            args: Prisma.unit_analyticsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.unit_analyticsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$unit_analyticsPayload>[]
          }
          delete: {
            args: Prisma.unit_analyticsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$unit_analyticsPayload>
          }
          update: {
            args: Prisma.unit_analyticsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$unit_analyticsPayload>
          }
          deleteMany: {
            args: Prisma.unit_analyticsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.unit_analyticsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.unit_analyticsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$unit_analyticsPayload>
          }
          aggregate: {
            args: Prisma.Unit_analyticsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnit_analytics>
          }
          groupBy: {
            args: Prisma.unit_analyticsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Unit_analyticsGroupByOutputType>[]
          }
          count: {
            args: Prisma.unit_analyticsCountArgs<ExtArgs>
            result: $Utils.Optional<Unit_analyticsCountAggregateOutputType> | number
          }
        }
      }
      NotificationPreference: {
        payload: Prisma.$NotificationPreferencePayload<ExtArgs>
        fields: Prisma.NotificationPreferenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationPreferenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationPreferenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          findFirst: {
            args: Prisma.NotificationPreferenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationPreferenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          findMany: {
            args: Prisma.NotificationPreferenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>[]
          }
          create: {
            args: Prisma.NotificationPreferenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          createMany: {
            args: Prisma.NotificationPreferenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationPreferenceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>[]
          }
          delete: {
            args: Prisma.NotificationPreferenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          update: {
            args: Prisma.NotificationPreferenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          deleteMany: {
            args: Prisma.NotificationPreferenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationPreferenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationPreferenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          aggregate: {
            args: Prisma.NotificationPreferenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationPreference>
          }
          groupBy: {
            args: Prisma.NotificationPreferenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationPreferenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationPreferenceCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationPreferenceCountAggregateOutputType> | number
          }
        }
      }
      NotificationLog: {
        payload: Prisma.$NotificationLogPayload<ExtArgs>
        fields: Prisma.NotificationLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          findFirst: {
            args: Prisma.NotificationLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          findMany: {
            args: Prisma.NotificationLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>[]
          }
          create: {
            args: Prisma.NotificationLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          createMany: {
            args: Prisma.NotificationLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>[]
          }
          delete: {
            args: Prisma.NotificationLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          update: {
            args: Prisma.NotificationLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          deleteMany: {
            args: Prisma.NotificationLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          aggregate: {
            args: Prisma.NotificationLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationLog>
          }
          groupBy: {
            args: Prisma.NotificationLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationLogCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationLogCountAggregateOutputType> | number
          }
        }
      }
      DropdownOption: {
        payload: Prisma.$DropdownOptionPayload<ExtArgs>
        fields: Prisma.DropdownOptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DropdownOptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DropdownOptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DropdownOptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DropdownOptionPayload>
          }
          findFirst: {
            args: Prisma.DropdownOptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DropdownOptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DropdownOptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DropdownOptionPayload>
          }
          findMany: {
            args: Prisma.DropdownOptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DropdownOptionPayload>[]
          }
          create: {
            args: Prisma.DropdownOptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DropdownOptionPayload>
          }
          createMany: {
            args: Prisma.DropdownOptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DropdownOptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DropdownOptionPayload>[]
          }
          delete: {
            args: Prisma.DropdownOptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DropdownOptionPayload>
          }
          update: {
            args: Prisma.DropdownOptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DropdownOptionPayload>
          }
          deleteMany: {
            args: Prisma.DropdownOptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DropdownOptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DropdownOptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DropdownOptionPayload>
          }
          aggregate: {
            args: Prisma.DropdownOptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDropdownOption>
          }
          groupBy: {
            args: Prisma.DropdownOptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<DropdownOptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.DropdownOptionCountArgs<ExtArgs>
            result: $Utils.Optional<DropdownOptionCountAggregateOutputType> | number
          }
        }
      }
      CategoryDefault: {
        payload: Prisma.$CategoryDefaultPayload<ExtArgs>
        fields: Prisma.CategoryDefaultFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryDefaultFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryDefaultPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryDefaultFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryDefaultPayload>
          }
          findFirst: {
            args: Prisma.CategoryDefaultFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryDefaultPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryDefaultFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryDefaultPayload>
          }
          findMany: {
            args: Prisma.CategoryDefaultFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryDefaultPayload>[]
          }
          create: {
            args: Prisma.CategoryDefaultCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryDefaultPayload>
          }
          createMany: {
            args: Prisma.CategoryDefaultCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryDefaultCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryDefaultPayload>[]
          }
          delete: {
            args: Prisma.CategoryDefaultDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryDefaultPayload>
          }
          update: {
            args: Prisma.CategoryDefaultUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryDefaultPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDefaultDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryDefaultUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CategoryDefaultUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryDefaultPayload>
          }
          aggregate: {
            args: Prisma.CategoryDefaultAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategoryDefault>
          }
          groupBy: {
            args: Prisma.CategoryDefaultGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryDefaultGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryDefaultCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryDefaultCountAggregateOutputType> | number
          }
        }
      }
      TransportRequest: {
        payload: Prisma.$TransportRequestPayload<ExtArgs>
        fields: Prisma.TransportRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransportRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransportRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransportRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransportRequestPayload>
          }
          findFirst: {
            args: Prisma.TransportRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransportRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransportRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransportRequestPayload>
          }
          findMany: {
            args: Prisma.TransportRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransportRequestPayload>[]
          }
          create: {
            args: Prisma.TransportRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransportRequestPayload>
          }
          createMany: {
            args: Prisma.TransportRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransportRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransportRequestPayload>[]
          }
          delete: {
            args: Prisma.TransportRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransportRequestPayload>
          }
          update: {
            args: Prisma.TransportRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransportRequestPayload>
          }
          deleteMany: {
            args: Prisma.TransportRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransportRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TransportRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransportRequestPayload>
          }
          aggregate: {
            args: Prisma.TransportRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransportRequest>
          }
          groupBy: {
            args: Prisma.TransportRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransportRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransportRequestCountArgs<ExtArgs>
            result: $Utils.Optional<TransportRequestCountAggregateOutputType> | number
          }
        }
      }
      Facility: {
        payload: Prisma.$FacilityPayload<ExtArgs>
        fields: Prisma.FacilityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FacilityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FacilityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>
          }
          findFirst: {
            args: Prisma.FacilityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FacilityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>
          }
          findMany: {
            args: Prisma.FacilityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>[]
          }
          create: {
            args: Prisma.FacilityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>
          }
          createMany: {
            args: Prisma.FacilityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FacilityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>[]
          }
          delete: {
            args: Prisma.FacilityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>
          }
          update: {
            args: Prisma.FacilityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>
          }
          deleteMany: {
            args: Prisma.FacilityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FacilityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FacilityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>
          }
          aggregate: {
            args: Prisma.FacilityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFacility>
          }
          groupBy: {
            args: Prisma.FacilityGroupByArgs<ExtArgs>
            result: $Utils.Optional<FacilityGroupByOutputType>[]
          }
          count: {
            args: Prisma.FacilityCountArgs<ExtArgs>
            result: $Utils.Optional<FacilityCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CenterUserCountOutputType
   */

  export type CenterUserCountOutputType = {
    notificationLogs: number
    notificationPreferences: number
  }

  export type CenterUserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notificationLogs?: boolean | CenterUserCountOutputTypeCountNotificationLogsArgs
    notificationPreferences?: boolean | CenterUserCountOutputTypeCountNotificationPreferencesArgs
  }

  // Custom InputTypes
  /**
   * CenterUserCountOutputType without action
   */
  export type CenterUserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CenterUserCountOutputType
     */
    select?: CenterUserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CenterUserCountOutputType without action
   */
  export type CenterUserCountOutputTypeCountNotificationLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationLogWhereInput
  }

  /**
   * CenterUserCountOutputType without action
   */
  export type CenterUserCountOutputTypeCountNotificationPreferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationPreferenceWhereInput
  }


  /**
   * Count Type HealthcareUserCountOutputType
   */

  export type HealthcareUserCountOutputType = {
    locations: number
  }

  export type HealthcareUserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    locations?: boolean | HealthcareUserCountOutputTypeCountLocationsArgs
  }

  // Custom InputTypes
  /**
   * HealthcareUserCountOutputType without action
   */
  export type HealthcareUserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthcareUserCountOutputType
     */
    select?: HealthcareUserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HealthcareUserCountOutputType without action
   */
  export type HealthcareUserCountOutputTypeCountLocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HealthcareLocationWhereInput
  }


  /**
   * Count Type HealthcareLocationCountOutputType
   */

  export type HealthcareLocationCountOutputType = {
    transportRequests: number
  }

  export type HealthcareLocationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transportRequests?: boolean | HealthcareLocationCountOutputTypeCountTransportRequestsArgs
  }

  // Custom InputTypes
  /**
   * HealthcareLocationCountOutputType without action
   */
  export type HealthcareLocationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthcareLocationCountOutputType
     */
    select?: HealthcareLocationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HealthcareLocationCountOutputType without action
   */
  export type HealthcareLocationCountOutputTypeCountTransportRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransportRequestWhereInput
  }


  /**
   * Count Type EMSAgencyCountOutputType
   */

  export type EMSAgencyCountOutputType = {
    units: number
    users: number
  }

  export type EMSAgencyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    units?: boolean | EMSAgencyCountOutputTypeCountUnitsArgs
    users?: boolean | EMSAgencyCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * EMSAgencyCountOutputType without action
   */
  export type EMSAgencyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EMSAgencyCountOutputType
     */
    select?: EMSAgencyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EMSAgencyCountOutputType without action
   */
  export type EMSAgencyCountOutputTypeCountUnitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitWhereInput
  }

  /**
   * EMSAgencyCountOutputType without action
   */
  export type EMSAgencyCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EMSUserWhereInput
  }


  /**
   * Count Type TripCountOutputType
   */

  export type TripCountOutputType = {
    agencyResponses: number
  }

  export type TripCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agencyResponses?: boolean | TripCountOutputTypeCountAgencyResponsesArgs
  }

  // Custom InputTypes
  /**
   * TripCountOutputType without action
   */
  export type TripCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripCountOutputType
     */
    select?: TripCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TripCountOutputType without action
   */
  export type TripCountOutputTypeCountAgencyResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencyResponseWhereInput
  }


  /**
   * Count Type Pickup_locationsCountOutputType
   */

  export type Pickup_locationsCountOutputType = {
    trips: number
    legacyTrips: number
  }

  export type Pickup_locationsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trips?: boolean | Pickup_locationsCountOutputTypeCountTripsArgs
    legacyTrips?: boolean | Pickup_locationsCountOutputTypeCountLegacyTripsArgs
  }

  // Custom InputTypes
  /**
   * Pickup_locationsCountOutputType without action
   */
  export type Pickup_locationsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pickup_locationsCountOutputType
     */
    select?: Pickup_locationsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Pickup_locationsCountOutputType without action
   */
  export type Pickup_locationsCountOutputTypeCountTripsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransportRequestWhereInput
  }

  /**
   * Pickup_locationsCountOutputType without action
   */
  export type Pickup_locationsCountOutputTypeCountLegacyTripsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TripWhereInput
  }


  /**
   * Count Type UnitCountOutputType
   */

  export type UnitCountOutputType = {
    assignedTrips: number
  }

  export type UnitCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedTrips?: boolean | UnitCountOutputTypeCountAssignedTripsArgs
  }

  // Custom InputTypes
  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitCountOutputType
     */
    select?: UnitCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeCountAssignedTripsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransportRequestWhereInput
  }


  /**
   * Count Type FacilityCountOutputType
   */

  export type FacilityCountOutputType = {
    originTrips: number
    destinationTrips: number
  }

  export type FacilityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    originTrips?: boolean | FacilityCountOutputTypeCountOriginTripsArgs
    destinationTrips?: boolean | FacilityCountOutputTypeCountDestinationTripsArgs
  }

  // Custom InputTypes
  /**
   * FacilityCountOutputType without action
   */
  export type FacilityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityCountOutputType
     */
    select?: FacilityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FacilityCountOutputType without action
   */
  export type FacilityCountOutputTypeCountOriginTripsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransportRequestWhereInput
  }

  /**
   * FacilityCountOutputType without action
   */
  export type FacilityCountOutputTypeCountDestinationTripsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransportRequestWhereInput
  }


  /**
   * Models
   */

  /**
   * Model CenterUser
   */

  export type AggregateCenterUser = {
    _count: CenterUserCountAggregateOutputType | null
    _min: CenterUserMinAggregateOutputType | null
    _max: CenterUserMaxAggregateOutputType | null
  }

  export type CenterUserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    userType: string | null
    phone: string | null
    emailNotifications: boolean | null
    smsNotifications: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CenterUserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    userType: string | null
    phone: string | null
    emailNotifications: boolean | null
    smsNotifications: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CenterUserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    name: number
    userType: number
    phone: number
    emailNotifications: number
    smsNotifications: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CenterUserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    userType?: true
    phone?: true
    emailNotifications?: true
    smsNotifications?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CenterUserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    userType?: true
    phone?: true
    emailNotifications?: true
    smsNotifications?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CenterUserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    userType?: true
    phone?: true
    emailNotifications?: true
    smsNotifications?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CenterUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CenterUser to aggregate.
     */
    where?: CenterUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CenterUsers to fetch.
     */
    orderBy?: CenterUserOrderByWithRelationInput | CenterUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CenterUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CenterUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CenterUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CenterUsers
    **/
    _count?: true | CenterUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CenterUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CenterUserMaxAggregateInputType
  }

  export type GetCenterUserAggregateType<T extends CenterUserAggregateArgs> = {
        [P in keyof T & keyof AggregateCenterUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCenterUser[P]>
      : GetScalarType<T[P], AggregateCenterUser[P]>
  }




  export type CenterUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CenterUserWhereInput
    orderBy?: CenterUserOrderByWithAggregationInput | CenterUserOrderByWithAggregationInput[]
    by: CenterUserScalarFieldEnum[] | CenterUserScalarFieldEnum
    having?: CenterUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CenterUserCountAggregateInputType | true
    _min?: CenterUserMinAggregateInputType
    _max?: CenterUserMaxAggregateInputType
  }

  export type CenterUserGroupByOutputType = {
    id: string
    email: string
    password: string
    name: string
    userType: string
    phone: string | null
    emailNotifications: boolean
    smsNotifications: boolean
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: CenterUserCountAggregateOutputType | null
    _min: CenterUserMinAggregateOutputType | null
    _max: CenterUserMaxAggregateOutputType | null
  }

  type GetCenterUserGroupByPayload<T extends CenterUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CenterUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CenterUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CenterUserGroupByOutputType[P]>
            : GetScalarType<T[P], CenterUserGroupByOutputType[P]>
        }
      >
    >


  export type CenterUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    userType?: boolean
    phone?: boolean
    emailNotifications?: boolean
    smsNotifications?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    notificationLogs?: boolean | CenterUser$notificationLogsArgs<ExtArgs>
    notificationPreferences?: boolean | CenterUser$notificationPreferencesArgs<ExtArgs>
    _count?: boolean | CenterUserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["centerUser"]>

  export type CenterUserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    userType?: boolean
    phone?: boolean
    emailNotifications?: boolean
    smsNotifications?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["centerUser"]>

  export type CenterUserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    userType?: boolean
    phone?: boolean
    emailNotifications?: boolean
    smsNotifications?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CenterUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notificationLogs?: boolean | CenterUser$notificationLogsArgs<ExtArgs>
    notificationPreferences?: boolean | CenterUser$notificationPreferencesArgs<ExtArgs>
    _count?: boolean | CenterUserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CenterUserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CenterUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CenterUser"
    objects: {
      notificationLogs: Prisma.$NotificationLogPayload<ExtArgs>[]
      notificationPreferences: Prisma.$NotificationPreferencePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string
      name: string
      userType: string
      phone: string | null
      emailNotifications: boolean
      smsNotifications: boolean
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["centerUser"]>
    composites: {}
  }

  type CenterUserGetPayload<S extends boolean | null | undefined | CenterUserDefaultArgs> = $Result.GetResult<Prisma.$CenterUserPayload, S>

  type CenterUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CenterUserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CenterUserCountAggregateInputType | true
    }

  export interface CenterUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CenterUser'], meta: { name: 'CenterUser' } }
    /**
     * Find zero or one CenterUser that matches the filter.
     * @param {CenterUserFindUniqueArgs} args - Arguments to find a CenterUser
     * @example
     * // Get one CenterUser
     * const centerUser = await prisma.centerUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CenterUserFindUniqueArgs>(args: SelectSubset<T, CenterUserFindUniqueArgs<ExtArgs>>): Prisma__CenterUserClient<$Result.GetResult<Prisma.$CenterUserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CenterUser that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CenterUserFindUniqueOrThrowArgs} args - Arguments to find a CenterUser
     * @example
     * // Get one CenterUser
     * const centerUser = await prisma.centerUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CenterUserFindUniqueOrThrowArgs>(args: SelectSubset<T, CenterUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CenterUserClient<$Result.GetResult<Prisma.$CenterUserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CenterUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CenterUserFindFirstArgs} args - Arguments to find a CenterUser
     * @example
     * // Get one CenterUser
     * const centerUser = await prisma.centerUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CenterUserFindFirstArgs>(args?: SelectSubset<T, CenterUserFindFirstArgs<ExtArgs>>): Prisma__CenterUserClient<$Result.GetResult<Prisma.$CenterUserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CenterUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CenterUserFindFirstOrThrowArgs} args - Arguments to find a CenterUser
     * @example
     * // Get one CenterUser
     * const centerUser = await prisma.centerUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CenterUserFindFirstOrThrowArgs>(args?: SelectSubset<T, CenterUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__CenterUserClient<$Result.GetResult<Prisma.$CenterUserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CenterUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CenterUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CenterUsers
     * const centerUsers = await prisma.centerUser.findMany()
     * 
     * // Get first 10 CenterUsers
     * const centerUsers = await prisma.centerUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const centerUserWithIdOnly = await prisma.centerUser.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CenterUserFindManyArgs>(args?: SelectSubset<T, CenterUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CenterUserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CenterUser.
     * @param {CenterUserCreateArgs} args - Arguments to create a CenterUser.
     * @example
     * // Create one CenterUser
     * const CenterUser = await prisma.centerUser.create({
     *   data: {
     *     // ... data to create a CenterUser
     *   }
     * })
     * 
     */
    create<T extends CenterUserCreateArgs>(args: SelectSubset<T, CenterUserCreateArgs<ExtArgs>>): Prisma__CenterUserClient<$Result.GetResult<Prisma.$CenterUserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CenterUsers.
     * @param {CenterUserCreateManyArgs} args - Arguments to create many CenterUsers.
     * @example
     * // Create many CenterUsers
     * const centerUser = await prisma.centerUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CenterUserCreateManyArgs>(args?: SelectSubset<T, CenterUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CenterUsers and returns the data saved in the database.
     * @param {CenterUserCreateManyAndReturnArgs} args - Arguments to create many CenterUsers.
     * @example
     * // Create many CenterUsers
     * const centerUser = await prisma.centerUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CenterUsers and only return the `id`
     * const centerUserWithIdOnly = await prisma.centerUser.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CenterUserCreateManyAndReturnArgs>(args?: SelectSubset<T, CenterUserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CenterUserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CenterUser.
     * @param {CenterUserDeleteArgs} args - Arguments to delete one CenterUser.
     * @example
     * // Delete one CenterUser
     * const CenterUser = await prisma.centerUser.delete({
     *   where: {
     *     // ... filter to delete one CenterUser
     *   }
     * })
     * 
     */
    delete<T extends CenterUserDeleteArgs>(args: SelectSubset<T, CenterUserDeleteArgs<ExtArgs>>): Prisma__CenterUserClient<$Result.GetResult<Prisma.$CenterUserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CenterUser.
     * @param {CenterUserUpdateArgs} args - Arguments to update one CenterUser.
     * @example
     * // Update one CenterUser
     * const centerUser = await prisma.centerUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CenterUserUpdateArgs>(args: SelectSubset<T, CenterUserUpdateArgs<ExtArgs>>): Prisma__CenterUserClient<$Result.GetResult<Prisma.$CenterUserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CenterUsers.
     * @param {CenterUserDeleteManyArgs} args - Arguments to filter CenterUsers to delete.
     * @example
     * // Delete a few CenterUsers
     * const { count } = await prisma.centerUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CenterUserDeleteManyArgs>(args?: SelectSubset<T, CenterUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CenterUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CenterUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CenterUsers
     * const centerUser = await prisma.centerUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CenterUserUpdateManyArgs>(args: SelectSubset<T, CenterUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CenterUser.
     * @param {CenterUserUpsertArgs} args - Arguments to update or create a CenterUser.
     * @example
     * // Update or create a CenterUser
     * const centerUser = await prisma.centerUser.upsert({
     *   create: {
     *     // ... data to create a CenterUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CenterUser we want to update
     *   }
     * })
     */
    upsert<T extends CenterUserUpsertArgs>(args: SelectSubset<T, CenterUserUpsertArgs<ExtArgs>>): Prisma__CenterUserClient<$Result.GetResult<Prisma.$CenterUserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CenterUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CenterUserCountArgs} args - Arguments to filter CenterUsers to count.
     * @example
     * // Count the number of CenterUsers
     * const count = await prisma.centerUser.count({
     *   where: {
     *     // ... the filter for the CenterUsers we want to count
     *   }
     * })
    **/
    count<T extends CenterUserCountArgs>(
      args?: Subset<T, CenterUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CenterUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CenterUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CenterUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CenterUserAggregateArgs>(args: Subset<T, CenterUserAggregateArgs>): Prisma.PrismaPromise<GetCenterUserAggregateType<T>>

    /**
     * Group by CenterUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CenterUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CenterUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CenterUserGroupByArgs['orderBy'] }
        : { orderBy?: CenterUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CenterUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCenterUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CenterUser model
   */
  readonly fields: CenterUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CenterUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CenterUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    notificationLogs<T extends CenterUser$notificationLogsArgs<ExtArgs> = {}>(args?: Subset<T, CenterUser$notificationLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "findMany"> | Null>
    notificationPreferences<T extends CenterUser$notificationPreferencesArgs<ExtArgs> = {}>(args?: Subset<T, CenterUser$notificationPreferencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CenterUser model
   */ 
  interface CenterUserFieldRefs {
    readonly id: FieldRef<"CenterUser", 'String'>
    readonly email: FieldRef<"CenterUser", 'String'>
    readonly password: FieldRef<"CenterUser", 'String'>
    readonly name: FieldRef<"CenterUser", 'String'>
    readonly userType: FieldRef<"CenterUser", 'String'>
    readonly phone: FieldRef<"CenterUser", 'String'>
    readonly emailNotifications: FieldRef<"CenterUser", 'Boolean'>
    readonly smsNotifications: FieldRef<"CenterUser", 'Boolean'>
    readonly isActive: FieldRef<"CenterUser", 'Boolean'>
    readonly createdAt: FieldRef<"CenterUser", 'DateTime'>
    readonly updatedAt: FieldRef<"CenterUser", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CenterUser findUnique
   */
  export type CenterUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CenterUser
     */
    select?: CenterUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CenterUserInclude<ExtArgs> | null
    /**
     * Filter, which CenterUser to fetch.
     */
    where: CenterUserWhereUniqueInput
  }

  /**
   * CenterUser findUniqueOrThrow
   */
  export type CenterUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CenterUser
     */
    select?: CenterUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CenterUserInclude<ExtArgs> | null
    /**
     * Filter, which CenterUser to fetch.
     */
    where: CenterUserWhereUniqueInput
  }

  /**
   * CenterUser findFirst
   */
  export type CenterUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CenterUser
     */
    select?: CenterUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CenterUserInclude<ExtArgs> | null
    /**
     * Filter, which CenterUser to fetch.
     */
    where?: CenterUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CenterUsers to fetch.
     */
    orderBy?: CenterUserOrderByWithRelationInput | CenterUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CenterUsers.
     */
    cursor?: CenterUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CenterUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CenterUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CenterUsers.
     */
    distinct?: CenterUserScalarFieldEnum | CenterUserScalarFieldEnum[]
  }

  /**
   * CenterUser findFirstOrThrow
   */
  export type CenterUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CenterUser
     */
    select?: CenterUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CenterUserInclude<ExtArgs> | null
    /**
     * Filter, which CenterUser to fetch.
     */
    where?: CenterUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CenterUsers to fetch.
     */
    orderBy?: CenterUserOrderByWithRelationInput | CenterUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CenterUsers.
     */
    cursor?: CenterUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CenterUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CenterUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CenterUsers.
     */
    distinct?: CenterUserScalarFieldEnum | CenterUserScalarFieldEnum[]
  }

  /**
   * CenterUser findMany
   */
  export type CenterUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CenterUser
     */
    select?: CenterUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CenterUserInclude<ExtArgs> | null
    /**
     * Filter, which CenterUsers to fetch.
     */
    where?: CenterUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CenterUsers to fetch.
     */
    orderBy?: CenterUserOrderByWithRelationInput | CenterUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CenterUsers.
     */
    cursor?: CenterUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CenterUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CenterUsers.
     */
    skip?: number
    distinct?: CenterUserScalarFieldEnum | CenterUserScalarFieldEnum[]
  }

  /**
   * CenterUser create
   */
  export type CenterUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CenterUser
     */
    select?: CenterUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CenterUserInclude<ExtArgs> | null
    /**
     * The data needed to create a CenterUser.
     */
    data: XOR<CenterUserCreateInput, CenterUserUncheckedCreateInput>
  }

  /**
   * CenterUser createMany
   */
  export type CenterUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CenterUsers.
     */
    data: CenterUserCreateManyInput | CenterUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CenterUser createManyAndReturn
   */
  export type CenterUserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CenterUser
     */
    select?: CenterUserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CenterUsers.
     */
    data: CenterUserCreateManyInput | CenterUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CenterUser update
   */
  export type CenterUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CenterUser
     */
    select?: CenterUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CenterUserInclude<ExtArgs> | null
    /**
     * The data needed to update a CenterUser.
     */
    data: XOR<CenterUserUpdateInput, CenterUserUncheckedUpdateInput>
    /**
     * Choose, which CenterUser to update.
     */
    where: CenterUserWhereUniqueInput
  }

  /**
   * CenterUser updateMany
   */
  export type CenterUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CenterUsers.
     */
    data: XOR<CenterUserUpdateManyMutationInput, CenterUserUncheckedUpdateManyInput>
    /**
     * Filter which CenterUsers to update
     */
    where?: CenterUserWhereInput
  }

  /**
   * CenterUser upsert
   */
  export type CenterUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CenterUser
     */
    select?: CenterUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CenterUserInclude<ExtArgs> | null
    /**
     * The filter to search for the CenterUser to update in case it exists.
     */
    where: CenterUserWhereUniqueInput
    /**
     * In case the CenterUser found by the `where` argument doesn't exist, create a new CenterUser with this data.
     */
    create: XOR<CenterUserCreateInput, CenterUserUncheckedCreateInput>
    /**
     * In case the CenterUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CenterUserUpdateInput, CenterUserUncheckedUpdateInput>
  }

  /**
   * CenterUser delete
   */
  export type CenterUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CenterUser
     */
    select?: CenterUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CenterUserInclude<ExtArgs> | null
    /**
     * Filter which CenterUser to delete.
     */
    where: CenterUserWhereUniqueInput
  }

  /**
   * CenterUser deleteMany
   */
  export type CenterUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CenterUsers to delete
     */
    where?: CenterUserWhereInput
  }

  /**
   * CenterUser.notificationLogs
   */
  export type CenterUser$notificationLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    where?: NotificationLogWhereInput
    orderBy?: NotificationLogOrderByWithRelationInput | NotificationLogOrderByWithRelationInput[]
    cursor?: NotificationLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationLogScalarFieldEnum | NotificationLogScalarFieldEnum[]
  }

  /**
   * CenterUser.notificationPreferences
   */
  export type CenterUser$notificationPreferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    where?: NotificationPreferenceWhereInput
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    cursor?: NotificationPreferenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationPreferenceScalarFieldEnum | NotificationPreferenceScalarFieldEnum[]
  }

  /**
   * CenterUser without action
   */
  export type CenterUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CenterUser
     */
    select?: CenterUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CenterUserInclude<ExtArgs> | null
  }


  /**
   * Model HealthcareUser
   */

  export type AggregateHealthcareUser = {
    _count: HealthcareUserCountAggregateOutputType | null
    _min: HealthcareUserMinAggregateOutputType | null
    _max: HealthcareUserMaxAggregateOutputType | null
  }

  export type HealthcareUserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    facilityName: string | null
    facilityType: string | null
    userType: string | null
    isActive: boolean | null
    manageMultipleLocations: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HealthcareUserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    facilityName: string | null
    facilityType: string | null
    userType: string | null
    isActive: boolean | null
    manageMultipleLocations: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HealthcareUserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    name: number
    facilityName: number
    facilityType: number
    userType: number
    isActive: number
    manageMultipleLocations: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HealthcareUserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    facilityName?: true
    facilityType?: true
    userType?: true
    isActive?: true
    manageMultipleLocations?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HealthcareUserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    facilityName?: true
    facilityType?: true
    userType?: true
    isActive?: true
    manageMultipleLocations?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HealthcareUserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    facilityName?: true
    facilityType?: true
    userType?: true
    isActive?: true
    manageMultipleLocations?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HealthcareUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HealthcareUser to aggregate.
     */
    where?: HealthcareUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthcareUsers to fetch.
     */
    orderBy?: HealthcareUserOrderByWithRelationInput | HealthcareUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HealthcareUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthcareUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthcareUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HealthcareUsers
    **/
    _count?: true | HealthcareUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HealthcareUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HealthcareUserMaxAggregateInputType
  }

  export type GetHealthcareUserAggregateType<T extends HealthcareUserAggregateArgs> = {
        [P in keyof T & keyof AggregateHealthcareUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHealthcareUser[P]>
      : GetScalarType<T[P], AggregateHealthcareUser[P]>
  }




  export type HealthcareUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HealthcareUserWhereInput
    orderBy?: HealthcareUserOrderByWithAggregationInput | HealthcareUserOrderByWithAggregationInput[]
    by: HealthcareUserScalarFieldEnum[] | HealthcareUserScalarFieldEnum
    having?: HealthcareUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HealthcareUserCountAggregateInputType | true
    _min?: HealthcareUserMinAggregateInputType
    _max?: HealthcareUserMaxAggregateInputType
  }

  export type HealthcareUserGroupByOutputType = {
    id: string
    email: string
    password: string
    name: string
    facilityName: string
    facilityType: string
    userType: string
    isActive: boolean
    manageMultipleLocations: boolean
    createdAt: Date
    updatedAt: Date
    _count: HealthcareUserCountAggregateOutputType | null
    _min: HealthcareUserMinAggregateOutputType | null
    _max: HealthcareUserMaxAggregateOutputType | null
  }

  type GetHealthcareUserGroupByPayload<T extends HealthcareUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HealthcareUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HealthcareUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HealthcareUserGroupByOutputType[P]>
            : GetScalarType<T[P], HealthcareUserGroupByOutputType[P]>
        }
      >
    >


  export type HealthcareUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    facilityName?: boolean
    facilityType?: boolean
    userType?: boolean
    isActive?: boolean
    manageMultipleLocations?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    locations?: boolean | HealthcareUser$locationsArgs<ExtArgs>
    _count?: boolean | HealthcareUserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["healthcareUser"]>

  export type HealthcareUserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    facilityName?: boolean
    facilityType?: boolean
    userType?: boolean
    isActive?: boolean
    manageMultipleLocations?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["healthcareUser"]>

  export type HealthcareUserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    facilityName?: boolean
    facilityType?: boolean
    userType?: boolean
    isActive?: boolean
    manageMultipleLocations?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HealthcareUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    locations?: boolean | HealthcareUser$locationsArgs<ExtArgs>
    _count?: boolean | HealthcareUserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type HealthcareUserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $HealthcareUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HealthcareUser"
    objects: {
      locations: Prisma.$HealthcareLocationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string
      name: string
      facilityName: string
      facilityType: string
      userType: string
      isActive: boolean
      manageMultipleLocations: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["healthcareUser"]>
    composites: {}
  }

  type HealthcareUserGetPayload<S extends boolean | null | undefined | HealthcareUserDefaultArgs> = $Result.GetResult<Prisma.$HealthcareUserPayload, S>

  type HealthcareUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HealthcareUserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HealthcareUserCountAggregateInputType | true
    }

  export interface HealthcareUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HealthcareUser'], meta: { name: 'HealthcareUser' } }
    /**
     * Find zero or one HealthcareUser that matches the filter.
     * @param {HealthcareUserFindUniqueArgs} args - Arguments to find a HealthcareUser
     * @example
     * // Get one HealthcareUser
     * const healthcareUser = await prisma.healthcareUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HealthcareUserFindUniqueArgs>(args: SelectSubset<T, HealthcareUserFindUniqueArgs<ExtArgs>>): Prisma__HealthcareUserClient<$Result.GetResult<Prisma.$HealthcareUserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one HealthcareUser that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HealthcareUserFindUniqueOrThrowArgs} args - Arguments to find a HealthcareUser
     * @example
     * // Get one HealthcareUser
     * const healthcareUser = await prisma.healthcareUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HealthcareUserFindUniqueOrThrowArgs>(args: SelectSubset<T, HealthcareUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HealthcareUserClient<$Result.GetResult<Prisma.$HealthcareUserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first HealthcareUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthcareUserFindFirstArgs} args - Arguments to find a HealthcareUser
     * @example
     * // Get one HealthcareUser
     * const healthcareUser = await prisma.healthcareUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HealthcareUserFindFirstArgs>(args?: SelectSubset<T, HealthcareUserFindFirstArgs<ExtArgs>>): Prisma__HealthcareUserClient<$Result.GetResult<Prisma.$HealthcareUserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first HealthcareUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthcareUserFindFirstOrThrowArgs} args - Arguments to find a HealthcareUser
     * @example
     * // Get one HealthcareUser
     * const healthcareUser = await prisma.healthcareUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HealthcareUserFindFirstOrThrowArgs>(args?: SelectSubset<T, HealthcareUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__HealthcareUserClient<$Result.GetResult<Prisma.$HealthcareUserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more HealthcareUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthcareUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HealthcareUsers
     * const healthcareUsers = await prisma.healthcareUser.findMany()
     * 
     * // Get first 10 HealthcareUsers
     * const healthcareUsers = await prisma.healthcareUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const healthcareUserWithIdOnly = await prisma.healthcareUser.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HealthcareUserFindManyArgs>(args?: SelectSubset<T, HealthcareUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HealthcareUserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a HealthcareUser.
     * @param {HealthcareUserCreateArgs} args - Arguments to create a HealthcareUser.
     * @example
     * // Create one HealthcareUser
     * const HealthcareUser = await prisma.healthcareUser.create({
     *   data: {
     *     // ... data to create a HealthcareUser
     *   }
     * })
     * 
     */
    create<T extends HealthcareUserCreateArgs>(args: SelectSubset<T, HealthcareUserCreateArgs<ExtArgs>>): Prisma__HealthcareUserClient<$Result.GetResult<Prisma.$HealthcareUserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many HealthcareUsers.
     * @param {HealthcareUserCreateManyArgs} args - Arguments to create many HealthcareUsers.
     * @example
     * // Create many HealthcareUsers
     * const healthcareUser = await prisma.healthcareUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HealthcareUserCreateManyArgs>(args?: SelectSubset<T, HealthcareUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HealthcareUsers and returns the data saved in the database.
     * @param {HealthcareUserCreateManyAndReturnArgs} args - Arguments to create many HealthcareUsers.
     * @example
     * // Create many HealthcareUsers
     * const healthcareUser = await prisma.healthcareUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HealthcareUsers and only return the `id`
     * const healthcareUserWithIdOnly = await prisma.healthcareUser.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HealthcareUserCreateManyAndReturnArgs>(args?: SelectSubset<T, HealthcareUserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HealthcareUserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a HealthcareUser.
     * @param {HealthcareUserDeleteArgs} args - Arguments to delete one HealthcareUser.
     * @example
     * // Delete one HealthcareUser
     * const HealthcareUser = await prisma.healthcareUser.delete({
     *   where: {
     *     // ... filter to delete one HealthcareUser
     *   }
     * })
     * 
     */
    delete<T extends HealthcareUserDeleteArgs>(args: SelectSubset<T, HealthcareUserDeleteArgs<ExtArgs>>): Prisma__HealthcareUserClient<$Result.GetResult<Prisma.$HealthcareUserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one HealthcareUser.
     * @param {HealthcareUserUpdateArgs} args - Arguments to update one HealthcareUser.
     * @example
     * // Update one HealthcareUser
     * const healthcareUser = await prisma.healthcareUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HealthcareUserUpdateArgs>(args: SelectSubset<T, HealthcareUserUpdateArgs<ExtArgs>>): Prisma__HealthcareUserClient<$Result.GetResult<Prisma.$HealthcareUserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more HealthcareUsers.
     * @param {HealthcareUserDeleteManyArgs} args - Arguments to filter HealthcareUsers to delete.
     * @example
     * // Delete a few HealthcareUsers
     * const { count } = await prisma.healthcareUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HealthcareUserDeleteManyArgs>(args?: SelectSubset<T, HealthcareUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HealthcareUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthcareUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HealthcareUsers
     * const healthcareUser = await prisma.healthcareUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HealthcareUserUpdateManyArgs>(args: SelectSubset<T, HealthcareUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HealthcareUser.
     * @param {HealthcareUserUpsertArgs} args - Arguments to update or create a HealthcareUser.
     * @example
     * // Update or create a HealthcareUser
     * const healthcareUser = await prisma.healthcareUser.upsert({
     *   create: {
     *     // ... data to create a HealthcareUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HealthcareUser we want to update
     *   }
     * })
     */
    upsert<T extends HealthcareUserUpsertArgs>(args: SelectSubset<T, HealthcareUserUpsertArgs<ExtArgs>>): Prisma__HealthcareUserClient<$Result.GetResult<Prisma.$HealthcareUserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of HealthcareUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthcareUserCountArgs} args - Arguments to filter HealthcareUsers to count.
     * @example
     * // Count the number of HealthcareUsers
     * const count = await prisma.healthcareUser.count({
     *   where: {
     *     // ... the filter for the HealthcareUsers we want to count
     *   }
     * })
    **/
    count<T extends HealthcareUserCountArgs>(
      args?: Subset<T, HealthcareUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HealthcareUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HealthcareUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthcareUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HealthcareUserAggregateArgs>(args: Subset<T, HealthcareUserAggregateArgs>): Prisma.PrismaPromise<GetHealthcareUserAggregateType<T>>

    /**
     * Group by HealthcareUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthcareUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HealthcareUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HealthcareUserGroupByArgs['orderBy'] }
        : { orderBy?: HealthcareUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HealthcareUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHealthcareUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HealthcareUser model
   */
  readonly fields: HealthcareUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HealthcareUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HealthcareUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    locations<T extends HealthcareUser$locationsArgs<ExtArgs> = {}>(args?: Subset<T, HealthcareUser$locationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HealthcareLocationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HealthcareUser model
   */ 
  interface HealthcareUserFieldRefs {
    readonly id: FieldRef<"HealthcareUser", 'String'>
    readonly email: FieldRef<"HealthcareUser", 'String'>
    readonly password: FieldRef<"HealthcareUser", 'String'>
    readonly name: FieldRef<"HealthcareUser", 'String'>
    readonly facilityName: FieldRef<"HealthcareUser", 'String'>
    readonly facilityType: FieldRef<"HealthcareUser", 'String'>
    readonly userType: FieldRef<"HealthcareUser", 'String'>
    readonly isActive: FieldRef<"HealthcareUser", 'Boolean'>
    readonly manageMultipleLocations: FieldRef<"HealthcareUser", 'Boolean'>
    readonly createdAt: FieldRef<"HealthcareUser", 'DateTime'>
    readonly updatedAt: FieldRef<"HealthcareUser", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HealthcareUser findUnique
   */
  export type HealthcareUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthcareUser
     */
    select?: HealthcareUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthcareUserInclude<ExtArgs> | null
    /**
     * Filter, which HealthcareUser to fetch.
     */
    where: HealthcareUserWhereUniqueInput
  }

  /**
   * HealthcareUser findUniqueOrThrow
   */
  export type HealthcareUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthcareUser
     */
    select?: HealthcareUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthcareUserInclude<ExtArgs> | null
    /**
     * Filter, which HealthcareUser to fetch.
     */
    where: HealthcareUserWhereUniqueInput
  }

  /**
   * HealthcareUser findFirst
   */
  export type HealthcareUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthcareUser
     */
    select?: HealthcareUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthcareUserInclude<ExtArgs> | null
    /**
     * Filter, which HealthcareUser to fetch.
     */
    where?: HealthcareUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthcareUsers to fetch.
     */
    orderBy?: HealthcareUserOrderByWithRelationInput | HealthcareUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HealthcareUsers.
     */
    cursor?: HealthcareUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthcareUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthcareUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HealthcareUsers.
     */
    distinct?: HealthcareUserScalarFieldEnum | HealthcareUserScalarFieldEnum[]
  }

  /**
   * HealthcareUser findFirstOrThrow
   */
  export type HealthcareUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthcareUser
     */
    select?: HealthcareUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthcareUserInclude<ExtArgs> | null
    /**
     * Filter, which HealthcareUser to fetch.
     */
    where?: HealthcareUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthcareUsers to fetch.
     */
    orderBy?: HealthcareUserOrderByWithRelationInput | HealthcareUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HealthcareUsers.
     */
    cursor?: HealthcareUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthcareUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthcareUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HealthcareUsers.
     */
    distinct?: HealthcareUserScalarFieldEnum | HealthcareUserScalarFieldEnum[]
  }

  /**
   * HealthcareUser findMany
   */
  export type HealthcareUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthcareUser
     */
    select?: HealthcareUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthcareUserInclude<ExtArgs> | null
    /**
     * Filter, which HealthcareUsers to fetch.
     */
    where?: HealthcareUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthcareUsers to fetch.
     */
    orderBy?: HealthcareUserOrderByWithRelationInput | HealthcareUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HealthcareUsers.
     */
    cursor?: HealthcareUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthcareUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthcareUsers.
     */
    skip?: number
    distinct?: HealthcareUserScalarFieldEnum | HealthcareUserScalarFieldEnum[]
  }

  /**
   * HealthcareUser create
   */
  export type HealthcareUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthcareUser
     */
    select?: HealthcareUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthcareUserInclude<ExtArgs> | null
    /**
     * The data needed to create a HealthcareUser.
     */
    data: XOR<HealthcareUserCreateInput, HealthcareUserUncheckedCreateInput>
  }

  /**
   * HealthcareUser createMany
   */
  export type HealthcareUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HealthcareUsers.
     */
    data: HealthcareUserCreateManyInput | HealthcareUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HealthcareUser createManyAndReturn
   */
  export type HealthcareUserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthcareUser
     */
    select?: HealthcareUserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many HealthcareUsers.
     */
    data: HealthcareUserCreateManyInput | HealthcareUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HealthcareUser update
   */
  export type HealthcareUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthcareUser
     */
    select?: HealthcareUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthcareUserInclude<ExtArgs> | null
    /**
     * The data needed to update a HealthcareUser.
     */
    data: XOR<HealthcareUserUpdateInput, HealthcareUserUncheckedUpdateInput>
    /**
     * Choose, which HealthcareUser to update.
     */
    where: HealthcareUserWhereUniqueInput
  }

  /**
   * HealthcareUser updateMany
   */
  export type HealthcareUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HealthcareUsers.
     */
    data: XOR<HealthcareUserUpdateManyMutationInput, HealthcareUserUncheckedUpdateManyInput>
    /**
     * Filter which HealthcareUsers to update
     */
    where?: HealthcareUserWhereInput
  }

  /**
   * HealthcareUser upsert
   */
  export type HealthcareUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthcareUser
     */
    select?: HealthcareUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthcareUserInclude<ExtArgs> | null
    /**
     * The filter to search for the HealthcareUser to update in case it exists.
     */
    where: HealthcareUserWhereUniqueInput
    /**
     * In case the HealthcareUser found by the `where` argument doesn't exist, create a new HealthcareUser with this data.
     */
    create: XOR<HealthcareUserCreateInput, HealthcareUserUncheckedCreateInput>
    /**
     * In case the HealthcareUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HealthcareUserUpdateInput, HealthcareUserUncheckedUpdateInput>
  }

  /**
   * HealthcareUser delete
   */
  export type HealthcareUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthcareUser
     */
    select?: HealthcareUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthcareUserInclude<ExtArgs> | null
    /**
     * Filter which HealthcareUser to delete.
     */
    where: HealthcareUserWhereUniqueInput
  }

  /**
   * HealthcareUser deleteMany
   */
  export type HealthcareUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HealthcareUsers to delete
     */
    where?: HealthcareUserWhereInput
  }

  /**
   * HealthcareUser.locations
   */
  export type HealthcareUser$locationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthcareLocation
     */
    select?: HealthcareLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthcareLocationInclude<ExtArgs> | null
    where?: HealthcareLocationWhereInput
    orderBy?: HealthcareLocationOrderByWithRelationInput | HealthcareLocationOrderByWithRelationInput[]
    cursor?: HealthcareLocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HealthcareLocationScalarFieldEnum | HealthcareLocationScalarFieldEnum[]
  }

  /**
   * HealthcareUser without action
   */
  export type HealthcareUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthcareUser
     */
    select?: HealthcareUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthcareUserInclude<ExtArgs> | null
  }


  /**
   * Model HealthcareLocation
   */

  export type AggregateHealthcareLocation = {
    _count: HealthcareLocationCountAggregateOutputType | null
    _avg: HealthcareLocationAvgAggregateOutputType | null
    _sum: HealthcareLocationSumAggregateOutputType | null
    _min: HealthcareLocationMinAggregateOutputType | null
    _max: HealthcareLocationMaxAggregateOutputType | null
  }

  export type HealthcareLocationAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type HealthcareLocationSumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type HealthcareLocationMinAggregateOutputType = {
    id: string | null
    healthcareUserId: string | null
    locationName: string | null
    address: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    phone: string | null
    facilityType: string | null
    isActive: boolean | null
    isPrimary: boolean | null
    latitude: number | null
    longitude: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HealthcareLocationMaxAggregateOutputType = {
    id: string | null
    healthcareUserId: string | null
    locationName: string | null
    address: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    phone: string | null
    facilityType: string | null
    isActive: boolean | null
    isPrimary: boolean | null
    latitude: number | null
    longitude: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HealthcareLocationCountAggregateOutputType = {
    id: number
    healthcareUserId: number
    locationName: number
    address: number
    city: number
    state: number
    zipCode: number
    phone: number
    facilityType: number
    isActive: number
    isPrimary: number
    latitude: number
    longitude: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HealthcareLocationAvgAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type HealthcareLocationSumAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type HealthcareLocationMinAggregateInputType = {
    id?: true
    healthcareUserId?: true
    locationName?: true
    address?: true
    city?: true
    state?: true
    zipCode?: true
    phone?: true
    facilityType?: true
    isActive?: true
    isPrimary?: true
    latitude?: true
    longitude?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HealthcareLocationMaxAggregateInputType = {
    id?: true
    healthcareUserId?: true
    locationName?: true
    address?: true
    city?: true
    state?: true
    zipCode?: true
    phone?: true
    facilityType?: true
    isActive?: true
    isPrimary?: true
    latitude?: true
    longitude?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HealthcareLocationCountAggregateInputType = {
    id?: true
    healthcareUserId?: true
    locationName?: true
    address?: true
    city?: true
    state?: true
    zipCode?: true
    phone?: true
    facilityType?: true
    isActive?: true
    isPrimary?: true
    latitude?: true
    longitude?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HealthcareLocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HealthcareLocation to aggregate.
     */
    where?: HealthcareLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthcareLocations to fetch.
     */
    orderBy?: HealthcareLocationOrderByWithRelationInput | HealthcareLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HealthcareLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthcareLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthcareLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HealthcareLocations
    **/
    _count?: true | HealthcareLocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HealthcareLocationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HealthcareLocationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HealthcareLocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HealthcareLocationMaxAggregateInputType
  }

  export type GetHealthcareLocationAggregateType<T extends HealthcareLocationAggregateArgs> = {
        [P in keyof T & keyof AggregateHealthcareLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHealthcareLocation[P]>
      : GetScalarType<T[P], AggregateHealthcareLocation[P]>
  }




  export type HealthcareLocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HealthcareLocationWhereInput
    orderBy?: HealthcareLocationOrderByWithAggregationInput | HealthcareLocationOrderByWithAggregationInput[]
    by: HealthcareLocationScalarFieldEnum[] | HealthcareLocationScalarFieldEnum
    having?: HealthcareLocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HealthcareLocationCountAggregateInputType | true
    _avg?: HealthcareLocationAvgAggregateInputType
    _sum?: HealthcareLocationSumAggregateInputType
    _min?: HealthcareLocationMinAggregateInputType
    _max?: HealthcareLocationMaxAggregateInputType
  }

  export type HealthcareLocationGroupByOutputType = {
    id: string
    healthcareUserId: string
    locationName: string
    address: string
    city: string
    state: string
    zipCode: string
    phone: string | null
    facilityType: string
    isActive: boolean
    isPrimary: boolean
    latitude: number | null
    longitude: number | null
    createdAt: Date
    updatedAt: Date
    _count: HealthcareLocationCountAggregateOutputType | null
    _avg: HealthcareLocationAvgAggregateOutputType | null
    _sum: HealthcareLocationSumAggregateOutputType | null
    _min: HealthcareLocationMinAggregateOutputType | null
    _max: HealthcareLocationMaxAggregateOutputType | null
  }

  type GetHealthcareLocationGroupByPayload<T extends HealthcareLocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HealthcareLocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HealthcareLocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HealthcareLocationGroupByOutputType[P]>
            : GetScalarType<T[P], HealthcareLocationGroupByOutputType[P]>
        }
      >
    >


  export type HealthcareLocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    healthcareUserId?: boolean
    locationName?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    phone?: boolean
    facilityType?: boolean
    isActive?: boolean
    isPrimary?: boolean
    latitude?: boolean
    longitude?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    healthcareUser?: boolean | HealthcareUserDefaultArgs<ExtArgs>
    transportRequests?: boolean | HealthcareLocation$transportRequestsArgs<ExtArgs>
    _count?: boolean | HealthcareLocationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["healthcareLocation"]>

  export type HealthcareLocationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    healthcareUserId?: boolean
    locationName?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    phone?: boolean
    facilityType?: boolean
    isActive?: boolean
    isPrimary?: boolean
    latitude?: boolean
    longitude?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    healthcareUser?: boolean | HealthcareUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["healthcareLocation"]>

  export type HealthcareLocationSelectScalar = {
    id?: boolean
    healthcareUserId?: boolean
    locationName?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    phone?: boolean
    facilityType?: boolean
    isActive?: boolean
    isPrimary?: boolean
    latitude?: boolean
    longitude?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HealthcareLocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    healthcareUser?: boolean | HealthcareUserDefaultArgs<ExtArgs>
    transportRequests?: boolean | HealthcareLocation$transportRequestsArgs<ExtArgs>
    _count?: boolean | HealthcareLocationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type HealthcareLocationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    healthcareUser?: boolean | HealthcareUserDefaultArgs<ExtArgs>
  }

  export type $HealthcareLocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HealthcareLocation"
    objects: {
      healthcareUser: Prisma.$HealthcareUserPayload<ExtArgs>
      transportRequests: Prisma.$TransportRequestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      healthcareUserId: string
      locationName: string
      address: string
      city: string
      state: string
      zipCode: string
      phone: string | null
      facilityType: string
      isActive: boolean
      isPrimary: boolean
      latitude: number | null
      longitude: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["healthcareLocation"]>
    composites: {}
  }

  type HealthcareLocationGetPayload<S extends boolean | null | undefined | HealthcareLocationDefaultArgs> = $Result.GetResult<Prisma.$HealthcareLocationPayload, S>

  type HealthcareLocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HealthcareLocationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HealthcareLocationCountAggregateInputType | true
    }

  export interface HealthcareLocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HealthcareLocation'], meta: { name: 'HealthcareLocation' } }
    /**
     * Find zero or one HealthcareLocation that matches the filter.
     * @param {HealthcareLocationFindUniqueArgs} args - Arguments to find a HealthcareLocation
     * @example
     * // Get one HealthcareLocation
     * const healthcareLocation = await prisma.healthcareLocation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HealthcareLocationFindUniqueArgs>(args: SelectSubset<T, HealthcareLocationFindUniqueArgs<ExtArgs>>): Prisma__HealthcareLocationClient<$Result.GetResult<Prisma.$HealthcareLocationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one HealthcareLocation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HealthcareLocationFindUniqueOrThrowArgs} args - Arguments to find a HealthcareLocation
     * @example
     * // Get one HealthcareLocation
     * const healthcareLocation = await prisma.healthcareLocation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HealthcareLocationFindUniqueOrThrowArgs>(args: SelectSubset<T, HealthcareLocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HealthcareLocationClient<$Result.GetResult<Prisma.$HealthcareLocationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first HealthcareLocation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthcareLocationFindFirstArgs} args - Arguments to find a HealthcareLocation
     * @example
     * // Get one HealthcareLocation
     * const healthcareLocation = await prisma.healthcareLocation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HealthcareLocationFindFirstArgs>(args?: SelectSubset<T, HealthcareLocationFindFirstArgs<ExtArgs>>): Prisma__HealthcareLocationClient<$Result.GetResult<Prisma.$HealthcareLocationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first HealthcareLocation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthcareLocationFindFirstOrThrowArgs} args - Arguments to find a HealthcareLocation
     * @example
     * // Get one HealthcareLocation
     * const healthcareLocation = await prisma.healthcareLocation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HealthcareLocationFindFirstOrThrowArgs>(args?: SelectSubset<T, HealthcareLocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__HealthcareLocationClient<$Result.GetResult<Prisma.$HealthcareLocationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more HealthcareLocations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthcareLocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HealthcareLocations
     * const healthcareLocations = await prisma.healthcareLocation.findMany()
     * 
     * // Get first 10 HealthcareLocations
     * const healthcareLocations = await prisma.healthcareLocation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const healthcareLocationWithIdOnly = await prisma.healthcareLocation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HealthcareLocationFindManyArgs>(args?: SelectSubset<T, HealthcareLocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HealthcareLocationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a HealthcareLocation.
     * @param {HealthcareLocationCreateArgs} args - Arguments to create a HealthcareLocation.
     * @example
     * // Create one HealthcareLocation
     * const HealthcareLocation = await prisma.healthcareLocation.create({
     *   data: {
     *     // ... data to create a HealthcareLocation
     *   }
     * })
     * 
     */
    create<T extends HealthcareLocationCreateArgs>(args: SelectSubset<T, HealthcareLocationCreateArgs<ExtArgs>>): Prisma__HealthcareLocationClient<$Result.GetResult<Prisma.$HealthcareLocationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many HealthcareLocations.
     * @param {HealthcareLocationCreateManyArgs} args - Arguments to create many HealthcareLocations.
     * @example
     * // Create many HealthcareLocations
     * const healthcareLocation = await prisma.healthcareLocation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HealthcareLocationCreateManyArgs>(args?: SelectSubset<T, HealthcareLocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HealthcareLocations and returns the data saved in the database.
     * @param {HealthcareLocationCreateManyAndReturnArgs} args - Arguments to create many HealthcareLocations.
     * @example
     * // Create many HealthcareLocations
     * const healthcareLocation = await prisma.healthcareLocation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HealthcareLocations and only return the `id`
     * const healthcareLocationWithIdOnly = await prisma.healthcareLocation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HealthcareLocationCreateManyAndReturnArgs>(args?: SelectSubset<T, HealthcareLocationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HealthcareLocationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a HealthcareLocation.
     * @param {HealthcareLocationDeleteArgs} args - Arguments to delete one HealthcareLocation.
     * @example
     * // Delete one HealthcareLocation
     * const HealthcareLocation = await prisma.healthcareLocation.delete({
     *   where: {
     *     // ... filter to delete one HealthcareLocation
     *   }
     * })
     * 
     */
    delete<T extends HealthcareLocationDeleteArgs>(args: SelectSubset<T, HealthcareLocationDeleteArgs<ExtArgs>>): Prisma__HealthcareLocationClient<$Result.GetResult<Prisma.$HealthcareLocationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one HealthcareLocation.
     * @param {HealthcareLocationUpdateArgs} args - Arguments to update one HealthcareLocation.
     * @example
     * // Update one HealthcareLocation
     * const healthcareLocation = await prisma.healthcareLocation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HealthcareLocationUpdateArgs>(args: SelectSubset<T, HealthcareLocationUpdateArgs<ExtArgs>>): Prisma__HealthcareLocationClient<$Result.GetResult<Prisma.$HealthcareLocationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more HealthcareLocations.
     * @param {HealthcareLocationDeleteManyArgs} args - Arguments to filter HealthcareLocations to delete.
     * @example
     * // Delete a few HealthcareLocations
     * const { count } = await prisma.healthcareLocation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HealthcareLocationDeleteManyArgs>(args?: SelectSubset<T, HealthcareLocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HealthcareLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthcareLocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HealthcareLocations
     * const healthcareLocation = await prisma.healthcareLocation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HealthcareLocationUpdateManyArgs>(args: SelectSubset<T, HealthcareLocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HealthcareLocation.
     * @param {HealthcareLocationUpsertArgs} args - Arguments to update or create a HealthcareLocation.
     * @example
     * // Update or create a HealthcareLocation
     * const healthcareLocation = await prisma.healthcareLocation.upsert({
     *   create: {
     *     // ... data to create a HealthcareLocation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HealthcareLocation we want to update
     *   }
     * })
     */
    upsert<T extends HealthcareLocationUpsertArgs>(args: SelectSubset<T, HealthcareLocationUpsertArgs<ExtArgs>>): Prisma__HealthcareLocationClient<$Result.GetResult<Prisma.$HealthcareLocationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of HealthcareLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthcareLocationCountArgs} args - Arguments to filter HealthcareLocations to count.
     * @example
     * // Count the number of HealthcareLocations
     * const count = await prisma.healthcareLocation.count({
     *   where: {
     *     // ... the filter for the HealthcareLocations we want to count
     *   }
     * })
    **/
    count<T extends HealthcareLocationCountArgs>(
      args?: Subset<T, HealthcareLocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HealthcareLocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HealthcareLocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthcareLocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HealthcareLocationAggregateArgs>(args: Subset<T, HealthcareLocationAggregateArgs>): Prisma.PrismaPromise<GetHealthcareLocationAggregateType<T>>

    /**
     * Group by HealthcareLocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthcareLocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HealthcareLocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HealthcareLocationGroupByArgs['orderBy'] }
        : { orderBy?: HealthcareLocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HealthcareLocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHealthcareLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HealthcareLocation model
   */
  readonly fields: HealthcareLocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HealthcareLocation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HealthcareLocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    healthcareUser<T extends HealthcareUserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HealthcareUserDefaultArgs<ExtArgs>>): Prisma__HealthcareUserClient<$Result.GetResult<Prisma.$HealthcareUserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    transportRequests<T extends HealthcareLocation$transportRequestsArgs<ExtArgs> = {}>(args?: Subset<T, HealthcareLocation$transportRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransportRequestPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HealthcareLocation model
   */ 
  interface HealthcareLocationFieldRefs {
    readonly id: FieldRef<"HealthcareLocation", 'String'>
    readonly healthcareUserId: FieldRef<"HealthcareLocation", 'String'>
    readonly locationName: FieldRef<"HealthcareLocation", 'String'>
    readonly address: FieldRef<"HealthcareLocation", 'String'>
    readonly city: FieldRef<"HealthcareLocation", 'String'>
    readonly state: FieldRef<"HealthcareLocation", 'String'>
    readonly zipCode: FieldRef<"HealthcareLocation", 'String'>
    readonly phone: FieldRef<"HealthcareLocation", 'String'>
    readonly facilityType: FieldRef<"HealthcareLocation", 'String'>
    readonly isActive: FieldRef<"HealthcareLocation", 'Boolean'>
    readonly isPrimary: FieldRef<"HealthcareLocation", 'Boolean'>
    readonly latitude: FieldRef<"HealthcareLocation", 'Float'>
    readonly longitude: FieldRef<"HealthcareLocation", 'Float'>
    readonly createdAt: FieldRef<"HealthcareLocation", 'DateTime'>
    readonly updatedAt: FieldRef<"HealthcareLocation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HealthcareLocation findUnique
   */
  export type HealthcareLocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthcareLocation
     */
    select?: HealthcareLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthcareLocationInclude<ExtArgs> | null
    /**
     * Filter, which HealthcareLocation to fetch.
     */
    where: HealthcareLocationWhereUniqueInput
  }

  /**
   * HealthcareLocation findUniqueOrThrow
   */
  export type HealthcareLocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthcareLocation
     */
    select?: HealthcareLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthcareLocationInclude<ExtArgs> | null
    /**
     * Filter, which HealthcareLocation to fetch.
     */
    where: HealthcareLocationWhereUniqueInput
  }

  /**
   * HealthcareLocation findFirst
   */
  export type HealthcareLocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthcareLocation
     */
    select?: HealthcareLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthcareLocationInclude<ExtArgs> | null
    /**
     * Filter, which HealthcareLocation to fetch.
     */
    where?: HealthcareLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthcareLocations to fetch.
     */
    orderBy?: HealthcareLocationOrderByWithRelationInput | HealthcareLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HealthcareLocations.
     */
    cursor?: HealthcareLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthcareLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthcareLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HealthcareLocations.
     */
    distinct?: HealthcareLocationScalarFieldEnum | HealthcareLocationScalarFieldEnum[]
  }

  /**
   * HealthcareLocation findFirstOrThrow
   */
  export type HealthcareLocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthcareLocation
     */
    select?: HealthcareLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthcareLocationInclude<ExtArgs> | null
    /**
     * Filter, which HealthcareLocation to fetch.
     */
    where?: HealthcareLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthcareLocations to fetch.
     */
    orderBy?: HealthcareLocationOrderByWithRelationInput | HealthcareLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HealthcareLocations.
     */
    cursor?: HealthcareLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthcareLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthcareLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HealthcareLocations.
     */
    distinct?: HealthcareLocationScalarFieldEnum | HealthcareLocationScalarFieldEnum[]
  }

  /**
   * HealthcareLocation findMany
   */
  export type HealthcareLocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthcareLocation
     */
    select?: HealthcareLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthcareLocationInclude<ExtArgs> | null
    /**
     * Filter, which HealthcareLocations to fetch.
     */
    where?: HealthcareLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthcareLocations to fetch.
     */
    orderBy?: HealthcareLocationOrderByWithRelationInput | HealthcareLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HealthcareLocations.
     */
    cursor?: HealthcareLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthcareLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthcareLocations.
     */
    skip?: number
    distinct?: HealthcareLocationScalarFieldEnum | HealthcareLocationScalarFieldEnum[]
  }

  /**
   * HealthcareLocation create
   */
  export type HealthcareLocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthcareLocation
     */
    select?: HealthcareLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthcareLocationInclude<ExtArgs> | null
    /**
     * The data needed to create a HealthcareLocation.
     */
    data: XOR<HealthcareLocationCreateInput, HealthcareLocationUncheckedCreateInput>
  }

  /**
   * HealthcareLocation createMany
   */
  export type HealthcareLocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HealthcareLocations.
     */
    data: HealthcareLocationCreateManyInput | HealthcareLocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HealthcareLocation createManyAndReturn
   */
  export type HealthcareLocationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthcareLocation
     */
    select?: HealthcareLocationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many HealthcareLocations.
     */
    data: HealthcareLocationCreateManyInput | HealthcareLocationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthcareLocationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HealthcareLocation update
   */
  export type HealthcareLocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthcareLocation
     */
    select?: HealthcareLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthcareLocationInclude<ExtArgs> | null
    /**
     * The data needed to update a HealthcareLocation.
     */
    data: XOR<HealthcareLocationUpdateInput, HealthcareLocationUncheckedUpdateInput>
    /**
     * Choose, which HealthcareLocation to update.
     */
    where: HealthcareLocationWhereUniqueInput
  }

  /**
   * HealthcareLocation updateMany
   */
  export type HealthcareLocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HealthcareLocations.
     */
    data: XOR<HealthcareLocationUpdateManyMutationInput, HealthcareLocationUncheckedUpdateManyInput>
    /**
     * Filter which HealthcareLocations to update
     */
    where?: HealthcareLocationWhereInput
  }

  /**
   * HealthcareLocation upsert
   */
  export type HealthcareLocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthcareLocation
     */
    select?: HealthcareLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthcareLocationInclude<ExtArgs> | null
    /**
     * The filter to search for the HealthcareLocation to update in case it exists.
     */
    where: HealthcareLocationWhereUniqueInput
    /**
     * In case the HealthcareLocation found by the `where` argument doesn't exist, create a new HealthcareLocation with this data.
     */
    create: XOR<HealthcareLocationCreateInput, HealthcareLocationUncheckedCreateInput>
    /**
     * In case the HealthcareLocation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HealthcareLocationUpdateInput, HealthcareLocationUncheckedUpdateInput>
  }

  /**
   * HealthcareLocation delete
   */
  export type HealthcareLocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthcareLocation
     */
    select?: HealthcareLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthcareLocationInclude<ExtArgs> | null
    /**
     * Filter which HealthcareLocation to delete.
     */
    where: HealthcareLocationWhereUniqueInput
  }

  /**
   * HealthcareLocation deleteMany
   */
  export type HealthcareLocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HealthcareLocations to delete
     */
    where?: HealthcareLocationWhereInput
  }

  /**
   * HealthcareLocation.transportRequests
   */
  export type HealthcareLocation$transportRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransportRequest
     */
    select?: TransportRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportRequestInclude<ExtArgs> | null
    where?: TransportRequestWhereInput
    orderBy?: TransportRequestOrderByWithRelationInput | TransportRequestOrderByWithRelationInput[]
    cursor?: TransportRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransportRequestScalarFieldEnum | TransportRequestScalarFieldEnum[]
  }

  /**
   * HealthcareLocation without action
   */
  export type HealthcareLocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthcareLocation
     */
    select?: HealthcareLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthcareLocationInclude<ExtArgs> | null
  }


  /**
   * Model Hospital
   */

  export type AggregateHospital = {
    _count: HospitalCountAggregateOutputType | null
    _avg: HospitalAvgAggregateOutputType | null
    _sum: HospitalSumAggregateOutputType | null
    _min: HospitalMinAggregateOutputType | null
    _max: HospitalMaxAggregateOutputType | null
  }

  export type HospitalAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type HospitalSumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type HospitalMinAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    phone: string | null
    email: string | null
    type: string | null
    region: string | null
    latitude: number | null
    longitude: number | null
    operatingHours: string | null
    isActive: boolean | null
    requiresReview: boolean | null
    approvedAt: Date | null
    approvedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HospitalMaxAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    phone: string | null
    email: string | null
    type: string | null
    region: string | null
    latitude: number | null
    longitude: number | null
    operatingHours: string | null
    isActive: boolean | null
    requiresReview: boolean | null
    approvedAt: Date | null
    approvedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HospitalCountAggregateOutputType = {
    id: number
    name: number
    address: number
    city: number
    state: number
    zipCode: number
    phone: number
    email: number
    type: number
    capabilities: number
    region: number
    coordinates: number
    latitude: number
    longitude: number
    operatingHours: number
    isActive: number
    requiresReview: number
    approvedAt: number
    approvedBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HospitalAvgAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type HospitalSumAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type HospitalMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    city?: true
    state?: true
    zipCode?: true
    phone?: true
    email?: true
    type?: true
    region?: true
    latitude?: true
    longitude?: true
    operatingHours?: true
    isActive?: true
    requiresReview?: true
    approvedAt?: true
    approvedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HospitalMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    city?: true
    state?: true
    zipCode?: true
    phone?: true
    email?: true
    type?: true
    region?: true
    latitude?: true
    longitude?: true
    operatingHours?: true
    isActive?: true
    requiresReview?: true
    approvedAt?: true
    approvedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HospitalCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    city?: true
    state?: true
    zipCode?: true
    phone?: true
    email?: true
    type?: true
    capabilities?: true
    region?: true
    coordinates?: true
    latitude?: true
    longitude?: true
    operatingHours?: true
    isActive?: true
    requiresReview?: true
    approvedAt?: true
    approvedBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HospitalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Hospital to aggregate.
     */
    where?: HospitalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hospitals to fetch.
     */
    orderBy?: HospitalOrderByWithRelationInput | HospitalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HospitalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hospitals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hospitals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Hospitals
    **/
    _count?: true | HospitalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HospitalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HospitalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HospitalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HospitalMaxAggregateInputType
  }

  export type GetHospitalAggregateType<T extends HospitalAggregateArgs> = {
        [P in keyof T & keyof AggregateHospital]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHospital[P]>
      : GetScalarType<T[P], AggregateHospital[P]>
  }




  export type HospitalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HospitalWhereInput
    orderBy?: HospitalOrderByWithAggregationInput | HospitalOrderByWithAggregationInput[]
    by: HospitalScalarFieldEnum[] | HospitalScalarFieldEnum
    having?: HospitalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HospitalCountAggregateInputType | true
    _avg?: HospitalAvgAggregateInputType
    _sum?: HospitalSumAggregateInputType
    _min?: HospitalMinAggregateInputType
    _max?: HospitalMaxAggregateInputType
  }

  export type HospitalGroupByOutputType = {
    id: string
    name: string
    address: string
    city: string
    state: string
    zipCode: string
    phone: string | null
    email: string | null
    type: string
    capabilities: string[]
    region: string
    coordinates: JsonValue | null
    latitude: number | null
    longitude: number | null
    operatingHours: string | null
    isActive: boolean
    requiresReview: boolean
    approvedAt: Date | null
    approvedBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: HospitalCountAggregateOutputType | null
    _avg: HospitalAvgAggregateOutputType | null
    _sum: HospitalSumAggregateOutputType | null
    _min: HospitalMinAggregateOutputType | null
    _max: HospitalMaxAggregateOutputType | null
  }

  type GetHospitalGroupByPayload<T extends HospitalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HospitalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HospitalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HospitalGroupByOutputType[P]>
            : GetScalarType<T[P], HospitalGroupByOutputType[P]>
        }
      >
    >


  export type HospitalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    phone?: boolean
    email?: boolean
    type?: boolean
    capabilities?: boolean
    region?: boolean
    coordinates?: boolean
    latitude?: boolean
    longitude?: boolean
    operatingHours?: boolean
    isActive?: boolean
    requiresReview?: boolean
    approvedAt?: boolean
    approvedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["hospital"]>

  export type HospitalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    phone?: boolean
    email?: boolean
    type?: boolean
    capabilities?: boolean
    region?: boolean
    coordinates?: boolean
    latitude?: boolean
    longitude?: boolean
    operatingHours?: boolean
    isActive?: boolean
    requiresReview?: boolean
    approvedAt?: boolean
    approvedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["hospital"]>

  export type HospitalSelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    phone?: boolean
    email?: boolean
    type?: boolean
    capabilities?: boolean
    region?: boolean
    coordinates?: boolean
    latitude?: boolean
    longitude?: boolean
    operatingHours?: boolean
    isActive?: boolean
    requiresReview?: boolean
    approvedAt?: boolean
    approvedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $HospitalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Hospital"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      address: string
      city: string
      state: string
      zipCode: string
      phone: string | null
      email: string | null
      type: string
      capabilities: string[]
      region: string
      coordinates: Prisma.JsonValue | null
      latitude: number | null
      longitude: number | null
      operatingHours: string | null
      isActive: boolean
      requiresReview: boolean
      approvedAt: Date | null
      approvedBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["hospital"]>
    composites: {}
  }

  type HospitalGetPayload<S extends boolean | null | undefined | HospitalDefaultArgs> = $Result.GetResult<Prisma.$HospitalPayload, S>

  type HospitalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HospitalFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HospitalCountAggregateInputType | true
    }

  export interface HospitalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Hospital'], meta: { name: 'Hospital' } }
    /**
     * Find zero or one Hospital that matches the filter.
     * @param {HospitalFindUniqueArgs} args - Arguments to find a Hospital
     * @example
     * // Get one Hospital
     * const hospital = await prisma.hospital.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HospitalFindUniqueArgs>(args: SelectSubset<T, HospitalFindUniqueArgs<ExtArgs>>): Prisma__HospitalClient<$Result.GetResult<Prisma.$HospitalPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Hospital that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HospitalFindUniqueOrThrowArgs} args - Arguments to find a Hospital
     * @example
     * // Get one Hospital
     * const hospital = await prisma.hospital.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HospitalFindUniqueOrThrowArgs>(args: SelectSubset<T, HospitalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HospitalClient<$Result.GetResult<Prisma.$HospitalPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Hospital that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalFindFirstArgs} args - Arguments to find a Hospital
     * @example
     * // Get one Hospital
     * const hospital = await prisma.hospital.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HospitalFindFirstArgs>(args?: SelectSubset<T, HospitalFindFirstArgs<ExtArgs>>): Prisma__HospitalClient<$Result.GetResult<Prisma.$HospitalPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Hospital that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalFindFirstOrThrowArgs} args - Arguments to find a Hospital
     * @example
     * // Get one Hospital
     * const hospital = await prisma.hospital.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HospitalFindFirstOrThrowArgs>(args?: SelectSubset<T, HospitalFindFirstOrThrowArgs<ExtArgs>>): Prisma__HospitalClient<$Result.GetResult<Prisma.$HospitalPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Hospitals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Hospitals
     * const hospitals = await prisma.hospital.findMany()
     * 
     * // Get first 10 Hospitals
     * const hospitals = await prisma.hospital.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hospitalWithIdOnly = await prisma.hospital.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HospitalFindManyArgs>(args?: SelectSubset<T, HospitalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HospitalPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Hospital.
     * @param {HospitalCreateArgs} args - Arguments to create a Hospital.
     * @example
     * // Create one Hospital
     * const Hospital = await prisma.hospital.create({
     *   data: {
     *     // ... data to create a Hospital
     *   }
     * })
     * 
     */
    create<T extends HospitalCreateArgs>(args: SelectSubset<T, HospitalCreateArgs<ExtArgs>>): Prisma__HospitalClient<$Result.GetResult<Prisma.$HospitalPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Hospitals.
     * @param {HospitalCreateManyArgs} args - Arguments to create many Hospitals.
     * @example
     * // Create many Hospitals
     * const hospital = await prisma.hospital.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HospitalCreateManyArgs>(args?: SelectSubset<T, HospitalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Hospitals and returns the data saved in the database.
     * @param {HospitalCreateManyAndReturnArgs} args - Arguments to create many Hospitals.
     * @example
     * // Create many Hospitals
     * const hospital = await prisma.hospital.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Hospitals and only return the `id`
     * const hospitalWithIdOnly = await prisma.hospital.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HospitalCreateManyAndReturnArgs>(args?: SelectSubset<T, HospitalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HospitalPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Hospital.
     * @param {HospitalDeleteArgs} args - Arguments to delete one Hospital.
     * @example
     * // Delete one Hospital
     * const Hospital = await prisma.hospital.delete({
     *   where: {
     *     // ... filter to delete one Hospital
     *   }
     * })
     * 
     */
    delete<T extends HospitalDeleteArgs>(args: SelectSubset<T, HospitalDeleteArgs<ExtArgs>>): Prisma__HospitalClient<$Result.GetResult<Prisma.$HospitalPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Hospital.
     * @param {HospitalUpdateArgs} args - Arguments to update one Hospital.
     * @example
     * // Update one Hospital
     * const hospital = await prisma.hospital.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HospitalUpdateArgs>(args: SelectSubset<T, HospitalUpdateArgs<ExtArgs>>): Prisma__HospitalClient<$Result.GetResult<Prisma.$HospitalPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Hospitals.
     * @param {HospitalDeleteManyArgs} args - Arguments to filter Hospitals to delete.
     * @example
     * // Delete a few Hospitals
     * const { count } = await prisma.hospital.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HospitalDeleteManyArgs>(args?: SelectSubset<T, HospitalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Hospitals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Hospitals
     * const hospital = await prisma.hospital.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HospitalUpdateManyArgs>(args: SelectSubset<T, HospitalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Hospital.
     * @param {HospitalUpsertArgs} args - Arguments to update or create a Hospital.
     * @example
     * // Update or create a Hospital
     * const hospital = await prisma.hospital.upsert({
     *   create: {
     *     // ... data to create a Hospital
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Hospital we want to update
     *   }
     * })
     */
    upsert<T extends HospitalUpsertArgs>(args: SelectSubset<T, HospitalUpsertArgs<ExtArgs>>): Prisma__HospitalClient<$Result.GetResult<Prisma.$HospitalPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Hospitals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalCountArgs} args - Arguments to filter Hospitals to count.
     * @example
     * // Count the number of Hospitals
     * const count = await prisma.hospital.count({
     *   where: {
     *     // ... the filter for the Hospitals we want to count
     *   }
     * })
    **/
    count<T extends HospitalCountArgs>(
      args?: Subset<T, HospitalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HospitalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Hospital.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HospitalAggregateArgs>(args: Subset<T, HospitalAggregateArgs>): Prisma.PrismaPromise<GetHospitalAggregateType<T>>

    /**
     * Group by Hospital.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HospitalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HospitalGroupByArgs['orderBy'] }
        : { orderBy?: HospitalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HospitalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHospitalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Hospital model
   */
  readonly fields: HospitalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Hospital.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HospitalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Hospital model
   */ 
  interface HospitalFieldRefs {
    readonly id: FieldRef<"Hospital", 'String'>
    readonly name: FieldRef<"Hospital", 'String'>
    readonly address: FieldRef<"Hospital", 'String'>
    readonly city: FieldRef<"Hospital", 'String'>
    readonly state: FieldRef<"Hospital", 'String'>
    readonly zipCode: FieldRef<"Hospital", 'String'>
    readonly phone: FieldRef<"Hospital", 'String'>
    readonly email: FieldRef<"Hospital", 'String'>
    readonly type: FieldRef<"Hospital", 'String'>
    readonly capabilities: FieldRef<"Hospital", 'String[]'>
    readonly region: FieldRef<"Hospital", 'String'>
    readonly coordinates: FieldRef<"Hospital", 'Json'>
    readonly latitude: FieldRef<"Hospital", 'Float'>
    readonly longitude: FieldRef<"Hospital", 'Float'>
    readonly operatingHours: FieldRef<"Hospital", 'String'>
    readonly isActive: FieldRef<"Hospital", 'Boolean'>
    readonly requiresReview: FieldRef<"Hospital", 'Boolean'>
    readonly approvedAt: FieldRef<"Hospital", 'DateTime'>
    readonly approvedBy: FieldRef<"Hospital", 'String'>
    readonly createdAt: FieldRef<"Hospital", 'DateTime'>
    readonly updatedAt: FieldRef<"Hospital", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Hospital findUnique
   */
  export type HospitalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect<ExtArgs> | null
    /**
     * Filter, which Hospital to fetch.
     */
    where: HospitalWhereUniqueInput
  }

  /**
   * Hospital findUniqueOrThrow
   */
  export type HospitalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect<ExtArgs> | null
    /**
     * Filter, which Hospital to fetch.
     */
    where: HospitalWhereUniqueInput
  }

  /**
   * Hospital findFirst
   */
  export type HospitalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect<ExtArgs> | null
    /**
     * Filter, which Hospital to fetch.
     */
    where?: HospitalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hospitals to fetch.
     */
    orderBy?: HospitalOrderByWithRelationInput | HospitalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Hospitals.
     */
    cursor?: HospitalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hospitals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hospitals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Hospitals.
     */
    distinct?: HospitalScalarFieldEnum | HospitalScalarFieldEnum[]
  }

  /**
   * Hospital findFirstOrThrow
   */
  export type HospitalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect<ExtArgs> | null
    /**
     * Filter, which Hospital to fetch.
     */
    where?: HospitalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hospitals to fetch.
     */
    orderBy?: HospitalOrderByWithRelationInput | HospitalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Hospitals.
     */
    cursor?: HospitalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hospitals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hospitals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Hospitals.
     */
    distinct?: HospitalScalarFieldEnum | HospitalScalarFieldEnum[]
  }

  /**
   * Hospital findMany
   */
  export type HospitalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect<ExtArgs> | null
    /**
     * Filter, which Hospitals to fetch.
     */
    where?: HospitalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hospitals to fetch.
     */
    orderBy?: HospitalOrderByWithRelationInput | HospitalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Hospitals.
     */
    cursor?: HospitalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hospitals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hospitals.
     */
    skip?: number
    distinct?: HospitalScalarFieldEnum | HospitalScalarFieldEnum[]
  }

  /**
   * Hospital create
   */
  export type HospitalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect<ExtArgs> | null
    /**
     * The data needed to create a Hospital.
     */
    data: XOR<HospitalCreateInput, HospitalUncheckedCreateInput>
  }

  /**
   * Hospital createMany
   */
  export type HospitalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Hospitals.
     */
    data: HospitalCreateManyInput | HospitalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Hospital createManyAndReturn
   */
  export type HospitalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Hospitals.
     */
    data: HospitalCreateManyInput | HospitalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Hospital update
   */
  export type HospitalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect<ExtArgs> | null
    /**
     * The data needed to update a Hospital.
     */
    data: XOR<HospitalUpdateInput, HospitalUncheckedUpdateInput>
    /**
     * Choose, which Hospital to update.
     */
    where: HospitalWhereUniqueInput
  }

  /**
   * Hospital updateMany
   */
  export type HospitalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Hospitals.
     */
    data: XOR<HospitalUpdateManyMutationInput, HospitalUncheckedUpdateManyInput>
    /**
     * Filter which Hospitals to update
     */
    where?: HospitalWhereInput
  }

  /**
   * Hospital upsert
   */
  export type HospitalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect<ExtArgs> | null
    /**
     * The filter to search for the Hospital to update in case it exists.
     */
    where: HospitalWhereUniqueInput
    /**
     * In case the Hospital found by the `where` argument doesn't exist, create a new Hospital with this data.
     */
    create: XOR<HospitalCreateInput, HospitalUncheckedCreateInput>
    /**
     * In case the Hospital was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HospitalUpdateInput, HospitalUncheckedUpdateInput>
  }

  /**
   * Hospital delete
   */
  export type HospitalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect<ExtArgs> | null
    /**
     * Filter which Hospital to delete.
     */
    where: HospitalWhereUniqueInput
  }

  /**
   * Hospital deleteMany
   */
  export type HospitalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Hospitals to delete
     */
    where?: HospitalWhereInput
  }

  /**
   * Hospital without action
   */
  export type HospitalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect<ExtArgs> | null
  }


  /**
   * Model EMSUser
   */

  export type AggregateEMSUser = {
    _count: EMSUserCountAggregateOutputType | null
    _min: EMSUserMinAggregateOutputType | null
    _max: EMSUserMaxAggregateOutputType | null
  }

  export type EMSUserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    agencyName: string | null
    agencyId: string | null
    isActive: boolean | null
    userType: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EMSUserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    agencyName: string | null
    agencyId: string | null
    isActive: boolean | null
    userType: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EMSUserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    name: number
    agencyName: number
    agencyId: number
    isActive: number
    userType: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EMSUserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    agencyName?: true
    agencyId?: true
    isActive?: true
    userType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EMSUserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    agencyName?: true
    agencyId?: true
    isActive?: true
    userType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EMSUserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    agencyName?: true
    agencyId?: true
    isActive?: true
    userType?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EMSUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EMSUser to aggregate.
     */
    where?: EMSUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EMSUsers to fetch.
     */
    orderBy?: EMSUserOrderByWithRelationInput | EMSUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EMSUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EMSUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EMSUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EMSUsers
    **/
    _count?: true | EMSUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EMSUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EMSUserMaxAggregateInputType
  }

  export type GetEMSUserAggregateType<T extends EMSUserAggregateArgs> = {
        [P in keyof T & keyof AggregateEMSUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEMSUser[P]>
      : GetScalarType<T[P], AggregateEMSUser[P]>
  }




  export type EMSUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EMSUserWhereInput
    orderBy?: EMSUserOrderByWithAggregationInput | EMSUserOrderByWithAggregationInput[]
    by: EMSUserScalarFieldEnum[] | EMSUserScalarFieldEnum
    having?: EMSUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EMSUserCountAggregateInputType | true
    _min?: EMSUserMinAggregateInputType
    _max?: EMSUserMaxAggregateInputType
  }

  export type EMSUserGroupByOutputType = {
    id: string
    email: string
    password: string
    name: string
    agencyName: string
    agencyId: string | null
    isActive: boolean
    userType: string
    createdAt: Date
    updatedAt: Date
    _count: EMSUserCountAggregateOutputType | null
    _min: EMSUserMinAggregateOutputType | null
    _max: EMSUserMaxAggregateOutputType | null
  }

  type GetEMSUserGroupByPayload<T extends EMSUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EMSUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EMSUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EMSUserGroupByOutputType[P]>
            : GetScalarType<T[P], EMSUserGroupByOutputType[P]>
        }
      >
    >


  export type EMSUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    agencyName?: boolean
    agencyId?: boolean
    isActive?: boolean
    userType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agency?: boolean | EMSUser$agencyArgs<ExtArgs>
  }, ExtArgs["result"]["eMSUser"]>

  export type EMSUserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    agencyName?: boolean
    agencyId?: boolean
    isActive?: boolean
    userType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agency?: boolean | EMSUser$agencyArgs<ExtArgs>
  }, ExtArgs["result"]["eMSUser"]>

  export type EMSUserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    agencyName?: boolean
    agencyId?: boolean
    isActive?: boolean
    userType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EMSUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agency?: boolean | EMSUser$agencyArgs<ExtArgs>
  }
  export type EMSUserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agency?: boolean | EMSUser$agencyArgs<ExtArgs>
  }

  export type $EMSUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EMSUser"
    objects: {
      agency: Prisma.$EMSAgencyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string
      name: string
      agencyName: string
      agencyId: string | null
      isActive: boolean
      userType: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["eMSUser"]>
    composites: {}
  }

  type EMSUserGetPayload<S extends boolean | null | undefined | EMSUserDefaultArgs> = $Result.GetResult<Prisma.$EMSUserPayload, S>

  type EMSUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EMSUserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EMSUserCountAggregateInputType | true
    }

  export interface EMSUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EMSUser'], meta: { name: 'EMSUser' } }
    /**
     * Find zero or one EMSUser that matches the filter.
     * @param {EMSUserFindUniqueArgs} args - Arguments to find a EMSUser
     * @example
     * // Get one EMSUser
     * const eMSUser = await prisma.eMSUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EMSUserFindUniqueArgs>(args: SelectSubset<T, EMSUserFindUniqueArgs<ExtArgs>>): Prisma__EMSUserClient<$Result.GetResult<Prisma.$EMSUserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EMSUser that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EMSUserFindUniqueOrThrowArgs} args - Arguments to find a EMSUser
     * @example
     * // Get one EMSUser
     * const eMSUser = await prisma.eMSUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EMSUserFindUniqueOrThrowArgs>(args: SelectSubset<T, EMSUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EMSUserClient<$Result.GetResult<Prisma.$EMSUserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EMSUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EMSUserFindFirstArgs} args - Arguments to find a EMSUser
     * @example
     * // Get one EMSUser
     * const eMSUser = await prisma.eMSUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EMSUserFindFirstArgs>(args?: SelectSubset<T, EMSUserFindFirstArgs<ExtArgs>>): Prisma__EMSUserClient<$Result.GetResult<Prisma.$EMSUserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EMSUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EMSUserFindFirstOrThrowArgs} args - Arguments to find a EMSUser
     * @example
     * // Get one EMSUser
     * const eMSUser = await prisma.eMSUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EMSUserFindFirstOrThrowArgs>(args?: SelectSubset<T, EMSUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__EMSUserClient<$Result.GetResult<Prisma.$EMSUserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EMSUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EMSUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EMSUsers
     * const eMSUsers = await prisma.eMSUser.findMany()
     * 
     * // Get first 10 EMSUsers
     * const eMSUsers = await prisma.eMSUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eMSUserWithIdOnly = await prisma.eMSUser.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EMSUserFindManyArgs>(args?: SelectSubset<T, EMSUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EMSUserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EMSUser.
     * @param {EMSUserCreateArgs} args - Arguments to create a EMSUser.
     * @example
     * // Create one EMSUser
     * const EMSUser = await prisma.eMSUser.create({
     *   data: {
     *     // ... data to create a EMSUser
     *   }
     * })
     * 
     */
    create<T extends EMSUserCreateArgs>(args: SelectSubset<T, EMSUserCreateArgs<ExtArgs>>): Prisma__EMSUserClient<$Result.GetResult<Prisma.$EMSUserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EMSUsers.
     * @param {EMSUserCreateManyArgs} args - Arguments to create many EMSUsers.
     * @example
     * // Create many EMSUsers
     * const eMSUser = await prisma.eMSUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EMSUserCreateManyArgs>(args?: SelectSubset<T, EMSUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EMSUsers and returns the data saved in the database.
     * @param {EMSUserCreateManyAndReturnArgs} args - Arguments to create many EMSUsers.
     * @example
     * // Create many EMSUsers
     * const eMSUser = await prisma.eMSUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EMSUsers and only return the `id`
     * const eMSUserWithIdOnly = await prisma.eMSUser.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EMSUserCreateManyAndReturnArgs>(args?: SelectSubset<T, EMSUserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EMSUserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EMSUser.
     * @param {EMSUserDeleteArgs} args - Arguments to delete one EMSUser.
     * @example
     * // Delete one EMSUser
     * const EMSUser = await prisma.eMSUser.delete({
     *   where: {
     *     // ... filter to delete one EMSUser
     *   }
     * })
     * 
     */
    delete<T extends EMSUserDeleteArgs>(args: SelectSubset<T, EMSUserDeleteArgs<ExtArgs>>): Prisma__EMSUserClient<$Result.GetResult<Prisma.$EMSUserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EMSUser.
     * @param {EMSUserUpdateArgs} args - Arguments to update one EMSUser.
     * @example
     * // Update one EMSUser
     * const eMSUser = await prisma.eMSUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EMSUserUpdateArgs>(args: SelectSubset<T, EMSUserUpdateArgs<ExtArgs>>): Prisma__EMSUserClient<$Result.GetResult<Prisma.$EMSUserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EMSUsers.
     * @param {EMSUserDeleteManyArgs} args - Arguments to filter EMSUsers to delete.
     * @example
     * // Delete a few EMSUsers
     * const { count } = await prisma.eMSUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EMSUserDeleteManyArgs>(args?: SelectSubset<T, EMSUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EMSUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EMSUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EMSUsers
     * const eMSUser = await prisma.eMSUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EMSUserUpdateManyArgs>(args: SelectSubset<T, EMSUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EMSUser.
     * @param {EMSUserUpsertArgs} args - Arguments to update or create a EMSUser.
     * @example
     * // Update or create a EMSUser
     * const eMSUser = await prisma.eMSUser.upsert({
     *   create: {
     *     // ... data to create a EMSUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EMSUser we want to update
     *   }
     * })
     */
    upsert<T extends EMSUserUpsertArgs>(args: SelectSubset<T, EMSUserUpsertArgs<ExtArgs>>): Prisma__EMSUserClient<$Result.GetResult<Prisma.$EMSUserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EMSUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EMSUserCountArgs} args - Arguments to filter EMSUsers to count.
     * @example
     * // Count the number of EMSUsers
     * const count = await prisma.eMSUser.count({
     *   where: {
     *     // ... the filter for the EMSUsers we want to count
     *   }
     * })
    **/
    count<T extends EMSUserCountArgs>(
      args?: Subset<T, EMSUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EMSUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EMSUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EMSUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EMSUserAggregateArgs>(args: Subset<T, EMSUserAggregateArgs>): Prisma.PrismaPromise<GetEMSUserAggregateType<T>>

    /**
     * Group by EMSUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EMSUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EMSUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EMSUserGroupByArgs['orderBy'] }
        : { orderBy?: EMSUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EMSUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEMSUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EMSUser model
   */
  readonly fields: EMSUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EMSUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EMSUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agency<T extends EMSUser$agencyArgs<ExtArgs> = {}>(args?: Subset<T, EMSUser$agencyArgs<ExtArgs>>): Prisma__EMSAgencyClient<$Result.GetResult<Prisma.$EMSAgencyPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EMSUser model
   */ 
  interface EMSUserFieldRefs {
    readonly id: FieldRef<"EMSUser", 'String'>
    readonly email: FieldRef<"EMSUser", 'String'>
    readonly password: FieldRef<"EMSUser", 'String'>
    readonly name: FieldRef<"EMSUser", 'String'>
    readonly agencyName: FieldRef<"EMSUser", 'String'>
    readonly agencyId: FieldRef<"EMSUser", 'String'>
    readonly isActive: FieldRef<"EMSUser", 'Boolean'>
    readonly userType: FieldRef<"EMSUser", 'String'>
    readonly createdAt: FieldRef<"EMSUser", 'DateTime'>
    readonly updatedAt: FieldRef<"EMSUser", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EMSUser findUnique
   */
  export type EMSUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EMSUser
     */
    select?: EMSUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EMSUserInclude<ExtArgs> | null
    /**
     * Filter, which EMSUser to fetch.
     */
    where: EMSUserWhereUniqueInput
  }

  /**
   * EMSUser findUniqueOrThrow
   */
  export type EMSUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EMSUser
     */
    select?: EMSUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EMSUserInclude<ExtArgs> | null
    /**
     * Filter, which EMSUser to fetch.
     */
    where: EMSUserWhereUniqueInput
  }

  /**
   * EMSUser findFirst
   */
  export type EMSUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EMSUser
     */
    select?: EMSUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EMSUserInclude<ExtArgs> | null
    /**
     * Filter, which EMSUser to fetch.
     */
    where?: EMSUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EMSUsers to fetch.
     */
    orderBy?: EMSUserOrderByWithRelationInput | EMSUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EMSUsers.
     */
    cursor?: EMSUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EMSUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EMSUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EMSUsers.
     */
    distinct?: EMSUserScalarFieldEnum | EMSUserScalarFieldEnum[]
  }

  /**
   * EMSUser findFirstOrThrow
   */
  export type EMSUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EMSUser
     */
    select?: EMSUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EMSUserInclude<ExtArgs> | null
    /**
     * Filter, which EMSUser to fetch.
     */
    where?: EMSUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EMSUsers to fetch.
     */
    orderBy?: EMSUserOrderByWithRelationInput | EMSUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EMSUsers.
     */
    cursor?: EMSUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EMSUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EMSUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EMSUsers.
     */
    distinct?: EMSUserScalarFieldEnum | EMSUserScalarFieldEnum[]
  }

  /**
   * EMSUser findMany
   */
  export type EMSUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EMSUser
     */
    select?: EMSUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EMSUserInclude<ExtArgs> | null
    /**
     * Filter, which EMSUsers to fetch.
     */
    where?: EMSUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EMSUsers to fetch.
     */
    orderBy?: EMSUserOrderByWithRelationInput | EMSUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EMSUsers.
     */
    cursor?: EMSUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EMSUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EMSUsers.
     */
    skip?: number
    distinct?: EMSUserScalarFieldEnum | EMSUserScalarFieldEnum[]
  }

  /**
   * EMSUser create
   */
  export type EMSUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EMSUser
     */
    select?: EMSUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EMSUserInclude<ExtArgs> | null
    /**
     * The data needed to create a EMSUser.
     */
    data: XOR<EMSUserCreateInput, EMSUserUncheckedCreateInput>
  }

  /**
   * EMSUser createMany
   */
  export type EMSUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EMSUsers.
     */
    data: EMSUserCreateManyInput | EMSUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EMSUser createManyAndReturn
   */
  export type EMSUserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EMSUser
     */
    select?: EMSUserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EMSUsers.
     */
    data: EMSUserCreateManyInput | EMSUserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EMSUserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EMSUser update
   */
  export type EMSUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EMSUser
     */
    select?: EMSUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EMSUserInclude<ExtArgs> | null
    /**
     * The data needed to update a EMSUser.
     */
    data: XOR<EMSUserUpdateInput, EMSUserUncheckedUpdateInput>
    /**
     * Choose, which EMSUser to update.
     */
    where: EMSUserWhereUniqueInput
  }

  /**
   * EMSUser updateMany
   */
  export type EMSUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EMSUsers.
     */
    data: XOR<EMSUserUpdateManyMutationInput, EMSUserUncheckedUpdateManyInput>
    /**
     * Filter which EMSUsers to update
     */
    where?: EMSUserWhereInput
  }

  /**
   * EMSUser upsert
   */
  export type EMSUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EMSUser
     */
    select?: EMSUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EMSUserInclude<ExtArgs> | null
    /**
     * The filter to search for the EMSUser to update in case it exists.
     */
    where: EMSUserWhereUniqueInput
    /**
     * In case the EMSUser found by the `where` argument doesn't exist, create a new EMSUser with this data.
     */
    create: XOR<EMSUserCreateInput, EMSUserUncheckedCreateInput>
    /**
     * In case the EMSUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EMSUserUpdateInput, EMSUserUncheckedUpdateInput>
  }

  /**
   * EMSUser delete
   */
  export type EMSUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EMSUser
     */
    select?: EMSUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EMSUserInclude<ExtArgs> | null
    /**
     * Filter which EMSUser to delete.
     */
    where: EMSUserWhereUniqueInput
  }

  /**
   * EMSUser deleteMany
   */
  export type EMSUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EMSUsers to delete
     */
    where?: EMSUserWhereInput
  }

  /**
   * EMSUser.agency
   */
  export type EMSUser$agencyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EMSAgency
     */
    select?: EMSAgencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EMSAgencyInclude<ExtArgs> | null
    where?: EMSAgencyWhereInput
  }

  /**
   * EMSUser without action
   */
  export type EMSUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EMSUser
     */
    select?: EMSUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EMSUserInclude<ExtArgs> | null
  }


  /**
   * Model EMSAgency
   */

  export type AggregateEMSAgency = {
    _count: EMSAgencyCountAggregateOutputType | null
    _avg: EMSAgencyAvgAggregateOutputType | null
    _sum: EMSAgencySumAggregateOutputType | null
    _min: EMSAgencyMinAggregateOutputType | null
    _max: EMSAgencyMaxAggregateOutputType | null
  }

  export type EMSAgencyAvgAggregateOutputType = {
    availableUnits: number | null
    latitude: number | null
    longitude: number | null
    serviceRadius: number | null
    totalUnits: number | null
  }

  export type EMSAgencySumAggregateOutputType = {
    availableUnits: number | null
    latitude: number | null
    longitude: number | null
    serviceRadius: number | null
    totalUnits: number | null
  }

  export type EMSAgencyMinAggregateOutputType = {
    id: string | null
    name: string | null
    contactName: string | null
    phone: string | null
    email: string | null
    address: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    isActive: boolean | null
    status: string | null
    addedBy: string | null
    addedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    acceptsNotifications: boolean | null
    approvedAt: Date | null
    approvedBy: string | null
    availableUnits: number | null
    lastUpdated: Date | null
    latitude: number | null
    longitude: number | null
    requiresReview: boolean | null
    serviceRadius: number | null
    totalUnits: number | null
  }

  export type EMSAgencyMaxAggregateOutputType = {
    id: string | null
    name: string | null
    contactName: string | null
    phone: string | null
    email: string | null
    address: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    isActive: boolean | null
    status: string | null
    addedBy: string | null
    addedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    acceptsNotifications: boolean | null
    approvedAt: Date | null
    approvedBy: string | null
    availableUnits: number | null
    lastUpdated: Date | null
    latitude: number | null
    longitude: number | null
    requiresReview: boolean | null
    serviceRadius: number | null
    totalUnits: number | null
  }

  export type EMSAgencyCountAggregateOutputType = {
    id: number
    name: number
    contactName: number
    phone: number
    email: number
    address: number
    city: number
    state: number
    zipCode: number
    serviceArea: number
    operatingHours: number
    capabilities: number
    pricingStructure: number
    isActive: number
    status: number
    addedBy: number
    addedAt: number
    createdAt: number
    updatedAt: number
    acceptsNotifications: number
    approvedAt: number
    approvedBy: number
    availableUnits: number
    lastUpdated: number
    latitude: number
    longitude: number
    notificationMethods: number
    requiresReview: number
    serviceRadius: number
    totalUnits: number
    _all: number
  }


  export type EMSAgencyAvgAggregateInputType = {
    availableUnits?: true
    latitude?: true
    longitude?: true
    serviceRadius?: true
    totalUnits?: true
  }

  export type EMSAgencySumAggregateInputType = {
    availableUnits?: true
    latitude?: true
    longitude?: true
    serviceRadius?: true
    totalUnits?: true
  }

  export type EMSAgencyMinAggregateInputType = {
    id?: true
    name?: true
    contactName?: true
    phone?: true
    email?: true
    address?: true
    city?: true
    state?: true
    zipCode?: true
    isActive?: true
    status?: true
    addedBy?: true
    addedAt?: true
    createdAt?: true
    updatedAt?: true
    acceptsNotifications?: true
    approvedAt?: true
    approvedBy?: true
    availableUnits?: true
    lastUpdated?: true
    latitude?: true
    longitude?: true
    requiresReview?: true
    serviceRadius?: true
    totalUnits?: true
  }

  export type EMSAgencyMaxAggregateInputType = {
    id?: true
    name?: true
    contactName?: true
    phone?: true
    email?: true
    address?: true
    city?: true
    state?: true
    zipCode?: true
    isActive?: true
    status?: true
    addedBy?: true
    addedAt?: true
    createdAt?: true
    updatedAt?: true
    acceptsNotifications?: true
    approvedAt?: true
    approvedBy?: true
    availableUnits?: true
    lastUpdated?: true
    latitude?: true
    longitude?: true
    requiresReview?: true
    serviceRadius?: true
    totalUnits?: true
  }

  export type EMSAgencyCountAggregateInputType = {
    id?: true
    name?: true
    contactName?: true
    phone?: true
    email?: true
    address?: true
    city?: true
    state?: true
    zipCode?: true
    serviceArea?: true
    operatingHours?: true
    capabilities?: true
    pricingStructure?: true
    isActive?: true
    status?: true
    addedBy?: true
    addedAt?: true
    createdAt?: true
    updatedAt?: true
    acceptsNotifications?: true
    approvedAt?: true
    approvedBy?: true
    availableUnits?: true
    lastUpdated?: true
    latitude?: true
    longitude?: true
    notificationMethods?: true
    requiresReview?: true
    serviceRadius?: true
    totalUnits?: true
    _all?: true
  }

  export type EMSAgencyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EMSAgency to aggregate.
     */
    where?: EMSAgencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EMSAgencies to fetch.
     */
    orderBy?: EMSAgencyOrderByWithRelationInput | EMSAgencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EMSAgencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EMSAgencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EMSAgencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EMSAgencies
    **/
    _count?: true | EMSAgencyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EMSAgencyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EMSAgencySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EMSAgencyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EMSAgencyMaxAggregateInputType
  }

  export type GetEMSAgencyAggregateType<T extends EMSAgencyAggregateArgs> = {
        [P in keyof T & keyof AggregateEMSAgency]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEMSAgency[P]>
      : GetScalarType<T[P], AggregateEMSAgency[P]>
  }




  export type EMSAgencyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EMSAgencyWhereInput
    orderBy?: EMSAgencyOrderByWithAggregationInput | EMSAgencyOrderByWithAggregationInput[]
    by: EMSAgencyScalarFieldEnum[] | EMSAgencyScalarFieldEnum
    having?: EMSAgencyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EMSAgencyCountAggregateInputType | true
    _avg?: EMSAgencyAvgAggregateInputType
    _sum?: EMSAgencySumAggregateInputType
    _min?: EMSAgencyMinAggregateInputType
    _max?: EMSAgencyMaxAggregateInputType
  }

  export type EMSAgencyGroupByOutputType = {
    id: string
    name: string
    contactName: string
    phone: string
    email: string
    address: string
    city: string
    state: string
    zipCode: string
    serviceArea: string[]
    operatingHours: JsonValue | null
    capabilities: string[]
    pricingStructure: JsonValue | null
    isActive: boolean
    status: string
    addedBy: string | null
    addedAt: Date
    createdAt: Date
    updatedAt: Date
    acceptsNotifications: boolean
    approvedAt: Date | null
    approvedBy: string | null
    availableUnits: number
    lastUpdated: Date
    latitude: number | null
    longitude: number | null
    notificationMethods: string[]
    requiresReview: boolean
    serviceRadius: number | null
    totalUnits: number
    _count: EMSAgencyCountAggregateOutputType | null
    _avg: EMSAgencyAvgAggregateOutputType | null
    _sum: EMSAgencySumAggregateOutputType | null
    _min: EMSAgencyMinAggregateOutputType | null
    _max: EMSAgencyMaxAggregateOutputType | null
  }

  type GetEMSAgencyGroupByPayload<T extends EMSAgencyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EMSAgencyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EMSAgencyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EMSAgencyGroupByOutputType[P]>
            : GetScalarType<T[P], EMSAgencyGroupByOutputType[P]>
        }
      >
    >


  export type EMSAgencySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    contactName?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    serviceArea?: boolean
    operatingHours?: boolean
    capabilities?: boolean
    pricingStructure?: boolean
    isActive?: boolean
    status?: boolean
    addedBy?: boolean
    addedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    acceptsNotifications?: boolean
    approvedAt?: boolean
    approvedBy?: boolean
    availableUnits?: boolean
    lastUpdated?: boolean
    latitude?: boolean
    longitude?: boolean
    notificationMethods?: boolean
    requiresReview?: boolean
    serviceRadius?: boolean
    totalUnits?: boolean
    units?: boolean | EMSAgency$unitsArgs<ExtArgs>
    users?: boolean | EMSAgency$usersArgs<ExtArgs>
    _count?: boolean | EMSAgencyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eMSAgency"]>

  export type EMSAgencySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    contactName?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    serviceArea?: boolean
    operatingHours?: boolean
    capabilities?: boolean
    pricingStructure?: boolean
    isActive?: boolean
    status?: boolean
    addedBy?: boolean
    addedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    acceptsNotifications?: boolean
    approvedAt?: boolean
    approvedBy?: boolean
    availableUnits?: boolean
    lastUpdated?: boolean
    latitude?: boolean
    longitude?: boolean
    notificationMethods?: boolean
    requiresReview?: boolean
    serviceRadius?: boolean
    totalUnits?: boolean
  }, ExtArgs["result"]["eMSAgency"]>

  export type EMSAgencySelectScalar = {
    id?: boolean
    name?: boolean
    contactName?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    serviceArea?: boolean
    operatingHours?: boolean
    capabilities?: boolean
    pricingStructure?: boolean
    isActive?: boolean
    status?: boolean
    addedBy?: boolean
    addedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    acceptsNotifications?: boolean
    approvedAt?: boolean
    approvedBy?: boolean
    availableUnits?: boolean
    lastUpdated?: boolean
    latitude?: boolean
    longitude?: boolean
    notificationMethods?: boolean
    requiresReview?: boolean
    serviceRadius?: boolean
    totalUnits?: boolean
  }

  export type EMSAgencyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    units?: boolean | EMSAgency$unitsArgs<ExtArgs>
    users?: boolean | EMSAgency$usersArgs<ExtArgs>
    _count?: boolean | EMSAgencyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EMSAgencyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $EMSAgencyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EMSAgency"
    objects: {
      units: Prisma.$UnitPayload<ExtArgs>[]
      users: Prisma.$EMSUserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      contactName: string
      phone: string
      email: string
      address: string
      city: string
      state: string
      zipCode: string
      serviceArea: string[]
      operatingHours: Prisma.JsonValue | null
      capabilities: string[]
      pricingStructure: Prisma.JsonValue | null
      isActive: boolean
      status: string
      addedBy: string | null
      addedAt: Date
      createdAt: Date
      updatedAt: Date
      acceptsNotifications: boolean
      approvedAt: Date | null
      approvedBy: string | null
      availableUnits: number
      lastUpdated: Date
      latitude: number | null
      longitude: number | null
      notificationMethods: string[]
      requiresReview: boolean
      serviceRadius: number | null
      totalUnits: number
    }, ExtArgs["result"]["eMSAgency"]>
    composites: {}
  }

  type EMSAgencyGetPayload<S extends boolean | null | undefined | EMSAgencyDefaultArgs> = $Result.GetResult<Prisma.$EMSAgencyPayload, S>

  type EMSAgencyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EMSAgencyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EMSAgencyCountAggregateInputType | true
    }

  export interface EMSAgencyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EMSAgency'], meta: { name: 'EMSAgency' } }
    /**
     * Find zero or one EMSAgency that matches the filter.
     * @param {EMSAgencyFindUniqueArgs} args - Arguments to find a EMSAgency
     * @example
     * // Get one EMSAgency
     * const eMSAgency = await prisma.eMSAgency.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EMSAgencyFindUniqueArgs>(args: SelectSubset<T, EMSAgencyFindUniqueArgs<ExtArgs>>): Prisma__EMSAgencyClient<$Result.GetResult<Prisma.$EMSAgencyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EMSAgency that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EMSAgencyFindUniqueOrThrowArgs} args - Arguments to find a EMSAgency
     * @example
     * // Get one EMSAgency
     * const eMSAgency = await prisma.eMSAgency.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EMSAgencyFindUniqueOrThrowArgs>(args: SelectSubset<T, EMSAgencyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EMSAgencyClient<$Result.GetResult<Prisma.$EMSAgencyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EMSAgency that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EMSAgencyFindFirstArgs} args - Arguments to find a EMSAgency
     * @example
     * // Get one EMSAgency
     * const eMSAgency = await prisma.eMSAgency.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EMSAgencyFindFirstArgs>(args?: SelectSubset<T, EMSAgencyFindFirstArgs<ExtArgs>>): Prisma__EMSAgencyClient<$Result.GetResult<Prisma.$EMSAgencyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EMSAgency that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EMSAgencyFindFirstOrThrowArgs} args - Arguments to find a EMSAgency
     * @example
     * // Get one EMSAgency
     * const eMSAgency = await prisma.eMSAgency.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EMSAgencyFindFirstOrThrowArgs>(args?: SelectSubset<T, EMSAgencyFindFirstOrThrowArgs<ExtArgs>>): Prisma__EMSAgencyClient<$Result.GetResult<Prisma.$EMSAgencyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EMSAgencies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EMSAgencyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EMSAgencies
     * const eMSAgencies = await prisma.eMSAgency.findMany()
     * 
     * // Get first 10 EMSAgencies
     * const eMSAgencies = await prisma.eMSAgency.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eMSAgencyWithIdOnly = await prisma.eMSAgency.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EMSAgencyFindManyArgs>(args?: SelectSubset<T, EMSAgencyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EMSAgencyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EMSAgency.
     * @param {EMSAgencyCreateArgs} args - Arguments to create a EMSAgency.
     * @example
     * // Create one EMSAgency
     * const EMSAgency = await prisma.eMSAgency.create({
     *   data: {
     *     // ... data to create a EMSAgency
     *   }
     * })
     * 
     */
    create<T extends EMSAgencyCreateArgs>(args: SelectSubset<T, EMSAgencyCreateArgs<ExtArgs>>): Prisma__EMSAgencyClient<$Result.GetResult<Prisma.$EMSAgencyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EMSAgencies.
     * @param {EMSAgencyCreateManyArgs} args - Arguments to create many EMSAgencies.
     * @example
     * // Create many EMSAgencies
     * const eMSAgency = await prisma.eMSAgency.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EMSAgencyCreateManyArgs>(args?: SelectSubset<T, EMSAgencyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EMSAgencies and returns the data saved in the database.
     * @param {EMSAgencyCreateManyAndReturnArgs} args - Arguments to create many EMSAgencies.
     * @example
     * // Create many EMSAgencies
     * const eMSAgency = await prisma.eMSAgency.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EMSAgencies and only return the `id`
     * const eMSAgencyWithIdOnly = await prisma.eMSAgency.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EMSAgencyCreateManyAndReturnArgs>(args?: SelectSubset<T, EMSAgencyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EMSAgencyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EMSAgency.
     * @param {EMSAgencyDeleteArgs} args - Arguments to delete one EMSAgency.
     * @example
     * // Delete one EMSAgency
     * const EMSAgency = await prisma.eMSAgency.delete({
     *   where: {
     *     // ... filter to delete one EMSAgency
     *   }
     * })
     * 
     */
    delete<T extends EMSAgencyDeleteArgs>(args: SelectSubset<T, EMSAgencyDeleteArgs<ExtArgs>>): Prisma__EMSAgencyClient<$Result.GetResult<Prisma.$EMSAgencyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EMSAgency.
     * @param {EMSAgencyUpdateArgs} args - Arguments to update one EMSAgency.
     * @example
     * // Update one EMSAgency
     * const eMSAgency = await prisma.eMSAgency.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EMSAgencyUpdateArgs>(args: SelectSubset<T, EMSAgencyUpdateArgs<ExtArgs>>): Prisma__EMSAgencyClient<$Result.GetResult<Prisma.$EMSAgencyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EMSAgencies.
     * @param {EMSAgencyDeleteManyArgs} args - Arguments to filter EMSAgencies to delete.
     * @example
     * // Delete a few EMSAgencies
     * const { count } = await prisma.eMSAgency.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EMSAgencyDeleteManyArgs>(args?: SelectSubset<T, EMSAgencyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EMSAgencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EMSAgencyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EMSAgencies
     * const eMSAgency = await prisma.eMSAgency.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EMSAgencyUpdateManyArgs>(args: SelectSubset<T, EMSAgencyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EMSAgency.
     * @param {EMSAgencyUpsertArgs} args - Arguments to update or create a EMSAgency.
     * @example
     * // Update or create a EMSAgency
     * const eMSAgency = await prisma.eMSAgency.upsert({
     *   create: {
     *     // ... data to create a EMSAgency
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EMSAgency we want to update
     *   }
     * })
     */
    upsert<T extends EMSAgencyUpsertArgs>(args: SelectSubset<T, EMSAgencyUpsertArgs<ExtArgs>>): Prisma__EMSAgencyClient<$Result.GetResult<Prisma.$EMSAgencyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EMSAgencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EMSAgencyCountArgs} args - Arguments to filter EMSAgencies to count.
     * @example
     * // Count the number of EMSAgencies
     * const count = await prisma.eMSAgency.count({
     *   where: {
     *     // ... the filter for the EMSAgencies we want to count
     *   }
     * })
    **/
    count<T extends EMSAgencyCountArgs>(
      args?: Subset<T, EMSAgencyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EMSAgencyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EMSAgency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EMSAgencyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EMSAgencyAggregateArgs>(args: Subset<T, EMSAgencyAggregateArgs>): Prisma.PrismaPromise<GetEMSAgencyAggregateType<T>>

    /**
     * Group by EMSAgency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EMSAgencyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EMSAgencyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EMSAgencyGroupByArgs['orderBy'] }
        : { orderBy?: EMSAgencyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EMSAgencyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEMSAgencyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EMSAgency model
   */
  readonly fields: EMSAgencyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EMSAgency.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EMSAgencyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    units<T extends EMSAgency$unitsArgs<ExtArgs> = {}>(args?: Subset<T, EMSAgency$unitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findMany"> | Null>
    users<T extends EMSAgency$usersArgs<ExtArgs> = {}>(args?: Subset<T, EMSAgency$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EMSUserPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EMSAgency model
   */ 
  interface EMSAgencyFieldRefs {
    readonly id: FieldRef<"EMSAgency", 'String'>
    readonly name: FieldRef<"EMSAgency", 'String'>
    readonly contactName: FieldRef<"EMSAgency", 'String'>
    readonly phone: FieldRef<"EMSAgency", 'String'>
    readonly email: FieldRef<"EMSAgency", 'String'>
    readonly address: FieldRef<"EMSAgency", 'String'>
    readonly city: FieldRef<"EMSAgency", 'String'>
    readonly state: FieldRef<"EMSAgency", 'String'>
    readonly zipCode: FieldRef<"EMSAgency", 'String'>
    readonly serviceArea: FieldRef<"EMSAgency", 'String[]'>
    readonly operatingHours: FieldRef<"EMSAgency", 'Json'>
    readonly capabilities: FieldRef<"EMSAgency", 'String[]'>
    readonly pricingStructure: FieldRef<"EMSAgency", 'Json'>
    readonly isActive: FieldRef<"EMSAgency", 'Boolean'>
    readonly status: FieldRef<"EMSAgency", 'String'>
    readonly addedBy: FieldRef<"EMSAgency", 'String'>
    readonly addedAt: FieldRef<"EMSAgency", 'DateTime'>
    readonly createdAt: FieldRef<"EMSAgency", 'DateTime'>
    readonly updatedAt: FieldRef<"EMSAgency", 'DateTime'>
    readonly acceptsNotifications: FieldRef<"EMSAgency", 'Boolean'>
    readonly approvedAt: FieldRef<"EMSAgency", 'DateTime'>
    readonly approvedBy: FieldRef<"EMSAgency", 'String'>
    readonly availableUnits: FieldRef<"EMSAgency", 'Int'>
    readonly lastUpdated: FieldRef<"EMSAgency", 'DateTime'>
    readonly latitude: FieldRef<"EMSAgency", 'Float'>
    readonly longitude: FieldRef<"EMSAgency", 'Float'>
    readonly notificationMethods: FieldRef<"EMSAgency", 'String[]'>
    readonly requiresReview: FieldRef<"EMSAgency", 'Boolean'>
    readonly serviceRadius: FieldRef<"EMSAgency", 'Int'>
    readonly totalUnits: FieldRef<"EMSAgency", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * EMSAgency findUnique
   */
  export type EMSAgencyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EMSAgency
     */
    select?: EMSAgencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EMSAgencyInclude<ExtArgs> | null
    /**
     * Filter, which EMSAgency to fetch.
     */
    where: EMSAgencyWhereUniqueInput
  }

  /**
   * EMSAgency findUniqueOrThrow
   */
  export type EMSAgencyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EMSAgency
     */
    select?: EMSAgencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EMSAgencyInclude<ExtArgs> | null
    /**
     * Filter, which EMSAgency to fetch.
     */
    where: EMSAgencyWhereUniqueInput
  }

  /**
   * EMSAgency findFirst
   */
  export type EMSAgencyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EMSAgency
     */
    select?: EMSAgencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EMSAgencyInclude<ExtArgs> | null
    /**
     * Filter, which EMSAgency to fetch.
     */
    where?: EMSAgencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EMSAgencies to fetch.
     */
    orderBy?: EMSAgencyOrderByWithRelationInput | EMSAgencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EMSAgencies.
     */
    cursor?: EMSAgencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EMSAgencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EMSAgencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EMSAgencies.
     */
    distinct?: EMSAgencyScalarFieldEnum | EMSAgencyScalarFieldEnum[]
  }

  /**
   * EMSAgency findFirstOrThrow
   */
  export type EMSAgencyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EMSAgency
     */
    select?: EMSAgencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EMSAgencyInclude<ExtArgs> | null
    /**
     * Filter, which EMSAgency to fetch.
     */
    where?: EMSAgencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EMSAgencies to fetch.
     */
    orderBy?: EMSAgencyOrderByWithRelationInput | EMSAgencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EMSAgencies.
     */
    cursor?: EMSAgencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EMSAgencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EMSAgencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EMSAgencies.
     */
    distinct?: EMSAgencyScalarFieldEnum | EMSAgencyScalarFieldEnum[]
  }

  /**
   * EMSAgency findMany
   */
  export type EMSAgencyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EMSAgency
     */
    select?: EMSAgencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EMSAgencyInclude<ExtArgs> | null
    /**
     * Filter, which EMSAgencies to fetch.
     */
    where?: EMSAgencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EMSAgencies to fetch.
     */
    orderBy?: EMSAgencyOrderByWithRelationInput | EMSAgencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EMSAgencies.
     */
    cursor?: EMSAgencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EMSAgencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EMSAgencies.
     */
    skip?: number
    distinct?: EMSAgencyScalarFieldEnum | EMSAgencyScalarFieldEnum[]
  }

  /**
   * EMSAgency create
   */
  export type EMSAgencyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EMSAgency
     */
    select?: EMSAgencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EMSAgencyInclude<ExtArgs> | null
    /**
     * The data needed to create a EMSAgency.
     */
    data: XOR<EMSAgencyCreateInput, EMSAgencyUncheckedCreateInput>
  }

  /**
   * EMSAgency createMany
   */
  export type EMSAgencyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EMSAgencies.
     */
    data: EMSAgencyCreateManyInput | EMSAgencyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EMSAgency createManyAndReturn
   */
  export type EMSAgencyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EMSAgency
     */
    select?: EMSAgencySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EMSAgencies.
     */
    data: EMSAgencyCreateManyInput | EMSAgencyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EMSAgency update
   */
  export type EMSAgencyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EMSAgency
     */
    select?: EMSAgencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EMSAgencyInclude<ExtArgs> | null
    /**
     * The data needed to update a EMSAgency.
     */
    data: XOR<EMSAgencyUpdateInput, EMSAgencyUncheckedUpdateInput>
    /**
     * Choose, which EMSAgency to update.
     */
    where: EMSAgencyWhereUniqueInput
  }

  /**
   * EMSAgency updateMany
   */
  export type EMSAgencyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EMSAgencies.
     */
    data: XOR<EMSAgencyUpdateManyMutationInput, EMSAgencyUncheckedUpdateManyInput>
    /**
     * Filter which EMSAgencies to update
     */
    where?: EMSAgencyWhereInput
  }

  /**
   * EMSAgency upsert
   */
  export type EMSAgencyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EMSAgency
     */
    select?: EMSAgencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EMSAgencyInclude<ExtArgs> | null
    /**
     * The filter to search for the EMSAgency to update in case it exists.
     */
    where: EMSAgencyWhereUniqueInput
    /**
     * In case the EMSAgency found by the `where` argument doesn't exist, create a new EMSAgency with this data.
     */
    create: XOR<EMSAgencyCreateInput, EMSAgencyUncheckedCreateInput>
    /**
     * In case the EMSAgency was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EMSAgencyUpdateInput, EMSAgencyUncheckedUpdateInput>
  }

  /**
   * EMSAgency delete
   */
  export type EMSAgencyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EMSAgency
     */
    select?: EMSAgencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EMSAgencyInclude<ExtArgs> | null
    /**
     * Filter which EMSAgency to delete.
     */
    where: EMSAgencyWhereUniqueInput
  }

  /**
   * EMSAgency deleteMany
   */
  export type EMSAgencyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EMSAgencies to delete
     */
    where?: EMSAgencyWhereInput
  }

  /**
   * EMSAgency.units
   */
  export type EMSAgency$unitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    where?: UnitWhereInput
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    cursor?: UnitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * EMSAgency.users
   */
  export type EMSAgency$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EMSUser
     */
    select?: EMSUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EMSUserInclude<ExtArgs> | null
    where?: EMSUserWhereInput
    orderBy?: EMSUserOrderByWithRelationInput | EMSUserOrderByWithRelationInput[]
    cursor?: EMSUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EMSUserScalarFieldEnum | EMSUserScalarFieldEnum[]
  }

  /**
   * EMSAgency without action
   */
  export type EMSAgencyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EMSAgency
     */
    select?: EMSAgencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EMSAgencyInclude<ExtArgs> | null
  }


  /**
   * Model Trip
   */

  export type AggregateTrip = {
    _count: TripCountAggregateOutputType | null
    _avg: TripAvgAggregateOutputType | null
    _sum: TripSumAggregateOutputType | null
    _min: TripMinAggregateOutputType | null
    _max: TripMaxAggregateOutputType | null
  }

  export type TripAvgAggregateOutputType = {
    notificationRadius: number | null
    actualTripTimeMinutes: number | null
    completionTimeMinutes: number | null
    customerSatisfaction: number | null
    deadheadMiles: number | null
    destinationLatitude: number | null
    destinationLongitude: number | null
    distanceMiles: number | null
    efficiency: Decimal | null
    estimatedTripTimeMinutes: number | null
    insurancePayRate: Decimal | null
    loadedMiles: Decimal | null
    originLatitude: number | null
    originLongitude: number | null
    perMileRate: Decimal | null
    performanceScore: Decimal | null
    responseTimeMinutes: number | null
    revenuePerHour: Decimal | null
    tripCost: Decimal | null
    maxResponses: number | null
  }

  export type TripSumAggregateOutputType = {
    notificationRadius: number | null
    actualTripTimeMinutes: number | null
    completionTimeMinutes: number | null
    customerSatisfaction: number | null
    deadheadMiles: number | null
    destinationLatitude: number | null
    destinationLongitude: number | null
    distanceMiles: number | null
    efficiency: Decimal | null
    estimatedTripTimeMinutes: number | null
    insurancePayRate: Decimal | null
    loadedMiles: Decimal | null
    originLatitude: number | null
    originLongitude: number | null
    perMileRate: Decimal | null
    performanceScore: Decimal | null
    responseTimeMinutes: number | null
    revenuePerHour: Decimal | null
    tripCost: Decimal | null
    maxResponses: number | null
  }

  export type TripMinAggregateOutputType = {
    id: string | null
    tripNumber: string | null
    patientId: string | null
    patientWeight: string | null
    specialNeeds: string | null
    fromLocation: string | null
    toLocation: string | null
    scheduledTime: Date | null
    transportLevel: string | null
    urgencyLevel: string | null
    diagnosis: string | null
    mobilityLevel: string | null
    oxygenRequired: boolean | null
    monitoringRequired: boolean | null
    generateQRCode: boolean | null
    qrCodeData: string | null
    notificationRadius: number | null
    transferRequestTime: Date | null
    transferAcceptedTime: Date | null
    emsArrivalTime: Date | null
    emsDepartureTime: Date | null
    actualStartTime: Date | null
    actualEndTime: Date | null
    status: string | null
    priority: string | null
    notes: string | null
    assignedTo: string | null
    assignedAgencyId: string | null
    assignedUnitId: string | null
    acceptedTimestamp: Date | null
    pickupTimestamp: Date | null
    completionTimestamp: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    actualTripTimeMinutes: number | null
    backhaulOpportunity: boolean | null
    completionTimeMinutes: number | null
    customerSatisfaction: number | null
    deadheadMiles: number | null
    destinationLatitude: number | null
    destinationLongitude: number | null
    distanceMiles: number | null
    efficiency: Decimal | null
    estimatedTripTimeMinutes: number | null
    insuranceCompany: string | null
    insurancePayRate: Decimal | null
    loadedMiles: Decimal | null
    originLatitude: number | null
    originLongitude: number | null
    perMileRate: Decimal | null
    performanceScore: Decimal | null
    requestTimestamp: Date | null
    responseTimeMinutes: number | null
    revenuePerHour: Decimal | null
    tripCost: Decimal | null
    pickupLocationId: string | null
    maxResponses: number | null
    responseDeadline: Date | null
    responseStatus: string | null
    selectionMode: string | null
  }

  export type TripMaxAggregateOutputType = {
    id: string | null
    tripNumber: string | null
    patientId: string | null
    patientWeight: string | null
    specialNeeds: string | null
    fromLocation: string | null
    toLocation: string | null
    scheduledTime: Date | null
    transportLevel: string | null
    urgencyLevel: string | null
    diagnosis: string | null
    mobilityLevel: string | null
    oxygenRequired: boolean | null
    monitoringRequired: boolean | null
    generateQRCode: boolean | null
    qrCodeData: string | null
    notificationRadius: number | null
    transferRequestTime: Date | null
    transferAcceptedTime: Date | null
    emsArrivalTime: Date | null
    emsDepartureTime: Date | null
    actualStartTime: Date | null
    actualEndTime: Date | null
    status: string | null
    priority: string | null
    notes: string | null
    assignedTo: string | null
    assignedAgencyId: string | null
    assignedUnitId: string | null
    acceptedTimestamp: Date | null
    pickupTimestamp: Date | null
    completionTimestamp: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    actualTripTimeMinutes: number | null
    backhaulOpportunity: boolean | null
    completionTimeMinutes: number | null
    customerSatisfaction: number | null
    deadheadMiles: number | null
    destinationLatitude: number | null
    destinationLongitude: number | null
    distanceMiles: number | null
    efficiency: Decimal | null
    estimatedTripTimeMinutes: number | null
    insuranceCompany: string | null
    insurancePayRate: Decimal | null
    loadedMiles: Decimal | null
    originLatitude: number | null
    originLongitude: number | null
    perMileRate: Decimal | null
    performanceScore: Decimal | null
    requestTimestamp: Date | null
    responseTimeMinutes: number | null
    revenuePerHour: Decimal | null
    tripCost: Decimal | null
    pickupLocationId: string | null
    maxResponses: number | null
    responseDeadline: Date | null
    responseStatus: string | null
    selectionMode: string | null
  }

  export type TripCountAggregateOutputType = {
    id: number
    tripNumber: number
    patientId: number
    patientWeight: number
    specialNeeds: number
    fromLocation: number
    toLocation: number
    scheduledTime: number
    transportLevel: number
    urgencyLevel: number
    diagnosis: number
    mobilityLevel: number
    oxygenRequired: number
    monitoringRequired: number
    generateQRCode: number
    qrCodeData: number
    selectedAgencies: number
    notificationRadius: number
    transferRequestTime: number
    transferAcceptedTime: number
    emsArrivalTime: number
    emsDepartureTime: number
    actualStartTime: number
    actualEndTime: number
    status: number
    priority: number
    notes: number
    assignedTo: number
    assignedAgencyId: number
    assignedUnitId: number
    acceptedTimestamp: number
    pickupTimestamp: number
    completionTimestamp: number
    createdAt: number
    updatedAt: number
    actualTripTimeMinutes: number
    backhaulOpportunity: number
    completionTimeMinutes: number
    customerSatisfaction: number
    deadheadMiles: number
    destinationLatitude: number
    destinationLongitude: number
    distanceMiles: number
    efficiency: number
    estimatedTripTimeMinutes: number
    insuranceCompany: number
    insurancePayRate: number
    loadedMiles: number
    originLatitude: number
    originLongitude: number
    perMileRate: number
    performanceScore: number
    requestTimestamp: number
    responseTimeMinutes: number
    revenuePerHour: number
    tripCost: number
    pickupLocationId: number
    maxResponses: number
    responseDeadline: number
    responseStatus: number
    selectionMode: number
    _all: number
  }


  export type TripAvgAggregateInputType = {
    notificationRadius?: true
    actualTripTimeMinutes?: true
    completionTimeMinutes?: true
    customerSatisfaction?: true
    deadheadMiles?: true
    destinationLatitude?: true
    destinationLongitude?: true
    distanceMiles?: true
    efficiency?: true
    estimatedTripTimeMinutes?: true
    insurancePayRate?: true
    loadedMiles?: true
    originLatitude?: true
    originLongitude?: true
    perMileRate?: true
    performanceScore?: true
    responseTimeMinutes?: true
    revenuePerHour?: true
    tripCost?: true
    maxResponses?: true
  }

  export type TripSumAggregateInputType = {
    notificationRadius?: true
    actualTripTimeMinutes?: true
    completionTimeMinutes?: true
    customerSatisfaction?: true
    deadheadMiles?: true
    destinationLatitude?: true
    destinationLongitude?: true
    distanceMiles?: true
    efficiency?: true
    estimatedTripTimeMinutes?: true
    insurancePayRate?: true
    loadedMiles?: true
    originLatitude?: true
    originLongitude?: true
    perMileRate?: true
    performanceScore?: true
    responseTimeMinutes?: true
    revenuePerHour?: true
    tripCost?: true
    maxResponses?: true
  }

  export type TripMinAggregateInputType = {
    id?: true
    tripNumber?: true
    patientId?: true
    patientWeight?: true
    specialNeeds?: true
    fromLocation?: true
    toLocation?: true
    scheduledTime?: true
    transportLevel?: true
    urgencyLevel?: true
    diagnosis?: true
    mobilityLevel?: true
    oxygenRequired?: true
    monitoringRequired?: true
    generateQRCode?: true
    qrCodeData?: true
    notificationRadius?: true
    transferRequestTime?: true
    transferAcceptedTime?: true
    emsArrivalTime?: true
    emsDepartureTime?: true
    actualStartTime?: true
    actualEndTime?: true
    status?: true
    priority?: true
    notes?: true
    assignedTo?: true
    assignedAgencyId?: true
    assignedUnitId?: true
    acceptedTimestamp?: true
    pickupTimestamp?: true
    completionTimestamp?: true
    createdAt?: true
    updatedAt?: true
    actualTripTimeMinutes?: true
    backhaulOpportunity?: true
    completionTimeMinutes?: true
    customerSatisfaction?: true
    deadheadMiles?: true
    destinationLatitude?: true
    destinationLongitude?: true
    distanceMiles?: true
    efficiency?: true
    estimatedTripTimeMinutes?: true
    insuranceCompany?: true
    insurancePayRate?: true
    loadedMiles?: true
    originLatitude?: true
    originLongitude?: true
    perMileRate?: true
    performanceScore?: true
    requestTimestamp?: true
    responseTimeMinutes?: true
    revenuePerHour?: true
    tripCost?: true
    pickupLocationId?: true
    maxResponses?: true
    responseDeadline?: true
    responseStatus?: true
    selectionMode?: true
  }

  export type TripMaxAggregateInputType = {
    id?: true
    tripNumber?: true
    patientId?: true
    patientWeight?: true
    specialNeeds?: true
    fromLocation?: true
    toLocation?: true
    scheduledTime?: true
    transportLevel?: true
    urgencyLevel?: true
    diagnosis?: true
    mobilityLevel?: true
    oxygenRequired?: true
    monitoringRequired?: true
    generateQRCode?: true
    qrCodeData?: true
    notificationRadius?: true
    transferRequestTime?: true
    transferAcceptedTime?: true
    emsArrivalTime?: true
    emsDepartureTime?: true
    actualStartTime?: true
    actualEndTime?: true
    status?: true
    priority?: true
    notes?: true
    assignedTo?: true
    assignedAgencyId?: true
    assignedUnitId?: true
    acceptedTimestamp?: true
    pickupTimestamp?: true
    completionTimestamp?: true
    createdAt?: true
    updatedAt?: true
    actualTripTimeMinutes?: true
    backhaulOpportunity?: true
    completionTimeMinutes?: true
    customerSatisfaction?: true
    deadheadMiles?: true
    destinationLatitude?: true
    destinationLongitude?: true
    distanceMiles?: true
    efficiency?: true
    estimatedTripTimeMinutes?: true
    insuranceCompany?: true
    insurancePayRate?: true
    loadedMiles?: true
    originLatitude?: true
    originLongitude?: true
    perMileRate?: true
    performanceScore?: true
    requestTimestamp?: true
    responseTimeMinutes?: true
    revenuePerHour?: true
    tripCost?: true
    pickupLocationId?: true
    maxResponses?: true
    responseDeadline?: true
    responseStatus?: true
    selectionMode?: true
  }

  export type TripCountAggregateInputType = {
    id?: true
    tripNumber?: true
    patientId?: true
    patientWeight?: true
    specialNeeds?: true
    fromLocation?: true
    toLocation?: true
    scheduledTime?: true
    transportLevel?: true
    urgencyLevel?: true
    diagnosis?: true
    mobilityLevel?: true
    oxygenRequired?: true
    monitoringRequired?: true
    generateQRCode?: true
    qrCodeData?: true
    selectedAgencies?: true
    notificationRadius?: true
    transferRequestTime?: true
    transferAcceptedTime?: true
    emsArrivalTime?: true
    emsDepartureTime?: true
    actualStartTime?: true
    actualEndTime?: true
    status?: true
    priority?: true
    notes?: true
    assignedTo?: true
    assignedAgencyId?: true
    assignedUnitId?: true
    acceptedTimestamp?: true
    pickupTimestamp?: true
    completionTimestamp?: true
    createdAt?: true
    updatedAt?: true
    actualTripTimeMinutes?: true
    backhaulOpportunity?: true
    completionTimeMinutes?: true
    customerSatisfaction?: true
    deadheadMiles?: true
    destinationLatitude?: true
    destinationLongitude?: true
    distanceMiles?: true
    efficiency?: true
    estimatedTripTimeMinutes?: true
    insuranceCompany?: true
    insurancePayRate?: true
    loadedMiles?: true
    originLatitude?: true
    originLongitude?: true
    perMileRate?: true
    performanceScore?: true
    requestTimestamp?: true
    responseTimeMinutes?: true
    revenuePerHour?: true
    tripCost?: true
    pickupLocationId?: true
    maxResponses?: true
    responseDeadline?: true
    responseStatus?: true
    selectionMode?: true
    _all?: true
  }

  export type TripAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Trip to aggregate.
     */
    where?: TripWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trips to fetch.
     */
    orderBy?: TripOrderByWithRelationInput | TripOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TripWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Trips
    **/
    _count?: true | TripCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TripAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TripSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TripMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TripMaxAggregateInputType
  }

  export type GetTripAggregateType<T extends TripAggregateArgs> = {
        [P in keyof T & keyof AggregateTrip]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrip[P]>
      : GetScalarType<T[P], AggregateTrip[P]>
  }




  export type TripGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TripWhereInput
    orderBy?: TripOrderByWithAggregationInput | TripOrderByWithAggregationInput[]
    by: TripScalarFieldEnum[] | TripScalarFieldEnum
    having?: TripScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TripCountAggregateInputType | true
    _avg?: TripAvgAggregateInputType
    _sum?: TripSumAggregateInputType
    _min?: TripMinAggregateInputType
    _max?: TripMaxAggregateInputType
  }

  export type TripGroupByOutputType = {
    id: string
    tripNumber: string
    patientId: string
    patientWeight: string | null
    specialNeeds: string | null
    fromLocation: string
    toLocation: string
    scheduledTime: Date
    transportLevel: string
    urgencyLevel: string
    diagnosis: string | null
    mobilityLevel: string | null
    oxygenRequired: boolean
    monitoringRequired: boolean
    generateQRCode: boolean
    qrCodeData: string | null
    selectedAgencies: string[]
    notificationRadius: number | null
    transferRequestTime: Date | null
    transferAcceptedTime: Date | null
    emsArrivalTime: Date | null
    emsDepartureTime: Date | null
    actualStartTime: Date | null
    actualEndTime: Date | null
    status: string
    priority: string
    notes: string | null
    assignedTo: string | null
    assignedAgencyId: string | null
    assignedUnitId: string | null
    acceptedTimestamp: Date | null
    pickupTimestamp: Date | null
    completionTimestamp: Date | null
    createdAt: Date
    updatedAt: Date
    actualTripTimeMinutes: number | null
    backhaulOpportunity: boolean
    completionTimeMinutes: number | null
    customerSatisfaction: number | null
    deadheadMiles: number | null
    destinationLatitude: number | null
    destinationLongitude: number | null
    distanceMiles: number | null
    efficiency: Decimal | null
    estimatedTripTimeMinutes: number | null
    insuranceCompany: string | null
    insurancePayRate: Decimal | null
    loadedMiles: Decimal | null
    originLatitude: number | null
    originLongitude: number | null
    perMileRate: Decimal | null
    performanceScore: Decimal | null
    requestTimestamp: Date | null
    responseTimeMinutes: number | null
    revenuePerHour: Decimal | null
    tripCost: Decimal | null
    pickupLocationId: string | null
    maxResponses: number
    responseDeadline: Date | null
    responseStatus: string
    selectionMode: string
    _count: TripCountAggregateOutputType | null
    _avg: TripAvgAggregateOutputType | null
    _sum: TripSumAggregateOutputType | null
    _min: TripMinAggregateOutputType | null
    _max: TripMaxAggregateOutputType | null
  }

  type GetTripGroupByPayload<T extends TripGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TripGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TripGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TripGroupByOutputType[P]>
            : GetScalarType<T[P], TripGroupByOutputType[P]>
        }
      >
    >


  export type TripSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tripNumber?: boolean
    patientId?: boolean
    patientWeight?: boolean
    specialNeeds?: boolean
    fromLocation?: boolean
    toLocation?: boolean
    scheduledTime?: boolean
    transportLevel?: boolean
    urgencyLevel?: boolean
    diagnosis?: boolean
    mobilityLevel?: boolean
    oxygenRequired?: boolean
    monitoringRequired?: boolean
    generateQRCode?: boolean
    qrCodeData?: boolean
    selectedAgencies?: boolean
    notificationRadius?: boolean
    transferRequestTime?: boolean
    transferAcceptedTime?: boolean
    emsArrivalTime?: boolean
    emsDepartureTime?: boolean
    actualStartTime?: boolean
    actualEndTime?: boolean
    status?: boolean
    priority?: boolean
    notes?: boolean
    assignedTo?: boolean
    assignedAgencyId?: boolean
    assignedUnitId?: boolean
    acceptedTimestamp?: boolean
    pickupTimestamp?: boolean
    completionTimestamp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    actualTripTimeMinutes?: boolean
    backhaulOpportunity?: boolean
    completionTimeMinutes?: boolean
    customerSatisfaction?: boolean
    deadheadMiles?: boolean
    destinationLatitude?: boolean
    destinationLongitude?: boolean
    distanceMiles?: boolean
    efficiency?: boolean
    estimatedTripTimeMinutes?: boolean
    insuranceCompany?: boolean
    insurancePayRate?: boolean
    loadedMiles?: boolean
    originLatitude?: boolean
    originLongitude?: boolean
    perMileRate?: boolean
    performanceScore?: boolean
    requestTimestamp?: boolean
    responseTimeMinutes?: boolean
    revenuePerHour?: boolean
    tripCost?: boolean
    pickupLocationId?: boolean
    maxResponses?: boolean
    responseDeadline?: boolean
    responseStatus?: boolean
    selectionMode?: boolean
    agencyResponses?: boolean | Trip$agencyResponsesArgs<ExtArgs>
    pickup_locations?: boolean | Trip$pickup_locationsArgs<ExtArgs>
    _count?: boolean | TripCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trip"]>

  export type TripSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tripNumber?: boolean
    patientId?: boolean
    patientWeight?: boolean
    specialNeeds?: boolean
    fromLocation?: boolean
    toLocation?: boolean
    scheduledTime?: boolean
    transportLevel?: boolean
    urgencyLevel?: boolean
    diagnosis?: boolean
    mobilityLevel?: boolean
    oxygenRequired?: boolean
    monitoringRequired?: boolean
    generateQRCode?: boolean
    qrCodeData?: boolean
    selectedAgencies?: boolean
    notificationRadius?: boolean
    transferRequestTime?: boolean
    transferAcceptedTime?: boolean
    emsArrivalTime?: boolean
    emsDepartureTime?: boolean
    actualStartTime?: boolean
    actualEndTime?: boolean
    status?: boolean
    priority?: boolean
    notes?: boolean
    assignedTo?: boolean
    assignedAgencyId?: boolean
    assignedUnitId?: boolean
    acceptedTimestamp?: boolean
    pickupTimestamp?: boolean
    completionTimestamp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    actualTripTimeMinutes?: boolean
    backhaulOpportunity?: boolean
    completionTimeMinutes?: boolean
    customerSatisfaction?: boolean
    deadheadMiles?: boolean
    destinationLatitude?: boolean
    destinationLongitude?: boolean
    distanceMiles?: boolean
    efficiency?: boolean
    estimatedTripTimeMinutes?: boolean
    insuranceCompany?: boolean
    insurancePayRate?: boolean
    loadedMiles?: boolean
    originLatitude?: boolean
    originLongitude?: boolean
    perMileRate?: boolean
    performanceScore?: boolean
    requestTimestamp?: boolean
    responseTimeMinutes?: boolean
    revenuePerHour?: boolean
    tripCost?: boolean
    pickupLocationId?: boolean
    maxResponses?: boolean
    responseDeadline?: boolean
    responseStatus?: boolean
    selectionMode?: boolean
    pickup_locations?: boolean | Trip$pickup_locationsArgs<ExtArgs>
  }, ExtArgs["result"]["trip"]>

  export type TripSelectScalar = {
    id?: boolean
    tripNumber?: boolean
    patientId?: boolean
    patientWeight?: boolean
    specialNeeds?: boolean
    fromLocation?: boolean
    toLocation?: boolean
    scheduledTime?: boolean
    transportLevel?: boolean
    urgencyLevel?: boolean
    diagnosis?: boolean
    mobilityLevel?: boolean
    oxygenRequired?: boolean
    monitoringRequired?: boolean
    generateQRCode?: boolean
    qrCodeData?: boolean
    selectedAgencies?: boolean
    notificationRadius?: boolean
    transferRequestTime?: boolean
    transferAcceptedTime?: boolean
    emsArrivalTime?: boolean
    emsDepartureTime?: boolean
    actualStartTime?: boolean
    actualEndTime?: boolean
    status?: boolean
    priority?: boolean
    notes?: boolean
    assignedTo?: boolean
    assignedAgencyId?: boolean
    assignedUnitId?: boolean
    acceptedTimestamp?: boolean
    pickupTimestamp?: boolean
    completionTimestamp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    actualTripTimeMinutes?: boolean
    backhaulOpportunity?: boolean
    completionTimeMinutes?: boolean
    customerSatisfaction?: boolean
    deadheadMiles?: boolean
    destinationLatitude?: boolean
    destinationLongitude?: boolean
    distanceMiles?: boolean
    efficiency?: boolean
    estimatedTripTimeMinutes?: boolean
    insuranceCompany?: boolean
    insurancePayRate?: boolean
    loadedMiles?: boolean
    originLatitude?: boolean
    originLongitude?: boolean
    perMileRate?: boolean
    performanceScore?: boolean
    requestTimestamp?: boolean
    responseTimeMinutes?: boolean
    revenuePerHour?: boolean
    tripCost?: boolean
    pickupLocationId?: boolean
    maxResponses?: boolean
    responseDeadline?: boolean
    responseStatus?: boolean
    selectionMode?: boolean
  }

  export type TripInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agencyResponses?: boolean | Trip$agencyResponsesArgs<ExtArgs>
    pickup_locations?: boolean | Trip$pickup_locationsArgs<ExtArgs>
    _count?: boolean | TripCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TripIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pickup_locations?: boolean | Trip$pickup_locationsArgs<ExtArgs>
  }

  export type $TripPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Trip"
    objects: {
      agencyResponses: Prisma.$AgencyResponsePayload<ExtArgs>[]
      pickup_locations: Prisma.$pickup_locationsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tripNumber: string
      patientId: string
      patientWeight: string | null
      specialNeeds: string | null
      fromLocation: string
      toLocation: string
      scheduledTime: Date
      transportLevel: string
      urgencyLevel: string
      diagnosis: string | null
      mobilityLevel: string | null
      oxygenRequired: boolean
      monitoringRequired: boolean
      generateQRCode: boolean
      qrCodeData: string | null
      selectedAgencies: string[]
      notificationRadius: number | null
      transferRequestTime: Date | null
      transferAcceptedTime: Date | null
      emsArrivalTime: Date | null
      emsDepartureTime: Date | null
      actualStartTime: Date | null
      actualEndTime: Date | null
      status: string
      priority: string
      notes: string | null
      assignedTo: string | null
      assignedAgencyId: string | null
      assignedUnitId: string | null
      acceptedTimestamp: Date | null
      pickupTimestamp: Date | null
      completionTimestamp: Date | null
      createdAt: Date
      updatedAt: Date
      actualTripTimeMinutes: number | null
      backhaulOpportunity: boolean
      completionTimeMinutes: number | null
      customerSatisfaction: number | null
      deadheadMiles: number | null
      destinationLatitude: number | null
      destinationLongitude: number | null
      distanceMiles: number | null
      efficiency: Prisma.Decimal | null
      estimatedTripTimeMinutes: number | null
      insuranceCompany: string | null
      insurancePayRate: Prisma.Decimal | null
      loadedMiles: Prisma.Decimal | null
      originLatitude: number | null
      originLongitude: number | null
      perMileRate: Prisma.Decimal | null
      performanceScore: Prisma.Decimal | null
      requestTimestamp: Date | null
      responseTimeMinutes: number | null
      revenuePerHour: Prisma.Decimal | null
      tripCost: Prisma.Decimal | null
      pickupLocationId: string | null
      maxResponses: number
      responseDeadline: Date | null
      responseStatus: string
      selectionMode: string
    }, ExtArgs["result"]["trip"]>
    composites: {}
  }

  type TripGetPayload<S extends boolean | null | undefined | TripDefaultArgs> = $Result.GetResult<Prisma.$TripPayload, S>

  type TripCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TripFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TripCountAggregateInputType | true
    }

  export interface TripDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Trip'], meta: { name: 'Trip' } }
    /**
     * Find zero or one Trip that matches the filter.
     * @param {TripFindUniqueArgs} args - Arguments to find a Trip
     * @example
     * // Get one Trip
     * const trip = await prisma.trip.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TripFindUniqueArgs>(args: SelectSubset<T, TripFindUniqueArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Trip that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TripFindUniqueOrThrowArgs} args - Arguments to find a Trip
     * @example
     * // Get one Trip
     * const trip = await prisma.trip.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TripFindUniqueOrThrowArgs>(args: SelectSubset<T, TripFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Trip that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripFindFirstArgs} args - Arguments to find a Trip
     * @example
     * // Get one Trip
     * const trip = await prisma.trip.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TripFindFirstArgs>(args?: SelectSubset<T, TripFindFirstArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Trip that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripFindFirstOrThrowArgs} args - Arguments to find a Trip
     * @example
     * // Get one Trip
     * const trip = await prisma.trip.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TripFindFirstOrThrowArgs>(args?: SelectSubset<T, TripFindFirstOrThrowArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Trips that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Trips
     * const trips = await prisma.trip.findMany()
     * 
     * // Get first 10 Trips
     * const trips = await prisma.trip.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tripWithIdOnly = await prisma.trip.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TripFindManyArgs>(args?: SelectSubset<T, TripFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Trip.
     * @param {TripCreateArgs} args - Arguments to create a Trip.
     * @example
     * // Create one Trip
     * const Trip = await prisma.trip.create({
     *   data: {
     *     // ... data to create a Trip
     *   }
     * })
     * 
     */
    create<T extends TripCreateArgs>(args: SelectSubset<T, TripCreateArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Trips.
     * @param {TripCreateManyArgs} args - Arguments to create many Trips.
     * @example
     * // Create many Trips
     * const trip = await prisma.trip.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TripCreateManyArgs>(args?: SelectSubset<T, TripCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Trips and returns the data saved in the database.
     * @param {TripCreateManyAndReturnArgs} args - Arguments to create many Trips.
     * @example
     * // Create many Trips
     * const trip = await prisma.trip.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Trips and only return the `id`
     * const tripWithIdOnly = await prisma.trip.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TripCreateManyAndReturnArgs>(args?: SelectSubset<T, TripCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Trip.
     * @param {TripDeleteArgs} args - Arguments to delete one Trip.
     * @example
     * // Delete one Trip
     * const Trip = await prisma.trip.delete({
     *   where: {
     *     // ... filter to delete one Trip
     *   }
     * })
     * 
     */
    delete<T extends TripDeleteArgs>(args: SelectSubset<T, TripDeleteArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Trip.
     * @param {TripUpdateArgs} args - Arguments to update one Trip.
     * @example
     * // Update one Trip
     * const trip = await prisma.trip.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TripUpdateArgs>(args: SelectSubset<T, TripUpdateArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Trips.
     * @param {TripDeleteManyArgs} args - Arguments to filter Trips to delete.
     * @example
     * // Delete a few Trips
     * const { count } = await prisma.trip.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TripDeleteManyArgs>(args?: SelectSubset<T, TripDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Trips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Trips
     * const trip = await prisma.trip.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TripUpdateManyArgs>(args: SelectSubset<T, TripUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Trip.
     * @param {TripUpsertArgs} args - Arguments to update or create a Trip.
     * @example
     * // Update or create a Trip
     * const trip = await prisma.trip.upsert({
     *   create: {
     *     // ... data to create a Trip
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Trip we want to update
     *   }
     * })
     */
    upsert<T extends TripUpsertArgs>(args: SelectSubset<T, TripUpsertArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Trips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripCountArgs} args - Arguments to filter Trips to count.
     * @example
     * // Count the number of Trips
     * const count = await prisma.trip.count({
     *   where: {
     *     // ... the filter for the Trips we want to count
     *   }
     * })
    **/
    count<T extends TripCountArgs>(
      args?: Subset<T, TripCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TripCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Trip.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TripAggregateArgs>(args: Subset<T, TripAggregateArgs>): Prisma.PrismaPromise<GetTripAggregateType<T>>

    /**
     * Group by Trip.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TripGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TripGroupByArgs['orderBy'] }
        : { orderBy?: TripGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TripGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTripGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Trip model
   */
  readonly fields: TripFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Trip.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TripClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agencyResponses<T extends Trip$agencyResponsesArgs<ExtArgs> = {}>(args?: Subset<T, Trip$agencyResponsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyResponsePayload<ExtArgs>, T, "findMany"> | Null>
    pickup_locations<T extends Trip$pickup_locationsArgs<ExtArgs> = {}>(args?: Subset<T, Trip$pickup_locationsArgs<ExtArgs>>): Prisma__pickup_locationsClient<$Result.GetResult<Prisma.$pickup_locationsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Trip model
   */ 
  interface TripFieldRefs {
    readonly id: FieldRef<"Trip", 'String'>
    readonly tripNumber: FieldRef<"Trip", 'String'>
    readonly patientId: FieldRef<"Trip", 'String'>
    readonly patientWeight: FieldRef<"Trip", 'String'>
    readonly specialNeeds: FieldRef<"Trip", 'String'>
    readonly fromLocation: FieldRef<"Trip", 'String'>
    readonly toLocation: FieldRef<"Trip", 'String'>
    readonly scheduledTime: FieldRef<"Trip", 'DateTime'>
    readonly transportLevel: FieldRef<"Trip", 'String'>
    readonly urgencyLevel: FieldRef<"Trip", 'String'>
    readonly diagnosis: FieldRef<"Trip", 'String'>
    readonly mobilityLevel: FieldRef<"Trip", 'String'>
    readonly oxygenRequired: FieldRef<"Trip", 'Boolean'>
    readonly monitoringRequired: FieldRef<"Trip", 'Boolean'>
    readonly generateQRCode: FieldRef<"Trip", 'Boolean'>
    readonly qrCodeData: FieldRef<"Trip", 'String'>
    readonly selectedAgencies: FieldRef<"Trip", 'String[]'>
    readonly notificationRadius: FieldRef<"Trip", 'Int'>
    readonly transferRequestTime: FieldRef<"Trip", 'DateTime'>
    readonly transferAcceptedTime: FieldRef<"Trip", 'DateTime'>
    readonly emsArrivalTime: FieldRef<"Trip", 'DateTime'>
    readonly emsDepartureTime: FieldRef<"Trip", 'DateTime'>
    readonly actualStartTime: FieldRef<"Trip", 'DateTime'>
    readonly actualEndTime: FieldRef<"Trip", 'DateTime'>
    readonly status: FieldRef<"Trip", 'String'>
    readonly priority: FieldRef<"Trip", 'String'>
    readonly notes: FieldRef<"Trip", 'String'>
    readonly assignedTo: FieldRef<"Trip", 'String'>
    readonly assignedAgencyId: FieldRef<"Trip", 'String'>
    readonly assignedUnitId: FieldRef<"Trip", 'String'>
    readonly acceptedTimestamp: FieldRef<"Trip", 'DateTime'>
    readonly pickupTimestamp: FieldRef<"Trip", 'DateTime'>
    readonly completionTimestamp: FieldRef<"Trip", 'DateTime'>
    readonly createdAt: FieldRef<"Trip", 'DateTime'>
    readonly updatedAt: FieldRef<"Trip", 'DateTime'>
    readonly actualTripTimeMinutes: FieldRef<"Trip", 'Int'>
    readonly backhaulOpportunity: FieldRef<"Trip", 'Boolean'>
    readonly completionTimeMinutes: FieldRef<"Trip", 'Int'>
    readonly customerSatisfaction: FieldRef<"Trip", 'Int'>
    readonly deadheadMiles: FieldRef<"Trip", 'Float'>
    readonly destinationLatitude: FieldRef<"Trip", 'Float'>
    readonly destinationLongitude: FieldRef<"Trip", 'Float'>
    readonly distanceMiles: FieldRef<"Trip", 'Float'>
    readonly efficiency: FieldRef<"Trip", 'Decimal'>
    readonly estimatedTripTimeMinutes: FieldRef<"Trip", 'Int'>
    readonly insuranceCompany: FieldRef<"Trip", 'String'>
    readonly insurancePayRate: FieldRef<"Trip", 'Decimal'>
    readonly loadedMiles: FieldRef<"Trip", 'Decimal'>
    readonly originLatitude: FieldRef<"Trip", 'Float'>
    readonly originLongitude: FieldRef<"Trip", 'Float'>
    readonly perMileRate: FieldRef<"Trip", 'Decimal'>
    readonly performanceScore: FieldRef<"Trip", 'Decimal'>
    readonly requestTimestamp: FieldRef<"Trip", 'DateTime'>
    readonly responseTimeMinutes: FieldRef<"Trip", 'Int'>
    readonly revenuePerHour: FieldRef<"Trip", 'Decimal'>
    readonly tripCost: FieldRef<"Trip", 'Decimal'>
    readonly pickupLocationId: FieldRef<"Trip", 'String'>
    readonly maxResponses: FieldRef<"Trip", 'Int'>
    readonly responseDeadline: FieldRef<"Trip", 'DateTime'>
    readonly responseStatus: FieldRef<"Trip", 'String'>
    readonly selectionMode: FieldRef<"Trip", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Trip findUnique
   */
  export type TripFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * Filter, which Trip to fetch.
     */
    where: TripWhereUniqueInput
  }

  /**
   * Trip findUniqueOrThrow
   */
  export type TripFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * Filter, which Trip to fetch.
     */
    where: TripWhereUniqueInput
  }

  /**
   * Trip findFirst
   */
  export type TripFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * Filter, which Trip to fetch.
     */
    where?: TripWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trips to fetch.
     */
    orderBy?: TripOrderByWithRelationInput | TripOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Trips.
     */
    cursor?: TripWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Trips.
     */
    distinct?: TripScalarFieldEnum | TripScalarFieldEnum[]
  }

  /**
   * Trip findFirstOrThrow
   */
  export type TripFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * Filter, which Trip to fetch.
     */
    where?: TripWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trips to fetch.
     */
    orderBy?: TripOrderByWithRelationInput | TripOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Trips.
     */
    cursor?: TripWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Trips.
     */
    distinct?: TripScalarFieldEnum | TripScalarFieldEnum[]
  }

  /**
   * Trip findMany
   */
  export type TripFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * Filter, which Trips to fetch.
     */
    where?: TripWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trips to fetch.
     */
    orderBy?: TripOrderByWithRelationInput | TripOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Trips.
     */
    cursor?: TripWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trips.
     */
    skip?: number
    distinct?: TripScalarFieldEnum | TripScalarFieldEnum[]
  }

  /**
   * Trip create
   */
  export type TripCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * The data needed to create a Trip.
     */
    data: XOR<TripCreateInput, TripUncheckedCreateInput>
  }

  /**
   * Trip createMany
   */
  export type TripCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Trips.
     */
    data: TripCreateManyInput | TripCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Trip createManyAndReturn
   */
  export type TripCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Trips.
     */
    data: TripCreateManyInput | TripCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Trip update
   */
  export type TripUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * The data needed to update a Trip.
     */
    data: XOR<TripUpdateInput, TripUncheckedUpdateInput>
    /**
     * Choose, which Trip to update.
     */
    where: TripWhereUniqueInput
  }

  /**
   * Trip updateMany
   */
  export type TripUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Trips.
     */
    data: XOR<TripUpdateManyMutationInput, TripUncheckedUpdateManyInput>
    /**
     * Filter which Trips to update
     */
    where?: TripWhereInput
  }

  /**
   * Trip upsert
   */
  export type TripUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * The filter to search for the Trip to update in case it exists.
     */
    where: TripWhereUniqueInput
    /**
     * In case the Trip found by the `where` argument doesn't exist, create a new Trip with this data.
     */
    create: XOR<TripCreateInput, TripUncheckedCreateInput>
    /**
     * In case the Trip was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TripUpdateInput, TripUncheckedUpdateInput>
  }

  /**
   * Trip delete
   */
  export type TripDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * Filter which Trip to delete.
     */
    where: TripWhereUniqueInput
  }

  /**
   * Trip deleteMany
   */
  export type TripDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Trips to delete
     */
    where?: TripWhereInput
  }

  /**
   * Trip.agencyResponses
   */
  export type Trip$agencyResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyResponse
     */
    select?: AgencyResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyResponseInclude<ExtArgs> | null
    where?: AgencyResponseWhereInput
    orderBy?: AgencyResponseOrderByWithRelationInput | AgencyResponseOrderByWithRelationInput[]
    cursor?: AgencyResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgencyResponseScalarFieldEnum | AgencyResponseScalarFieldEnum[]
  }

  /**
   * Trip.pickup_locations
   */
  export type Trip$pickup_locationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pickup_locations
     */
    select?: pickup_locationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pickup_locationsInclude<ExtArgs> | null
    where?: pickup_locationsWhereInput
  }

  /**
   * Trip without action
   */
  export type TripDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
  }


  /**
   * Model AgencyResponse
   */

  export type AggregateAgencyResponse = {
    _count: AgencyResponseCountAggregateOutputType | null
    _min: AgencyResponseMinAggregateOutputType | null
    _max: AgencyResponseMaxAggregateOutputType | null
  }

  export type AgencyResponseMinAggregateOutputType = {
    id: string | null
    tripId: string | null
    agencyId: string | null
    response: string | null
    responseTimestamp: Date | null
    responseNotes: string | null
    estimatedArrival: Date | null
    isSelected: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgencyResponseMaxAggregateOutputType = {
    id: string | null
    tripId: string | null
    agencyId: string | null
    response: string | null
    responseTimestamp: Date | null
    responseNotes: string | null
    estimatedArrival: Date | null
    isSelected: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgencyResponseCountAggregateOutputType = {
    id: number
    tripId: number
    agencyId: number
    response: number
    responseTimestamp: number
    responseNotes: number
    estimatedArrival: number
    isSelected: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AgencyResponseMinAggregateInputType = {
    id?: true
    tripId?: true
    agencyId?: true
    response?: true
    responseTimestamp?: true
    responseNotes?: true
    estimatedArrival?: true
    isSelected?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgencyResponseMaxAggregateInputType = {
    id?: true
    tripId?: true
    agencyId?: true
    response?: true
    responseTimestamp?: true
    responseNotes?: true
    estimatedArrival?: true
    isSelected?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgencyResponseCountAggregateInputType = {
    id?: true
    tripId?: true
    agencyId?: true
    response?: true
    responseTimestamp?: true
    responseNotes?: true
    estimatedArrival?: true
    isSelected?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AgencyResponseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgencyResponse to aggregate.
     */
    where?: AgencyResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyResponses to fetch.
     */
    orderBy?: AgencyResponseOrderByWithRelationInput | AgencyResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgencyResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgencyResponses
    **/
    _count?: true | AgencyResponseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgencyResponseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgencyResponseMaxAggregateInputType
  }

  export type GetAgencyResponseAggregateType<T extends AgencyResponseAggregateArgs> = {
        [P in keyof T & keyof AggregateAgencyResponse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgencyResponse[P]>
      : GetScalarType<T[P], AggregateAgencyResponse[P]>
  }




  export type AgencyResponseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencyResponseWhereInput
    orderBy?: AgencyResponseOrderByWithAggregationInput | AgencyResponseOrderByWithAggregationInput[]
    by: AgencyResponseScalarFieldEnum[] | AgencyResponseScalarFieldEnum
    having?: AgencyResponseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgencyResponseCountAggregateInputType | true
    _min?: AgencyResponseMinAggregateInputType
    _max?: AgencyResponseMaxAggregateInputType
  }

  export type AgencyResponseGroupByOutputType = {
    id: string
    tripId: string
    agencyId: string
    response: string
    responseTimestamp: Date
    responseNotes: string | null
    estimatedArrival: Date | null
    isSelected: boolean
    createdAt: Date
    updatedAt: Date
    _count: AgencyResponseCountAggregateOutputType | null
    _min: AgencyResponseMinAggregateOutputType | null
    _max: AgencyResponseMaxAggregateOutputType | null
  }

  type GetAgencyResponseGroupByPayload<T extends AgencyResponseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgencyResponseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgencyResponseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgencyResponseGroupByOutputType[P]>
            : GetScalarType<T[P], AgencyResponseGroupByOutputType[P]>
        }
      >
    >


  export type AgencyResponseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tripId?: boolean
    agencyId?: boolean
    response?: boolean
    responseTimestamp?: boolean
    responseNotes?: boolean
    estimatedArrival?: boolean
    isSelected?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    trip?: boolean | TripDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agencyResponse"]>

  export type AgencyResponseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tripId?: boolean
    agencyId?: boolean
    response?: boolean
    responseTimestamp?: boolean
    responseNotes?: boolean
    estimatedArrival?: boolean
    isSelected?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    trip?: boolean | TripDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agencyResponse"]>

  export type AgencyResponseSelectScalar = {
    id?: boolean
    tripId?: boolean
    agencyId?: boolean
    response?: boolean
    responseTimestamp?: boolean
    responseNotes?: boolean
    estimatedArrival?: boolean
    isSelected?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AgencyResponseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trip?: boolean | TripDefaultArgs<ExtArgs>
  }
  export type AgencyResponseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trip?: boolean | TripDefaultArgs<ExtArgs>
  }

  export type $AgencyResponsePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AgencyResponse"
    objects: {
      trip: Prisma.$TripPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tripId: string
      agencyId: string
      response: string
      responseTimestamp: Date
      responseNotes: string | null
      estimatedArrival: Date | null
      isSelected: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["agencyResponse"]>
    composites: {}
  }

  type AgencyResponseGetPayload<S extends boolean | null | undefined | AgencyResponseDefaultArgs> = $Result.GetResult<Prisma.$AgencyResponsePayload, S>

  type AgencyResponseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AgencyResponseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AgencyResponseCountAggregateInputType | true
    }

  export interface AgencyResponseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgencyResponse'], meta: { name: 'AgencyResponse' } }
    /**
     * Find zero or one AgencyResponse that matches the filter.
     * @param {AgencyResponseFindUniqueArgs} args - Arguments to find a AgencyResponse
     * @example
     * // Get one AgencyResponse
     * const agencyResponse = await prisma.agencyResponse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgencyResponseFindUniqueArgs>(args: SelectSubset<T, AgencyResponseFindUniqueArgs<ExtArgs>>): Prisma__AgencyResponseClient<$Result.GetResult<Prisma.$AgencyResponsePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AgencyResponse that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AgencyResponseFindUniqueOrThrowArgs} args - Arguments to find a AgencyResponse
     * @example
     * // Get one AgencyResponse
     * const agencyResponse = await prisma.agencyResponse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgencyResponseFindUniqueOrThrowArgs>(args: SelectSubset<T, AgencyResponseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgencyResponseClient<$Result.GetResult<Prisma.$AgencyResponsePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AgencyResponse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyResponseFindFirstArgs} args - Arguments to find a AgencyResponse
     * @example
     * // Get one AgencyResponse
     * const agencyResponse = await prisma.agencyResponse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgencyResponseFindFirstArgs>(args?: SelectSubset<T, AgencyResponseFindFirstArgs<ExtArgs>>): Prisma__AgencyResponseClient<$Result.GetResult<Prisma.$AgencyResponsePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AgencyResponse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyResponseFindFirstOrThrowArgs} args - Arguments to find a AgencyResponse
     * @example
     * // Get one AgencyResponse
     * const agencyResponse = await prisma.agencyResponse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgencyResponseFindFirstOrThrowArgs>(args?: SelectSubset<T, AgencyResponseFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgencyResponseClient<$Result.GetResult<Prisma.$AgencyResponsePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AgencyResponses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyResponseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgencyResponses
     * const agencyResponses = await prisma.agencyResponse.findMany()
     * 
     * // Get first 10 AgencyResponses
     * const agencyResponses = await prisma.agencyResponse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agencyResponseWithIdOnly = await prisma.agencyResponse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgencyResponseFindManyArgs>(args?: SelectSubset<T, AgencyResponseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyResponsePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AgencyResponse.
     * @param {AgencyResponseCreateArgs} args - Arguments to create a AgencyResponse.
     * @example
     * // Create one AgencyResponse
     * const AgencyResponse = await prisma.agencyResponse.create({
     *   data: {
     *     // ... data to create a AgencyResponse
     *   }
     * })
     * 
     */
    create<T extends AgencyResponseCreateArgs>(args: SelectSubset<T, AgencyResponseCreateArgs<ExtArgs>>): Prisma__AgencyResponseClient<$Result.GetResult<Prisma.$AgencyResponsePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AgencyResponses.
     * @param {AgencyResponseCreateManyArgs} args - Arguments to create many AgencyResponses.
     * @example
     * // Create many AgencyResponses
     * const agencyResponse = await prisma.agencyResponse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgencyResponseCreateManyArgs>(args?: SelectSubset<T, AgencyResponseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AgencyResponses and returns the data saved in the database.
     * @param {AgencyResponseCreateManyAndReturnArgs} args - Arguments to create many AgencyResponses.
     * @example
     * // Create many AgencyResponses
     * const agencyResponse = await prisma.agencyResponse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AgencyResponses and only return the `id`
     * const agencyResponseWithIdOnly = await prisma.agencyResponse.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgencyResponseCreateManyAndReturnArgs>(args?: SelectSubset<T, AgencyResponseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyResponsePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AgencyResponse.
     * @param {AgencyResponseDeleteArgs} args - Arguments to delete one AgencyResponse.
     * @example
     * // Delete one AgencyResponse
     * const AgencyResponse = await prisma.agencyResponse.delete({
     *   where: {
     *     // ... filter to delete one AgencyResponse
     *   }
     * })
     * 
     */
    delete<T extends AgencyResponseDeleteArgs>(args: SelectSubset<T, AgencyResponseDeleteArgs<ExtArgs>>): Prisma__AgencyResponseClient<$Result.GetResult<Prisma.$AgencyResponsePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AgencyResponse.
     * @param {AgencyResponseUpdateArgs} args - Arguments to update one AgencyResponse.
     * @example
     * // Update one AgencyResponse
     * const agencyResponse = await prisma.agencyResponse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgencyResponseUpdateArgs>(args: SelectSubset<T, AgencyResponseUpdateArgs<ExtArgs>>): Prisma__AgencyResponseClient<$Result.GetResult<Prisma.$AgencyResponsePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AgencyResponses.
     * @param {AgencyResponseDeleteManyArgs} args - Arguments to filter AgencyResponses to delete.
     * @example
     * // Delete a few AgencyResponses
     * const { count } = await prisma.agencyResponse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgencyResponseDeleteManyArgs>(args?: SelectSubset<T, AgencyResponseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgencyResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyResponseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgencyResponses
     * const agencyResponse = await prisma.agencyResponse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgencyResponseUpdateManyArgs>(args: SelectSubset<T, AgencyResponseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AgencyResponse.
     * @param {AgencyResponseUpsertArgs} args - Arguments to update or create a AgencyResponse.
     * @example
     * // Update or create a AgencyResponse
     * const agencyResponse = await prisma.agencyResponse.upsert({
     *   create: {
     *     // ... data to create a AgencyResponse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgencyResponse we want to update
     *   }
     * })
     */
    upsert<T extends AgencyResponseUpsertArgs>(args: SelectSubset<T, AgencyResponseUpsertArgs<ExtArgs>>): Prisma__AgencyResponseClient<$Result.GetResult<Prisma.$AgencyResponsePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AgencyResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyResponseCountArgs} args - Arguments to filter AgencyResponses to count.
     * @example
     * // Count the number of AgencyResponses
     * const count = await prisma.agencyResponse.count({
     *   where: {
     *     // ... the filter for the AgencyResponses we want to count
     *   }
     * })
    **/
    count<T extends AgencyResponseCountArgs>(
      args?: Subset<T, AgencyResponseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgencyResponseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgencyResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyResponseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgencyResponseAggregateArgs>(args: Subset<T, AgencyResponseAggregateArgs>): Prisma.PrismaPromise<GetAgencyResponseAggregateType<T>>

    /**
     * Group by AgencyResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyResponseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgencyResponseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgencyResponseGroupByArgs['orderBy'] }
        : { orderBy?: AgencyResponseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgencyResponseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgencyResponseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AgencyResponse model
   */
  readonly fields: AgencyResponseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AgencyResponse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgencyResponseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    trip<T extends TripDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TripDefaultArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AgencyResponse model
   */ 
  interface AgencyResponseFieldRefs {
    readonly id: FieldRef<"AgencyResponse", 'String'>
    readonly tripId: FieldRef<"AgencyResponse", 'String'>
    readonly agencyId: FieldRef<"AgencyResponse", 'String'>
    readonly response: FieldRef<"AgencyResponse", 'String'>
    readonly responseTimestamp: FieldRef<"AgencyResponse", 'DateTime'>
    readonly responseNotes: FieldRef<"AgencyResponse", 'String'>
    readonly estimatedArrival: FieldRef<"AgencyResponse", 'DateTime'>
    readonly isSelected: FieldRef<"AgencyResponse", 'Boolean'>
    readonly createdAt: FieldRef<"AgencyResponse", 'DateTime'>
    readonly updatedAt: FieldRef<"AgencyResponse", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AgencyResponse findUnique
   */
  export type AgencyResponseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyResponse
     */
    select?: AgencyResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyResponseInclude<ExtArgs> | null
    /**
     * Filter, which AgencyResponse to fetch.
     */
    where: AgencyResponseWhereUniqueInput
  }

  /**
   * AgencyResponse findUniqueOrThrow
   */
  export type AgencyResponseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyResponse
     */
    select?: AgencyResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyResponseInclude<ExtArgs> | null
    /**
     * Filter, which AgencyResponse to fetch.
     */
    where: AgencyResponseWhereUniqueInput
  }

  /**
   * AgencyResponse findFirst
   */
  export type AgencyResponseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyResponse
     */
    select?: AgencyResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyResponseInclude<ExtArgs> | null
    /**
     * Filter, which AgencyResponse to fetch.
     */
    where?: AgencyResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyResponses to fetch.
     */
    orderBy?: AgencyResponseOrderByWithRelationInput | AgencyResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgencyResponses.
     */
    cursor?: AgencyResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgencyResponses.
     */
    distinct?: AgencyResponseScalarFieldEnum | AgencyResponseScalarFieldEnum[]
  }

  /**
   * AgencyResponse findFirstOrThrow
   */
  export type AgencyResponseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyResponse
     */
    select?: AgencyResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyResponseInclude<ExtArgs> | null
    /**
     * Filter, which AgencyResponse to fetch.
     */
    where?: AgencyResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyResponses to fetch.
     */
    orderBy?: AgencyResponseOrderByWithRelationInput | AgencyResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgencyResponses.
     */
    cursor?: AgencyResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgencyResponses.
     */
    distinct?: AgencyResponseScalarFieldEnum | AgencyResponseScalarFieldEnum[]
  }

  /**
   * AgencyResponse findMany
   */
  export type AgencyResponseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyResponse
     */
    select?: AgencyResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyResponseInclude<ExtArgs> | null
    /**
     * Filter, which AgencyResponses to fetch.
     */
    where?: AgencyResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencyResponses to fetch.
     */
    orderBy?: AgencyResponseOrderByWithRelationInput | AgencyResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgencyResponses.
     */
    cursor?: AgencyResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencyResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencyResponses.
     */
    skip?: number
    distinct?: AgencyResponseScalarFieldEnum | AgencyResponseScalarFieldEnum[]
  }

  /**
   * AgencyResponse create
   */
  export type AgencyResponseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyResponse
     */
    select?: AgencyResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyResponseInclude<ExtArgs> | null
    /**
     * The data needed to create a AgencyResponse.
     */
    data: XOR<AgencyResponseCreateInput, AgencyResponseUncheckedCreateInput>
  }

  /**
   * AgencyResponse createMany
   */
  export type AgencyResponseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgencyResponses.
     */
    data: AgencyResponseCreateManyInput | AgencyResponseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AgencyResponse createManyAndReturn
   */
  export type AgencyResponseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyResponse
     */
    select?: AgencyResponseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AgencyResponses.
     */
    data: AgencyResponseCreateManyInput | AgencyResponseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyResponseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgencyResponse update
   */
  export type AgencyResponseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyResponse
     */
    select?: AgencyResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyResponseInclude<ExtArgs> | null
    /**
     * The data needed to update a AgencyResponse.
     */
    data: XOR<AgencyResponseUpdateInput, AgencyResponseUncheckedUpdateInput>
    /**
     * Choose, which AgencyResponse to update.
     */
    where: AgencyResponseWhereUniqueInput
  }

  /**
   * AgencyResponse updateMany
   */
  export type AgencyResponseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgencyResponses.
     */
    data: XOR<AgencyResponseUpdateManyMutationInput, AgencyResponseUncheckedUpdateManyInput>
    /**
     * Filter which AgencyResponses to update
     */
    where?: AgencyResponseWhereInput
  }

  /**
   * AgencyResponse upsert
   */
  export type AgencyResponseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyResponse
     */
    select?: AgencyResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyResponseInclude<ExtArgs> | null
    /**
     * The filter to search for the AgencyResponse to update in case it exists.
     */
    where: AgencyResponseWhereUniqueInput
    /**
     * In case the AgencyResponse found by the `where` argument doesn't exist, create a new AgencyResponse with this data.
     */
    create: XOR<AgencyResponseCreateInput, AgencyResponseUncheckedCreateInput>
    /**
     * In case the AgencyResponse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgencyResponseUpdateInput, AgencyResponseUncheckedUpdateInput>
  }

  /**
   * AgencyResponse delete
   */
  export type AgencyResponseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyResponse
     */
    select?: AgencyResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyResponseInclude<ExtArgs> | null
    /**
     * Filter which AgencyResponse to delete.
     */
    where: AgencyResponseWhereUniqueInput
  }

  /**
   * AgencyResponse deleteMany
   */
  export type AgencyResponseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgencyResponses to delete
     */
    where?: AgencyResponseWhereInput
  }

  /**
   * AgencyResponse without action
   */
  export type AgencyResponseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyResponse
     */
    select?: AgencyResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyResponseInclude<ExtArgs> | null
  }


  /**
   * Model SystemAnalytics
   */

  export type AggregateSystemAnalytics = {
    _count: SystemAnalyticsCountAggregateOutputType | null
    _min: SystemAnalyticsMinAggregateOutputType | null
    _max: SystemAnalyticsMaxAggregateOutputType | null
  }

  export type SystemAnalyticsMinAggregateOutputType = {
    id: string | null
    metricName: string | null
    timestamp: Date | null
    userId: string | null
    createdAt: Date | null
  }

  export type SystemAnalyticsMaxAggregateOutputType = {
    id: string | null
    metricName: string | null
    timestamp: Date | null
    userId: string | null
    createdAt: Date | null
  }

  export type SystemAnalyticsCountAggregateOutputType = {
    id: number
    metricName: number
    metricValue: number
    timestamp: number
    userId: number
    createdAt: number
    _all: number
  }


  export type SystemAnalyticsMinAggregateInputType = {
    id?: true
    metricName?: true
    timestamp?: true
    userId?: true
    createdAt?: true
  }

  export type SystemAnalyticsMaxAggregateInputType = {
    id?: true
    metricName?: true
    timestamp?: true
    userId?: true
    createdAt?: true
  }

  export type SystemAnalyticsCountAggregateInputType = {
    id?: true
    metricName?: true
    metricValue?: true
    timestamp?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type SystemAnalyticsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemAnalytics to aggregate.
     */
    where?: SystemAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemAnalytics to fetch.
     */
    orderBy?: SystemAnalyticsOrderByWithRelationInput | SystemAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemAnalytics
    **/
    _count?: true | SystemAnalyticsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemAnalyticsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemAnalyticsMaxAggregateInputType
  }

  export type GetSystemAnalyticsAggregateType<T extends SystemAnalyticsAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemAnalytics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemAnalytics[P]>
      : GetScalarType<T[P], AggregateSystemAnalytics[P]>
  }




  export type SystemAnalyticsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemAnalyticsWhereInput
    orderBy?: SystemAnalyticsOrderByWithAggregationInput | SystemAnalyticsOrderByWithAggregationInput[]
    by: SystemAnalyticsScalarFieldEnum[] | SystemAnalyticsScalarFieldEnum
    having?: SystemAnalyticsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemAnalyticsCountAggregateInputType | true
    _min?: SystemAnalyticsMinAggregateInputType
    _max?: SystemAnalyticsMaxAggregateInputType
  }

  export type SystemAnalyticsGroupByOutputType = {
    id: string
    metricName: string
    metricValue: JsonValue
    timestamp: Date
    userId: string | null
    createdAt: Date
    _count: SystemAnalyticsCountAggregateOutputType | null
    _min: SystemAnalyticsMinAggregateOutputType | null
    _max: SystemAnalyticsMaxAggregateOutputType | null
  }

  type GetSystemAnalyticsGroupByPayload<T extends SystemAnalyticsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemAnalyticsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemAnalyticsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemAnalyticsGroupByOutputType[P]>
            : GetScalarType<T[P], SystemAnalyticsGroupByOutputType[P]>
        }
      >
    >


  export type SystemAnalyticsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    metricName?: boolean
    metricValue?: boolean
    timestamp?: boolean
    userId?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["systemAnalytics"]>

  export type SystemAnalyticsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    metricName?: boolean
    metricValue?: boolean
    timestamp?: boolean
    userId?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["systemAnalytics"]>

  export type SystemAnalyticsSelectScalar = {
    id?: boolean
    metricName?: boolean
    metricValue?: boolean
    timestamp?: boolean
    userId?: boolean
    createdAt?: boolean
  }


  export type $SystemAnalyticsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemAnalytics"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      metricName: string
      metricValue: Prisma.JsonValue
      timestamp: Date
      userId: string | null
      createdAt: Date
    }, ExtArgs["result"]["systemAnalytics"]>
    composites: {}
  }

  type SystemAnalyticsGetPayload<S extends boolean | null | undefined | SystemAnalyticsDefaultArgs> = $Result.GetResult<Prisma.$SystemAnalyticsPayload, S>

  type SystemAnalyticsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SystemAnalyticsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SystemAnalyticsCountAggregateInputType | true
    }

  export interface SystemAnalyticsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemAnalytics'], meta: { name: 'SystemAnalytics' } }
    /**
     * Find zero or one SystemAnalytics that matches the filter.
     * @param {SystemAnalyticsFindUniqueArgs} args - Arguments to find a SystemAnalytics
     * @example
     * // Get one SystemAnalytics
     * const systemAnalytics = await prisma.systemAnalytics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemAnalyticsFindUniqueArgs>(args: SelectSubset<T, SystemAnalyticsFindUniqueArgs<ExtArgs>>): Prisma__SystemAnalyticsClient<$Result.GetResult<Prisma.$SystemAnalyticsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SystemAnalytics that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SystemAnalyticsFindUniqueOrThrowArgs} args - Arguments to find a SystemAnalytics
     * @example
     * // Get one SystemAnalytics
     * const systemAnalytics = await prisma.systemAnalytics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemAnalyticsFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemAnalyticsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemAnalyticsClient<$Result.GetResult<Prisma.$SystemAnalyticsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SystemAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemAnalyticsFindFirstArgs} args - Arguments to find a SystemAnalytics
     * @example
     * // Get one SystemAnalytics
     * const systemAnalytics = await prisma.systemAnalytics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemAnalyticsFindFirstArgs>(args?: SelectSubset<T, SystemAnalyticsFindFirstArgs<ExtArgs>>): Prisma__SystemAnalyticsClient<$Result.GetResult<Prisma.$SystemAnalyticsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SystemAnalytics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemAnalyticsFindFirstOrThrowArgs} args - Arguments to find a SystemAnalytics
     * @example
     * // Get one SystemAnalytics
     * const systemAnalytics = await prisma.systemAnalytics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemAnalyticsFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemAnalyticsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemAnalyticsClient<$Result.GetResult<Prisma.$SystemAnalyticsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SystemAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemAnalyticsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemAnalytics
     * const systemAnalytics = await prisma.systemAnalytics.findMany()
     * 
     * // Get first 10 SystemAnalytics
     * const systemAnalytics = await prisma.systemAnalytics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemAnalyticsWithIdOnly = await prisma.systemAnalytics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemAnalyticsFindManyArgs>(args?: SelectSubset<T, SystemAnalyticsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemAnalyticsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SystemAnalytics.
     * @param {SystemAnalyticsCreateArgs} args - Arguments to create a SystemAnalytics.
     * @example
     * // Create one SystemAnalytics
     * const SystemAnalytics = await prisma.systemAnalytics.create({
     *   data: {
     *     // ... data to create a SystemAnalytics
     *   }
     * })
     * 
     */
    create<T extends SystemAnalyticsCreateArgs>(args: SelectSubset<T, SystemAnalyticsCreateArgs<ExtArgs>>): Prisma__SystemAnalyticsClient<$Result.GetResult<Prisma.$SystemAnalyticsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SystemAnalytics.
     * @param {SystemAnalyticsCreateManyArgs} args - Arguments to create many SystemAnalytics.
     * @example
     * // Create many SystemAnalytics
     * const systemAnalytics = await prisma.systemAnalytics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemAnalyticsCreateManyArgs>(args?: SelectSubset<T, SystemAnalyticsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemAnalytics and returns the data saved in the database.
     * @param {SystemAnalyticsCreateManyAndReturnArgs} args - Arguments to create many SystemAnalytics.
     * @example
     * // Create many SystemAnalytics
     * const systemAnalytics = await prisma.systemAnalytics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemAnalytics and only return the `id`
     * const systemAnalyticsWithIdOnly = await prisma.systemAnalytics.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemAnalyticsCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemAnalyticsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemAnalyticsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SystemAnalytics.
     * @param {SystemAnalyticsDeleteArgs} args - Arguments to delete one SystemAnalytics.
     * @example
     * // Delete one SystemAnalytics
     * const SystemAnalytics = await prisma.systemAnalytics.delete({
     *   where: {
     *     // ... filter to delete one SystemAnalytics
     *   }
     * })
     * 
     */
    delete<T extends SystemAnalyticsDeleteArgs>(args: SelectSubset<T, SystemAnalyticsDeleteArgs<ExtArgs>>): Prisma__SystemAnalyticsClient<$Result.GetResult<Prisma.$SystemAnalyticsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SystemAnalytics.
     * @param {SystemAnalyticsUpdateArgs} args - Arguments to update one SystemAnalytics.
     * @example
     * // Update one SystemAnalytics
     * const systemAnalytics = await prisma.systemAnalytics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemAnalyticsUpdateArgs>(args: SelectSubset<T, SystemAnalyticsUpdateArgs<ExtArgs>>): Prisma__SystemAnalyticsClient<$Result.GetResult<Prisma.$SystemAnalyticsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SystemAnalytics.
     * @param {SystemAnalyticsDeleteManyArgs} args - Arguments to filter SystemAnalytics to delete.
     * @example
     * // Delete a few SystemAnalytics
     * const { count } = await prisma.systemAnalytics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemAnalyticsDeleteManyArgs>(args?: SelectSubset<T, SystemAnalyticsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemAnalyticsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemAnalytics
     * const systemAnalytics = await prisma.systemAnalytics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemAnalyticsUpdateManyArgs>(args: SelectSubset<T, SystemAnalyticsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SystemAnalytics.
     * @param {SystemAnalyticsUpsertArgs} args - Arguments to update or create a SystemAnalytics.
     * @example
     * // Update or create a SystemAnalytics
     * const systemAnalytics = await prisma.systemAnalytics.upsert({
     *   create: {
     *     // ... data to create a SystemAnalytics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemAnalytics we want to update
     *   }
     * })
     */
    upsert<T extends SystemAnalyticsUpsertArgs>(args: SelectSubset<T, SystemAnalyticsUpsertArgs<ExtArgs>>): Prisma__SystemAnalyticsClient<$Result.GetResult<Prisma.$SystemAnalyticsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SystemAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemAnalyticsCountArgs} args - Arguments to filter SystemAnalytics to count.
     * @example
     * // Count the number of SystemAnalytics
     * const count = await prisma.systemAnalytics.count({
     *   where: {
     *     // ... the filter for the SystemAnalytics we want to count
     *   }
     * })
    **/
    count<T extends SystemAnalyticsCountArgs>(
      args?: Subset<T, SystemAnalyticsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemAnalyticsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemAnalyticsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemAnalyticsAggregateArgs>(args: Subset<T, SystemAnalyticsAggregateArgs>): Prisma.PrismaPromise<GetSystemAnalyticsAggregateType<T>>

    /**
     * Group by SystemAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemAnalyticsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemAnalyticsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemAnalyticsGroupByArgs['orderBy'] }
        : { orderBy?: SystemAnalyticsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemAnalyticsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemAnalyticsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemAnalytics model
   */
  readonly fields: SystemAnalyticsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemAnalytics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemAnalyticsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemAnalytics model
   */ 
  interface SystemAnalyticsFieldRefs {
    readonly id: FieldRef<"SystemAnalytics", 'String'>
    readonly metricName: FieldRef<"SystemAnalytics", 'String'>
    readonly metricValue: FieldRef<"SystemAnalytics", 'Json'>
    readonly timestamp: FieldRef<"SystemAnalytics", 'DateTime'>
    readonly userId: FieldRef<"SystemAnalytics", 'String'>
    readonly createdAt: FieldRef<"SystemAnalytics", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemAnalytics findUnique
   */
  export type SystemAnalyticsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemAnalytics
     */
    select?: SystemAnalyticsSelect<ExtArgs> | null
    /**
     * Filter, which SystemAnalytics to fetch.
     */
    where: SystemAnalyticsWhereUniqueInput
  }

  /**
   * SystemAnalytics findUniqueOrThrow
   */
  export type SystemAnalyticsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemAnalytics
     */
    select?: SystemAnalyticsSelect<ExtArgs> | null
    /**
     * Filter, which SystemAnalytics to fetch.
     */
    where: SystemAnalyticsWhereUniqueInput
  }

  /**
   * SystemAnalytics findFirst
   */
  export type SystemAnalyticsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemAnalytics
     */
    select?: SystemAnalyticsSelect<ExtArgs> | null
    /**
     * Filter, which SystemAnalytics to fetch.
     */
    where?: SystemAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemAnalytics to fetch.
     */
    orderBy?: SystemAnalyticsOrderByWithRelationInput | SystemAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemAnalytics.
     */
    cursor?: SystemAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemAnalytics.
     */
    distinct?: SystemAnalyticsScalarFieldEnum | SystemAnalyticsScalarFieldEnum[]
  }

  /**
   * SystemAnalytics findFirstOrThrow
   */
  export type SystemAnalyticsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemAnalytics
     */
    select?: SystemAnalyticsSelect<ExtArgs> | null
    /**
     * Filter, which SystemAnalytics to fetch.
     */
    where?: SystemAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemAnalytics to fetch.
     */
    orderBy?: SystemAnalyticsOrderByWithRelationInput | SystemAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemAnalytics.
     */
    cursor?: SystemAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemAnalytics.
     */
    distinct?: SystemAnalyticsScalarFieldEnum | SystemAnalyticsScalarFieldEnum[]
  }

  /**
   * SystemAnalytics findMany
   */
  export type SystemAnalyticsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemAnalytics
     */
    select?: SystemAnalyticsSelect<ExtArgs> | null
    /**
     * Filter, which SystemAnalytics to fetch.
     */
    where?: SystemAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemAnalytics to fetch.
     */
    orderBy?: SystemAnalyticsOrderByWithRelationInput | SystemAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemAnalytics.
     */
    cursor?: SystemAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemAnalytics.
     */
    skip?: number
    distinct?: SystemAnalyticsScalarFieldEnum | SystemAnalyticsScalarFieldEnum[]
  }

  /**
   * SystemAnalytics create
   */
  export type SystemAnalyticsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemAnalytics
     */
    select?: SystemAnalyticsSelect<ExtArgs> | null
    /**
     * The data needed to create a SystemAnalytics.
     */
    data: XOR<SystemAnalyticsCreateInput, SystemAnalyticsUncheckedCreateInput>
  }

  /**
   * SystemAnalytics createMany
   */
  export type SystemAnalyticsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemAnalytics.
     */
    data: SystemAnalyticsCreateManyInput | SystemAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemAnalytics createManyAndReturn
   */
  export type SystemAnalyticsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemAnalytics
     */
    select?: SystemAnalyticsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SystemAnalytics.
     */
    data: SystemAnalyticsCreateManyInput | SystemAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemAnalytics update
   */
  export type SystemAnalyticsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemAnalytics
     */
    select?: SystemAnalyticsSelect<ExtArgs> | null
    /**
     * The data needed to update a SystemAnalytics.
     */
    data: XOR<SystemAnalyticsUpdateInput, SystemAnalyticsUncheckedUpdateInput>
    /**
     * Choose, which SystemAnalytics to update.
     */
    where: SystemAnalyticsWhereUniqueInput
  }

  /**
   * SystemAnalytics updateMany
   */
  export type SystemAnalyticsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemAnalytics.
     */
    data: XOR<SystemAnalyticsUpdateManyMutationInput, SystemAnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which SystemAnalytics to update
     */
    where?: SystemAnalyticsWhereInput
  }

  /**
   * SystemAnalytics upsert
   */
  export type SystemAnalyticsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemAnalytics
     */
    select?: SystemAnalyticsSelect<ExtArgs> | null
    /**
     * The filter to search for the SystemAnalytics to update in case it exists.
     */
    where: SystemAnalyticsWhereUniqueInput
    /**
     * In case the SystemAnalytics found by the `where` argument doesn't exist, create a new SystemAnalytics with this data.
     */
    create: XOR<SystemAnalyticsCreateInput, SystemAnalyticsUncheckedCreateInput>
    /**
     * In case the SystemAnalytics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemAnalyticsUpdateInput, SystemAnalyticsUncheckedUpdateInput>
  }

  /**
   * SystemAnalytics delete
   */
  export type SystemAnalyticsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemAnalytics
     */
    select?: SystemAnalyticsSelect<ExtArgs> | null
    /**
     * Filter which SystemAnalytics to delete.
     */
    where: SystemAnalyticsWhereUniqueInput
  }

  /**
   * SystemAnalytics deleteMany
   */
  export type SystemAnalyticsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemAnalytics to delete
     */
    where?: SystemAnalyticsWhereInput
  }

  /**
   * SystemAnalytics without action
   */
  export type SystemAnalyticsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemAnalytics
     */
    select?: SystemAnalyticsSelect<ExtArgs> | null
  }


  /**
   * Model TripCostBreakdown
   */

  export type AggregateTripCostBreakdown = {
    _count: TripCostBreakdownCountAggregateOutputType | null
    _avg: TripCostBreakdownAvgAggregateOutputType | null
    _sum: TripCostBreakdownSumAggregateOutputType | null
    _min: TripCostBreakdownMinAggregateOutputType | null
    _max: TripCostBreakdownMaxAggregateOutputType | null
  }

  export type TripCostBreakdownAvgAggregateOutputType = {
    baseRevenue: Decimal | null
    mileageRevenue: Decimal | null
    priorityRevenue: Decimal | null
    specialRequirementsRevenue: Decimal | null
    insuranceAdjustment: Decimal | null
    totalRevenue: Decimal | null
    crewLaborCost: Decimal | null
    vehicleCost: Decimal | null
    fuelCost: Decimal | null
    maintenanceCost: Decimal | null
    overheadCost: Decimal | null
    totalCost: Decimal | null
    grossProfit: Decimal | null
    profitMargin: Decimal | null
    revenuePerMile: Decimal | null
    costPerMile: Decimal | null
    loadedMileRatio: Decimal | null
    deadheadMileRatio: Decimal | null
    utilizationRate: Decimal | null
    tripDistance: Decimal | null
    loadedMiles: Decimal | null
    deadheadMiles: Decimal | null
    tripDurationHours: Decimal | null
  }

  export type TripCostBreakdownSumAggregateOutputType = {
    baseRevenue: Decimal | null
    mileageRevenue: Decimal | null
    priorityRevenue: Decimal | null
    specialRequirementsRevenue: Decimal | null
    insuranceAdjustment: Decimal | null
    totalRevenue: Decimal | null
    crewLaborCost: Decimal | null
    vehicleCost: Decimal | null
    fuelCost: Decimal | null
    maintenanceCost: Decimal | null
    overheadCost: Decimal | null
    totalCost: Decimal | null
    grossProfit: Decimal | null
    profitMargin: Decimal | null
    revenuePerMile: Decimal | null
    costPerMile: Decimal | null
    loadedMileRatio: Decimal | null
    deadheadMileRatio: Decimal | null
    utilizationRate: Decimal | null
    tripDistance: Decimal | null
    loadedMiles: Decimal | null
    deadheadMiles: Decimal | null
    tripDurationHours: Decimal | null
  }

  export type TripCostBreakdownMinAggregateOutputType = {
    id: string | null
    tripId: string | null
    baseRevenue: Decimal | null
    mileageRevenue: Decimal | null
    priorityRevenue: Decimal | null
    specialRequirementsRevenue: Decimal | null
    insuranceAdjustment: Decimal | null
    totalRevenue: Decimal | null
    crewLaborCost: Decimal | null
    vehicleCost: Decimal | null
    fuelCost: Decimal | null
    maintenanceCost: Decimal | null
    overheadCost: Decimal | null
    totalCost: Decimal | null
    grossProfit: Decimal | null
    profitMargin: Decimal | null
    revenuePerMile: Decimal | null
    costPerMile: Decimal | null
    loadedMileRatio: Decimal | null
    deadheadMileRatio: Decimal | null
    utilizationRate: Decimal | null
    tripDistance: Decimal | null
    loadedMiles: Decimal | null
    deadheadMiles: Decimal | null
    tripDurationHours: Decimal | null
    transportLevel: string | null
    priorityLevel: string | null
    costCenterId: string | null
    costCenterName: string | null
    calculatedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TripCostBreakdownMaxAggregateOutputType = {
    id: string | null
    tripId: string | null
    baseRevenue: Decimal | null
    mileageRevenue: Decimal | null
    priorityRevenue: Decimal | null
    specialRequirementsRevenue: Decimal | null
    insuranceAdjustment: Decimal | null
    totalRevenue: Decimal | null
    crewLaborCost: Decimal | null
    vehicleCost: Decimal | null
    fuelCost: Decimal | null
    maintenanceCost: Decimal | null
    overheadCost: Decimal | null
    totalCost: Decimal | null
    grossProfit: Decimal | null
    profitMargin: Decimal | null
    revenuePerMile: Decimal | null
    costPerMile: Decimal | null
    loadedMileRatio: Decimal | null
    deadheadMileRatio: Decimal | null
    utilizationRate: Decimal | null
    tripDistance: Decimal | null
    loadedMiles: Decimal | null
    deadheadMiles: Decimal | null
    tripDurationHours: Decimal | null
    transportLevel: string | null
    priorityLevel: string | null
    costCenterId: string | null
    costCenterName: string | null
    calculatedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TripCostBreakdownCountAggregateOutputType = {
    id: number
    tripId: number
    baseRevenue: number
    mileageRevenue: number
    priorityRevenue: number
    specialRequirementsRevenue: number
    insuranceAdjustment: number
    totalRevenue: number
    crewLaborCost: number
    vehicleCost: number
    fuelCost: number
    maintenanceCost: number
    overheadCost: number
    totalCost: number
    grossProfit: number
    profitMargin: number
    revenuePerMile: number
    costPerMile: number
    loadedMileRatio: number
    deadheadMileRatio: number
    utilizationRate: number
    tripDistance: number
    loadedMiles: number
    deadheadMiles: number
    tripDurationHours: number
    transportLevel: number
    priorityLevel: number
    costCenterId: number
    costCenterName: number
    calculatedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TripCostBreakdownAvgAggregateInputType = {
    baseRevenue?: true
    mileageRevenue?: true
    priorityRevenue?: true
    specialRequirementsRevenue?: true
    insuranceAdjustment?: true
    totalRevenue?: true
    crewLaborCost?: true
    vehicleCost?: true
    fuelCost?: true
    maintenanceCost?: true
    overheadCost?: true
    totalCost?: true
    grossProfit?: true
    profitMargin?: true
    revenuePerMile?: true
    costPerMile?: true
    loadedMileRatio?: true
    deadheadMileRatio?: true
    utilizationRate?: true
    tripDistance?: true
    loadedMiles?: true
    deadheadMiles?: true
    tripDurationHours?: true
  }

  export type TripCostBreakdownSumAggregateInputType = {
    baseRevenue?: true
    mileageRevenue?: true
    priorityRevenue?: true
    specialRequirementsRevenue?: true
    insuranceAdjustment?: true
    totalRevenue?: true
    crewLaborCost?: true
    vehicleCost?: true
    fuelCost?: true
    maintenanceCost?: true
    overheadCost?: true
    totalCost?: true
    grossProfit?: true
    profitMargin?: true
    revenuePerMile?: true
    costPerMile?: true
    loadedMileRatio?: true
    deadheadMileRatio?: true
    utilizationRate?: true
    tripDistance?: true
    loadedMiles?: true
    deadheadMiles?: true
    tripDurationHours?: true
  }

  export type TripCostBreakdownMinAggregateInputType = {
    id?: true
    tripId?: true
    baseRevenue?: true
    mileageRevenue?: true
    priorityRevenue?: true
    specialRequirementsRevenue?: true
    insuranceAdjustment?: true
    totalRevenue?: true
    crewLaborCost?: true
    vehicleCost?: true
    fuelCost?: true
    maintenanceCost?: true
    overheadCost?: true
    totalCost?: true
    grossProfit?: true
    profitMargin?: true
    revenuePerMile?: true
    costPerMile?: true
    loadedMileRatio?: true
    deadheadMileRatio?: true
    utilizationRate?: true
    tripDistance?: true
    loadedMiles?: true
    deadheadMiles?: true
    tripDurationHours?: true
    transportLevel?: true
    priorityLevel?: true
    costCenterId?: true
    costCenterName?: true
    calculatedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TripCostBreakdownMaxAggregateInputType = {
    id?: true
    tripId?: true
    baseRevenue?: true
    mileageRevenue?: true
    priorityRevenue?: true
    specialRequirementsRevenue?: true
    insuranceAdjustment?: true
    totalRevenue?: true
    crewLaborCost?: true
    vehicleCost?: true
    fuelCost?: true
    maintenanceCost?: true
    overheadCost?: true
    totalCost?: true
    grossProfit?: true
    profitMargin?: true
    revenuePerMile?: true
    costPerMile?: true
    loadedMileRatio?: true
    deadheadMileRatio?: true
    utilizationRate?: true
    tripDistance?: true
    loadedMiles?: true
    deadheadMiles?: true
    tripDurationHours?: true
    transportLevel?: true
    priorityLevel?: true
    costCenterId?: true
    costCenterName?: true
    calculatedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TripCostBreakdownCountAggregateInputType = {
    id?: true
    tripId?: true
    baseRevenue?: true
    mileageRevenue?: true
    priorityRevenue?: true
    specialRequirementsRevenue?: true
    insuranceAdjustment?: true
    totalRevenue?: true
    crewLaborCost?: true
    vehicleCost?: true
    fuelCost?: true
    maintenanceCost?: true
    overheadCost?: true
    totalCost?: true
    grossProfit?: true
    profitMargin?: true
    revenuePerMile?: true
    costPerMile?: true
    loadedMileRatio?: true
    deadheadMileRatio?: true
    utilizationRate?: true
    tripDistance?: true
    loadedMiles?: true
    deadheadMiles?: true
    tripDurationHours?: true
    transportLevel?: true
    priorityLevel?: true
    costCenterId?: true
    costCenterName?: true
    calculatedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TripCostBreakdownAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TripCostBreakdown to aggregate.
     */
    where?: TripCostBreakdownWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TripCostBreakdowns to fetch.
     */
    orderBy?: TripCostBreakdownOrderByWithRelationInput | TripCostBreakdownOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TripCostBreakdownWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TripCostBreakdowns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TripCostBreakdowns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TripCostBreakdowns
    **/
    _count?: true | TripCostBreakdownCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TripCostBreakdownAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TripCostBreakdownSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TripCostBreakdownMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TripCostBreakdownMaxAggregateInputType
  }

  export type GetTripCostBreakdownAggregateType<T extends TripCostBreakdownAggregateArgs> = {
        [P in keyof T & keyof AggregateTripCostBreakdown]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTripCostBreakdown[P]>
      : GetScalarType<T[P], AggregateTripCostBreakdown[P]>
  }




  export type TripCostBreakdownGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TripCostBreakdownWhereInput
    orderBy?: TripCostBreakdownOrderByWithAggregationInput | TripCostBreakdownOrderByWithAggregationInput[]
    by: TripCostBreakdownScalarFieldEnum[] | TripCostBreakdownScalarFieldEnum
    having?: TripCostBreakdownScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TripCostBreakdownCountAggregateInputType | true
    _avg?: TripCostBreakdownAvgAggregateInputType
    _sum?: TripCostBreakdownSumAggregateInputType
    _min?: TripCostBreakdownMinAggregateInputType
    _max?: TripCostBreakdownMaxAggregateInputType
  }

  export type TripCostBreakdownGroupByOutputType = {
    id: string
    tripId: string
    baseRevenue: Decimal
    mileageRevenue: Decimal
    priorityRevenue: Decimal
    specialRequirementsRevenue: Decimal
    insuranceAdjustment: Decimal
    totalRevenue: Decimal
    crewLaborCost: Decimal
    vehicleCost: Decimal
    fuelCost: Decimal
    maintenanceCost: Decimal
    overheadCost: Decimal
    totalCost: Decimal
    grossProfit: Decimal
    profitMargin: Decimal
    revenuePerMile: Decimal
    costPerMile: Decimal
    loadedMileRatio: Decimal
    deadheadMileRatio: Decimal
    utilizationRate: Decimal
    tripDistance: Decimal
    loadedMiles: Decimal
    deadheadMiles: Decimal
    tripDurationHours: Decimal
    transportLevel: string
    priorityLevel: string
    costCenterId: string | null
    costCenterName: string | null
    calculatedAt: Date
    createdAt: Date
    updatedAt: Date
    _count: TripCostBreakdownCountAggregateOutputType | null
    _avg: TripCostBreakdownAvgAggregateOutputType | null
    _sum: TripCostBreakdownSumAggregateOutputType | null
    _min: TripCostBreakdownMinAggregateOutputType | null
    _max: TripCostBreakdownMaxAggregateOutputType | null
  }

  type GetTripCostBreakdownGroupByPayload<T extends TripCostBreakdownGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TripCostBreakdownGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TripCostBreakdownGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TripCostBreakdownGroupByOutputType[P]>
            : GetScalarType<T[P], TripCostBreakdownGroupByOutputType[P]>
        }
      >
    >


  export type TripCostBreakdownSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tripId?: boolean
    baseRevenue?: boolean
    mileageRevenue?: boolean
    priorityRevenue?: boolean
    specialRequirementsRevenue?: boolean
    insuranceAdjustment?: boolean
    totalRevenue?: boolean
    crewLaborCost?: boolean
    vehicleCost?: boolean
    fuelCost?: boolean
    maintenanceCost?: boolean
    overheadCost?: boolean
    totalCost?: boolean
    grossProfit?: boolean
    profitMargin?: boolean
    revenuePerMile?: boolean
    costPerMile?: boolean
    loadedMileRatio?: boolean
    deadheadMileRatio?: boolean
    utilizationRate?: boolean
    tripDistance?: boolean
    loadedMiles?: boolean
    deadheadMiles?: boolean
    tripDurationHours?: boolean
    transportLevel?: boolean
    priorityLevel?: boolean
    costCenterId?: boolean
    costCenterName?: boolean
    calculatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tripCostBreakdown"]>

  export type TripCostBreakdownSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tripId?: boolean
    baseRevenue?: boolean
    mileageRevenue?: boolean
    priorityRevenue?: boolean
    specialRequirementsRevenue?: boolean
    insuranceAdjustment?: boolean
    totalRevenue?: boolean
    crewLaborCost?: boolean
    vehicleCost?: boolean
    fuelCost?: boolean
    maintenanceCost?: boolean
    overheadCost?: boolean
    totalCost?: boolean
    grossProfit?: boolean
    profitMargin?: boolean
    revenuePerMile?: boolean
    costPerMile?: boolean
    loadedMileRatio?: boolean
    deadheadMileRatio?: boolean
    utilizationRate?: boolean
    tripDistance?: boolean
    loadedMiles?: boolean
    deadheadMiles?: boolean
    tripDurationHours?: boolean
    transportLevel?: boolean
    priorityLevel?: boolean
    costCenterId?: boolean
    costCenterName?: boolean
    calculatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tripCostBreakdown"]>

  export type TripCostBreakdownSelectScalar = {
    id?: boolean
    tripId?: boolean
    baseRevenue?: boolean
    mileageRevenue?: boolean
    priorityRevenue?: boolean
    specialRequirementsRevenue?: boolean
    insuranceAdjustment?: boolean
    totalRevenue?: boolean
    crewLaborCost?: boolean
    vehicleCost?: boolean
    fuelCost?: boolean
    maintenanceCost?: boolean
    overheadCost?: boolean
    totalCost?: boolean
    grossProfit?: boolean
    profitMargin?: boolean
    revenuePerMile?: boolean
    costPerMile?: boolean
    loadedMileRatio?: boolean
    deadheadMileRatio?: boolean
    utilizationRate?: boolean
    tripDistance?: boolean
    loadedMiles?: boolean
    deadheadMiles?: boolean
    tripDurationHours?: boolean
    transportLevel?: boolean
    priorityLevel?: boolean
    costCenterId?: boolean
    costCenterName?: boolean
    calculatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $TripCostBreakdownPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TripCostBreakdown"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tripId: string
      baseRevenue: Prisma.Decimal
      mileageRevenue: Prisma.Decimal
      priorityRevenue: Prisma.Decimal
      specialRequirementsRevenue: Prisma.Decimal
      insuranceAdjustment: Prisma.Decimal
      totalRevenue: Prisma.Decimal
      crewLaborCost: Prisma.Decimal
      vehicleCost: Prisma.Decimal
      fuelCost: Prisma.Decimal
      maintenanceCost: Prisma.Decimal
      overheadCost: Prisma.Decimal
      totalCost: Prisma.Decimal
      grossProfit: Prisma.Decimal
      profitMargin: Prisma.Decimal
      revenuePerMile: Prisma.Decimal
      costPerMile: Prisma.Decimal
      loadedMileRatio: Prisma.Decimal
      deadheadMileRatio: Prisma.Decimal
      utilizationRate: Prisma.Decimal
      tripDistance: Prisma.Decimal
      loadedMiles: Prisma.Decimal
      deadheadMiles: Prisma.Decimal
      tripDurationHours: Prisma.Decimal
      transportLevel: string
      priorityLevel: string
      costCenterId: string | null
      costCenterName: string | null
      calculatedAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tripCostBreakdown"]>
    composites: {}
  }

  type TripCostBreakdownGetPayload<S extends boolean | null | undefined | TripCostBreakdownDefaultArgs> = $Result.GetResult<Prisma.$TripCostBreakdownPayload, S>

  type TripCostBreakdownCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TripCostBreakdownFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TripCostBreakdownCountAggregateInputType | true
    }

  export interface TripCostBreakdownDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TripCostBreakdown'], meta: { name: 'TripCostBreakdown' } }
    /**
     * Find zero or one TripCostBreakdown that matches the filter.
     * @param {TripCostBreakdownFindUniqueArgs} args - Arguments to find a TripCostBreakdown
     * @example
     * // Get one TripCostBreakdown
     * const tripCostBreakdown = await prisma.tripCostBreakdown.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TripCostBreakdownFindUniqueArgs>(args: SelectSubset<T, TripCostBreakdownFindUniqueArgs<ExtArgs>>): Prisma__TripCostBreakdownClient<$Result.GetResult<Prisma.$TripCostBreakdownPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TripCostBreakdown that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TripCostBreakdownFindUniqueOrThrowArgs} args - Arguments to find a TripCostBreakdown
     * @example
     * // Get one TripCostBreakdown
     * const tripCostBreakdown = await prisma.tripCostBreakdown.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TripCostBreakdownFindUniqueOrThrowArgs>(args: SelectSubset<T, TripCostBreakdownFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TripCostBreakdownClient<$Result.GetResult<Prisma.$TripCostBreakdownPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TripCostBreakdown that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripCostBreakdownFindFirstArgs} args - Arguments to find a TripCostBreakdown
     * @example
     * // Get one TripCostBreakdown
     * const tripCostBreakdown = await prisma.tripCostBreakdown.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TripCostBreakdownFindFirstArgs>(args?: SelectSubset<T, TripCostBreakdownFindFirstArgs<ExtArgs>>): Prisma__TripCostBreakdownClient<$Result.GetResult<Prisma.$TripCostBreakdownPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TripCostBreakdown that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripCostBreakdownFindFirstOrThrowArgs} args - Arguments to find a TripCostBreakdown
     * @example
     * // Get one TripCostBreakdown
     * const tripCostBreakdown = await prisma.tripCostBreakdown.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TripCostBreakdownFindFirstOrThrowArgs>(args?: SelectSubset<T, TripCostBreakdownFindFirstOrThrowArgs<ExtArgs>>): Prisma__TripCostBreakdownClient<$Result.GetResult<Prisma.$TripCostBreakdownPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TripCostBreakdowns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripCostBreakdownFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TripCostBreakdowns
     * const tripCostBreakdowns = await prisma.tripCostBreakdown.findMany()
     * 
     * // Get first 10 TripCostBreakdowns
     * const tripCostBreakdowns = await prisma.tripCostBreakdown.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tripCostBreakdownWithIdOnly = await prisma.tripCostBreakdown.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TripCostBreakdownFindManyArgs>(args?: SelectSubset<T, TripCostBreakdownFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripCostBreakdownPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TripCostBreakdown.
     * @param {TripCostBreakdownCreateArgs} args - Arguments to create a TripCostBreakdown.
     * @example
     * // Create one TripCostBreakdown
     * const TripCostBreakdown = await prisma.tripCostBreakdown.create({
     *   data: {
     *     // ... data to create a TripCostBreakdown
     *   }
     * })
     * 
     */
    create<T extends TripCostBreakdownCreateArgs>(args: SelectSubset<T, TripCostBreakdownCreateArgs<ExtArgs>>): Prisma__TripCostBreakdownClient<$Result.GetResult<Prisma.$TripCostBreakdownPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TripCostBreakdowns.
     * @param {TripCostBreakdownCreateManyArgs} args - Arguments to create many TripCostBreakdowns.
     * @example
     * // Create many TripCostBreakdowns
     * const tripCostBreakdown = await prisma.tripCostBreakdown.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TripCostBreakdownCreateManyArgs>(args?: SelectSubset<T, TripCostBreakdownCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TripCostBreakdowns and returns the data saved in the database.
     * @param {TripCostBreakdownCreateManyAndReturnArgs} args - Arguments to create many TripCostBreakdowns.
     * @example
     * // Create many TripCostBreakdowns
     * const tripCostBreakdown = await prisma.tripCostBreakdown.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TripCostBreakdowns and only return the `id`
     * const tripCostBreakdownWithIdOnly = await prisma.tripCostBreakdown.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TripCostBreakdownCreateManyAndReturnArgs>(args?: SelectSubset<T, TripCostBreakdownCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripCostBreakdownPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TripCostBreakdown.
     * @param {TripCostBreakdownDeleteArgs} args - Arguments to delete one TripCostBreakdown.
     * @example
     * // Delete one TripCostBreakdown
     * const TripCostBreakdown = await prisma.tripCostBreakdown.delete({
     *   where: {
     *     // ... filter to delete one TripCostBreakdown
     *   }
     * })
     * 
     */
    delete<T extends TripCostBreakdownDeleteArgs>(args: SelectSubset<T, TripCostBreakdownDeleteArgs<ExtArgs>>): Prisma__TripCostBreakdownClient<$Result.GetResult<Prisma.$TripCostBreakdownPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TripCostBreakdown.
     * @param {TripCostBreakdownUpdateArgs} args - Arguments to update one TripCostBreakdown.
     * @example
     * // Update one TripCostBreakdown
     * const tripCostBreakdown = await prisma.tripCostBreakdown.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TripCostBreakdownUpdateArgs>(args: SelectSubset<T, TripCostBreakdownUpdateArgs<ExtArgs>>): Prisma__TripCostBreakdownClient<$Result.GetResult<Prisma.$TripCostBreakdownPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TripCostBreakdowns.
     * @param {TripCostBreakdownDeleteManyArgs} args - Arguments to filter TripCostBreakdowns to delete.
     * @example
     * // Delete a few TripCostBreakdowns
     * const { count } = await prisma.tripCostBreakdown.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TripCostBreakdownDeleteManyArgs>(args?: SelectSubset<T, TripCostBreakdownDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TripCostBreakdowns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripCostBreakdownUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TripCostBreakdowns
     * const tripCostBreakdown = await prisma.tripCostBreakdown.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TripCostBreakdownUpdateManyArgs>(args: SelectSubset<T, TripCostBreakdownUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TripCostBreakdown.
     * @param {TripCostBreakdownUpsertArgs} args - Arguments to update or create a TripCostBreakdown.
     * @example
     * // Update or create a TripCostBreakdown
     * const tripCostBreakdown = await prisma.tripCostBreakdown.upsert({
     *   create: {
     *     // ... data to create a TripCostBreakdown
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TripCostBreakdown we want to update
     *   }
     * })
     */
    upsert<T extends TripCostBreakdownUpsertArgs>(args: SelectSubset<T, TripCostBreakdownUpsertArgs<ExtArgs>>): Prisma__TripCostBreakdownClient<$Result.GetResult<Prisma.$TripCostBreakdownPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TripCostBreakdowns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripCostBreakdownCountArgs} args - Arguments to filter TripCostBreakdowns to count.
     * @example
     * // Count the number of TripCostBreakdowns
     * const count = await prisma.tripCostBreakdown.count({
     *   where: {
     *     // ... the filter for the TripCostBreakdowns we want to count
     *   }
     * })
    **/
    count<T extends TripCostBreakdownCountArgs>(
      args?: Subset<T, TripCostBreakdownCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TripCostBreakdownCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TripCostBreakdown.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripCostBreakdownAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TripCostBreakdownAggregateArgs>(args: Subset<T, TripCostBreakdownAggregateArgs>): Prisma.PrismaPromise<GetTripCostBreakdownAggregateType<T>>

    /**
     * Group by TripCostBreakdown.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripCostBreakdownGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TripCostBreakdownGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TripCostBreakdownGroupByArgs['orderBy'] }
        : { orderBy?: TripCostBreakdownGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TripCostBreakdownGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTripCostBreakdownGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TripCostBreakdown model
   */
  readonly fields: TripCostBreakdownFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TripCostBreakdown.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TripCostBreakdownClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TripCostBreakdown model
   */ 
  interface TripCostBreakdownFieldRefs {
    readonly id: FieldRef<"TripCostBreakdown", 'String'>
    readonly tripId: FieldRef<"TripCostBreakdown", 'String'>
    readonly baseRevenue: FieldRef<"TripCostBreakdown", 'Decimal'>
    readonly mileageRevenue: FieldRef<"TripCostBreakdown", 'Decimal'>
    readonly priorityRevenue: FieldRef<"TripCostBreakdown", 'Decimal'>
    readonly specialRequirementsRevenue: FieldRef<"TripCostBreakdown", 'Decimal'>
    readonly insuranceAdjustment: FieldRef<"TripCostBreakdown", 'Decimal'>
    readonly totalRevenue: FieldRef<"TripCostBreakdown", 'Decimal'>
    readonly crewLaborCost: FieldRef<"TripCostBreakdown", 'Decimal'>
    readonly vehicleCost: FieldRef<"TripCostBreakdown", 'Decimal'>
    readonly fuelCost: FieldRef<"TripCostBreakdown", 'Decimal'>
    readonly maintenanceCost: FieldRef<"TripCostBreakdown", 'Decimal'>
    readonly overheadCost: FieldRef<"TripCostBreakdown", 'Decimal'>
    readonly totalCost: FieldRef<"TripCostBreakdown", 'Decimal'>
    readonly grossProfit: FieldRef<"TripCostBreakdown", 'Decimal'>
    readonly profitMargin: FieldRef<"TripCostBreakdown", 'Decimal'>
    readonly revenuePerMile: FieldRef<"TripCostBreakdown", 'Decimal'>
    readonly costPerMile: FieldRef<"TripCostBreakdown", 'Decimal'>
    readonly loadedMileRatio: FieldRef<"TripCostBreakdown", 'Decimal'>
    readonly deadheadMileRatio: FieldRef<"TripCostBreakdown", 'Decimal'>
    readonly utilizationRate: FieldRef<"TripCostBreakdown", 'Decimal'>
    readonly tripDistance: FieldRef<"TripCostBreakdown", 'Decimal'>
    readonly loadedMiles: FieldRef<"TripCostBreakdown", 'Decimal'>
    readonly deadheadMiles: FieldRef<"TripCostBreakdown", 'Decimal'>
    readonly tripDurationHours: FieldRef<"TripCostBreakdown", 'Decimal'>
    readonly transportLevel: FieldRef<"TripCostBreakdown", 'String'>
    readonly priorityLevel: FieldRef<"TripCostBreakdown", 'String'>
    readonly costCenterId: FieldRef<"TripCostBreakdown", 'String'>
    readonly costCenterName: FieldRef<"TripCostBreakdown", 'String'>
    readonly calculatedAt: FieldRef<"TripCostBreakdown", 'DateTime'>
    readonly createdAt: FieldRef<"TripCostBreakdown", 'DateTime'>
    readonly updatedAt: FieldRef<"TripCostBreakdown", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TripCostBreakdown findUnique
   */
  export type TripCostBreakdownFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripCostBreakdown
     */
    select?: TripCostBreakdownSelect<ExtArgs> | null
    /**
     * Filter, which TripCostBreakdown to fetch.
     */
    where: TripCostBreakdownWhereUniqueInput
  }

  /**
   * TripCostBreakdown findUniqueOrThrow
   */
  export type TripCostBreakdownFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripCostBreakdown
     */
    select?: TripCostBreakdownSelect<ExtArgs> | null
    /**
     * Filter, which TripCostBreakdown to fetch.
     */
    where: TripCostBreakdownWhereUniqueInput
  }

  /**
   * TripCostBreakdown findFirst
   */
  export type TripCostBreakdownFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripCostBreakdown
     */
    select?: TripCostBreakdownSelect<ExtArgs> | null
    /**
     * Filter, which TripCostBreakdown to fetch.
     */
    where?: TripCostBreakdownWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TripCostBreakdowns to fetch.
     */
    orderBy?: TripCostBreakdownOrderByWithRelationInput | TripCostBreakdownOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TripCostBreakdowns.
     */
    cursor?: TripCostBreakdownWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TripCostBreakdowns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TripCostBreakdowns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TripCostBreakdowns.
     */
    distinct?: TripCostBreakdownScalarFieldEnum | TripCostBreakdownScalarFieldEnum[]
  }

  /**
   * TripCostBreakdown findFirstOrThrow
   */
  export type TripCostBreakdownFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripCostBreakdown
     */
    select?: TripCostBreakdownSelect<ExtArgs> | null
    /**
     * Filter, which TripCostBreakdown to fetch.
     */
    where?: TripCostBreakdownWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TripCostBreakdowns to fetch.
     */
    orderBy?: TripCostBreakdownOrderByWithRelationInput | TripCostBreakdownOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TripCostBreakdowns.
     */
    cursor?: TripCostBreakdownWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TripCostBreakdowns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TripCostBreakdowns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TripCostBreakdowns.
     */
    distinct?: TripCostBreakdownScalarFieldEnum | TripCostBreakdownScalarFieldEnum[]
  }

  /**
   * TripCostBreakdown findMany
   */
  export type TripCostBreakdownFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripCostBreakdown
     */
    select?: TripCostBreakdownSelect<ExtArgs> | null
    /**
     * Filter, which TripCostBreakdowns to fetch.
     */
    where?: TripCostBreakdownWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TripCostBreakdowns to fetch.
     */
    orderBy?: TripCostBreakdownOrderByWithRelationInput | TripCostBreakdownOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TripCostBreakdowns.
     */
    cursor?: TripCostBreakdownWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TripCostBreakdowns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TripCostBreakdowns.
     */
    skip?: number
    distinct?: TripCostBreakdownScalarFieldEnum | TripCostBreakdownScalarFieldEnum[]
  }

  /**
   * TripCostBreakdown create
   */
  export type TripCostBreakdownCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripCostBreakdown
     */
    select?: TripCostBreakdownSelect<ExtArgs> | null
    /**
     * The data needed to create a TripCostBreakdown.
     */
    data: XOR<TripCostBreakdownCreateInput, TripCostBreakdownUncheckedCreateInput>
  }

  /**
   * TripCostBreakdown createMany
   */
  export type TripCostBreakdownCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TripCostBreakdowns.
     */
    data: TripCostBreakdownCreateManyInput | TripCostBreakdownCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TripCostBreakdown createManyAndReturn
   */
  export type TripCostBreakdownCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripCostBreakdown
     */
    select?: TripCostBreakdownSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TripCostBreakdowns.
     */
    data: TripCostBreakdownCreateManyInput | TripCostBreakdownCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TripCostBreakdown update
   */
  export type TripCostBreakdownUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripCostBreakdown
     */
    select?: TripCostBreakdownSelect<ExtArgs> | null
    /**
     * The data needed to update a TripCostBreakdown.
     */
    data: XOR<TripCostBreakdownUpdateInput, TripCostBreakdownUncheckedUpdateInput>
    /**
     * Choose, which TripCostBreakdown to update.
     */
    where: TripCostBreakdownWhereUniqueInput
  }

  /**
   * TripCostBreakdown updateMany
   */
  export type TripCostBreakdownUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TripCostBreakdowns.
     */
    data: XOR<TripCostBreakdownUpdateManyMutationInput, TripCostBreakdownUncheckedUpdateManyInput>
    /**
     * Filter which TripCostBreakdowns to update
     */
    where?: TripCostBreakdownWhereInput
  }

  /**
   * TripCostBreakdown upsert
   */
  export type TripCostBreakdownUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripCostBreakdown
     */
    select?: TripCostBreakdownSelect<ExtArgs> | null
    /**
     * The filter to search for the TripCostBreakdown to update in case it exists.
     */
    where: TripCostBreakdownWhereUniqueInput
    /**
     * In case the TripCostBreakdown found by the `where` argument doesn't exist, create a new TripCostBreakdown with this data.
     */
    create: XOR<TripCostBreakdownCreateInput, TripCostBreakdownUncheckedCreateInput>
    /**
     * In case the TripCostBreakdown was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TripCostBreakdownUpdateInput, TripCostBreakdownUncheckedUpdateInput>
  }

  /**
   * TripCostBreakdown delete
   */
  export type TripCostBreakdownDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripCostBreakdown
     */
    select?: TripCostBreakdownSelect<ExtArgs> | null
    /**
     * Filter which TripCostBreakdown to delete.
     */
    where: TripCostBreakdownWhereUniqueInput
  }

  /**
   * TripCostBreakdown deleteMany
   */
  export type TripCostBreakdownDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TripCostBreakdowns to delete
     */
    where?: TripCostBreakdownWhereInput
  }

  /**
   * TripCostBreakdown without action
   */
  export type TripCostBreakdownDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripCostBreakdown
     */
    select?: TripCostBreakdownSelect<ExtArgs> | null
  }


  /**
   * Model CostCenter
   */

  export type AggregateCostCenter = {
    _count: CostCenterCountAggregateOutputType | null
    _avg: CostCenterAvgAggregateOutputType | null
    _sum: CostCenterSumAggregateOutputType | null
    _min: CostCenterMinAggregateOutputType | null
    _max: CostCenterMaxAggregateOutputType | null
  }

  export type CostCenterAvgAggregateOutputType = {
    overheadRate: Decimal | null
    fixedCosts: Decimal | null
    variableCosts: Decimal | null
  }

  export type CostCenterSumAggregateOutputType = {
    overheadRate: Decimal | null
    fixedCosts: Decimal | null
    variableCosts: Decimal | null
  }

  export type CostCenterMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    code: string | null
    overheadRate: Decimal | null
    fixedCosts: Decimal | null
    variableCosts: Decimal | null
    allocationMethod: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CostCenterMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    code: string | null
    overheadRate: Decimal | null
    fixedCosts: Decimal | null
    variableCosts: Decimal | null
    allocationMethod: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CostCenterCountAggregateOutputType = {
    id: number
    name: number
    description: number
    code: number
    overheadRate: number
    fixedCosts: number
    variableCosts: number
    allocationMethod: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CostCenterAvgAggregateInputType = {
    overheadRate?: true
    fixedCosts?: true
    variableCosts?: true
  }

  export type CostCenterSumAggregateInputType = {
    overheadRate?: true
    fixedCosts?: true
    variableCosts?: true
  }

  export type CostCenterMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    code?: true
    overheadRate?: true
    fixedCosts?: true
    variableCosts?: true
    allocationMethod?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CostCenterMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    code?: true
    overheadRate?: true
    fixedCosts?: true
    variableCosts?: true
    allocationMethod?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CostCenterCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    code?: true
    overheadRate?: true
    fixedCosts?: true
    variableCosts?: true
    allocationMethod?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CostCenterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CostCenter to aggregate.
     */
    where?: CostCenterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostCenters to fetch.
     */
    orderBy?: CostCenterOrderByWithRelationInput | CostCenterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CostCenterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostCenters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostCenters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CostCenters
    **/
    _count?: true | CostCenterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CostCenterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CostCenterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CostCenterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CostCenterMaxAggregateInputType
  }

  export type GetCostCenterAggregateType<T extends CostCenterAggregateArgs> = {
        [P in keyof T & keyof AggregateCostCenter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCostCenter[P]>
      : GetScalarType<T[P], AggregateCostCenter[P]>
  }




  export type CostCenterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CostCenterWhereInput
    orderBy?: CostCenterOrderByWithAggregationInput | CostCenterOrderByWithAggregationInput[]
    by: CostCenterScalarFieldEnum[] | CostCenterScalarFieldEnum
    having?: CostCenterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CostCenterCountAggregateInputType | true
    _avg?: CostCenterAvgAggregateInputType
    _sum?: CostCenterSumAggregateInputType
    _min?: CostCenterMinAggregateInputType
    _max?: CostCenterMaxAggregateInputType
  }

  export type CostCenterGroupByOutputType = {
    id: string
    name: string
    description: string | null
    code: string
    overheadRate: Decimal
    fixedCosts: Decimal
    variableCosts: Decimal
    allocationMethod: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: CostCenterCountAggregateOutputType | null
    _avg: CostCenterAvgAggregateOutputType | null
    _sum: CostCenterSumAggregateOutputType | null
    _min: CostCenterMinAggregateOutputType | null
    _max: CostCenterMaxAggregateOutputType | null
  }

  type GetCostCenterGroupByPayload<T extends CostCenterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CostCenterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CostCenterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CostCenterGroupByOutputType[P]>
            : GetScalarType<T[P], CostCenterGroupByOutputType[P]>
        }
      >
    >


  export type CostCenterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    code?: boolean
    overheadRate?: boolean
    fixedCosts?: boolean
    variableCosts?: boolean
    allocationMethod?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["costCenter"]>

  export type CostCenterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    code?: boolean
    overheadRate?: boolean
    fixedCosts?: boolean
    variableCosts?: boolean
    allocationMethod?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["costCenter"]>

  export type CostCenterSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    code?: boolean
    overheadRate?: boolean
    fixedCosts?: boolean
    variableCosts?: boolean
    allocationMethod?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $CostCenterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CostCenter"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      code: string
      overheadRate: Prisma.Decimal
      fixedCosts: Prisma.Decimal
      variableCosts: Prisma.Decimal
      allocationMethod: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["costCenter"]>
    composites: {}
  }

  type CostCenterGetPayload<S extends boolean | null | undefined | CostCenterDefaultArgs> = $Result.GetResult<Prisma.$CostCenterPayload, S>

  type CostCenterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CostCenterFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CostCenterCountAggregateInputType | true
    }

  export interface CostCenterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CostCenter'], meta: { name: 'CostCenter' } }
    /**
     * Find zero or one CostCenter that matches the filter.
     * @param {CostCenterFindUniqueArgs} args - Arguments to find a CostCenter
     * @example
     * // Get one CostCenter
     * const costCenter = await prisma.costCenter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CostCenterFindUniqueArgs>(args: SelectSubset<T, CostCenterFindUniqueArgs<ExtArgs>>): Prisma__CostCenterClient<$Result.GetResult<Prisma.$CostCenterPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CostCenter that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CostCenterFindUniqueOrThrowArgs} args - Arguments to find a CostCenter
     * @example
     * // Get one CostCenter
     * const costCenter = await prisma.costCenter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CostCenterFindUniqueOrThrowArgs>(args: SelectSubset<T, CostCenterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CostCenterClient<$Result.GetResult<Prisma.$CostCenterPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CostCenter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostCenterFindFirstArgs} args - Arguments to find a CostCenter
     * @example
     * // Get one CostCenter
     * const costCenter = await prisma.costCenter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CostCenterFindFirstArgs>(args?: SelectSubset<T, CostCenterFindFirstArgs<ExtArgs>>): Prisma__CostCenterClient<$Result.GetResult<Prisma.$CostCenterPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CostCenter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostCenterFindFirstOrThrowArgs} args - Arguments to find a CostCenter
     * @example
     * // Get one CostCenter
     * const costCenter = await prisma.costCenter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CostCenterFindFirstOrThrowArgs>(args?: SelectSubset<T, CostCenterFindFirstOrThrowArgs<ExtArgs>>): Prisma__CostCenterClient<$Result.GetResult<Prisma.$CostCenterPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CostCenters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostCenterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CostCenters
     * const costCenters = await prisma.costCenter.findMany()
     * 
     * // Get first 10 CostCenters
     * const costCenters = await prisma.costCenter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const costCenterWithIdOnly = await prisma.costCenter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CostCenterFindManyArgs>(args?: SelectSubset<T, CostCenterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostCenterPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CostCenter.
     * @param {CostCenterCreateArgs} args - Arguments to create a CostCenter.
     * @example
     * // Create one CostCenter
     * const CostCenter = await prisma.costCenter.create({
     *   data: {
     *     // ... data to create a CostCenter
     *   }
     * })
     * 
     */
    create<T extends CostCenterCreateArgs>(args: SelectSubset<T, CostCenterCreateArgs<ExtArgs>>): Prisma__CostCenterClient<$Result.GetResult<Prisma.$CostCenterPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CostCenters.
     * @param {CostCenterCreateManyArgs} args - Arguments to create many CostCenters.
     * @example
     * // Create many CostCenters
     * const costCenter = await prisma.costCenter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CostCenterCreateManyArgs>(args?: SelectSubset<T, CostCenterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CostCenters and returns the data saved in the database.
     * @param {CostCenterCreateManyAndReturnArgs} args - Arguments to create many CostCenters.
     * @example
     * // Create many CostCenters
     * const costCenter = await prisma.costCenter.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CostCenters and only return the `id`
     * const costCenterWithIdOnly = await prisma.costCenter.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CostCenterCreateManyAndReturnArgs>(args?: SelectSubset<T, CostCenterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostCenterPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CostCenter.
     * @param {CostCenterDeleteArgs} args - Arguments to delete one CostCenter.
     * @example
     * // Delete one CostCenter
     * const CostCenter = await prisma.costCenter.delete({
     *   where: {
     *     // ... filter to delete one CostCenter
     *   }
     * })
     * 
     */
    delete<T extends CostCenterDeleteArgs>(args: SelectSubset<T, CostCenterDeleteArgs<ExtArgs>>): Prisma__CostCenterClient<$Result.GetResult<Prisma.$CostCenterPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CostCenter.
     * @param {CostCenterUpdateArgs} args - Arguments to update one CostCenter.
     * @example
     * // Update one CostCenter
     * const costCenter = await prisma.costCenter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CostCenterUpdateArgs>(args: SelectSubset<T, CostCenterUpdateArgs<ExtArgs>>): Prisma__CostCenterClient<$Result.GetResult<Prisma.$CostCenterPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CostCenters.
     * @param {CostCenterDeleteManyArgs} args - Arguments to filter CostCenters to delete.
     * @example
     * // Delete a few CostCenters
     * const { count } = await prisma.costCenter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CostCenterDeleteManyArgs>(args?: SelectSubset<T, CostCenterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CostCenters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostCenterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CostCenters
     * const costCenter = await prisma.costCenter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CostCenterUpdateManyArgs>(args: SelectSubset<T, CostCenterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CostCenter.
     * @param {CostCenterUpsertArgs} args - Arguments to update or create a CostCenter.
     * @example
     * // Update or create a CostCenter
     * const costCenter = await prisma.costCenter.upsert({
     *   create: {
     *     // ... data to create a CostCenter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CostCenter we want to update
     *   }
     * })
     */
    upsert<T extends CostCenterUpsertArgs>(args: SelectSubset<T, CostCenterUpsertArgs<ExtArgs>>): Prisma__CostCenterClient<$Result.GetResult<Prisma.$CostCenterPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CostCenters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostCenterCountArgs} args - Arguments to filter CostCenters to count.
     * @example
     * // Count the number of CostCenters
     * const count = await prisma.costCenter.count({
     *   where: {
     *     // ... the filter for the CostCenters we want to count
     *   }
     * })
    **/
    count<T extends CostCenterCountArgs>(
      args?: Subset<T, CostCenterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CostCenterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CostCenter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostCenterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CostCenterAggregateArgs>(args: Subset<T, CostCenterAggregateArgs>): Prisma.PrismaPromise<GetCostCenterAggregateType<T>>

    /**
     * Group by CostCenter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostCenterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CostCenterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CostCenterGroupByArgs['orderBy'] }
        : { orderBy?: CostCenterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CostCenterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCostCenterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CostCenter model
   */
  readonly fields: CostCenterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CostCenter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CostCenterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CostCenter model
   */ 
  interface CostCenterFieldRefs {
    readonly id: FieldRef<"CostCenter", 'String'>
    readonly name: FieldRef<"CostCenter", 'String'>
    readonly description: FieldRef<"CostCenter", 'String'>
    readonly code: FieldRef<"CostCenter", 'String'>
    readonly overheadRate: FieldRef<"CostCenter", 'Decimal'>
    readonly fixedCosts: FieldRef<"CostCenter", 'Decimal'>
    readonly variableCosts: FieldRef<"CostCenter", 'Decimal'>
    readonly allocationMethod: FieldRef<"CostCenter", 'String'>
    readonly isActive: FieldRef<"CostCenter", 'Boolean'>
    readonly createdAt: FieldRef<"CostCenter", 'DateTime'>
    readonly updatedAt: FieldRef<"CostCenter", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CostCenter findUnique
   */
  export type CostCenterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostCenter
     */
    select?: CostCenterSelect<ExtArgs> | null
    /**
     * Filter, which CostCenter to fetch.
     */
    where: CostCenterWhereUniqueInput
  }

  /**
   * CostCenter findUniqueOrThrow
   */
  export type CostCenterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostCenter
     */
    select?: CostCenterSelect<ExtArgs> | null
    /**
     * Filter, which CostCenter to fetch.
     */
    where: CostCenterWhereUniqueInput
  }

  /**
   * CostCenter findFirst
   */
  export type CostCenterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostCenter
     */
    select?: CostCenterSelect<ExtArgs> | null
    /**
     * Filter, which CostCenter to fetch.
     */
    where?: CostCenterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostCenters to fetch.
     */
    orderBy?: CostCenterOrderByWithRelationInput | CostCenterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CostCenters.
     */
    cursor?: CostCenterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostCenters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostCenters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CostCenters.
     */
    distinct?: CostCenterScalarFieldEnum | CostCenterScalarFieldEnum[]
  }

  /**
   * CostCenter findFirstOrThrow
   */
  export type CostCenterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostCenter
     */
    select?: CostCenterSelect<ExtArgs> | null
    /**
     * Filter, which CostCenter to fetch.
     */
    where?: CostCenterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostCenters to fetch.
     */
    orderBy?: CostCenterOrderByWithRelationInput | CostCenterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CostCenters.
     */
    cursor?: CostCenterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostCenters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostCenters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CostCenters.
     */
    distinct?: CostCenterScalarFieldEnum | CostCenterScalarFieldEnum[]
  }

  /**
   * CostCenter findMany
   */
  export type CostCenterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostCenter
     */
    select?: CostCenterSelect<ExtArgs> | null
    /**
     * Filter, which CostCenters to fetch.
     */
    where?: CostCenterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostCenters to fetch.
     */
    orderBy?: CostCenterOrderByWithRelationInput | CostCenterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CostCenters.
     */
    cursor?: CostCenterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostCenters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostCenters.
     */
    skip?: number
    distinct?: CostCenterScalarFieldEnum | CostCenterScalarFieldEnum[]
  }

  /**
   * CostCenter create
   */
  export type CostCenterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostCenter
     */
    select?: CostCenterSelect<ExtArgs> | null
    /**
     * The data needed to create a CostCenter.
     */
    data: XOR<CostCenterCreateInput, CostCenterUncheckedCreateInput>
  }

  /**
   * CostCenter createMany
   */
  export type CostCenterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CostCenters.
     */
    data: CostCenterCreateManyInput | CostCenterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CostCenter createManyAndReturn
   */
  export type CostCenterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostCenter
     */
    select?: CostCenterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CostCenters.
     */
    data: CostCenterCreateManyInput | CostCenterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CostCenter update
   */
  export type CostCenterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostCenter
     */
    select?: CostCenterSelect<ExtArgs> | null
    /**
     * The data needed to update a CostCenter.
     */
    data: XOR<CostCenterUpdateInput, CostCenterUncheckedUpdateInput>
    /**
     * Choose, which CostCenter to update.
     */
    where: CostCenterWhereUniqueInput
  }

  /**
   * CostCenter updateMany
   */
  export type CostCenterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CostCenters.
     */
    data: XOR<CostCenterUpdateManyMutationInput, CostCenterUncheckedUpdateManyInput>
    /**
     * Filter which CostCenters to update
     */
    where?: CostCenterWhereInput
  }

  /**
   * CostCenter upsert
   */
  export type CostCenterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostCenter
     */
    select?: CostCenterSelect<ExtArgs> | null
    /**
     * The filter to search for the CostCenter to update in case it exists.
     */
    where: CostCenterWhereUniqueInput
    /**
     * In case the CostCenter found by the `where` argument doesn't exist, create a new CostCenter with this data.
     */
    create: XOR<CostCenterCreateInput, CostCenterUncheckedCreateInput>
    /**
     * In case the CostCenter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CostCenterUpdateInput, CostCenterUncheckedUpdateInput>
  }

  /**
   * CostCenter delete
   */
  export type CostCenterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostCenter
     */
    select?: CostCenterSelect<ExtArgs> | null
    /**
     * Filter which CostCenter to delete.
     */
    where: CostCenterWhereUniqueInput
  }

  /**
   * CostCenter deleteMany
   */
  export type CostCenterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CostCenters to delete
     */
    where?: CostCenterWhereInput
  }

  /**
   * CostCenter without action
   */
  export type CostCenterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostCenter
     */
    select?: CostCenterSelect<ExtArgs> | null
  }


  /**
   * Model backhaul_opportunities
   */

  export type AggregateBackhaul_opportunities = {
    _count: Backhaul_opportunitiesCountAggregateOutputType | null
    _avg: Backhaul_opportunitiesAvgAggregateOutputType | null
    _sum: Backhaul_opportunitiesSumAggregateOutputType | null
    _min: Backhaul_opportunitiesMinAggregateOutputType | null
    _max: Backhaul_opportunitiesMaxAggregateOutputType | null
  }

  export type Backhaul_opportunitiesAvgAggregateOutputType = {
    revenueBonus: Decimal | null
    efficiency: Decimal | null
  }

  export type Backhaul_opportunitiesSumAggregateOutputType = {
    revenueBonus: Decimal | null
    efficiency: Decimal | null
  }

  export type Backhaul_opportunitiesMinAggregateOutputType = {
    id: string | null
    tripId1: string | null
    tripId2: string | null
    revenueBonus: Decimal | null
    efficiency: Decimal | null
    createdAt: Date | null
    isActive: boolean | null
  }

  export type Backhaul_opportunitiesMaxAggregateOutputType = {
    id: string | null
    tripId1: string | null
    tripId2: string | null
    revenueBonus: Decimal | null
    efficiency: Decimal | null
    createdAt: Date | null
    isActive: boolean | null
  }

  export type Backhaul_opportunitiesCountAggregateOutputType = {
    id: number
    tripId1: number
    tripId2: number
    revenueBonus: number
    efficiency: number
    createdAt: number
    isActive: number
    _all: number
  }


  export type Backhaul_opportunitiesAvgAggregateInputType = {
    revenueBonus?: true
    efficiency?: true
  }

  export type Backhaul_opportunitiesSumAggregateInputType = {
    revenueBonus?: true
    efficiency?: true
  }

  export type Backhaul_opportunitiesMinAggregateInputType = {
    id?: true
    tripId1?: true
    tripId2?: true
    revenueBonus?: true
    efficiency?: true
    createdAt?: true
    isActive?: true
  }

  export type Backhaul_opportunitiesMaxAggregateInputType = {
    id?: true
    tripId1?: true
    tripId2?: true
    revenueBonus?: true
    efficiency?: true
    createdAt?: true
    isActive?: true
  }

  export type Backhaul_opportunitiesCountAggregateInputType = {
    id?: true
    tripId1?: true
    tripId2?: true
    revenueBonus?: true
    efficiency?: true
    createdAt?: true
    isActive?: true
    _all?: true
  }

  export type Backhaul_opportunitiesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which backhaul_opportunities to aggregate.
     */
    where?: backhaul_opportunitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of backhaul_opportunities to fetch.
     */
    orderBy?: backhaul_opportunitiesOrderByWithRelationInput | backhaul_opportunitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: backhaul_opportunitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` backhaul_opportunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` backhaul_opportunities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned backhaul_opportunities
    **/
    _count?: true | Backhaul_opportunitiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Backhaul_opportunitiesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Backhaul_opportunitiesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Backhaul_opportunitiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Backhaul_opportunitiesMaxAggregateInputType
  }

  export type GetBackhaul_opportunitiesAggregateType<T extends Backhaul_opportunitiesAggregateArgs> = {
        [P in keyof T & keyof AggregateBackhaul_opportunities]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBackhaul_opportunities[P]>
      : GetScalarType<T[P], AggregateBackhaul_opportunities[P]>
  }




  export type backhaul_opportunitiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: backhaul_opportunitiesWhereInput
    orderBy?: backhaul_opportunitiesOrderByWithAggregationInput | backhaul_opportunitiesOrderByWithAggregationInput[]
    by: Backhaul_opportunitiesScalarFieldEnum[] | Backhaul_opportunitiesScalarFieldEnum
    having?: backhaul_opportunitiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Backhaul_opportunitiesCountAggregateInputType | true
    _avg?: Backhaul_opportunitiesAvgAggregateInputType
    _sum?: Backhaul_opportunitiesSumAggregateInputType
    _min?: Backhaul_opportunitiesMinAggregateInputType
    _max?: Backhaul_opportunitiesMaxAggregateInputType
  }

  export type Backhaul_opportunitiesGroupByOutputType = {
    id: string
    tripId1: string
    tripId2: string
    revenueBonus: Decimal | null
    efficiency: Decimal | null
    createdAt: Date
    isActive: boolean
    _count: Backhaul_opportunitiesCountAggregateOutputType | null
    _avg: Backhaul_opportunitiesAvgAggregateOutputType | null
    _sum: Backhaul_opportunitiesSumAggregateOutputType | null
    _min: Backhaul_opportunitiesMinAggregateOutputType | null
    _max: Backhaul_opportunitiesMaxAggregateOutputType | null
  }

  type GetBackhaul_opportunitiesGroupByPayload<T extends backhaul_opportunitiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Backhaul_opportunitiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Backhaul_opportunitiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Backhaul_opportunitiesGroupByOutputType[P]>
            : GetScalarType<T[P], Backhaul_opportunitiesGroupByOutputType[P]>
        }
      >
    >


  export type backhaul_opportunitiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tripId1?: boolean
    tripId2?: boolean
    revenueBonus?: boolean
    efficiency?: boolean
    createdAt?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["backhaul_opportunities"]>

  export type backhaul_opportunitiesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tripId1?: boolean
    tripId2?: boolean
    revenueBonus?: boolean
    efficiency?: boolean
    createdAt?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["backhaul_opportunities"]>

  export type backhaul_opportunitiesSelectScalar = {
    id?: boolean
    tripId1?: boolean
    tripId2?: boolean
    revenueBonus?: boolean
    efficiency?: boolean
    createdAt?: boolean
    isActive?: boolean
  }


  export type $backhaul_opportunitiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "backhaul_opportunities"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tripId1: string
      tripId2: string
      revenueBonus: Prisma.Decimal | null
      efficiency: Prisma.Decimal | null
      createdAt: Date
      isActive: boolean
    }, ExtArgs["result"]["backhaul_opportunities"]>
    composites: {}
  }

  type backhaul_opportunitiesGetPayload<S extends boolean | null | undefined | backhaul_opportunitiesDefaultArgs> = $Result.GetResult<Prisma.$backhaul_opportunitiesPayload, S>

  type backhaul_opportunitiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<backhaul_opportunitiesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Backhaul_opportunitiesCountAggregateInputType | true
    }

  export interface backhaul_opportunitiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['backhaul_opportunities'], meta: { name: 'backhaul_opportunities' } }
    /**
     * Find zero or one Backhaul_opportunities that matches the filter.
     * @param {backhaul_opportunitiesFindUniqueArgs} args - Arguments to find a Backhaul_opportunities
     * @example
     * // Get one Backhaul_opportunities
     * const backhaul_opportunities = await prisma.backhaul_opportunities.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends backhaul_opportunitiesFindUniqueArgs>(args: SelectSubset<T, backhaul_opportunitiesFindUniqueArgs<ExtArgs>>): Prisma__backhaul_opportunitiesClient<$Result.GetResult<Prisma.$backhaul_opportunitiesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Backhaul_opportunities that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {backhaul_opportunitiesFindUniqueOrThrowArgs} args - Arguments to find a Backhaul_opportunities
     * @example
     * // Get one Backhaul_opportunities
     * const backhaul_opportunities = await prisma.backhaul_opportunities.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends backhaul_opportunitiesFindUniqueOrThrowArgs>(args: SelectSubset<T, backhaul_opportunitiesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__backhaul_opportunitiesClient<$Result.GetResult<Prisma.$backhaul_opportunitiesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Backhaul_opportunities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {backhaul_opportunitiesFindFirstArgs} args - Arguments to find a Backhaul_opportunities
     * @example
     * // Get one Backhaul_opportunities
     * const backhaul_opportunities = await prisma.backhaul_opportunities.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends backhaul_opportunitiesFindFirstArgs>(args?: SelectSubset<T, backhaul_opportunitiesFindFirstArgs<ExtArgs>>): Prisma__backhaul_opportunitiesClient<$Result.GetResult<Prisma.$backhaul_opportunitiesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Backhaul_opportunities that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {backhaul_opportunitiesFindFirstOrThrowArgs} args - Arguments to find a Backhaul_opportunities
     * @example
     * // Get one Backhaul_opportunities
     * const backhaul_opportunities = await prisma.backhaul_opportunities.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends backhaul_opportunitiesFindFirstOrThrowArgs>(args?: SelectSubset<T, backhaul_opportunitiesFindFirstOrThrowArgs<ExtArgs>>): Prisma__backhaul_opportunitiesClient<$Result.GetResult<Prisma.$backhaul_opportunitiesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Backhaul_opportunities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {backhaul_opportunitiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Backhaul_opportunities
     * const backhaul_opportunities = await prisma.backhaul_opportunities.findMany()
     * 
     * // Get first 10 Backhaul_opportunities
     * const backhaul_opportunities = await prisma.backhaul_opportunities.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const backhaul_opportunitiesWithIdOnly = await prisma.backhaul_opportunities.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends backhaul_opportunitiesFindManyArgs>(args?: SelectSubset<T, backhaul_opportunitiesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$backhaul_opportunitiesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Backhaul_opportunities.
     * @param {backhaul_opportunitiesCreateArgs} args - Arguments to create a Backhaul_opportunities.
     * @example
     * // Create one Backhaul_opportunities
     * const Backhaul_opportunities = await prisma.backhaul_opportunities.create({
     *   data: {
     *     // ... data to create a Backhaul_opportunities
     *   }
     * })
     * 
     */
    create<T extends backhaul_opportunitiesCreateArgs>(args: SelectSubset<T, backhaul_opportunitiesCreateArgs<ExtArgs>>): Prisma__backhaul_opportunitiesClient<$Result.GetResult<Prisma.$backhaul_opportunitiesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Backhaul_opportunities.
     * @param {backhaul_opportunitiesCreateManyArgs} args - Arguments to create many Backhaul_opportunities.
     * @example
     * // Create many Backhaul_opportunities
     * const backhaul_opportunities = await prisma.backhaul_opportunities.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends backhaul_opportunitiesCreateManyArgs>(args?: SelectSubset<T, backhaul_opportunitiesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Backhaul_opportunities and returns the data saved in the database.
     * @param {backhaul_opportunitiesCreateManyAndReturnArgs} args - Arguments to create many Backhaul_opportunities.
     * @example
     * // Create many Backhaul_opportunities
     * const backhaul_opportunities = await prisma.backhaul_opportunities.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Backhaul_opportunities and only return the `id`
     * const backhaul_opportunitiesWithIdOnly = await prisma.backhaul_opportunities.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends backhaul_opportunitiesCreateManyAndReturnArgs>(args?: SelectSubset<T, backhaul_opportunitiesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$backhaul_opportunitiesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Backhaul_opportunities.
     * @param {backhaul_opportunitiesDeleteArgs} args - Arguments to delete one Backhaul_opportunities.
     * @example
     * // Delete one Backhaul_opportunities
     * const Backhaul_opportunities = await prisma.backhaul_opportunities.delete({
     *   where: {
     *     // ... filter to delete one Backhaul_opportunities
     *   }
     * })
     * 
     */
    delete<T extends backhaul_opportunitiesDeleteArgs>(args: SelectSubset<T, backhaul_opportunitiesDeleteArgs<ExtArgs>>): Prisma__backhaul_opportunitiesClient<$Result.GetResult<Prisma.$backhaul_opportunitiesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Backhaul_opportunities.
     * @param {backhaul_opportunitiesUpdateArgs} args - Arguments to update one Backhaul_opportunities.
     * @example
     * // Update one Backhaul_opportunities
     * const backhaul_opportunities = await prisma.backhaul_opportunities.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends backhaul_opportunitiesUpdateArgs>(args: SelectSubset<T, backhaul_opportunitiesUpdateArgs<ExtArgs>>): Prisma__backhaul_opportunitiesClient<$Result.GetResult<Prisma.$backhaul_opportunitiesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Backhaul_opportunities.
     * @param {backhaul_opportunitiesDeleteManyArgs} args - Arguments to filter Backhaul_opportunities to delete.
     * @example
     * // Delete a few Backhaul_opportunities
     * const { count } = await prisma.backhaul_opportunities.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends backhaul_opportunitiesDeleteManyArgs>(args?: SelectSubset<T, backhaul_opportunitiesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Backhaul_opportunities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {backhaul_opportunitiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Backhaul_opportunities
     * const backhaul_opportunities = await prisma.backhaul_opportunities.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends backhaul_opportunitiesUpdateManyArgs>(args: SelectSubset<T, backhaul_opportunitiesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Backhaul_opportunities.
     * @param {backhaul_opportunitiesUpsertArgs} args - Arguments to update or create a Backhaul_opportunities.
     * @example
     * // Update or create a Backhaul_opportunities
     * const backhaul_opportunities = await prisma.backhaul_opportunities.upsert({
     *   create: {
     *     // ... data to create a Backhaul_opportunities
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Backhaul_opportunities we want to update
     *   }
     * })
     */
    upsert<T extends backhaul_opportunitiesUpsertArgs>(args: SelectSubset<T, backhaul_opportunitiesUpsertArgs<ExtArgs>>): Prisma__backhaul_opportunitiesClient<$Result.GetResult<Prisma.$backhaul_opportunitiesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Backhaul_opportunities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {backhaul_opportunitiesCountArgs} args - Arguments to filter Backhaul_opportunities to count.
     * @example
     * // Count the number of Backhaul_opportunities
     * const count = await prisma.backhaul_opportunities.count({
     *   where: {
     *     // ... the filter for the Backhaul_opportunities we want to count
     *   }
     * })
    **/
    count<T extends backhaul_opportunitiesCountArgs>(
      args?: Subset<T, backhaul_opportunitiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Backhaul_opportunitiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Backhaul_opportunities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Backhaul_opportunitiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Backhaul_opportunitiesAggregateArgs>(args: Subset<T, Backhaul_opportunitiesAggregateArgs>): Prisma.PrismaPromise<GetBackhaul_opportunitiesAggregateType<T>>

    /**
     * Group by Backhaul_opportunities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {backhaul_opportunitiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends backhaul_opportunitiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: backhaul_opportunitiesGroupByArgs['orderBy'] }
        : { orderBy?: backhaul_opportunitiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, backhaul_opportunitiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBackhaul_opportunitiesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the backhaul_opportunities model
   */
  readonly fields: backhaul_opportunitiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for backhaul_opportunities.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__backhaul_opportunitiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the backhaul_opportunities model
   */ 
  interface backhaul_opportunitiesFieldRefs {
    readonly id: FieldRef<"backhaul_opportunities", 'String'>
    readonly tripId1: FieldRef<"backhaul_opportunities", 'String'>
    readonly tripId2: FieldRef<"backhaul_opportunities", 'String'>
    readonly revenueBonus: FieldRef<"backhaul_opportunities", 'Decimal'>
    readonly efficiency: FieldRef<"backhaul_opportunities", 'Decimal'>
    readonly createdAt: FieldRef<"backhaul_opportunities", 'DateTime'>
    readonly isActive: FieldRef<"backhaul_opportunities", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * backhaul_opportunities findUnique
   */
  export type backhaul_opportunitiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the backhaul_opportunities
     */
    select?: backhaul_opportunitiesSelect<ExtArgs> | null
    /**
     * Filter, which backhaul_opportunities to fetch.
     */
    where: backhaul_opportunitiesWhereUniqueInput
  }

  /**
   * backhaul_opportunities findUniqueOrThrow
   */
  export type backhaul_opportunitiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the backhaul_opportunities
     */
    select?: backhaul_opportunitiesSelect<ExtArgs> | null
    /**
     * Filter, which backhaul_opportunities to fetch.
     */
    where: backhaul_opportunitiesWhereUniqueInput
  }

  /**
   * backhaul_opportunities findFirst
   */
  export type backhaul_opportunitiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the backhaul_opportunities
     */
    select?: backhaul_opportunitiesSelect<ExtArgs> | null
    /**
     * Filter, which backhaul_opportunities to fetch.
     */
    where?: backhaul_opportunitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of backhaul_opportunities to fetch.
     */
    orderBy?: backhaul_opportunitiesOrderByWithRelationInput | backhaul_opportunitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for backhaul_opportunities.
     */
    cursor?: backhaul_opportunitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` backhaul_opportunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` backhaul_opportunities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of backhaul_opportunities.
     */
    distinct?: Backhaul_opportunitiesScalarFieldEnum | Backhaul_opportunitiesScalarFieldEnum[]
  }

  /**
   * backhaul_opportunities findFirstOrThrow
   */
  export type backhaul_opportunitiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the backhaul_opportunities
     */
    select?: backhaul_opportunitiesSelect<ExtArgs> | null
    /**
     * Filter, which backhaul_opportunities to fetch.
     */
    where?: backhaul_opportunitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of backhaul_opportunities to fetch.
     */
    orderBy?: backhaul_opportunitiesOrderByWithRelationInput | backhaul_opportunitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for backhaul_opportunities.
     */
    cursor?: backhaul_opportunitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` backhaul_opportunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` backhaul_opportunities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of backhaul_opportunities.
     */
    distinct?: Backhaul_opportunitiesScalarFieldEnum | Backhaul_opportunitiesScalarFieldEnum[]
  }

  /**
   * backhaul_opportunities findMany
   */
  export type backhaul_opportunitiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the backhaul_opportunities
     */
    select?: backhaul_opportunitiesSelect<ExtArgs> | null
    /**
     * Filter, which backhaul_opportunities to fetch.
     */
    where?: backhaul_opportunitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of backhaul_opportunities to fetch.
     */
    orderBy?: backhaul_opportunitiesOrderByWithRelationInput | backhaul_opportunitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing backhaul_opportunities.
     */
    cursor?: backhaul_opportunitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` backhaul_opportunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` backhaul_opportunities.
     */
    skip?: number
    distinct?: Backhaul_opportunitiesScalarFieldEnum | Backhaul_opportunitiesScalarFieldEnum[]
  }

  /**
   * backhaul_opportunities create
   */
  export type backhaul_opportunitiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the backhaul_opportunities
     */
    select?: backhaul_opportunitiesSelect<ExtArgs> | null
    /**
     * The data needed to create a backhaul_opportunities.
     */
    data: XOR<backhaul_opportunitiesCreateInput, backhaul_opportunitiesUncheckedCreateInput>
  }

  /**
   * backhaul_opportunities createMany
   */
  export type backhaul_opportunitiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many backhaul_opportunities.
     */
    data: backhaul_opportunitiesCreateManyInput | backhaul_opportunitiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * backhaul_opportunities createManyAndReturn
   */
  export type backhaul_opportunitiesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the backhaul_opportunities
     */
    select?: backhaul_opportunitiesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many backhaul_opportunities.
     */
    data: backhaul_opportunitiesCreateManyInput | backhaul_opportunitiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * backhaul_opportunities update
   */
  export type backhaul_opportunitiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the backhaul_opportunities
     */
    select?: backhaul_opportunitiesSelect<ExtArgs> | null
    /**
     * The data needed to update a backhaul_opportunities.
     */
    data: XOR<backhaul_opportunitiesUpdateInput, backhaul_opportunitiesUncheckedUpdateInput>
    /**
     * Choose, which backhaul_opportunities to update.
     */
    where: backhaul_opportunitiesWhereUniqueInput
  }

  /**
   * backhaul_opportunities updateMany
   */
  export type backhaul_opportunitiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update backhaul_opportunities.
     */
    data: XOR<backhaul_opportunitiesUpdateManyMutationInput, backhaul_opportunitiesUncheckedUpdateManyInput>
    /**
     * Filter which backhaul_opportunities to update
     */
    where?: backhaul_opportunitiesWhereInput
  }

  /**
   * backhaul_opportunities upsert
   */
  export type backhaul_opportunitiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the backhaul_opportunities
     */
    select?: backhaul_opportunitiesSelect<ExtArgs> | null
    /**
     * The filter to search for the backhaul_opportunities to update in case it exists.
     */
    where: backhaul_opportunitiesWhereUniqueInput
    /**
     * In case the backhaul_opportunities found by the `where` argument doesn't exist, create a new backhaul_opportunities with this data.
     */
    create: XOR<backhaul_opportunitiesCreateInput, backhaul_opportunitiesUncheckedCreateInput>
    /**
     * In case the backhaul_opportunities was found with the provided `where` argument, update it with this data.
     */
    update: XOR<backhaul_opportunitiesUpdateInput, backhaul_opportunitiesUncheckedUpdateInput>
  }

  /**
   * backhaul_opportunities delete
   */
  export type backhaul_opportunitiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the backhaul_opportunities
     */
    select?: backhaul_opportunitiesSelect<ExtArgs> | null
    /**
     * Filter which backhaul_opportunities to delete.
     */
    where: backhaul_opportunitiesWhereUniqueInput
  }

  /**
   * backhaul_opportunities deleteMany
   */
  export type backhaul_opportunitiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which backhaul_opportunities to delete
     */
    where?: backhaul_opportunitiesWhereInput
  }

  /**
   * backhaul_opportunities without action
   */
  export type backhaul_opportunitiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the backhaul_opportunities
     */
    select?: backhaul_opportunitiesSelect<ExtArgs> | null
  }


  /**
   * Model pickup_locations
   */

  export type AggregatePickup_locations = {
    _count: Pickup_locationsCountAggregateOutputType | null
    _min: Pickup_locationsMinAggregateOutputType | null
    _max: Pickup_locationsMaxAggregateOutputType | null
  }

  export type Pickup_locationsMinAggregateOutputType = {
    id: string | null
    hospitalId: string | null
    name: string | null
    description: string | null
    contactPhone: string | null
    contactEmail: string | null
    floor: string | null
    room: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Pickup_locationsMaxAggregateOutputType = {
    id: string | null
    hospitalId: string | null
    name: string | null
    description: string | null
    contactPhone: string | null
    contactEmail: string | null
    floor: string | null
    room: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Pickup_locationsCountAggregateOutputType = {
    id: number
    hospitalId: number
    name: number
    description: number
    contactPhone: number
    contactEmail: number
    floor: number
    room: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Pickup_locationsMinAggregateInputType = {
    id?: true
    hospitalId?: true
    name?: true
    description?: true
    contactPhone?: true
    contactEmail?: true
    floor?: true
    room?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Pickup_locationsMaxAggregateInputType = {
    id?: true
    hospitalId?: true
    name?: true
    description?: true
    contactPhone?: true
    contactEmail?: true
    floor?: true
    room?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Pickup_locationsCountAggregateInputType = {
    id?: true
    hospitalId?: true
    name?: true
    description?: true
    contactPhone?: true
    contactEmail?: true
    floor?: true
    room?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Pickup_locationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pickup_locations to aggregate.
     */
    where?: pickup_locationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pickup_locations to fetch.
     */
    orderBy?: pickup_locationsOrderByWithRelationInput | pickup_locationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: pickup_locationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pickup_locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pickup_locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pickup_locations
    **/
    _count?: true | Pickup_locationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Pickup_locationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Pickup_locationsMaxAggregateInputType
  }

  export type GetPickup_locationsAggregateType<T extends Pickup_locationsAggregateArgs> = {
        [P in keyof T & keyof AggregatePickup_locations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePickup_locations[P]>
      : GetScalarType<T[P], AggregatePickup_locations[P]>
  }




  export type pickup_locationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pickup_locationsWhereInput
    orderBy?: pickup_locationsOrderByWithAggregationInput | pickup_locationsOrderByWithAggregationInput[]
    by: Pickup_locationsScalarFieldEnum[] | Pickup_locationsScalarFieldEnum
    having?: pickup_locationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Pickup_locationsCountAggregateInputType | true
    _min?: Pickup_locationsMinAggregateInputType
    _max?: Pickup_locationsMaxAggregateInputType
  }

  export type Pickup_locationsGroupByOutputType = {
    id: string
    hospitalId: string
    name: string
    description: string | null
    contactPhone: string | null
    contactEmail: string | null
    floor: string | null
    room: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: Pickup_locationsCountAggregateOutputType | null
    _min: Pickup_locationsMinAggregateOutputType | null
    _max: Pickup_locationsMaxAggregateOutputType | null
  }

  type GetPickup_locationsGroupByPayload<T extends pickup_locationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Pickup_locationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Pickup_locationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Pickup_locationsGroupByOutputType[P]>
            : GetScalarType<T[P], Pickup_locationsGroupByOutputType[P]>
        }
      >
    >


  export type pickup_locationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hospitalId?: boolean
    name?: boolean
    description?: boolean
    contactPhone?: boolean
    contactEmail?: boolean
    floor?: boolean
    room?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    trips?: boolean | pickup_locations$tripsArgs<ExtArgs>
    legacyTrips?: boolean | pickup_locations$legacyTripsArgs<ExtArgs>
    _count?: boolean | Pickup_locationsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pickup_locations"]>

  export type pickup_locationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hospitalId?: boolean
    name?: boolean
    description?: boolean
    contactPhone?: boolean
    contactEmail?: boolean
    floor?: boolean
    room?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["pickup_locations"]>

  export type pickup_locationsSelectScalar = {
    id?: boolean
    hospitalId?: boolean
    name?: boolean
    description?: boolean
    contactPhone?: boolean
    contactEmail?: boolean
    floor?: boolean
    room?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type pickup_locationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trips?: boolean | pickup_locations$tripsArgs<ExtArgs>
    legacyTrips?: boolean | pickup_locations$legacyTripsArgs<ExtArgs>
    _count?: boolean | Pickup_locationsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type pickup_locationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $pickup_locationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "pickup_locations"
    objects: {
      trips: Prisma.$TransportRequestPayload<ExtArgs>[]
      legacyTrips: Prisma.$TripPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      hospitalId: string
      name: string
      description: string | null
      contactPhone: string | null
      contactEmail: string | null
      floor: string | null
      room: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pickup_locations"]>
    composites: {}
  }

  type pickup_locationsGetPayload<S extends boolean | null | undefined | pickup_locationsDefaultArgs> = $Result.GetResult<Prisma.$pickup_locationsPayload, S>

  type pickup_locationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<pickup_locationsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Pickup_locationsCountAggregateInputType | true
    }

  export interface pickup_locationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['pickup_locations'], meta: { name: 'pickup_locations' } }
    /**
     * Find zero or one Pickup_locations that matches the filter.
     * @param {pickup_locationsFindUniqueArgs} args - Arguments to find a Pickup_locations
     * @example
     * // Get one Pickup_locations
     * const pickup_locations = await prisma.pickup_locations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends pickup_locationsFindUniqueArgs>(args: SelectSubset<T, pickup_locationsFindUniqueArgs<ExtArgs>>): Prisma__pickup_locationsClient<$Result.GetResult<Prisma.$pickup_locationsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Pickup_locations that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {pickup_locationsFindUniqueOrThrowArgs} args - Arguments to find a Pickup_locations
     * @example
     * // Get one Pickup_locations
     * const pickup_locations = await prisma.pickup_locations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends pickup_locationsFindUniqueOrThrowArgs>(args: SelectSubset<T, pickup_locationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__pickup_locationsClient<$Result.GetResult<Prisma.$pickup_locationsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Pickup_locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pickup_locationsFindFirstArgs} args - Arguments to find a Pickup_locations
     * @example
     * // Get one Pickup_locations
     * const pickup_locations = await prisma.pickup_locations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends pickup_locationsFindFirstArgs>(args?: SelectSubset<T, pickup_locationsFindFirstArgs<ExtArgs>>): Prisma__pickup_locationsClient<$Result.GetResult<Prisma.$pickup_locationsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Pickup_locations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pickup_locationsFindFirstOrThrowArgs} args - Arguments to find a Pickup_locations
     * @example
     * // Get one Pickup_locations
     * const pickup_locations = await prisma.pickup_locations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends pickup_locationsFindFirstOrThrowArgs>(args?: SelectSubset<T, pickup_locationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__pickup_locationsClient<$Result.GetResult<Prisma.$pickup_locationsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Pickup_locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pickup_locationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pickup_locations
     * const pickup_locations = await prisma.pickup_locations.findMany()
     * 
     * // Get first 10 Pickup_locations
     * const pickup_locations = await prisma.pickup_locations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pickup_locationsWithIdOnly = await prisma.pickup_locations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends pickup_locationsFindManyArgs>(args?: SelectSubset<T, pickup_locationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pickup_locationsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Pickup_locations.
     * @param {pickup_locationsCreateArgs} args - Arguments to create a Pickup_locations.
     * @example
     * // Create one Pickup_locations
     * const Pickup_locations = await prisma.pickup_locations.create({
     *   data: {
     *     // ... data to create a Pickup_locations
     *   }
     * })
     * 
     */
    create<T extends pickup_locationsCreateArgs>(args: SelectSubset<T, pickup_locationsCreateArgs<ExtArgs>>): Prisma__pickup_locationsClient<$Result.GetResult<Prisma.$pickup_locationsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Pickup_locations.
     * @param {pickup_locationsCreateManyArgs} args - Arguments to create many Pickup_locations.
     * @example
     * // Create many Pickup_locations
     * const pickup_locations = await prisma.pickup_locations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends pickup_locationsCreateManyArgs>(args?: SelectSubset<T, pickup_locationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pickup_locations and returns the data saved in the database.
     * @param {pickup_locationsCreateManyAndReturnArgs} args - Arguments to create many Pickup_locations.
     * @example
     * // Create many Pickup_locations
     * const pickup_locations = await prisma.pickup_locations.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pickup_locations and only return the `id`
     * const pickup_locationsWithIdOnly = await prisma.pickup_locations.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends pickup_locationsCreateManyAndReturnArgs>(args?: SelectSubset<T, pickup_locationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pickup_locationsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Pickup_locations.
     * @param {pickup_locationsDeleteArgs} args - Arguments to delete one Pickup_locations.
     * @example
     * // Delete one Pickup_locations
     * const Pickup_locations = await prisma.pickup_locations.delete({
     *   where: {
     *     // ... filter to delete one Pickup_locations
     *   }
     * })
     * 
     */
    delete<T extends pickup_locationsDeleteArgs>(args: SelectSubset<T, pickup_locationsDeleteArgs<ExtArgs>>): Prisma__pickup_locationsClient<$Result.GetResult<Prisma.$pickup_locationsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Pickup_locations.
     * @param {pickup_locationsUpdateArgs} args - Arguments to update one Pickup_locations.
     * @example
     * // Update one Pickup_locations
     * const pickup_locations = await prisma.pickup_locations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends pickup_locationsUpdateArgs>(args: SelectSubset<T, pickup_locationsUpdateArgs<ExtArgs>>): Prisma__pickup_locationsClient<$Result.GetResult<Prisma.$pickup_locationsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Pickup_locations.
     * @param {pickup_locationsDeleteManyArgs} args - Arguments to filter Pickup_locations to delete.
     * @example
     * // Delete a few Pickup_locations
     * const { count } = await prisma.pickup_locations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends pickup_locationsDeleteManyArgs>(args?: SelectSubset<T, pickup_locationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pickup_locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pickup_locationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pickup_locations
     * const pickup_locations = await prisma.pickup_locations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends pickup_locationsUpdateManyArgs>(args: SelectSubset<T, pickup_locationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pickup_locations.
     * @param {pickup_locationsUpsertArgs} args - Arguments to update or create a Pickup_locations.
     * @example
     * // Update or create a Pickup_locations
     * const pickup_locations = await prisma.pickup_locations.upsert({
     *   create: {
     *     // ... data to create a Pickup_locations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pickup_locations we want to update
     *   }
     * })
     */
    upsert<T extends pickup_locationsUpsertArgs>(args: SelectSubset<T, pickup_locationsUpsertArgs<ExtArgs>>): Prisma__pickup_locationsClient<$Result.GetResult<Prisma.$pickup_locationsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Pickup_locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pickup_locationsCountArgs} args - Arguments to filter Pickup_locations to count.
     * @example
     * // Count the number of Pickup_locations
     * const count = await prisma.pickup_locations.count({
     *   where: {
     *     // ... the filter for the Pickup_locations we want to count
     *   }
     * })
    **/
    count<T extends pickup_locationsCountArgs>(
      args?: Subset<T, pickup_locationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Pickup_locationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pickup_locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Pickup_locationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Pickup_locationsAggregateArgs>(args: Subset<T, Pickup_locationsAggregateArgs>): Prisma.PrismaPromise<GetPickup_locationsAggregateType<T>>

    /**
     * Group by Pickup_locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pickup_locationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends pickup_locationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: pickup_locationsGroupByArgs['orderBy'] }
        : { orderBy?: pickup_locationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, pickup_locationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPickup_locationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the pickup_locations model
   */
  readonly fields: pickup_locationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for pickup_locations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__pickup_locationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    trips<T extends pickup_locations$tripsArgs<ExtArgs> = {}>(args?: Subset<T, pickup_locations$tripsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransportRequestPayload<ExtArgs>, T, "findMany"> | Null>
    legacyTrips<T extends pickup_locations$legacyTripsArgs<ExtArgs> = {}>(args?: Subset<T, pickup_locations$legacyTripsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the pickup_locations model
   */ 
  interface pickup_locationsFieldRefs {
    readonly id: FieldRef<"pickup_locations", 'String'>
    readonly hospitalId: FieldRef<"pickup_locations", 'String'>
    readonly name: FieldRef<"pickup_locations", 'String'>
    readonly description: FieldRef<"pickup_locations", 'String'>
    readonly contactPhone: FieldRef<"pickup_locations", 'String'>
    readonly contactEmail: FieldRef<"pickup_locations", 'String'>
    readonly floor: FieldRef<"pickup_locations", 'String'>
    readonly room: FieldRef<"pickup_locations", 'String'>
    readonly isActive: FieldRef<"pickup_locations", 'Boolean'>
    readonly createdAt: FieldRef<"pickup_locations", 'DateTime'>
    readonly updatedAt: FieldRef<"pickup_locations", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * pickup_locations findUnique
   */
  export type pickup_locationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pickup_locations
     */
    select?: pickup_locationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pickup_locationsInclude<ExtArgs> | null
    /**
     * Filter, which pickup_locations to fetch.
     */
    where: pickup_locationsWhereUniqueInput
  }

  /**
   * pickup_locations findUniqueOrThrow
   */
  export type pickup_locationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pickup_locations
     */
    select?: pickup_locationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pickup_locationsInclude<ExtArgs> | null
    /**
     * Filter, which pickup_locations to fetch.
     */
    where: pickup_locationsWhereUniqueInput
  }

  /**
   * pickup_locations findFirst
   */
  export type pickup_locationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pickup_locations
     */
    select?: pickup_locationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pickup_locationsInclude<ExtArgs> | null
    /**
     * Filter, which pickup_locations to fetch.
     */
    where?: pickup_locationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pickup_locations to fetch.
     */
    orderBy?: pickup_locationsOrderByWithRelationInput | pickup_locationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pickup_locations.
     */
    cursor?: pickup_locationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pickup_locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pickup_locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pickup_locations.
     */
    distinct?: Pickup_locationsScalarFieldEnum | Pickup_locationsScalarFieldEnum[]
  }

  /**
   * pickup_locations findFirstOrThrow
   */
  export type pickup_locationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pickup_locations
     */
    select?: pickup_locationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pickup_locationsInclude<ExtArgs> | null
    /**
     * Filter, which pickup_locations to fetch.
     */
    where?: pickup_locationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pickup_locations to fetch.
     */
    orderBy?: pickup_locationsOrderByWithRelationInput | pickup_locationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pickup_locations.
     */
    cursor?: pickup_locationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pickup_locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pickup_locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pickup_locations.
     */
    distinct?: Pickup_locationsScalarFieldEnum | Pickup_locationsScalarFieldEnum[]
  }

  /**
   * pickup_locations findMany
   */
  export type pickup_locationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pickup_locations
     */
    select?: pickup_locationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pickup_locationsInclude<ExtArgs> | null
    /**
     * Filter, which pickup_locations to fetch.
     */
    where?: pickup_locationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pickup_locations to fetch.
     */
    orderBy?: pickup_locationsOrderByWithRelationInput | pickup_locationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pickup_locations.
     */
    cursor?: pickup_locationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pickup_locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pickup_locations.
     */
    skip?: number
    distinct?: Pickup_locationsScalarFieldEnum | Pickup_locationsScalarFieldEnum[]
  }

  /**
   * pickup_locations create
   */
  export type pickup_locationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pickup_locations
     */
    select?: pickup_locationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pickup_locationsInclude<ExtArgs> | null
    /**
     * The data needed to create a pickup_locations.
     */
    data: XOR<pickup_locationsCreateInput, pickup_locationsUncheckedCreateInput>
  }

  /**
   * pickup_locations createMany
   */
  export type pickup_locationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many pickup_locations.
     */
    data: pickup_locationsCreateManyInput | pickup_locationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pickup_locations createManyAndReturn
   */
  export type pickup_locationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pickup_locations
     */
    select?: pickup_locationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many pickup_locations.
     */
    data: pickup_locationsCreateManyInput | pickup_locationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pickup_locations update
   */
  export type pickup_locationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pickup_locations
     */
    select?: pickup_locationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pickup_locationsInclude<ExtArgs> | null
    /**
     * The data needed to update a pickup_locations.
     */
    data: XOR<pickup_locationsUpdateInput, pickup_locationsUncheckedUpdateInput>
    /**
     * Choose, which pickup_locations to update.
     */
    where: pickup_locationsWhereUniqueInput
  }

  /**
   * pickup_locations updateMany
   */
  export type pickup_locationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update pickup_locations.
     */
    data: XOR<pickup_locationsUpdateManyMutationInput, pickup_locationsUncheckedUpdateManyInput>
    /**
     * Filter which pickup_locations to update
     */
    where?: pickup_locationsWhereInput
  }

  /**
   * pickup_locations upsert
   */
  export type pickup_locationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pickup_locations
     */
    select?: pickup_locationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pickup_locationsInclude<ExtArgs> | null
    /**
     * The filter to search for the pickup_locations to update in case it exists.
     */
    where: pickup_locationsWhereUniqueInput
    /**
     * In case the pickup_locations found by the `where` argument doesn't exist, create a new pickup_locations with this data.
     */
    create: XOR<pickup_locationsCreateInput, pickup_locationsUncheckedCreateInput>
    /**
     * In case the pickup_locations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pickup_locationsUpdateInput, pickup_locationsUncheckedUpdateInput>
  }

  /**
   * pickup_locations delete
   */
  export type pickup_locationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pickup_locations
     */
    select?: pickup_locationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pickup_locationsInclude<ExtArgs> | null
    /**
     * Filter which pickup_locations to delete.
     */
    where: pickup_locationsWhereUniqueInput
  }

  /**
   * pickup_locations deleteMany
   */
  export type pickup_locationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pickup_locations to delete
     */
    where?: pickup_locationsWhereInput
  }

  /**
   * pickup_locations.trips
   */
  export type pickup_locations$tripsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransportRequest
     */
    select?: TransportRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportRequestInclude<ExtArgs> | null
    where?: TransportRequestWhereInput
    orderBy?: TransportRequestOrderByWithRelationInput | TransportRequestOrderByWithRelationInput[]
    cursor?: TransportRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransportRequestScalarFieldEnum | TransportRequestScalarFieldEnum[]
  }

  /**
   * pickup_locations.legacyTrips
   */
  export type pickup_locations$legacyTripsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    where?: TripWhereInput
    orderBy?: TripOrderByWithRelationInput | TripOrderByWithRelationInput[]
    cursor?: TripWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TripScalarFieldEnum | TripScalarFieldEnum[]
  }

  /**
   * pickup_locations without action
   */
  export type pickup_locationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pickup_locations
     */
    select?: pickup_locationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pickup_locationsInclude<ExtArgs> | null
  }


  /**
   * Model pricing_models
   */

  export type AggregatePricing_models = {
    _count: Pricing_modelsCountAggregateOutputType | null
    _avg: Pricing_modelsAvgAggregateOutputType | null
    _sum: Pricing_modelsSumAggregateOutputType | null
    _min: Pricing_modelsMinAggregateOutputType | null
    _max: Pricing_modelsMaxAggregateOutputType | null
  }

  export type Pricing_modelsAvgAggregateOutputType = {
    isolationPricing: Decimal | null
    bariatricPricing: Decimal | null
    oxygenPricing: Decimal | null
    monitoringPricing: Decimal | null
  }

  export type Pricing_modelsSumAggregateOutputType = {
    isolationPricing: Decimal | null
    bariatricPricing: Decimal | null
    oxygenPricing: Decimal | null
    monitoringPricing: Decimal | null
  }

  export type Pricing_modelsMinAggregateOutputType = {
    id: string | null
    agencyId: string | null
    name: string | null
    isActive: boolean | null
    isolationPricing: Decimal | null
    bariatricPricing: Decimal | null
    oxygenPricing: Decimal | null
    monitoringPricing: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Pricing_modelsMaxAggregateOutputType = {
    id: string | null
    agencyId: string | null
    name: string | null
    isActive: boolean | null
    isolationPricing: Decimal | null
    bariatricPricing: Decimal | null
    oxygenPricing: Decimal | null
    monitoringPricing: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Pricing_modelsCountAggregateOutputType = {
    id: number
    agencyId: number
    name: number
    isActive: number
    baseRates: number
    perMileRates: number
    priorityMultipliers: number
    peakHourMultipliers: number
    weekendMultipliers: number
    seasonalMultipliers: number
    zoneMultipliers: number
    distanceTiers: number
    specialRequirements: number
    isolationPricing: number
    bariatricPricing: number
    oxygenPricing: number
    monitoringPricing: number
    insuranceRates: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Pricing_modelsAvgAggregateInputType = {
    isolationPricing?: true
    bariatricPricing?: true
    oxygenPricing?: true
    monitoringPricing?: true
  }

  export type Pricing_modelsSumAggregateInputType = {
    isolationPricing?: true
    bariatricPricing?: true
    oxygenPricing?: true
    monitoringPricing?: true
  }

  export type Pricing_modelsMinAggregateInputType = {
    id?: true
    agencyId?: true
    name?: true
    isActive?: true
    isolationPricing?: true
    bariatricPricing?: true
    oxygenPricing?: true
    monitoringPricing?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Pricing_modelsMaxAggregateInputType = {
    id?: true
    agencyId?: true
    name?: true
    isActive?: true
    isolationPricing?: true
    bariatricPricing?: true
    oxygenPricing?: true
    monitoringPricing?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Pricing_modelsCountAggregateInputType = {
    id?: true
    agencyId?: true
    name?: true
    isActive?: true
    baseRates?: true
    perMileRates?: true
    priorityMultipliers?: true
    peakHourMultipliers?: true
    weekendMultipliers?: true
    seasonalMultipliers?: true
    zoneMultipliers?: true
    distanceTiers?: true
    specialRequirements?: true
    isolationPricing?: true
    bariatricPricing?: true
    oxygenPricing?: true
    monitoringPricing?: true
    insuranceRates?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Pricing_modelsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pricing_models to aggregate.
     */
    where?: pricing_modelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pricing_models to fetch.
     */
    orderBy?: pricing_modelsOrderByWithRelationInput | pricing_modelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: pricing_modelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pricing_models from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pricing_models.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pricing_models
    **/
    _count?: true | Pricing_modelsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Pricing_modelsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Pricing_modelsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Pricing_modelsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Pricing_modelsMaxAggregateInputType
  }

  export type GetPricing_modelsAggregateType<T extends Pricing_modelsAggregateArgs> = {
        [P in keyof T & keyof AggregatePricing_models]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePricing_models[P]>
      : GetScalarType<T[P], AggregatePricing_models[P]>
  }




  export type pricing_modelsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pricing_modelsWhereInput
    orderBy?: pricing_modelsOrderByWithAggregationInput | pricing_modelsOrderByWithAggregationInput[]
    by: Pricing_modelsScalarFieldEnum[] | Pricing_modelsScalarFieldEnum
    having?: pricing_modelsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Pricing_modelsCountAggregateInputType | true
    _avg?: Pricing_modelsAvgAggregateInputType
    _sum?: Pricing_modelsSumAggregateInputType
    _min?: Pricing_modelsMinAggregateInputType
    _max?: Pricing_modelsMaxAggregateInputType
  }

  export type Pricing_modelsGroupByOutputType = {
    id: string
    agencyId: string | null
    name: string
    isActive: boolean
    baseRates: JsonValue
    perMileRates: JsonValue
    priorityMultipliers: JsonValue
    peakHourMultipliers: JsonValue
    weekendMultipliers: JsonValue
    seasonalMultipliers: JsonValue
    zoneMultipliers: JsonValue
    distanceTiers: JsonValue
    specialRequirements: JsonValue
    isolationPricing: Decimal | null
    bariatricPricing: Decimal | null
    oxygenPricing: Decimal | null
    monitoringPricing: Decimal | null
    insuranceRates: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: Pricing_modelsCountAggregateOutputType | null
    _avg: Pricing_modelsAvgAggregateOutputType | null
    _sum: Pricing_modelsSumAggregateOutputType | null
    _min: Pricing_modelsMinAggregateOutputType | null
    _max: Pricing_modelsMaxAggregateOutputType | null
  }

  type GetPricing_modelsGroupByPayload<T extends pricing_modelsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Pricing_modelsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Pricing_modelsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Pricing_modelsGroupByOutputType[P]>
            : GetScalarType<T[P], Pricing_modelsGroupByOutputType[P]>
        }
      >
    >


  export type pricing_modelsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agencyId?: boolean
    name?: boolean
    isActive?: boolean
    baseRates?: boolean
    perMileRates?: boolean
    priorityMultipliers?: boolean
    peakHourMultipliers?: boolean
    weekendMultipliers?: boolean
    seasonalMultipliers?: boolean
    zoneMultipliers?: boolean
    distanceTiers?: boolean
    specialRequirements?: boolean
    isolationPricing?: boolean
    bariatricPricing?: boolean
    oxygenPricing?: boolean
    monitoringPricing?: boolean
    insuranceRates?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["pricing_models"]>

  export type pricing_modelsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agencyId?: boolean
    name?: boolean
    isActive?: boolean
    baseRates?: boolean
    perMileRates?: boolean
    priorityMultipliers?: boolean
    peakHourMultipliers?: boolean
    weekendMultipliers?: boolean
    seasonalMultipliers?: boolean
    zoneMultipliers?: boolean
    distanceTiers?: boolean
    specialRequirements?: boolean
    isolationPricing?: boolean
    bariatricPricing?: boolean
    oxygenPricing?: boolean
    monitoringPricing?: boolean
    insuranceRates?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["pricing_models"]>

  export type pricing_modelsSelectScalar = {
    id?: boolean
    agencyId?: boolean
    name?: boolean
    isActive?: boolean
    baseRates?: boolean
    perMileRates?: boolean
    priorityMultipliers?: boolean
    peakHourMultipliers?: boolean
    weekendMultipliers?: boolean
    seasonalMultipliers?: boolean
    zoneMultipliers?: boolean
    distanceTiers?: boolean
    specialRequirements?: boolean
    isolationPricing?: boolean
    bariatricPricing?: boolean
    oxygenPricing?: boolean
    monitoringPricing?: boolean
    insuranceRates?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $pricing_modelsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "pricing_models"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      agencyId: string | null
      name: string
      isActive: boolean
      baseRates: Prisma.JsonValue
      perMileRates: Prisma.JsonValue
      priorityMultipliers: Prisma.JsonValue
      peakHourMultipliers: Prisma.JsonValue
      weekendMultipliers: Prisma.JsonValue
      seasonalMultipliers: Prisma.JsonValue
      zoneMultipliers: Prisma.JsonValue
      distanceTiers: Prisma.JsonValue
      specialRequirements: Prisma.JsonValue
      isolationPricing: Prisma.Decimal | null
      bariatricPricing: Prisma.Decimal | null
      oxygenPricing: Prisma.Decimal | null
      monitoringPricing: Prisma.Decimal | null
      insuranceRates: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pricing_models"]>
    composites: {}
  }

  type pricing_modelsGetPayload<S extends boolean | null | undefined | pricing_modelsDefaultArgs> = $Result.GetResult<Prisma.$pricing_modelsPayload, S>

  type pricing_modelsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<pricing_modelsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Pricing_modelsCountAggregateInputType | true
    }

  export interface pricing_modelsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['pricing_models'], meta: { name: 'pricing_models' } }
    /**
     * Find zero or one Pricing_models that matches the filter.
     * @param {pricing_modelsFindUniqueArgs} args - Arguments to find a Pricing_models
     * @example
     * // Get one Pricing_models
     * const pricing_models = await prisma.pricing_models.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends pricing_modelsFindUniqueArgs>(args: SelectSubset<T, pricing_modelsFindUniqueArgs<ExtArgs>>): Prisma__pricing_modelsClient<$Result.GetResult<Prisma.$pricing_modelsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Pricing_models that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {pricing_modelsFindUniqueOrThrowArgs} args - Arguments to find a Pricing_models
     * @example
     * // Get one Pricing_models
     * const pricing_models = await prisma.pricing_models.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends pricing_modelsFindUniqueOrThrowArgs>(args: SelectSubset<T, pricing_modelsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__pricing_modelsClient<$Result.GetResult<Prisma.$pricing_modelsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Pricing_models that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pricing_modelsFindFirstArgs} args - Arguments to find a Pricing_models
     * @example
     * // Get one Pricing_models
     * const pricing_models = await prisma.pricing_models.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends pricing_modelsFindFirstArgs>(args?: SelectSubset<T, pricing_modelsFindFirstArgs<ExtArgs>>): Prisma__pricing_modelsClient<$Result.GetResult<Prisma.$pricing_modelsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Pricing_models that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pricing_modelsFindFirstOrThrowArgs} args - Arguments to find a Pricing_models
     * @example
     * // Get one Pricing_models
     * const pricing_models = await prisma.pricing_models.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends pricing_modelsFindFirstOrThrowArgs>(args?: SelectSubset<T, pricing_modelsFindFirstOrThrowArgs<ExtArgs>>): Prisma__pricing_modelsClient<$Result.GetResult<Prisma.$pricing_modelsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Pricing_models that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pricing_modelsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pricing_models
     * const pricing_models = await prisma.pricing_models.findMany()
     * 
     * // Get first 10 Pricing_models
     * const pricing_models = await prisma.pricing_models.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pricing_modelsWithIdOnly = await prisma.pricing_models.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends pricing_modelsFindManyArgs>(args?: SelectSubset<T, pricing_modelsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pricing_modelsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Pricing_models.
     * @param {pricing_modelsCreateArgs} args - Arguments to create a Pricing_models.
     * @example
     * // Create one Pricing_models
     * const Pricing_models = await prisma.pricing_models.create({
     *   data: {
     *     // ... data to create a Pricing_models
     *   }
     * })
     * 
     */
    create<T extends pricing_modelsCreateArgs>(args: SelectSubset<T, pricing_modelsCreateArgs<ExtArgs>>): Prisma__pricing_modelsClient<$Result.GetResult<Prisma.$pricing_modelsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Pricing_models.
     * @param {pricing_modelsCreateManyArgs} args - Arguments to create many Pricing_models.
     * @example
     * // Create many Pricing_models
     * const pricing_models = await prisma.pricing_models.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends pricing_modelsCreateManyArgs>(args?: SelectSubset<T, pricing_modelsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pricing_models and returns the data saved in the database.
     * @param {pricing_modelsCreateManyAndReturnArgs} args - Arguments to create many Pricing_models.
     * @example
     * // Create many Pricing_models
     * const pricing_models = await prisma.pricing_models.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pricing_models and only return the `id`
     * const pricing_modelsWithIdOnly = await prisma.pricing_models.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends pricing_modelsCreateManyAndReturnArgs>(args?: SelectSubset<T, pricing_modelsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pricing_modelsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Pricing_models.
     * @param {pricing_modelsDeleteArgs} args - Arguments to delete one Pricing_models.
     * @example
     * // Delete one Pricing_models
     * const Pricing_models = await prisma.pricing_models.delete({
     *   where: {
     *     // ... filter to delete one Pricing_models
     *   }
     * })
     * 
     */
    delete<T extends pricing_modelsDeleteArgs>(args: SelectSubset<T, pricing_modelsDeleteArgs<ExtArgs>>): Prisma__pricing_modelsClient<$Result.GetResult<Prisma.$pricing_modelsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Pricing_models.
     * @param {pricing_modelsUpdateArgs} args - Arguments to update one Pricing_models.
     * @example
     * // Update one Pricing_models
     * const pricing_models = await prisma.pricing_models.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends pricing_modelsUpdateArgs>(args: SelectSubset<T, pricing_modelsUpdateArgs<ExtArgs>>): Prisma__pricing_modelsClient<$Result.GetResult<Prisma.$pricing_modelsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Pricing_models.
     * @param {pricing_modelsDeleteManyArgs} args - Arguments to filter Pricing_models to delete.
     * @example
     * // Delete a few Pricing_models
     * const { count } = await prisma.pricing_models.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends pricing_modelsDeleteManyArgs>(args?: SelectSubset<T, pricing_modelsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pricing_models.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pricing_modelsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pricing_models
     * const pricing_models = await prisma.pricing_models.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends pricing_modelsUpdateManyArgs>(args: SelectSubset<T, pricing_modelsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pricing_models.
     * @param {pricing_modelsUpsertArgs} args - Arguments to update or create a Pricing_models.
     * @example
     * // Update or create a Pricing_models
     * const pricing_models = await prisma.pricing_models.upsert({
     *   create: {
     *     // ... data to create a Pricing_models
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pricing_models we want to update
     *   }
     * })
     */
    upsert<T extends pricing_modelsUpsertArgs>(args: SelectSubset<T, pricing_modelsUpsertArgs<ExtArgs>>): Prisma__pricing_modelsClient<$Result.GetResult<Prisma.$pricing_modelsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Pricing_models.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pricing_modelsCountArgs} args - Arguments to filter Pricing_models to count.
     * @example
     * // Count the number of Pricing_models
     * const count = await prisma.pricing_models.count({
     *   where: {
     *     // ... the filter for the Pricing_models we want to count
     *   }
     * })
    **/
    count<T extends pricing_modelsCountArgs>(
      args?: Subset<T, pricing_modelsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Pricing_modelsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pricing_models.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Pricing_modelsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Pricing_modelsAggregateArgs>(args: Subset<T, Pricing_modelsAggregateArgs>): Prisma.PrismaPromise<GetPricing_modelsAggregateType<T>>

    /**
     * Group by Pricing_models.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pricing_modelsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends pricing_modelsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: pricing_modelsGroupByArgs['orderBy'] }
        : { orderBy?: pricing_modelsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, pricing_modelsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPricing_modelsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the pricing_models model
   */
  readonly fields: pricing_modelsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for pricing_models.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__pricing_modelsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the pricing_models model
   */ 
  interface pricing_modelsFieldRefs {
    readonly id: FieldRef<"pricing_models", 'String'>
    readonly agencyId: FieldRef<"pricing_models", 'String'>
    readonly name: FieldRef<"pricing_models", 'String'>
    readonly isActive: FieldRef<"pricing_models", 'Boolean'>
    readonly baseRates: FieldRef<"pricing_models", 'Json'>
    readonly perMileRates: FieldRef<"pricing_models", 'Json'>
    readonly priorityMultipliers: FieldRef<"pricing_models", 'Json'>
    readonly peakHourMultipliers: FieldRef<"pricing_models", 'Json'>
    readonly weekendMultipliers: FieldRef<"pricing_models", 'Json'>
    readonly seasonalMultipliers: FieldRef<"pricing_models", 'Json'>
    readonly zoneMultipliers: FieldRef<"pricing_models", 'Json'>
    readonly distanceTiers: FieldRef<"pricing_models", 'Json'>
    readonly specialRequirements: FieldRef<"pricing_models", 'Json'>
    readonly isolationPricing: FieldRef<"pricing_models", 'Decimal'>
    readonly bariatricPricing: FieldRef<"pricing_models", 'Decimal'>
    readonly oxygenPricing: FieldRef<"pricing_models", 'Decimal'>
    readonly monitoringPricing: FieldRef<"pricing_models", 'Decimal'>
    readonly insuranceRates: FieldRef<"pricing_models", 'Json'>
    readonly createdAt: FieldRef<"pricing_models", 'DateTime'>
    readonly updatedAt: FieldRef<"pricing_models", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * pricing_models findUnique
   */
  export type pricing_modelsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pricing_models
     */
    select?: pricing_modelsSelect<ExtArgs> | null
    /**
     * Filter, which pricing_models to fetch.
     */
    where: pricing_modelsWhereUniqueInput
  }

  /**
   * pricing_models findUniqueOrThrow
   */
  export type pricing_modelsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pricing_models
     */
    select?: pricing_modelsSelect<ExtArgs> | null
    /**
     * Filter, which pricing_models to fetch.
     */
    where: pricing_modelsWhereUniqueInput
  }

  /**
   * pricing_models findFirst
   */
  export type pricing_modelsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pricing_models
     */
    select?: pricing_modelsSelect<ExtArgs> | null
    /**
     * Filter, which pricing_models to fetch.
     */
    where?: pricing_modelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pricing_models to fetch.
     */
    orderBy?: pricing_modelsOrderByWithRelationInput | pricing_modelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pricing_models.
     */
    cursor?: pricing_modelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pricing_models from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pricing_models.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pricing_models.
     */
    distinct?: Pricing_modelsScalarFieldEnum | Pricing_modelsScalarFieldEnum[]
  }

  /**
   * pricing_models findFirstOrThrow
   */
  export type pricing_modelsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pricing_models
     */
    select?: pricing_modelsSelect<ExtArgs> | null
    /**
     * Filter, which pricing_models to fetch.
     */
    where?: pricing_modelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pricing_models to fetch.
     */
    orderBy?: pricing_modelsOrderByWithRelationInput | pricing_modelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pricing_models.
     */
    cursor?: pricing_modelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pricing_models from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pricing_models.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pricing_models.
     */
    distinct?: Pricing_modelsScalarFieldEnum | Pricing_modelsScalarFieldEnum[]
  }

  /**
   * pricing_models findMany
   */
  export type pricing_modelsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pricing_models
     */
    select?: pricing_modelsSelect<ExtArgs> | null
    /**
     * Filter, which pricing_models to fetch.
     */
    where?: pricing_modelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pricing_models to fetch.
     */
    orderBy?: pricing_modelsOrderByWithRelationInput | pricing_modelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pricing_models.
     */
    cursor?: pricing_modelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pricing_models from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pricing_models.
     */
    skip?: number
    distinct?: Pricing_modelsScalarFieldEnum | Pricing_modelsScalarFieldEnum[]
  }

  /**
   * pricing_models create
   */
  export type pricing_modelsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pricing_models
     */
    select?: pricing_modelsSelect<ExtArgs> | null
    /**
     * The data needed to create a pricing_models.
     */
    data: XOR<pricing_modelsCreateInput, pricing_modelsUncheckedCreateInput>
  }

  /**
   * pricing_models createMany
   */
  export type pricing_modelsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many pricing_models.
     */
    data: pricing_modelsCreateManyInput | pricing_modelsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pricing_models createManyAndReturn
   */
  export type pricing_modelsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pricing_models
     */
    select?: pricing_modelsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many pricing_models.
     */
    data: pricing_modelsCreateManyInput | pricing_modelsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pricing_models update
   */
  export type pricing_modelsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pricing_models
     */
    select?: pricing_modelsSelect<ExtArgs> | null
    /**
     * The data needed to update a pricing_models.
     */
    data: XOR<pricing_modelsUpdateInput, pricing_modelsUncheckedUpdateInput>
    /**
     * Choose, which pricing_models to update.
     */
    where: pricing_modelsWhereUniqueInput
  }

  /**
   * pricing_models updateMany
   */
  export type pricing_modelsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update pricing_models.
     */
    data: XOR<pricing_modelsUpdateManyMutationInput, pricing_modelsUncheckedUpdateManyInput>
    /**
     * Filter which pricing_models to update
     */
    where?: pricing_modelsWhereInput
  }

  /**
   * pricing_models upsert
   */
  export type pricing_modelsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pricing_models
     */
    select?: pricing_modelsSelect<ExtArgs> | null
    /**
     * The filter to search for the pricing_models to update in case it exists.
     */
    where: pricing_modelsWhereUniqueInput
    /**
     * In case the pricing_models found by the `where` argument doesn't exist, create a new pricing_models with this data.
     */
    create: XOR<pricing_modelsCreateInput, pricing_modelsUncheckedCreateInput>
    /**
     * In case the pricing_models was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pricing_modelsUpdateInput, pricing_modelsUncheckedUpdateInput>
  }

  /**
   * pricing_models delete
   */
  export type pricing_modelsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pricing_models
     */
    select?: pricing_modelsSelect<ExtArgs> | null
    /**
     * Filter which pricing_models to delete.
     */
    where: pricing_modelsWhereUniqueInput
  }

  /**
   * pricing_models deleteMany
   */
  export type pricing_modelsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pricing_models to delete
     */
    where?: pricing_modelsWhereInput
  }

  /**
   * pricing_models without action
   */
  export type pricing_modelsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pricing_models
     */
    select?: pricing_modelsSelect<ExtArgs> | null
  }


  /**
   * Model route_optimization_settings
   */

  export type AggregateRoute_optimization_settings = {
    _count: Route_optimization_settingsCountAggregateOutputType | null
    _avg: Route_optimization_settingsAvgAggregateOutputType | null
    _sum: Route_optimization_settingsSumAggregateOutputType | null
    _min: Route_optimization_settingsMinAggregateOutputType | null
    _max: Route_optimization_settingsMaxAggregateOutputType | null
  }

  export type Route_optimization_settingsAvgAggregateOutputType = {
    deadheadMileWeight: Decimal | null
    waitTimeWeight: Decimal | null
    backhaulBonusWeight: Decimal | null
    overtimeRiskWeight: Decimal | null
    revenueWeight: Decimal | null
    maxDeadheadMiles: Decimal | null
    maxWaitTimeMinutes: number | null
    maxOvertimeHours: Decimal | null
    maxResponseTimeMinutes: number | null
    maxServiceDistance: Decimal | null
    backhaulTimeWindow: number | null
    backhaulDistanceLimit: Decimal | null
    backhaulRevenueBonus: Decimal | null
    targetLoadedMileRatio: Decimal | null
    targetRevenuePerHour: Decimal | null
    targetResponseTime: number | null
    targetEfficiency: Decimal | null
    maxOptimizationTime: number | null
    crewAvailabilityWeight: Decimal | null
    equipmentCompatibilityWeight: Decimal | null
    patientPriorityWeight: Decimal | null
  }

  export type Route_optimization_settingsSumAggregateOutputType = {
    deadheadMileWeight: Decimal | null
    waitTimeWeight: Decimal | null
    backhaulBonusWeight: Decimal | null
    overtimeRiskWeight: Decimal | null
    revenueWeight: Decimal | null
    maxDeadheadMiles: Decimal | null
    maxWaitTimeMinutes: number | null
    maxOvertimeHours: Decimal | null
    maxResponseTimeMinutes: number | null
    maxServiceDistance: Decimal | null
    backhaulTimeWindow: number | null
    backhaulDistanceLimit: Decimal | null
    backhaulRevenueBonus: Decimal | null
    targetLoadedMileRatio: Decimal | null
    targetRevenuePerHour: Decimal | null
    targetResponseTime: number | null
    targetEfficiency: Decimal | null
    maxOptimizationTime: number | null
    crewAvailabilityWeight: Decimal | null
    equipmentCompatibilityWeight: Decimal | null
    patientPriorityWeight: Decimal | null
  }

  export type Route_optimization_settingsMinAggregateOutputType = {
    id: string | null
    agencyId: string | null
    deadheadMileWeight: Decimal | null
    waitTimeWeight: Decimal | null
    backhaulBonusWeight: Decimal | null
    overtimeRiskWeight: Decimal | null
    revenueWeight: Decimal | null
    maxDeadheadMiles: Decimal | null
    maxWaitTimeMinutes: number | null
    maxOvertimeHours: Decimal | null
    maxResponseTimeMinutes: number | null
    maxServiceDistance: Decimal | null
    backhaulTimeWindow: number | null
    backhaulDistanceLimit: Decimal | null
    backhaulRevenueBonus: Decimal | null
    enableBackhaulOptimization: boolean | null
    targetLoadedMileRatio: Decimal | null
    targetRevenuePerHour: Decimal | null
    targetResponseTime: number | null
    targetEfficiency: Decimal | null
    optimizationAlgorithm: string | null
    maxOptimizationTime: number | null
    enableRealTimeOptimization: boolean | null
    crewAvailabilityWeight: Decimal | null
    equipmentCompatibilityWeight: Decimal | null
    patientPriorityWeight: Decimal | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Route_optimization_settingsMaxAggregateOutputType = {
    id: string | null
    agencyId: string | null
    deadheadMileWeight: Decimal | null
    waitTimeWeight: Decimal | null
    backhaulBonusWeight: Decimal | null
    overtimeRiskWeight: Decimal | null
    revenueWeight: Decimal | null
    maxDeadheadMiles: Decimal | null
    maxWaitTimeMinutes: number | null
    maxOvertimeHours: Decimal | null
    maxResponseTimeMinutes: number | null
    maxServiceDistance: Decimal | null
    backhaulTimeWindow: number | null
    backhaulDistanceLimit: Decimal | null
    backhaulRevenueBonus: Decimal | null
    enableBackhaulOptimization: boolean | null
    targetLoadedMileRatio: Decimal | null
    targetRevenuePerHour: Decimal | null
    targetResponseTime: number | null
    targetEfficiency: Decimal | null
    optimizationAlgorithm: string | null
    maxOptimizationTime: number | null
    enableRealTimeOptimization: boolean | null
    crewAvailabilityWeight: Decimal | null
    equipmentCompatibilityWeight: Decimal | null
    patientPriorityWeight: Decimal | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Route_optimization_settingsCountAggregateOutputType = {
    id: number
    agencyId: number
    deadheadMileWeight: number
    waitTimeWeight: number
    backhaulBonusWeight: number
    overtimeRiskWeight: number
    revenueWeight: number
    maxDeadheadMiles: number
    maxWaitTimeMinutes: number
    maxOvertimeHours: number
    maxResponseTimeMinutes: number
    maxServiceDistance: number
    backhaulTimeWindow: number
    backhaulDistanceLimit: number
    backhaulRevenueBonus: number
    enableBackhaulOptimization: number
    targetLoadedMileRatio: number
    targetRevenuePerHour: number
    targetResponseTime: number
    targetEfficiency: number
    optimizationAlgorithm: number
    maxOptimizationTime: number
    enableRealTimeOptimization: number
    crewAvailabilityWeight: number
    equipmentCompatibilityWeight: number
    patientPriorityWeight: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Route_optimization_settingsAvgAggregateInputType = {
    deadheadMileWeight?: true
    waitTimeWeight?: true
    backhaulBonusWeight?: true
    overtimeRiskWeight?: true
    revenueWeight?: true
    maxDeadheadMiles?: true
    maxWaitTimeMinutes?: true
    maxOvertimeHours?: true
    maxResponseTimeMinutes?: true
    maxServiceDistance?: true
    backhaulTimeWindow?: true
    backhaulDistanceLimit?: true
    backhaulRevenueBonus?: true
    targetLoadedMileRatio?: true
    targetRevenuePerHour?: true
    targetResponseTime?: true
    targetEfficiency?: true
    maxOptimizationTime?: true
    crewAvailabilityWeight?: true
    equipmentCompatibilityWeight?: true
    patientPriorityWeight?: true
  }

  export type Route_optimization_settingsSumAggregateInputType = {
    deadheadMileWeight?: true
    waitTimeWeight?: true
    backhaulBonusWeight?: true
    overtimeRiskWeight?: true
    revenueWeight?: true
    maxDeadheadMiles?: true
    maxWaitTimeMinutes?: true
    maxOvertimeHours?: true
    maxResponseTimeMinutes?: true
    maxServiceDistance?: true
    backhaulTimeWindow?: true
    backhaulDistanceLimit?: true
    backhaulRevenueBonus?: true
    targetLoadedMileRatio?: true
    targetRevenuePerHour?: true
    targetResponseTime?: true
    targetEfficiency?: true
    maxOptimizationTime?: true
    crewAvailabilityWeight?: true
    equipmentCompatibilityWeight?: true
    patientPriorityWeight?: true
  }

  export type Route_optimization_settingsMinAggregateInputType = {
    id?: true
    agencyId?: true
    deadheadMileWeight?: true
    waitTimeWeight?: true
    backhaulBonusWeight?: true
    overtimeRiskWeight?: true
    revenueWeight?: true
    maxDeadheadMiles?: true
    maxWaitTimeMinutes?: true
    maxOvertimeHours?: true
    maxResponseTimeMinutes?: true
    maxServiceDistance?: true
    backhaulTimeWindow?: true
    backhaulDistanceLimit?: true
    backhaulRevenueBonus?: true
    enableBackhaulOptimization?: true
    targetLoadedMileRatio?: true
    targetRevenuePerHour?: true
    targetResponseTime?: true
    targetEfficiency?: true
    optimizationAlgorithm?: true
    maxOptimizationTime?: true
    enableRealTimeOptimization?: true
    crewAvailabilityWeight?: true
    equipmentCompatibilityWeight?: true
    patientPriorityWeight?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Route_optimization_settingsMaxAggregateInputType = {
    id?: true
    agencyId?: true
    deadheadMileWeight?: true
    waitTimeWeight?: true
    backhaulBonusWeight?: true
    overtimeRiskWeight?: true
    revenueWeight?: true
    maxDeadheadMiles?: true
    maxWaitTimeMinutes?: true
    maxOvertimeHours?: true
    maxResponseTimeMinutes?: true
    maxServiceDistance?: true
    backhaulTimeWindow?: true
    backhaulDistanceLimit?: true
    backhaulRevenueBonus?: true
    enableBackhaulOptimization?: true
    targetLoadedMileRatio?: true
    targetRevenuePerHour?: true
    targetResponseTime?: true
    targetEfficiency?: true
    optimizationAlgorithm?: true
    maxOptimizationTime?: true
    enableRealTimeOptimization?: true
    crewAvailabilityWeight?: true
    equipmentCompatibilityWeight?: true
    patientPriorityWeight?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Route_optimization_settingsCountAggregateInputType = {
    id?: true
    agencyId?: true
    deadheadMileWeight?: true
    waitTimeWeight?: true
    backhaulBonusWeight?: true
    overtimeRiskWeight?: true
    revenueWeight?: true
    maxDeadheadMiles?: true
    maxWaitTimeMinutes?: true
    maxOvertimeHours?: true
    maxResponseTimeMinutes?: true
    maxServiceDistance?: true
    backhaulTimeWindow?: true
    backhaulDistanceLimit?: true
    backhaulRevenueBonus?: true
    enableBackhaulOptimization?: true
    targetLoadedMileRatio?: true
    targetRevenuePerHour?: true
    targetResponseTime?: true
    targetEfficiency?: true
    optimizationAlgorithm?: true
    maxOptimizationTime?: true
    enableRealTimeOptimization?: true
    crewAvailabilityWeight?: true
    equipmentCompatibilityWeight?: true
    patientPriorityWeight?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Route_optimization_settingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which route_optimization_settings to aggregate.
     */
    where?: route_optimization_settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of route_optimization_settings to fetch.
     */
    orderBy?: route_optimization_settingsOrderByWithRelationInput | route_optimization_settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: route_optimization_settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` route_optimization_settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` route_optimization_settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned route_optimization_settings
    **/
    _count?: true | Route_optimization_settingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Route_optimization_settingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Route_optimization_settingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Route_optimization_settingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Route_optimization_settingsMaxAggregateInputType
  }

  export type GetRoute_optimization_settingsAggregateType<T extends Route_optimization_settingsAggregateArgs> = {
        [P in keyof T & keyof AggregateRoute_optimization_settings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoute_optimization_settings[P]>
      : GetScalarType<T[P], AggregateRoute_optimization_settings[P]>
  }




  export type route_optimization_settingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: route_optimization_settingsWhereInput
    orderBy?: route_optimization_settingsOrderByWithAggregationInput | route_optimization_settingsOrderByWithAggregationInput[]
    by: Route_optimization_settingsScalarFieldEnum[] | Route_optimization_settingsScalarFieldEnum
    having?: route_optimization_settingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Route_optimization_settingsCountAggregateInputType | true
    _avg?: Route_optimization_settingsAvgAggregateInputType
    _sum?: Route_optimization_settingsSumAggregateInputType
    _min?: Route_optimization_settingsMinAggregateInputType
    _max?: Route_optimization_settingsMaxAggregateInputType
  }

  export type Route_optimization_settingsGroupByOutputType = {
    id: string
    agencyId: string | null
    deadheadMileWeight: Decimal
    waitTimeWeight: Decimal
    backhaulBonusWeight: Decimal
    overtimeRiskWeight: Decimal
    revenueWeight: Decimal
    maxDeadheadMiles: Decimal
    maxWaitTimeMinutes: number
    maxOvertimeHours: Decimal
    maxResponseTimeMinutes: number
    maxServiceDistance: Decimal
    backhaulTimeWindow: number
    backhaulDistanceLimit: Decimal
    backhaulRevenueBonus: Decimal
    enableBackhaulOptimization: boolean
    targetLoadedMileRatio: Decimal
    targetRevenuePerHour: Decimal
    targetResponseTime: number
    targetEfficiency: Decimal
    optimizationAlgorithm: string
    maxOptimizationTime: number
    enableRealTimeOptimization: boolean
    crewAvailabilityWeight: Decimal
    equipmentCompatibilityWeight: Decimal
    patientPriorityWeight: Decimal
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: Route_optimization_settingsCountAggregateOutputType | null
    _avg: Route_optimization_settingsAvgAggregateOutputType | null
    _sum: Route_optimization_settingsSumAggregateOutputType | null
    _min: Route_optimization_settingsMinAggregateOutputType | null
    _max: Route_optimization_settingsMaxAggregateOutputType | null
  }

  type GetRoute_optimization_settingsGroupByPayload<T extends route_optimization_settingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Route_optimization_settingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Route_optimization_settingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Route_optimization_settingsGroupByOutputType[P]>
            : GetScalarType<T[P], Route_optimization_settingsGroupByOutputType[P]>
        }
      >
    >


  export type route_optimization_settingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agencyId?: boolean
    deadheadMileWeight?: boolean
    waitTimeWeight?: boolean
    backhaulBonusWeight?: boolean
    overtimeRiskWeight?: boolean
    revenueWeight?: boolean
    maxDeadheadMiles?: boolean
    maxWaitTimeMinutes?: boolean
    maxOvertimeHours?: boolean
    maxResponseTimeMinutes?: boolean
    maxServiceDistance?: boolean
    backhaulTimeWindow?: boolean
    backhaulDistanceLimit?: boolean
    backhaulRevenueBonus?: boolean
    enableBackhaulOptimization?: boolean
    targetLoadedMileRatio?: boolean
    targetRevenuePerHour?: boolean
    targetResponseTime?: boolean
    targetEfficiency?: boolean
    optimizationAlgorithm?: boolean
    maxOptimizationTime?: boolean
    enableRealTimeOptimization?: boolean
    crewAvailabilityWeight?: boolean
    equipmentCompatibilityWeight?: boolean
    patientPriorityWeight?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["route_optimization_settings"]>

  export type route_optimization_settingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agencyId?: boolean
    deadheadMileWeight?: boolean
    waitTimeWeight?: boolean
    backhaulBonusWeight?: boolean
    overtimeRiskWeight?: boolean
    revenueWeight?: boolean
    maxDeadheadMiles?: boolean
    maxWaitTimeMinutes?: boolean
    maxOvertimeHours?: boolean
    maxResponseTimeMinutes?: boolean
    maxServiceDistance?: boolean
    backhaulTimeWindow?: boolean
    backhaulDistanceLimit?: boolean
    backhaulRevenueBonus?: boolean
    enableBackhaulOptimization?: boolean
    targetLoadedMileRatio?: boolean
    targetRevenuePerHour?: boolean
    targetResponseTime?: boolean
    targetEfficiency?: boolean
    optimizationAlgorithm?: boolean
    maxOptimizationTime?: boolean
    enableRealTimeOptimization?: boolean
    crewAvailabilityWeight?: boolean
    equipmentCompatibilityWeight?: boolean
    patientPriorityWeight?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["route_optimization_settings"]>

  export type route_optimization_settingsSelectScalar = {
    id?: boolean
    agencyId?: boolean
    deadheadMileWeight?: boolean
    waitTimeWeight?: boolean
    backhaulBonusWeight?: boolean
    overtimeRiskWeight?: boolean
    revenueWeight?: boolean
    maxDeadheadMiles?: boolean
    maxWaitTimeMinutes?: boolean
    maxOvertimeHours?: boolean
    maxResponseTimeMinutes?: boolean
    maxServiceDistance?: boolean
    backhaulTimeWindow?: boolean
    backhaulDistanceLimit?: boolean
    backhaulRevenueBonus?: boolean
    enableBackhaulOptimization?: boolean
    targetLoadedMileRatio?: boolean
    targetRevenuePerHour?: boolean
    targetResponseTime?: boolean
    targetEfficiency?: boolean
    optimizationAlgorithm?: boolean
    maxOptimizationTime?: boolean
    enableRealTimeOptimization?: boolean
    crewAvailabilityWeight?: boolean
    equipmentCompatibilityWeight?: boolean
    patientPriorityWeight?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $route_optimization_settingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "route_optimization_settings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      agencyId: string | null
      deadheadMileWeight: Prisma.Decimal
      waitTimeWeight: Prisma.Decimal
      backhaulBonusWeight: Prisma.Decimal
      overtimeRiskWeight: Prisma.Decimal
      revenueWeight: Prisma.Decimal
      maxDeadheadMiles: Prisma.Decimal
      maxWaitTimeMinutes: number
      maxOvertimeHours: Prisma.Decimal
      maxResponseTimeMinutes: number
      maxServiceDistance: Prisma.Decimal
      backhaulTimeWindow: number
      backhaulDistanceLimit: Prisma.Decimal
      backhaulRevenueBonus: Prisma.Decimal
      enableBackhaulOptimization: boolean
      targetLoadedMileRatio: Prisma.Decimal
      targetRevenuePerHour: Prisma.Decimal
      targetResponseTime: number
      targetEfficiency: Prisma.Decimal
      optimizationAlgorithm: string
      maxOptimizationTime: number
      enableRealTimeOptimization: boolean
      crewAvailabilityWeight: Prisma.Decimal
      equipmentCompatibilityWeight: Prisma.Decimal
      patientPriorityWeight: Prisma.Decimal
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["route_optimization_settings"]>
    composites: {}
  }

  type route_optimization_settingsGetPayload<S extends boolean | null | undefined | route_optimization_settingsDefaultArgs> = $Result.GetResult<Prisma.$route_optimization_settingsPayload, S>

  type route_optimization_settingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<route_optimization_settingsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Route_optimization_settingsCountAggregateInputType | true
    }

  export interface route_optimization_settingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['route_optimization_settings'], meta: { name: 'route_optimization_settings' } }
    /**
     * Find zero or one Route_optimization_settings that matches the filter.
     * @param {route_optimization_settingsFindUniqueArgs} args - Arguments to find a Route_optimization_settings
     * @example
     * // Get one Route_optimization_settings
     * const route_optimization_settings = await prisma.route_optimization_settings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends route_optimization_settingsFindUniqueArgs>(args: SelectSubset<T, route_optimization_settingsFindUniqueArgs<ExtArgs>>): Prisma__route_optimization_settingsClient<$Result.GetResult<Prisma.$route_optimization_settingsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Route_optimization_settings that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {route_optimization_settingsFindUniqueOrThrowArgs} args - Arguments to find a Route_optimization_settings
     * @example
     * // Get one Route_optimization_settings
     * const route_optimization_settings = await prisma.route_optimization_settings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends route_optimization_settingsFindUniqueOrThrowArgs>(args: SelectSubset<T, route_optimization_settingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__route_optimization_settingsClient<$Result.GetResult<Prisma.$route_optimization_settingsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Route_optimization_settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {route_optimization_settingsFindFirstArgs} args - Arguments to find a Route_optimization_settings
     * @example
     * // Get one Route_optimization_settings
     * const route_optimization_settings = await prisma.route_optimization_settings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends route_optimization_settingsFindFirstArgs>(args?: SelectSubset<T, route_optimization_settingsFindFirstArgs<ExtArgs>>): Prisma__route_optimization_settingsClient<$Result.GetResult<Prisma.$route_optimization_settingsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Route_optimization_settings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {route_optimization_settingsFindFirstOrThrowArgs} args - Arguments to find a Route_optimization_settings
     * @example
     * // Get one Route_optimization_settings
     * const route_optimization_settings = await prisma.route_optimization_settings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends route_optimization_settingsFindFirstOrThrowArgs>(args?: SelectSubset<T, route_optimization_settingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__route_optimization_settingsClient<$Result.GetResult<Prisma.$route_optimization_settingsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Route_optimization_settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {route_optimization_settingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Route_optimization_settings
     * const route_optimization_settings = await prisma.route_optimization_settings.findMany()
     * 
     * // Get first 10 Route_optimization_settings
     * const route_optimization_settings = await prisma.route_optimization_settings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const route_optimization_settingsWithIdOnly = await prisma.route_optimization_settings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends route_optimization_settingsFindManyArgs>(args?: SelectSubset<T, route_optimization_settingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$route_optimization_settingsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Route_optimization_settings.
     * @param {route_optimization_settingsCreateArgs} args - Arguments to create a Route_optimization_settings.
     * @example
     * // Create one Route_optimization_settings
     * const Route_optimization_settings = await prisma.route_optimization_settings.create({
     *   data: {
     *     // ... data to create a Route_optimization_settings
     *   }
     * })
     * 
     */
    create<T extends route_optimization_settingsCreateArgs>(args: SelectSubset<T, route_optimization_settingsCreateArgs<ExtArgs>>): Prisma__route_optimization_settingsClient<$Result.GetResult<Prisma.$route_optimization_settingsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Route_optimization_settings.
     * @param {route_optimization_settingsCreateManyArgs} args - Arguments to create many Route_optimization_settings.
     * @example
     * // Create many Route_optimization_settings
     * const route_optimization_settings = await prisma.route_optimization_settings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends route_optimization_settingsCreateManyArgs>(args?: SelectSubset<T, route_optimization_settingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Route_optimization_settings and returns the data saved in the database.
     * @param {route_optimization_settingsCreateManyAndReturnArgs} args - Arguments to create many Route_optimization_settings.
     * @example
     * // Create many Route_optimization_settings
     * const route_optimization_settings = await prisma.route_optimization_settings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Route_optimization_settings and only return the `id`
     * const route_optimization_settingsWithIdOnly = await prisma.route_optimization_settings.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends route_optimization_settingsCreateManyAndReturnArgs>(args?: SelectSubset<T, route_optimization_settingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$route_optimization_settingsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Route_optimization_settings.
     * @param {route_optimization_settingsDeleteArgs} args - Arguments to delete one Route_optimization_settings.
     * @example
     * // Delete one Route_optimization_settings
     * const Route_optimization_settings = await prisma.route_optimization_settings.delete({
     *   where: {
     *     // ... filter to delete one Route_optimization_settings
     *   }
     * })
     * 
     */
    delete<T extends route_optimization_settingsDeleteArgs>(args: SelectSubset<T, route_optimization_settingsDeleteArgs<ExtArgs>>): Prisma__route_optimization_settingsClient<$Result.GetResult<Prisma.$route_optimization_settingsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Route_optimization_settings.
     * @param {route_optimization_settingsUpdateArgs} args - Arguments to update one Route_optimization_settings.
     * @example
     * // Update one Route_optimization_settings
     * const route_optimization_settings = await prisma.route_optimization_settings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends route_optimization_settingsUpdateArgs>(args: SelectSubset<T, route_optimization_settingsUpdateArgs<ExtArgs>>): Prisma__route_optimization_settingsClient<$Result.GetResult<Prisma.$route_optimization_settingsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Route_optimization_settings.
     * @param {route_optimization_settingsDeleteManyArgs} args - Arguments to filter Route_optimization_settings to delete.
     * @example
     * // Delete a few Route_optimization_settings
     * const { count } = await prisma.route_optimization_settings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends route_optimization_settingsDeleteManyArgs>(args?: SelectSubset<T, route_optimization_settingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Route_optimization_settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {route_optimization_settingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Route_optimization_settings
     * const route_optimization_settings = await prisma.route_optimization_settings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends route_optimization_settingsUpdateManyArgs>(args: SelectSubset<T, route_optimization_settingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Route_optimization_settings.
     * @param {route_optimization_settingsUpsertArgs} args - Arguments to update or create a Route_optimization_settings.
     * @example
     * // Update or create a Route_optimization_settings
     * const route_optimization_settings = await prisma.route_optimization_settings.upsert({
     *   create: {
     *     // ... data to create a Route_optimization_settings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Route_optimization_settings we want to update
     *   }
     * })
     */
    upsert<T extends route_optimization_settingsUpsertArgs>(args: SelectSubset<T, route_optimization_settingsUpsertArgs<ExtArgs>>): Prisma__route_optimization_settingsClient<$Result.GetResult<Prisma.$route_optimization_settingsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Route_optimization_settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {route_optimization_settingsCountArgs} args - Arguments to filter Route_optimization_settings to count.
     * @example
     * // Count the number of Route_optimization_settings
     * const count = await prisma.route_optimization_settings.count({
     *   where: {
     *     // ... the filter for the Route_optimization_settings we want to count
     *   }
     * })
    **/
    count<T extends route_optimization_settingsCountArgs>(
      args?: Subset<T, route_optimization_settingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Route_optimization_settingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Route_optimization_settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Route_optimization_settingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Route_optimization_settingsAggregateArgs>(args: Subset<T, Route_optimization_settingsAggregateArgs>): Prisma.PrismaPromise<GetRoute_optimization_settingsAggregateType<T>>

    /**
     * Group by Route_optimization_settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {route_optimization_settingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends route_optimization_settingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: route_optimization_settingsGroupByArgs['orderBy'] }
        : { orderBy?: route_optimization_settingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, route_optimization_settingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoute_optimization_settingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the route_optimization_settings model
   */
  readonly fields: route_optimization_settingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for route_optimization_settings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__route_optimization_settingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the route_optimization_settings model
   */ 
  interface route_optimization_settingsFieldRefs {
    readonly id: FieldRef<"route_optimization_settings", 'String'>
    readonly agencyId: FieldRef<"route_optimization_settings", 'String'>
    readonly deadheadMileWeight: FieldRef<"route_optimization_settings", 'Decimal'>
    readonly waitTimeWeight: FieldRef<"route_optimization_settings", 'Decimal'>
    readonly backhaulBonusWeight: FieldRef<"route_optimization_settings", 'Decimal'>
    readonly overtimeRiskWeight: FieldRef<"route_optimization_settings", 'Decimal'>
    readonly revenueWeight: FieldRef<"route_optimization_settings", 'Decimal'>
    readonly maxDeadheadMiles: FieldRef<"route_optimization_settings", 'Decimal'>
    readonly maxWaitTimeMinutes: FieldRef<"route_optimization_settings", 'Int'>
    readonly maxOvertimeHours: FieldRef<"route_optimization_settings", 'Decimal'>
    readonly maxResponseTimeMinutes: FieldRef<"route_optimization_settings", 'Int'>
    readonly maxServiceDistance: FieldRef<"route_optimization_settings", 'Decimal'>
    readonly backhaulTimeWindow: FieldRef<"route_optimization_settings", 'Int'>
    readonly backhaulDistanceLimit: FieldRef<"route_optimization_settings", 'Decimal'>
    readonly backhaulRevenueBonus: FieldRef<"route_optimization_settings", 'Decimal'>
    readonly enableBackhaulOptimization: FieldRef<"route_optimization_settings", 'Boolean'>
    readonly targetLoadedMileRatio: FieldRef<"route_optimization_settings", 'Decimal'>
    readonly targetRevenuePerHour: FieldRef<"route_optimization_settings", 'Decimal'>
    readonly targetResponseTime: FieldRef<"route_optimization_settings", 'Int'>
    readonly targetEfficiency: FieldRef<"route_optimization_settings", 'Decimal'>
    readonly optimizationAlgorithm: FieldRef<"route_optimization_settings", 'String'>
    readonly maxOptimizationTime: FieldRef<"route_optimization_settings", 'Int'>
    readonly enableRealTimeOptimization: FieldRef<"route_optimization_settings", 'Boolean'>
    readonly crewAvailabilityWeight: FieldRef<"route_optimization_settings", 'Decimal'>
    readonly equipmentCompatibilityWeight: FieldRef<"route_optimization_settings", 'Decimal'>
    readonly patientPriorityWeight: FieldRef<"route_optimization_settings", 'Decimal'>
    readonly isActive: FieldRef<"route_optimization_settings", 'Boolean'>
    readonly createdAt: FieldRef<"route_optimization_settings", 'DateTime'>
    readonly updatedAt: FieldRef<"route_optimization_settings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * route_optimization_settings findUnique
   */
  export type route_optimization_settingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the route_optimization_settings
     */
    select?: route_optimization_settingsSelect<ExtArgs> | null
    /**
     * Filter, which route_optimization_settings to fetch.
     */
    where: route_optimization_settingsWhereUniqueInput
  }

  /**
   * route_optimization_settings findUniqueOrThrow
   */
  export type route_optimization_settingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the route_optimization_settings
     */
    select?: route_optimization_settingsSelect<ExtArgs> | null
    /**
     * Filter, which route_optimization_settings to fetch.
     */
    where: route_optimization_settingsWhereUniqueInput
  }

  /**
   * route_optimization_settings findFirst
   */
  export type route_optimization_settingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the route_optimization_settings
     */
    select?: route_optimization_settingsSelect<ExtArgs> | null
    /**
     * Filter, which route_optimization_settings to fetch.
     */
    where?: route_optimization_settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of route_optimization_settings to fetch.
     */
    orderBy?: route_optimization_settingsOrderByWithRelationInput | route_optimization_settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for route_optimization_settings.
     */
    cursor?: route_optimization_settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` route_optimization_settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` route_optimization_settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of route_optimization_settings.
     */
    distinct?: Route_optimization_settingsScalarFieldEnum | Route_optimization_settingsScalarFieldEnum[]
  }

  /**
   * route_optimization_settings findFirstOrThrow
   */
  export type route_optimization_settingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the route_optimization_settings
     */
    select?: route_optimization_settingsSelect<ExtArgs> | null
    /**
     * Filter, which route_optimization_settings to fetch.
     */
    where?: route_optimization_settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of route_optimization_settings to fetch.
     */
    orderBy?: route_optimization_settingsOrderByWithRelationInput | route_optimization_settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for route_optimization_settings.
     */
    cursor?: route_optimization_settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` route_optimization_settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` route_optimization_settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of route_optimization_settings.
     */
    distinct?: Route_optimization_settingsScalarFieldEnum | Route_optimization_settingsScalarFieldEnum[]
  }

  /**
   * route_optimization_settings findMany
   */
  export type route_optimization_settingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the route_optimization_settings
     */
    select?: route_optimization_settingsSelect<ExtArgs> | null
    /**
     * Filter, which route_optimization_settings to fetch.
     */
    where?: route_optimization_settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of route_optimization_settings to fetch.
     */
    orderBy?: route_optimization_settingsOrderByWithRelationInput | route_optimization_settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing route_optimization_settings.
     */
    cursor?: route_optimization_settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` route_optimization_settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` route_optimization_settings.
     */
    skip?: number
    distinct?: Route_optimization_settingsScalarFieldEnum | Route_optimization_settingsScalarFieldEnum[]
  }

  /**
   * route_optimization_settings create
   */
  export type route_optimization_settingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the route_optimization_settings
     */
    select?: route_optimization_settingsSelect<ExtArgs> | null
    /**
     * The data needed to create a route_optimization_settings.
     */
    data: XOR<route_optimization_settingsCreateInput, route_optimization_settingsUncheckedCreateInput>
  }

  /**
   * route_optimization_settings createMany
   */
  export type route_optimization_settingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many route_optimization_settings.
     */
    data: route_optimization_settingsCreateManyInput | route_optimization_settingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * route_optimization_settings createManyAndReturn
   */
  export type route_optimization_settingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the route_optimization_settings
     */
    select?: route_optimization_settingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many route_optimization_settings.
     */
    data: route_optimization_settingsCreateManyInput | route_optimization_settingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * route_optimization_settings update
   */
  export type route_optimization_settingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the route_optimization_settings
     */
    select?: route_optimization_settingsSelect<ExtArgs> | null
    /**
     * The data needed to update a route_optimization_settings.
     */
    data: XOR<route_optimization_settingsUpdateInput, route_optimization_settingsUncheckedUpdateInput>
    /**
     * Choose, which route_optimization_settings to update.
     */
    where: route_optimization_settingsWhereUniqueInput
  }

  /**
   * route_optimization_settings updateMany
   */
  export type route_optimization_settingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update route_optimization_settings.
     */
    data: XOR<route_optimization_settingsUpdateManyMutationInput, route_optimization_settingsUncheckedUpdateManyInput>
    /**
     * Filter which route_optimization_settings to update
     */
    where?: route_optimization_settingsWhereInput
  }

  /**
   * route_optimization_settings upsert
   */
  export type route_optimization_settingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the route_optimization_settings
     */
    select?: route_optimization_settingsSelect<ExtArgs> | null
    /**
     * The filter to search for the route_optimization_settings to update in case it exists.
     */
    where: route_optimization_settingsWhereUniqueInput
    /**
     * In case the route_optimization_settings found by the `where` argument doesn't exist, create a new route_optimization_settings with this data.
     */
    create: XOR<route_optimization_settingsCreateInput, route_optimization_settingsUncheckedCreateInput>
    /**
     * In case the route_optimization_settings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<route_optimization_settingsUpdateInput, route_optimization_settingsUncheckedUpdateInput>
  }

  /**
   * route_optimization_settings delete
   */
  export type route_optimization_settingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the route_optimization_settings
     */
    select?: route_optimization_settingsSelect<ExtArgs> | null
    /**
     * Filter which route_optimization_settings to delete.
     */
    where: route_optimization_settingsWhereUniqueInput
  }

  /**
   * route_optimization_settings deleteMany
   */
  export type route_optimization_settingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which route_optimization_settings to delete
     */
    where?: route_optimization_settingsWhereInput
  }

  /**
   * route_optimization_settings without action
   */
  export type route_optimization_settingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the route_optimization_settings
     */
    select?: route_optimization_settingsSelect<ExtArgs> | null
  }


  /**
   * Model Unit
   */

  export type AggregateUnit = {
    _count: UnitCountAggregateOutputType | null
    _avg: UnitAvgAggregateOutputType | null
    _sum: UnitSumAggregateOutputType | null
    _min: UnitMinAggregateOutputType | null
    _max: UnitMaxAggregateOutputType | null
  }

  export type UnitAvgAggregateOutputType = {
    crewSize: number | null
    latitude: number | null
    longitude: number | null
  }

  export type UnitSumAggregateOutputType = {
    crewSize: number | null
    latitude: number | null
    longitude: number | null
  }

  export type UnitMinAggregateOutputType = {
    id: string | null
    agencyId: string | null
    unitNumber: string | null
    type: string | null
    status: string | null
    currentStatus: string | null
    currentLocation: string | null
    crewSize: number | null
    latitude: number | null
    longitude: number | null
    lastMaintenance: Date | null
    nextMaintenance: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UnitMaxAggregateOutputType = {
    id: string | null
    agencyId: string | null
    unitNumber: string | null
    type: string | null
    status: string | null
    currentStatus: string | null
    currentLocation: string | null
    crewSize: number | null
    latitude: number | null
    longitude: number | null
    lastMaintenance: Date | null
    nextMaintenance: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UnitCountAggregateOutputType = {
    id: number
    agencyId: number
    unitNumber: number
    type: number
    status: number
    currentStatus: number
    currentLocation: number
    capabilities: number
    crewSize: number
    equipment: number
    location: number
    latitude: number
    longitude: number
    lastMaintenance: number
    nextMaintenance: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UnitAvgAggregateInputType = {
    crewSize?: true
    latitude?: true
    longitude?: true
  }

  export type UnitSumAggregateInputType = {
    crewSize?: true
    latitude?: true
    longitude?: true
  }

  export type UnitMinAggregateInputType = {
    id?: true
    agencyId?: true
    unitNumber?: true
    type?: true
    status?: true
    currentStatus?: true
    currentLocation?: true
    crewSize?: true
    latitude?: true
    longitude?: true
    lastMaintenance?: true
    nextMaintenance?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UnitMaxAggregateInputType = {
    id?: true
    agencyId?: true
    unitNumber?: true
    type?: true
    status?: true
    currentStatus?: true
    currentLocation?: true
    crewSize?: true
    latitude?: true
    longitude?: true
    lastMaintenance?: true
    nextMaintenance?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UnitCountAggregateInputType = {
    id?: true
    agencyId?: true
    unitNumber?: true
    type?: true
    status?: true
    currentStatus?: true
    currentLocation?: true
    capabilities?: true
    crewSize?: true
    equipment?: true
    location?: true
    latitude?: true
    longitude?: true
    lastMaintenance?: true
    nextMaintenance?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UnitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Unit to aggregate.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Units
    **/
    _count?: true | UnitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UnitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UnitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnitMaxAggregateInputType
  }

  export type GetUnitAggregateType<T extends UnitAggregateArgs> = {
        [P in keyof T & keyof AggregateUnit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnit[P]>
      : GetScalarType<T[P], AggregateUnit[P]>
  }




  export type UnitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitWhereInput
    orderBy?: UnitOrderByWithAggregationInput | UnitOrderByWithAggregationInput[]
    by: UnitScalarFieldEnum[] | UnitScalarFieldEnum
    having?: UnitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnitCountAggregateInputType | true
    _avg?: UnitAvgAggregateInputType
    _sum?: UnitSumAggregateInputType
    _min?: UnitMinAggregateInputType
    _max?: UnitMaxAggregateInputType
  }

  export type UnitGroupByOutputType = {
    id: string
    agencyId: string
    unitNumber: string
    type: string
    status: string
    currentStatus: string
    currentLocation: string | null
    capabilities: string[]
    crewSize: number
    equipment: string[]
    location: JsonValue | null
    latitude: number | null
    longitude: number | null
    lastMaintenance: Date | null
    nextMaintenance: Date | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: UnitCountAggregateOutputType | null
    _avg: UnitAvgAggregateOutputType | null
    _sum: UnitSumAggregateOutputType | null
    _min: UnitMinAggregateOutputType | null
    _max: UnitMaxAggregateOutputType | null
  }

  type GetUnitGroupByPayload<T extends UnitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnitGroupByOutputType[P]>
            : GetScalarType<T[P], UnitGroupByOutputType[P]>
        }
      >
    >


  export type UnitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agencyId?: boolean
    unitNumber?: boolean
    type?: boolean
    status?: boolean
    currentStatus?: boolean
    currentLocation?: boolean
    capabilities?: boolean
    crewSize?: boolean
    equipment?: boolean
    location?: boolean
    latitude?: boolean
    longitude?: boolean
    lastMaintenance?: boolean
    nextMaintenance?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    analytics?: boolean | Unit$analyticsArgs<ExtArgs>
    agency?: boolean | EMSAgencyDefaultArgs<ExtArgs>
    assignedTrips?: boolean | Unit$assignedTripsArgs<ExtArgs>
    _count?: boolean | UnitCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unit"]>

  export type UnitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agencyId?: boolean
    unitNumber?: boolean
    type?: boolean
    status?: boolean
    currentStatus?: boolean
    currentLocation?: boolean
    capabilities?: boolean
    crewSize?: boolean
    equipment?: boolean
    location?: boolean
    latitude?: boolean
    longitude?: boolean
    lastMaintenance?: boolean
    nextMaintenance?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agency?: boolean | EMSAgencyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unit"]>

  export type UnitSelectScalar = {
    id?: boolean
    agencyId?: boolean
    unitNumber?: boolean
    type?: boolean
    status?: boolean
    currentStatus?: boolean
    currentLocation?: boolean
    capabilities?: boolean
    crewSize?: boolean
    equipment?: boolean
    location?: boolean
    latitude?: boolean
    longitude?: boolean
    lastMaintenance?: boolean
    nextMaintenance?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UnitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    analytics?: boolean | Unit$analyticsArgs<ExtArgs>
    agency?: boolean | EMSAgencyDefaultArgs<ExtArgs>
    assignedTrips?: boolean | Unit$assignedTripsArgs<ExtArgs>
    _count?: boolean | UnitCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UnitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agency?: boolean | EMSAgencyDefaultArgs<ExtArgs>
  }

  export type $UnitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Unit"
    objects: {
      analytics: Prisma.$unit_analyticsPayload<ExtArgs> | null
      agency: Prisma.$EMSAgencyPayload<ExtArgs>
      assignedTrips: Prisma.$TransportRequestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      agencyId: string
      unitNumber: string
      type: string
      status: string
      currentStatus: string
      currentLocation: string | null
      capabilities: string[]
      crewSize: number
      equipment: string[]
      location: Prisma.JsonValue | null
      latitude: number | null
      longitude: number | null
      lastMaintenance: Date | null
      nextMaintenance: Date | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["unit"]>
    composites: {}
  }

  type UnitGetPayload<S extends boolean | null | undefined | UnitDefaultArgs> = $Result.GetResult<Prisma.$UnitPayload, S>

  type UnitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UnitFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UnitCountAggregateInputType | true
    }

  export interface UnitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Unit'], meta: { name: 'Unit' } }
    /**
     * Find zero or one Unit that matches the filter.
     * @param {UnitFindUniqueArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnitFindUniqueArgs>(args: SelectSubset<T, UnitFindUniqueArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Unit that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UnitFindUniqueOrThrowArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnitFindUniqueOrThrowArgs>(args: SelectSubset<T, UnitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Unit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindFirstArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnitFindFirstArgs>(args?: SelectSubset<T, UnitFindFirstArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Unit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindFirstOrThrowArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnitFindFirstOrThrowArgs>(args?: SelectSubset<T, UnitFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Units that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Units
     * const units = await prisma.unit.findMany()
     * 
     * // Get first 10 Units
     * const units = await prisma.unit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unitWithIdOnly = await prisma.unit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UnitFindManyArgs>(args?: SelectSubset<T, UnitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Unit.
     * @param {UnitCreateArgs} args - Arguments to create a Unit.
     * @example
     * // Create one Unit
     * const Unit = await prisma.unit.create({
     *   data: {
     *     // ... data to create a Unit
     *   }
     * })
     * 
     */
    create<T extends UnitCreateArgs>(args: SelectSubset<T, UnitCreateArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Units.
     * @param {UnitCreateManyArgs} args - Arguments to create many Units.
     * @example
     * // Create many Units
     * const unit = await prisma.unit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnitCreateManyArgs>(args?: SelectSubset<T, UnitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Units and returns the data saved in the database.
     * @param {UnitCreateManyAndReturnArgs} args - Arguments to create many Units.
     * @example
     * // Create many Units
     * const unit = await prisma.unit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Units and only return the `id`
     * const unitWithIdOnly = await prisma.unit.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UnitCreateManyAndReturnArgs>(args?: SelectSubset<T, UnitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Unit.
     * @param {UnitDeleteArgs} args - Arguments to delete one Unit.
     * @example
     * // Delete one Unit
     * const Unit = await prisma.unit.delete({
     *   where: {
     *     // ... filter to delete one Unit
     *   }
     * })
     * 
     */
    delete<T extends UnitDeleteArgs>(args: SelectSubset<T, UnitDeleteArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Unit.
     * @param {UnitUpdateArgs} args - Arguments to update one Unit.
     * @example
     * // Update one Unit
     * const unit = await prisma.unit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnitUpdateArgs>(args: SelectSubset<T, UnitUpdateArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Units.
     * @param {UnitDeleteManyArgs} args - Arguments to filter Units to delete.
     * @example
     * // Delete a few Units
     * const { count } = await prisma.unit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnitDeleteManyArgs>(args?: SelectSubset<T, UnitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Units.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Units
     * const unit = await prisma.unit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnitUpdateManyArgs>(args: SelectSubset<T, UnitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Unit.
     * @param {UnitUpsertArgs} args - Arguments to update or create a Unit.
     * @example
     * // Update or create a Unit
     * const unit = await prisma.unit.upsert({
     *   create: {
     *     // ... data to create a Unit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Unit we want to update
     *   }
     * })
     */
    upsert<T extends UnitUpsertArgs>(args: SelectSubset<T, UnitUpsertArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Units.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitCountArgs} args - Arguments to filter Units to count.
     * @example
     * // Count the number of Units
     * const count = await prisma.unit.count({
     *   where: {
     *     // ... the filter for the Units we want to count
     *   }
     * })
    **/
    count<T extends UnitCountArgs>(
      args?: Subset<T, UnitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Unit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnitAggregateArgs>(args: Subset<T, UnitAggregateArgs>): Prisma.PrismaPromise<GetUnitAggregateType<T>>

    /**
     * Group by Unit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnitGroupByArgs['orderBy'] }
        : { orderBy?: UnitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Unit model
   */
  readonly fields: UnitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Unit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    analytics<T extends Unit$analyticsArgs<ExtArgs> = {}>(args?: Subset<T, Unit$analyticsArgs<ExtArgs>>): Prisma__unit_analyticsClient<$Result.GetResult<Prisma.$unit_analyticsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    agency<T extends EMSAgencyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EMSAgencyDefaultArgs<ExtArgs>>): Prisma__EMSAgencyClient<$Result.GetResult<Prisma.$EMSAgencyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    assignedTrips<T extends Unit$assignedTripsArgs<ExtArgs> = {}>(args?: Subset<T, Unit$assignedTripsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransportRequestPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Unit model
   */ 
  interface UnitFieldRefs {
    readonly id: FieldRef<"Unit", 'String'>
    readonly agencyId: FieldRef<"Unit", 'String'>
    readonly unitNumber: FieldRef<"Unit", 'String'>
    readonly type: FieldRef<"Unit", 'String'>
    readonly status: FieldRef<"Unit", 'String'>
    readonly currentStatus: FieldRef<"Unit", 'String'>
    readonly currentLocation: FieldRef<"Unit", 'String'>
    readonly capabilities: FieldRef<"Unit", 'String[]'>
    readonly crewSize: FieldRef<"Unit", 'Int'>
    readonly equipment: FieldRef<"Unit", 'String[]'>
    readonly location: FieldRef<"Unit", 'Json'>
    readonly latitude: FieldRef<"Unit", 'Float'>
    readonly longitude: FieldRef<"Unit", 'Float'>
    readonly lastMaintenance: FieldRef<"Unit", 'DateTime'>
    readonly nextMaintenance: FieldRef<"Unit", 'DateTime'>
    readonly isActive: FieldRef<"Unit", 'Boolean'>
    readonly createdAt: FieldRef<"Unit", 'DateTime'>
    readonly updatedAt: FieldRef<"Unit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Unit findUnique
   */
  export type UnitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit findUniqueOrThrow
   */
  export type UnitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit findFirst
   */
  export type UnitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Units.
     */
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Unit findFirstOrThrow
   */
  export type UnitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Units.
     */
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Unit findMany
   */
  export type UnitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Units to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Unit create
   */
  export type UnitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The data needed to create a Unit.
     */
    data: XOR<UnitCreateInput, UnitUncheckedCreateInput>
  }

  /**
   * Unit createMany
   */
  export type UnitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Units.
     */
    data: UnitCreateManyInput | UnitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Unit createManyAndReturn
   */
  export type UnitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Units.
     */
    data: UnitCreateManyInput | UnitCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Unit update
   */
  export type UnitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The data needed to update a Unit.
     */
    data: XOR<UnitUpdateInput, UnitUncheckedUpdateInput>
    /**
     * Choose, which Unit to update.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit updateMany
   */
  export type UnitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Units.
     */
    data: XOR<UnitUpdateManyMutationInput, UnitUncheckedUpdateManyInput>
    /**
     * Filter which Units to update
     */
    where?: UnitWhereInput
  }

  /**
   * Unit upsert
   */
  export type UnitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The filter to search for the Unit to update in case it exists.
     */
    where: UnitWhereUniqueInput
    /**
     * In case the Unit found by the `where` argument doesn't exist, create a new Unit with this data.
     */
    create: XOR<UnitCreateInput, UnitUncheckedCreateInput>
    /**
     * In case the Unit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnitUpdateInput, UnitUncheckedUpdateInput>
  }

  /**
   * Unit delete
   */
  export type UnitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter which Unit to delete.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit deleteMany
   */
  export type UnitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Units to delete
     */
    where?: UnitWhereInput
  }

  /**
   * Unit.analytics
   */
  export type Unit$analyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unit_analytics
     */
    select?: unit_analyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: unit_analyticsInclude<ExtArgs> | null
    where?: unit_analyticsWhereInput
  }

  /**
   * Unit.assignedTrips
   */
  export type Unit$assignedTripsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransportRequest
     */
    select?: TransportRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportRequestInclude<ExtArgs> | null
    where?: TransportRequestWhereInput
    orderBy?: TransportRequestOrderByWithRelationInput | TransportRequestOrderByWithRelationInput[]
    cursor?: TransportRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransportRequestScalarFieldEnum | TransportRequestScalarFieldEnum[]
  }

  /**
   * Unit without action
   */
  export type UnitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
  }


  /**
   * Model unit_analytics
   */

  export type AggregateUnit_analytics = {
    _count: Unit_analyticsCountAggregateOutputType | null
    _avg: Unit_analyticsAvgAggregateOutputType | null
    _sum: Unit_analyticsSumAggregateOutputType | null
    _min: Unit_analyticsMinAggregateOutputType | null
    _max: Unit_analyticsMaxAggregateOutputType | null
  }

  export type Unit_analyticsAvgAggregateOutputType = {
    performanceScore: Decimal | null
    efficiency: Decimal | null
    totalTrips: number | null
    totalTripsCompleted: number | null
    averageResponseTime: Decimal | null
  }

  export type Unit_analyticsSumAggregateOutputType = {
    performanceScore: Decimal | null
    efficiency: Decimal | null
    totalTrips: number | null
    totalTripsCompleted: number | null
    averageResponseTime: Decimal | null
  }

  export type Unit_analyticsMinAggregateOutputType = {
    id: string | null
    unitId: string | null
    performanceScore: Decimal | null
    efficiency: Decimal | null
    totalTrips: number | null
    totalTripsCompleted: number | null
    averageResponseTime: Decimal | null
    lastUpdated: Date | null
  }

  export type Unit_analyticsMaxAggregateOutputType = {
    id: string | null
    unitId: string | null
    performanceScore: Decimal | null
    efficiency: Decimal | null
    totalTrips: number | null
    totalTripsCompleted: number | null
    averageResponseTime: Decimal | null
    lastUpdated: Date | null
  }

  export type Unit_analyticsCountAggregateOutputType = {
    id: number
    unitId: number
    performanceScore: number
    efficiency: number
    totalTrips: number
    totalTripsCompleted: number
    averageResponseTime: number
    lastUpdated: number
    _all: number
  }


  export type Unit_analyticsAvgAggregateInputType = {
    performanceScore?: true
    efficiency?: true
    totalTrips?: true
    totalTripsCompleted?: true
    averageResponseTime?: true
  }

  export type Unit_analyticsSumAggregateInputType = {
    performanceScore?: true
    efficiency?: true
    totalTrips?: true
    totalTripsCompleted?: true
    averageResponseTime?: true
  }

  export type Unit_analyticsMinAggregateInputType = {
    id?: true
    unitId?: true
    performanceScore?: true
    efficiency?: true
    totalTrips?: true
    totalTripsCompleted?: true
    averageResponseTime?: true
    lastUpdated?: true
  }

  export type Unit_analyticsMaxAggregateInputType = {
    id?: true
    unitId?: true
    performanceScore?: true
    efficiency?: true
    totalTrips?: true
    totalTripsCompleted?: true
    averageResponseTime?: true
    lastUpdated?: true
  }

  export type Unit_analyticsCountAggregateInputType = {
    id?: true
    unitId?: true
    performanceScore?: true
    efficiency?: true
    totalTrips?: true
    totalTripsCompleted?: true
    averageResponseTime?: true
    lastUpdated?: true
    _all?: true
  }

  export type Unit_analyticsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which unit_analytics to aggregate.
     */
    where?: unit_analyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of unit_analytics to fetch.
     */
    orderBy?: unit_analyticsOrderByWithRelationInput | unit_analyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: unit_analyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` unit_analytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` unit_analytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned unit_analytics
    **/
    _count?: true | Unit_analyticsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Unit_analyticsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Unit_analyticsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Unit_analyticsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Unit_analyticsMaxAggregateInputType
  }

  export type GetUnit_analyticsAggregateType<T extends Unit_analyticsAggregateArgs> = {
        [P in keyof T & keyof AggregateUnit_analytics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnit_analytics[P]>
      : GetScalarType<T[P], AggregateUnit_analytics[P]>
  }




  export type unit_analyticsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: unit_analyticsWhereInput
    orderBy?: unit_analyticsOrderByWithAggregationInput | unit_analyticsOrderByWithAggregationInput[]
    by: Unit_analyticsScalarFieldEnum[] | Unit_analyticsScalarFieldEnum
    having?: unit_analyticsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Unit_analyticsCountAggregateInputType | true
    _avg?: Unit_analyticsAvgAggregateInputType
    _sum?: Unit_analyticsSumAggregateInputType
    _min?: Unit_analyticsMinAggregateInputType
    _max?: Unit_analyticsMaxAggregateInputType
  }

  export type Unit_analyticsGroupByOutputType = {
    id: string
    unitId: string
    performanceScore: Decimal | null
    efficiency: Decimal | null
    totalTrips: number
    totalTripsCompleted: number
    averageResponseTime: Decimal | null
    lastUpdated: Date
    _count: Unit_analyticsCountAggregateOutputType | null
    _avg: Unit_analyticsAvgAggregateOutputType | null
    _sum: Unit_analyticsSumAggregateOutputType | null
    _min: Unit_analyticsMinAggregateOutputType | null
    _max: Unit_analyticsMaxAggregateOutputType | null
  }

  type GetUnit_analyticsGroupByPayload<T extends unit_analyticsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Unit_analyticsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Unit_analyticsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Unit_analyticsGroupByOutputType[P]>
            : GetScalarType<T[P], Unit_analyticsGroupByOutputType[P]>
        }
      >
    >


  export type unit_analyticsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitId?: boolean
    performanceScore?: boolean
    efficiency?: boolean
    totalTrips?: boolean
    totalTripsCompleted?: boolean
    averageResponseTime?: boolean
    lastUpdated?: boolean
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unit_analytics"]>

  export type unit_analyticsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitId?: boolean
    performanceScore?: boolean
    efficiency?: boolean
    totalTrips?: boolean
    totalTripsCompleted?: boolean
    averageResponseTime?: boolean
    lastUpdated?: boolean
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unit_analytics"]>

  export type unit_analyticsSelectScalar = {
    id?: boolean
    unitId?: boolean
    performanceScore?: boolean
    efficiency?: boolean
    totalTrips?: boolean
    totalTripsCompleted?: boolean
    averageResponseTime?: boolean
    lastUpdated?: boolean
  }

  export type unit_analyticsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }
  export type unit_analyticsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }

  export type $unit_analyticsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "unit_analytics"
    objects: {
      unit: Prisma.$UnitPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      unitId: string
      performanceScore: Prisma.Decimal | null
      efficiency: Prisma.Decimal | null
      totalTrips: number
      totalTripsCompleted: number
      averageResponseTime: Prisma.Decimal | null
      lastUpdated: Date
    }, ExtArgs["result"]["unit_analytics"]>
    composites: {}
  }

  type unit_analyticsGetPayload<S extends boolean | null | undefined | unit_analyticsDefaultArgs> = $Result.GetResult<Prisma.$unit_analyticsPayload, S>

  type unit_analyticsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<unit_analyticsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Unit_analyticsCountAggregateInputType | true
    }

  export interface unit_analyticsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['unit_analytics'], meta: { name: 'unit_analytics' } }
    /**
     * Find zero or one Unit_analytics that matches the filter.
     * @param {unit_analyticsFindUniqueArgs} args - Arguments to find a Unit_analytics
     * @example
     * // Get one Unit_analytics
     * const unit_analytics = await prisma.unit_analytics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends unit_analyticsFindUniqueArgs>(args: SelectSubset<T, unit_analyticsFindUniqueArgs<ExtArgs>>): Prisma__unit_analyticsClient<$Result.GetResult<Prisma.$unit_analyticsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Unit_analytics that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {unit_analyticsFindUniqueOrThrowArgs} args - Arguments to find a Unit_analytics
     * @example
     * // Get one Unit_analytics
     * const unit_analytics = await prisma.unit_analytics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends unit_analyticsFindUniqueOrThrowArgs>(args: SelectSubset<T, unit_analyticsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__unit_analyticsClient<$Result.GetResult<Prisma.$unit_analyticsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Unit_analytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {unit_analyticsFindFirstArgs} args - Arguments to find a Unit_analytics
     * @example
     * // Get one Unit_analytics
     * const unit_analytics = await prisma.unit_analytics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends unit_analyticsFindFirstArgs>(args?: SelectSubset<T, unit_analyticsFindFirstArgs<ExtArgs>>): Prisma__unit_analyticsClient<$Result.GetResult<Prisma.$unit_analyticsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Unit_analytics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {unit_analyticsFindFirstOrThrowArgs} args - Arguments to find a Unit_analytics
     * @example
     * // Get one Unit_analytics
     * const unit_analytics = await prisma.unit_analytics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends unit_analyticsFindFirstOrThrowArgs>(args?: SelectSubset<T, unit_analyticsFindFirstOrThrowArgs<ExtArgs>>): Prisma__unit_analyticsClient<$Result.GetResult<Prisma.$unit_analyticsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Unit_analytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {unit_analyticsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Unit_analytics
     * const unit_analytics = await prisma.unit_analytics.findMany()
     * 
     * // Get first 10 Unit_analytics
     * const unit_analytics = await prisma.unit_analytics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unit_analyticsWithIdOnly = await prisma.unit_analytics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends unit_analyticsFindManyArgs>(args?: SelectSubset<T, unit_analyticsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$unit_analyticsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Unit_analytics.
     * @param {unit_analyticsCreateArgs} args - Arguments to create a Unit_analytics.
     * @example
     * // Create one Unit_analytics
     * const Unit_analytics = await prisma.unit_analytics.create({
     *   data: {
     *     // ... data to create a Unit_analytics
     *   }
     * })
     * 
     */
    create<T extends unit_analyticsCreateArgs>(args: SelectSubset<T, unit_analyticsCreateArgs<ExtArgs>>): Prisma__unit_analyticsClient<$Result.GetResult<Prisma.$unit_analyticsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Unit_analytics.
     * @param {unit_analyticsCreateManyArgs} args - Arguments to create many Unit_analytics.
     * @example
     * // Create many Unit_analytics
     * const unit_analytics = await prisma.unit_analytics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends unit_analyticsCreateManyArgs>(args?: SelectSubset<T, unit_analyticsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Unit_analytics and returns the data saved in the database.
     * @param {unit_analyticsCreateManyAndReturnArgs} args - Arguments to create many Unit_analytics.
     * @example
     * // Create many Unit_analytics
     * const unit_analytics = await prisma.unit_analytics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Unit_analytics and only return the `id`
     * const unit_analyticsWithIdOnly = await prisma.unit_analytics.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends unit_analyticsCreateManyAndReturnArgs>(args?: SelectSubset<T, unit_analyticsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$unit_analyticsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Unit_analytics.
     * @param {unit_analyticsDeleteArgs} args - Arguments to delete one Unit_analytics.
     * @example
     * // Delete one Unit_analytics
     * const Unit_analytics = await prisma.unit_analytics.delete({
     *   where: {
     *     // ... filter to delete one Unit_analytics
     *   }
     * })
     * 
     */
    delete<T extends unit_analyticsDeleteArgs>(args: SelectSubset<T, unit_analyticsDeleteArgs<ExtArgs>>): Prisma__unit_analyticsClient<$Result.GetResult<Prisma.$unit_analyticsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Unit_analytics.
     * @param {unit_analyticsUpdateArgs} args - Arguments to update one Unit_analytics.
     * @example
     * // Update one Unit_analytics
     * const unit_analytics = await prisma.unit_analytics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends unit_analyticsUpdateArgs>(args: SelectSubset<T, unit_analyticsUpdateArgs<ExtArgs>>): Prisma__unit_analyticsClient<$Result.GetResult<Prisma.$unit_analyticsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Unit_analytics.
     * @param {unit_analyticsDeleteManyArgs} args - Arguments to filter Unit_analytics to delete.
     * @example
     * // Delete a few Unit_analytics
     * const { count } = await prisma.unit_analytics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends unit_analyticsDeleteManyArgs>(args?: SelectSubset<T, unit_analyticsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Unit_analytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {unit_analyticsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Unit_analytics
     * const unit_analytics = await prisma.unit_analytics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends unit_analyticsUpdateManyArgs>(args: SelectSubset<T, unit_analyticsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Unit_analytics.
     * @param {unit_analyticsUpsertArgs} args - Arguments to update or create a Unit_analytics.
     * @example
     * // Update or create a Unit_analytics
     * const unit_analytics = await prisma.unit_analytics.upsert({
     *   create: {
     *     // ... data to create a Unit_analytics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Unit_analytics we want to update
     *   }
     * })
     */
    upsert<T extends unit_analyticsUpsertArgs>(args: SelectSubset<T, unit_analyticsUpsertArgs<ExtArgs>>): Prisma__unit_analyticsClient<$Result.GetResult<Prisma.$unit_analyticsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Unit_analytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {unit_analyticsCountArgs} args - Arguments to filter Unit_analytics to count.
     * @example
     * // Count the number of Unit_analytics
     * const count = await prisma.unit_analytics.count({
     *   where: {
     *     // ... the filter for the Unit_analytics we want to count
     *   }
     * })
    **/
    count<T extends unit_analyticsCountArgs>(
      args?: Subset<T, unit_analyticsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Unit_analyticsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Unit_analytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Unit_analyticsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Unit_analyticsAggregateArgs>(args: Subset<T, Unit_analyticsAggregateArgs>): Prisma.PrismaPromise<GetUnit_analyticsAggregateType<T>>

    /**
     * Group by Unit_analytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {unit_analyticsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends unit_analyticsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: unit_analyticsGroupByArgs['orderBy'] }
        : { orderBy?: unit_analyticsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, unit_analyticsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnit_analyticsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the unit_analytics model
   */
  readonly fields: unit_analyticsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for unit_analytics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__unit_analyticsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    unit<T extends UnitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitDefaultArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the unit_analytics model
   */ 
  interface unit_analyticsFieldRefs {
    readonly id: FieldRef<"unit_analytics", 'String'>
    readonly unitId: FieldRef<"unit_analytics", 'String'>
    readonly performanceScore: FieldRef<"unit_analytics", 'Decimal'>
    readonly efficiency: FieldRef<"unit_analytics", 'Decimal'>
    readonly totalTrips: FieldRef<"unit_analytics", 'Int'>
    readonly totalTripsCompleted: FieldRef<"unit_analytics", 'Int'>
    readonly averageResponseTime: FieldRef<"unit_analytics", 'Decimal'>
    readonly lastUpdated: FieldRef<"unit_analytics", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * unit_analytics findUnique
   */
  export type unit_analyticsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unit_analytics
     */
    select?: unit_analyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: unit_analyticsInclude<ExtArgs> | null
    /**
     * Filter, which unit_analytics to fetch.
     */
    where: unit_analyticsWhereUniqueInput
  }

  /**
   * unit_analytics findUniqueOrThrow
   */
  export type unit_analyticsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unit_analytics
     */
    select?: unit_analyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: unit_analyticsInclude<ExtArgs> | null
    /**
     * Filter, which unit_analytics to fetch.
     */
    where: unit_analyticsWhereUniqueInput
  }

  /**
   * unit_analytics findFirst
   */
  export type unit_analyticsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unit_analytics
     */
    select?: unit_analyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: unit_analyticsInclude<ExtArgs> | null
    /**
     * Filter, which unit_analytics to fetch.
     */
    where?: unit_analyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of unit_analytics to fetch.
     */
    orderBy?: unit_analyticsOrderByWithRelationInput | unit_analyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for unit_analytics.
     */
    cursor?: unit_analyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` unit_analytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` unit_analytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of unit_analytics.
     */
    distinct?: Unit_analyticsScalarFieldEnum | Unit_analyticsScalarFieldEnum[]
  }

  /**
   * unit_analytics findFirstOrThrow
   */
  export type unit_analyticsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unit_analytics
     */
    select?: unit_analyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: unit_analyticsInclude<ExtArgs> | null
    /**
     * Filter, which unit_analytics to fetch.
     */
    where?: unit_analyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of unit_analytics to fetch.
     */
    orderBy?: unit_analyticsOrderByWithRelationInput | unit_analyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for unit_analytics.
     */
    cursor?: unit_analyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` unit_analytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` unit_analytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of unit_analytics.
     */
    distinct?: Unit_analyticsScalarFieldEnum | Unit_analyticsScalarFieldEnum[]
  }

  /**
   * unit_analytics findMany
   */
  export type unit_analyticsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unit_analytics
     */
    select?: unit_analyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: unit_analyticsInclude<ExtArgs> | null
    /**
     * Filter, which unit_analytics to fetch.
     */
    where?: unit_analyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of unit_analytics to fetch.
     */
    orderBy?: unit_analyticsOrderByWithRelationInput | unit_analyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing unit_analytics.
     */
    cursor?: unit_analyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` unit_analytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` unit_analytics.
     */
    skip?: number
    distinct?: Unit_analyticsScalarFieldEnum | Unit_analyticsScalarFieldEnum[]
  }

  /**
   * unit_analytics create
   */
  export type unit_analyticsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unit_analytics
     */
    select?: unit_analyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: unit_analyticsInclude<ExtArgs> | null
    /**
     * The data needed to create a unit_analytics.
     */
    data: XOR<unit_analyticsCreateInput, unit_analyticsUncheckedCreateInput>
  }

  /**
   * unit_analytics createMany
   */
  export type unit_analyticsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many unit_analytics.
     */
    data: unit_analyticsCreateManyInput | unit_analyticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * unit_analytics createManyAndReturn
   */
  export type unit_analyticsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unit_analytics
     */
    select?: unit_analyticsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many unit_analytics.
     */
    data: unit_analyticsCreateManyInput | unit_analyticsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: unit_analyticsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * unit_analytics update
   */
  export type unit_analyticsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unit_analytics
     */
    select?: unit_analyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: unit_analyticsInclude<ExtArgs> | null
    /**
     * The data needed to update a unit_analytics.
     */
    data: XOR<unit_analyticsUpdateInput, unit_analyticsUncheckedUpdateInput>
    /**
     * Choose, which unit_analytics to update.
     */
    where: unit_analyticsWhereUniqueInput
  }

  /**
   * unit_analytics updateMany
   */
  export type unit_analyticsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update unit_analytics.
     */
    data: XOR<unit_analyticsUpdateManyMutationInput, unit_analyticsUncheckedUpdateManyInput>
    /**
     * Filter which unit_analytics to update
     */
    where?: unit_analyticsWhereInput
  }

  /**
   * unit_analytics upsert
   */
  export type unit_analyticsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unit_analytics
     */
    select?: unit_analyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: unit_analyticsInclude<ExtArgs> | null
    /**
     * The filter to search for the unit_analytics to update in case it exists.
     */
    where: unit_analyticsWhereUniqueInput
    /**
     * In case the unit_analytics found by the `where` argument doesn't exist, create a new unit_analytics with this data.
     */
    create: XOR<unit_analyticsCreateInput, unit_analyticsUncheckedCreateInput>
    /**
     * In case the unit_analytics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<unit_analyticsUpdateInput, unit_analyticsUncheckedUpdateInput>
  }

  /**
   * unit_analytics delete
   */
  export type unit_analyticsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unit_analytics
     */
    select?: unit_analyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: unit_analyticsInclude<ExtArgs> | null
    /**
     * Filter which unit_analytics to delete.
     */
    where: unit_analyticsWhereUniqueInput
  }

  /**
   * unit_analytics deleteMany
   */
  export type unit_analyticsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which unit_analytics to delete
     */
    where?: unit_analyticsWhereInput
  }

  /**
   * unit_analytics without action
   */
  export type unit_analyticsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unit_analytics
     */
    select?: unit_analyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: unit_analyticsInclude<ExtArgs> | null
  }


  /**
   * Model NotificationPreference
   */

  export type AggregateNotificationPreference = {
    _count: NotificationPreferenceCountAggregateOutputType | null
    _min: NotificationPreferenceMinAggregateOutputType | null
    _max: NotificationPreferenceMaxAggregateOutputType | null
  }

  export type NotificationPreferenceMinAggregateOutputType = {
    id: string | null
    userId: string | null
    notificationType: string | null
    emailEnabled: boolean | null
    smsEnabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationPreferenceMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    notificationType: string | null
    emailEnabled: boolean | null
    smsEnabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationPreferenceCountAggregateOutputType = {
    id: number
    userId: number
    notificationType: number
    emailEnabled: number
    smsEnabled: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationPreferenceMinAggregateInputType = {
    id?: true
    userId?: true
    notificationType?: true
    emailEnabled?: true
    smsEnabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationPreferenceMaxAggregateInputType = {
    id?: true
    userId?: true
    notificationType?: true
    emailEnabled?: true
    smsEnabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationPreferenceCountAggregateInputType = {
    id?: true
    userId?: true
    notificationType?: true
    emailEnabled?: true
    smsEnabled?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationPreferenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationPreference to aggregate.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationPreferences
    **/
    _count?: true | NotificationPreferenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationPreferenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationPreferenceMaxAggregateInputType
  }

  export type GetNotificationPreferenceAggregateType<T extends NotificationPreferenceAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationPreference]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationPreference[P]>
      : GetScalarType<T[P], AggregateNotificationPreference[P]>
  }




  export type NotificationPreferenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationPreferenceWhereInput
    orderBy?: NotificationPreferenceOrderByWithAggregationInput | NotificationPreferenceOrderByWithAggregationInput[]
    by: NotificationPreferenceScalarFieldEnum[] | NotificationPreferenceScalarFieldEnum
    having?: NotificationPreferenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationPreferenceCountAggregateInputType | true
    _min?: NotificationPreferenceMinAggregateInputType
    _max?: NotificationPreferenceMaxAggregateInputType
  }

  export type NotificationPreferenceGroupByOutputType = {
    id: string
    userId: string
    notificationType: string
    emailEnabled: boolean
    smsEnabled: boolean
    createdAt: Date
    updatedAt: Date
    _count: NotificationPreferenceCountAggregateOutputType | null
    _min: NotificationPreferenceMinAggregateOutputType | null
    _max: NotificationPreferenceMaxAggregateOutputType | null
  }

  type GetNotificationPreferenceGroupByPayload<T extends NotificationPreferenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationPreferenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationPreferenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationPreferenceGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationPreferenceGroupByOutputType[P]>
        }
      >
    >


  export type NotificationPreferenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    notificationType?: boolean
    emailEnabled?: boolean
    smsEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | CenterUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationPreference"]>

  export type NotificationPreferenceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    notificationType?: boolean
    emailEnabled?: boolean
    smsEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | CenterUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationPreference"]>

  export type NotificationPreferenceSelectScalar = {
    id?: boolean
    userId?: boolean
    notificationType?: boolean
    emailEnabled?: boolean
    smsEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationPreferenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | CenterUserDefaultArgs<ExtArgs>
  }
  export type NotificationPreferenceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | CenterUserDefaultArgs<ExtArgs>
  }

  export type $NotificationPreferencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationPreference"
    objects: {
      user: Prisma.$CenterUserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      notificationType: string
      emailEnabled: boolean
      smsEnabled: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notificationPreference"]>
    composites: {}
  }

  type NotificationPreferenceGetPayload<S extends boolean | null | undefined | NotificationPreferenceDefaultArgs> = $Result.GetResult<Prisma.$NotificationPreferencePayload, S>

  type NotificationPreferenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationPreferenceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationPreferenceCountAggregateInputType | true
    }

  export interface NotificationPreferenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationPreference'], meta: { name: 'NotificationPreference' } }
    /**
     * Find zero or one NotificationPreference that matches the filter.
     * @param {NotificationPreferenceFindUniqueArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationPreferenceFindUniqueArgs>(args: SelectSubset<T, NotificationPreferenceFindUniqueArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NotificationPreference that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationPreferenceFindUniqueOrThrowArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationPreferenceFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationPreferenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NotificationPreference that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceFindFirstArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationPreferenceFindFirstArgs>(args?: SelectSubset<T, NotificationPreferenceFindFirstArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NotificationPreference that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceFindFirstOrThrowArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationPreferenceFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationPreferenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NotificationPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationPreferences
     * const notificationPreferences = await prisma.notificationPreference.findMany()
     * 
     * // Get first 10 NotificationPreferences
     * const notificationPreferences = await prisma.notificationPreference.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationPreferenceWithIdOnly = await prisma.notificationPreference.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationPreferenceFindManyArgs>(args?: SelectSubset<T, NotificationPreferenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NotificationPreference.
     * @param {NotificationPreferenceCreateArgs} args - Arguments to create a NotificationPreference.
     * @example
     * // Create one NotificationPreference
     * const NotificationPreference = await prisma.notificationPreference.create({
     *   data: {
     *     // ... data to create a NotificationPreference
     *   }
     * })
     * 
     */
    create<T extends NotificationPreferenceCreateArgs>(args: SelectSubset<T, NotificationPreferenceCreateArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NotificationPreferences.
     * @param {NotificationPreferenceCreateManyArgs} args - Arguments to create many NotificationPreferences.
     * @example
     * // Create many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationPreferenceCreateManyArgs>(args?: SelectSubset<T, NotificationPreferenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationPreferences and returns the data saved in the database.
     * @param {NotificationPreferenceCreateManyAndReturnArgs} args - Arguments to create many NotificationPreferences.
     * @example
     * // Create many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationPreferences and only return the `id`
     * const notificationPreferenceWithIdOnly = await prisma.notificationPreference.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationPreferenceCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationPreferenceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NotificationPreference.
     * @param {NotificationPreferenceDeleteArgs} args - Arguments to delete one NotificationPreference.
     * @example
     * // Delete one NotificationPreference
     * const NotificationPreference = await prisma.notificationPreference.delete({
     *   where: {
     *     // ... filter to delete one NotificationPreference
     *   }
     * })
     * 
     */
    delete<T extends NotificationPreferenceDeleteArgs>(args: SelectSubset<T, NotificationPreferenceDeleteArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NotificationPreference.
     * @param {NotificationPreferenceUpdateArgs} args - Arguments to update one NotificationPreference.
     * @example
     * // Update one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationPreferenceUpdateArgs>(args: SelectSubset<T, NotificationPreferenceUpdateArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NotificationPreferences.
     * @param {NotificationPreferenceDeleteManyArgs} args - Arguments to filter NotificationPreferences to delete.
     * @example
     * // Delete a few NotificationPreferences
     * const { count } = await prisma.notificationPreference.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationPreferenceDeleteManyArgs>(args?: SelectSubset<T, NotificationPreferenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationPreferenceUpdateManyArgs>(args: SelectSubset<T, NotificationPreferenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NotificationPreference.
     * @param {NotificationPreferenceUpsertArgs} args - Arguments to update or create a NotificationPreference.
     * @example
     * // Update or create a NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.upsert({
     *   create: {
     *     // ... data to create a NotificationPreference
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationPreference we want to update
     *   }
     * })
     */
    upsert<T extends NotificationPreferenceUpsertArgs>(args: SelectSubset<T, NotificationPreferenceUpsertArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NotificationPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceCountArgs} args - Arguments to filter NotificationPreferences to count.
     * @example
     * // Count the number of NotificationPreferences
     * const count = await prisma.notificationPreference.count({
     *   where: {
     *     // ... the filter for the NotificationPreferences we want to count
     *   }
     * })
    **/
    count<T extends NotificationPreferenceCountArgs>(
      args?: Subset<T, NotificationPreferenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationPreferenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationPreferenceAggregateArgs>(args: Subset<T, NotificationPreferenceAggregateArgs>): Prisma.PrismaPromise<GetNotificationPreferenceAggregateType<T>>

    /**
     * Group by NotificationPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationPreferenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationPreferenceGroupByArgs['orderBy'] }
        : { orderBy?: NotificationPreferenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationPreferenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationPreferenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationPreference model
   */
  readonly fields: NotificationPreferenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationPreference.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationPreferenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends CenterUserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CenterUserDefaultArgs<ExtArgs>>): Prisma__CenterUserClient<$Result.GetResult<Prisma.$CenterUserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationPreference model
   */ 
  interface NotificationPreferenceFieldRefs {
    readonly id: FieldRef<"NotificationPreference", 'String'>
    readonly userId: FieldRef<"NotificationPreference", 'String'>
    readonly notificationType: FieldRef<"NotificationPreference", 'String'>
    readonly emailEnabled: FieldRef<"NotificationPreference", 'Boolean'>
    readonly smsEnabled: FieldRef<"NotificationPreference", 'Boolean'>
    readonly createdAt: FieldRef<"NotificationPreference", 'DateTime'>
    readonly updatedAt: FieldRef<"NotificationPreference", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NotificationPreference findUnique
   */
  export type NotificationPreferenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference findUniqueOrThrow
   */
  export type NotificationPreferenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference findFirst
   */
  export type NotificationPreferenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationPreferences.
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationPreferences.
     */
    distinct?: NotificationPreferenceScalarFieldEnum | NotificationPreferenceScalarFieldEnum[]
  }

  /**
   * NotificationPreference findFirstOrThrow
   */
  export type NotificationPreferenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationPreferences.
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationPreferences.
     */
    distinct?: NotificationPreferenceScalarFieldEnum | NotificationPreferenceScalarFieldEnum[]
  }

  /**
   * NotificationPreference findMany
   */
  export type NotificationPreferenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreferences to fetch.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationPreferences.
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    distinct?: NotificationPreferenceScalarFieldEnum | NotificationPreferenceScalarFieldEnum[]
  }

  /**
   * NotificationPreference create
   */
  export type NotificationPreferenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * The data needed to create a NotificationPreference.
     */
    data: XOR<NotificationPreferenceCreateInput, NotificationPreferenceUncheckedCreateInput>
  }

  /**
   * NotificationPreference createMany
   */
  export type NotificationPreferenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationPreferences.
     */
    data: NotificationPreferenceCreateManyInput | NotificationPreferenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationPreference createManyAndReturn
   */
  export type NotificationPreferenceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NotificationPreferences.
     */
    data: NotificationPreferenceCreateManyInput | NotificationPreferenceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationPreference update
   */
  export type NotificationPreferenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * The data needed to update a NotificationPreference.
     */
    data: XOR<NotificationPreferenceUpdateInput, NotificationPreferenceUncheckedUpdateInput>
    /**
     * Choose, which NotificationPreference to update.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference updateMany
   */
  export type NotificationPreferenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationPreferences.
     */
    data: XOR<NotificationPreferenceUpdateManyMutationInput, NotificationPreferenceUncheckedUpdateManyInput>
    /**
     * Filter which NotificationPreferences to update
     */
    where?: NotificationPreferenceWhereInput
  }

  /**
   * NotificationPreference upsert
   */
  export type NotificationPreferenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * The filter to search for the NotificationPreference to update in case it exists.
     */
    where: NotificationPreferenceWhereUniqueInput
    /**
     * In case the NotificationPreference found by the `where` argument doesn't exist, create a new NotificationPreference with this data.
     */
    create: XOR<NotificationPreferenceCreateInput, NotificationPreferenceUncheckedCreateInput>
    /**
     * In case the NotificationPreference was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationPreferenceUpdateInput, NotificationPreferenceUncheckedUpdateInput>
  }

  /**
   * NotificationPreference delete
   */
  export type NotificationPreferenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter which NotificationPreference to delete.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference deleteMany
   */
  export type NotificationPreferenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationPreferences to delete
     */
    where?: NotificationPreferenceWhereInput
  }

  /**
   * NotificationPreference without action
   */
  export type NotificationPreferenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
  }


  /**
   * Model NotificationLog
   */

  export type AggregateNotificationLog = {
    _count: NotificationLogCountAggregateOutputType | null
    _min: NotificationLogMinAggregateOutputType | null
    _max: NotificationLogMaxAggregateOutputType | null
  }

  export type NotificationLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    notificationType: string | null
    channel: string | null
    status: string | null
    sentAt: Date | null
    deliveredAt: Date | null
    errorMessage: string | null
  }

  export type NotificationLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    notificationType: string | null
    channel: string | null
    status: string | null
    sentAt: Date | null
    deliveredAt: Date | null
    errorMessage: string | null
  }

  export type NotificationLogCountAggregateOutputType = {
    id: number
    userId: number
    notificationType: number
    channel: number
    status: number
    sentAt: number
    deliveredAt: number
    errorMessage: number
    _all: number
  }


  export type NotificationLogMinAggregateInputType = {
    id?: true
    userId?: true
    notificationType?: true
    channel?: true
    status?: true
    sentAt?: true
    deliveredAt?: true
    errorMessage?: true
  }

  export type NotificationLogMaxAggregateInputType = {
    id?: true
    userId?: true
    notificationType?: true
    channel?: true
    status?: true
    sentAt?: true
    deliveredAt?: true
    errorMessage?: true
  }

  export type NotificationLogCountAggregateInputType = {
    id?: true
    userId?: true
    notificationType?: true
    channel?: true
    status?: true
    sentAt?: true
    deliveredAt?: true
    errorMessage?: true
    _all?: true
  }

  export type NotificationLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationLog to aggregate.
     */
    where?: NotificationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationLogs to fetch.
     */
    orderBy?: NotificationLogOrderByWithRelationInput | NotificationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationLogs
    **/
    _count?: true | NotificationLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationLogMaxAggregateInputType
  }

  export type GetNotificationLogAggregateType<T extends NotificationLogAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationLog[P]>
      : GetScalarType<T[P], AggregateNotificationLog[P]>
  }




  export type NotificationLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationLogWhereInput
    orderBy?: NotificationLogOrderByWithAggregationInput | NotificationLogOrderByWithAggregationInput[]
    by: NotificationLogScalarFieldEnum[] | NotificationLogScalarFieldEnum
    having?: NotificationLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationLogCountAggregateInputType | true
    _min?: NotificationLogMinAggregateInputType
    _max?: NotificationLogMaxAggregateInputType
  }

  export type NotificationLogGroupByOutputType = {
    id: string
    userId: string
    notificationType: string
    channel: string
    status: string
    sentAt: Date
    deliveredAt: Date | null
    errorMessage: string | null
    _count: NotificationLogCountAggregateOutputType | null
    _min: NotificationLogMinAggregateOutputType | null
    _max: NotificationLogMaxAggregateOutputType | null
  }

  type GetNotificationLogGroupByPayload<T extends NotificationLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationLogGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationLogGroupByOutputType[P]>
        }
      >
    >


  export type NotificationLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    notificationType?: boolean
    channel?: boolean
    status?: boolean
    sentAt?: boolean
    deliveredAt?: boolean
    errorMessage?: boolean
    user?: boolean | CenterUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationLog"]>

  export type NotificationLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    notificationType?: boolean
    channel?: boolean
    status?: boolean
    sentAt?: boolean
    deliveredAt?: boolean
    errorMessage?: boolean
    user?: boolean | CenterUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationLog"]>

  export type NotificationLogSelectScalar = {
    id?: boolean
    userId?: boolean
    notificationType?: boolean
    channel?: boolean
    status?: boolean
    sentAt?: boolean
    deliveredAt?: boolean
    errorMessage?: boolean
  }

  export type NotificationLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | CenterUserDefaultArgs<ExtArgs>
  }
  export type NotificationLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | CenterUserDefaultArgs<ExtArgs>
  }

  export type $NotificationLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationLog"
    objects: {
      user: Prisma.$CenterUserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      notificationType: string
      channel: string
      status: string
      sentAt: Date
      deliveredAt: Date | null
      errorMessage: string | null
    }, ExtArgs["result"]["notificationLog"]>
    composites: {}
  }

  type NotificationLogGetPayload<S extends boolean | null | undefined | NotificationLogDefaultArgs> = $Result.GetResult<Prisma.$NotificationLogPayload, S>

  type NotificationLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationLogCountAggregateInputType | true
    }

  export interface NotificationLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationLog'], meta: { name: 'NotificationLog' } }
    /**
     * Find zero or one NotificationLog that matches the filter.
     * @param {NotificationLogFindUniqueArgs} args - Arguments to find a NotificationLog
     * @example
     * // Get one NotificationLog
     * const notificationLog = await prisma.notificationLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationLogFindUniqueArgs>(args: SelectSubset<T, NotificationLogFindUniqueArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NotificationLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationLogFindUniqueOrThrowArgs} args - Arguments to find a NotificationLog
     * @example
     * // Get one NotificationLog
     * const notificationLog = await prisma.notificationLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationLogFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NotificationLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogFindFirstArgs} args - Arguments to find a NotificationLog
     * @example
     * // Get one NotificationLog
     * const notificationLog = await prisma.notificationLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationLogFindFirstArgs>(args?: SelectSubset<T, NotificationLogFindFirstArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NotificationLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogFindFirstOrThrowArgs} args - Arguments to find a NotificationLog
     * @example
     * // Get one NotificationLog
     * const notificationLog = await prisma.notificationLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationLogFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NotificationLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationLogs
     * const notificationLogs = await prisma.notificationLog.findMany()
     * 
     * // Get first 10 NotificationLogs
     * const notificationLogs = await prisma.notificationLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationLogWithIdOnly = await prisma.notificationLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationLogFindManyArgs>(args?: SelectSubset<T, NotificationLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NotificationLog.
     * @param {NotificationLogCreateArgs} args - Arguments to create a NotificationLog.
     * @example
     * // Create one NotificationLog
     * const NotificationLog = await prisma.notificationLog.create({
     *   data: {
     *     // ... data to create a NotificationLog
     *   }
     * })
     * 
     */
    create<T extends NotificationLogCreateArgs>(args: SelectSubset<T, NotificationLogCreateArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NotificationLogs.
     * @param {NotificationLogCreateManyArgs} args - Arguments to create many NotificationLogs.
     * @example
     * // Create many NotificationLogs
     * const notificationLog = await prisma.notificationLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationLogCreateManyArgs>(args?: SelectSubset<T, NotificationLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationLogs and returns the data saved in the database.
     * @param {NotificationLogCreateManyAndReturnArgs} args - Arguments to create many NotificationLogs.
     * @example
     * // Create many NotificationLogs
     * const notificationLog = await prisma.notificationLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationLogs and only return the `id`
     * const notificationLogWithIdOnly = await prisma.notificationLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationLogCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NotificationLog.
     * @param {NotificationLogDeleteArgs} args - Arguments to delete one NotificationLog.
     * @example
     * // Delete one NotificationLog
     * const NotificationLog = await prisma.notificationLog.delete({
     *   where: {
     *     // ... filter to delete one NotificationLog
     *   }
     * })
     * 
     */
    delete<T extends NotificationLogDeleteArgs>(args: SelectSubset<T, NotificationLogDeleteArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NotificationLog.
     * @param {NotificationLogUpdateArgs} args - Arguments to update one NotificationLog.
     * @example
     * // Update one NotificationLog
     * const notificationLog = await prisma.notificationLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationLogUpdateArgs>(args: SelectSubset<T, NotificationLogUpdateArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NotificationLogs.
     * @param {NotificationLogDeleteManyArgs} args - Arguments to filter NotificationLogs to delete.
     * @example
     * // Delete a few NotificationLogs
     * const { count } = await prisma.notificationLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationLogDeleteManyArgs>(args?: SelectSubset<T, NotificationLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationLogs
     * const notificationLog = await prisma.notificationLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationLogUpdateManyArgs>(args: SelectSubset<T, NotificationLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NotificationLog.
     * @param {NotificationLogUpsertArgs} args - Arguments to update or create a NotificationLog.
     * @example
     * // Update or create a NotificationLog
     * const notificationLog = await prisma.notificationLog.upsert({
     *   create: {
     *     // ... data to create a NotificationLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationLog we want to update
     *   }
     * })
     */
    upsert<T extends NotificationLogUpsertArgs>(args: SelectSubset<T, NotificationLogUpsertArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NotificationLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogCountArgs} args - Arguments to filter NotificationLogs to count.
     * @example
     * // Count the number of NotificationLogs
     * const count = await prisma.notificationLog.count({
     *   where: {
     *     // ... the filter for the NotificationLogs we want to count
     *   }
     * })
    **/
    count<T extends NotificationLogCountArgs>(
      args?: Subset<T, NotificationLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationLogAggregateArgs>(args: Subset<T, NotificationLogAggregateArgs>): Prisma.PrismaPromise<GetNotificationLogAggregateType<T>>

    /**
     * Group by NotificationLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationLogGroupByArgs['orderBy'] }
        : { orderBy?: NotificationLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationLog model
   */
  readonly fields: NotificationLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends CenterUserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CenterUserDefaultArgs<ExtArgs>>): Prisma__CenterUserClient<$Result.GetResult<Prisma.$CenterUserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationLog model
   */ 
  interface NotificationLogFieldRefs {
    readonly id: FieldRef<"NotificationLog", 'String'>
    readonly userId: FieldRef<"NotificationLog", 'String'>
    readonly notificationType: FieldRef<"NotificationLog", 'String'>
    readonly channel: FieldRef<"NotificationLog", 'String'>
    readonly status: FieldRef<"NotificationLog", 'String'>
    readonly sentAt: FieldRef<"NotificationLog", 'DateTime'>
    readonly deliveredAt: FieldRef<"NotificationLog", 'DateTime'>
    readonly errorMessage: FieldRef<"NotificationLog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * NotificationLog findUnique
   */
  export type NotificationLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    /**
     * Filter, which NotificationLog to fetch.
     */
    where: NotificationLogWhereUniqueInput
  }

  /**
   * NotificationLog findUniqueOrThrow
   */
  export type NotificationLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    /**
     * Filter, which NotificationLog to fetch.
     */
    where: NotificationLogWhereUniqueInput
  }

  /**
   * NotificationLog findFirst
   */
  export type NotificationLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    /**
     * Filter, which NotificationLog to fetch.
     */
    where?: NotificationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationLogs to fetch.
     */
    orderBy?: NotificationLogOrderByWithRelationInput | NotificationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationLogs.
     */
    cursor?: NotificationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationLogs.
     */
    distinct?: NotificationLogScalarFieldEnum | NotificationLogScalarFieldEnum[]
  }

  /**
   * NotificationLog findFirstOrThrow
   */
  export type NotificationLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    /**
     * Filter, which NotificationLog to fetch.
     */
    where?: NotificationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationLogs to fetch.
     */
    orderBy?: NotificationLogOrderByWithRelationInput | NotificationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationLogs.
     */
    cursor?: NotificationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationLogs.
     */
    distinct?: NotificationLogScalarFieldEnum | NotificationLogScalarFieldEnum[]
  }

  /**
   * NotificationLog findMany
   */
  export type NotificationLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    /**
     * Filter, which NotificationLogs to fetch.
     */
    where?: NotificationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationLogs to fetch.
     */
    orderBy?: NotificationLogOrderByWithRelationInput | NotificationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationLogs.
     */
    cursor?: NotificationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationLogs.
     */
    skip?: number
    distinct?: NotificationLogScalarFieldEnum | NotificationLogScalarFieldEnum[]
  }

  /**
   * NotificationLog create
   */
  export type NotificationLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    /**
     * The data needed to create a NotificationLog.
     */
    data: XOR<NotificationLogCreateInput, NotificationLogUncheckedCreateInput>
  }

  /**
   * NotificationLog createMany
   */
  export type NotificationLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationLogs.
     */
    data: NotificationLogCreateManyInput | NotificationLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationLog createManyAndReturn
   */
  export type NotificationLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NotificationLogs.
     */
    data: NotificationLogCreateManyInput | NotificationLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationLog update
   */
  export type NotificationLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    /**
     * The data needed to update a NotificationLog.
     */
    data: XOR<NotificationLogUpdateInput, NotificationLogUncheckedUpdateInput>
    /**
     * Choose, which NotificationLog to update.
     */
    where: NotificationLogWhereUniqueInput
  }

  /**
   * NotificationLog updateMany
   */
  export type NotificationLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationLogs.
     */
    data: XOR<NotificationLogUpdateManyMutationInput, NotificationLogUncheckedUpdateManyInput>
    /**
     * Filter which NotificationLogs to update
     */
    where?: NotificationLogWhereInput
  }

  /**
   * NotificationLog upsert
   */
  export type NotificationLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    /**
     * The filter to search for the NotificationLog to update in case it exists.
     */
    where: NotificationLogWhereUniqueInput
    /**
     * In case the NotificationLog found by the `where` argument doesn't exist, create a new NotificationLog with this data.
     */
    create: XOR<NotificationLogCreateInput, NotificationLogUncheckedCreateInput>
    /**
     * In case the NotificationLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationLogUpdateInput, NotificationLogUncheckedUpdateInput>
  }

  /**
   * NotificationLog delete
   */
  export type NotificationLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    /**
     * Filter which NotificationLog to delete.
     */
    where: NotificationLogWhereUniqueInput
  }

  /**
   * NotificationLog deleteMany
   */
  export type NotificationLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationLogs to delete
     */
    where?: NotificationLogWhereInput
  }

  /**
   * NotificationLog without action
   */
  export type NotificationLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
  }


  /**
   * Model DropdownOption
   */

  export type AggregateDropdownOption = {
    _count: DropdownOptionCountAggregateOutputType | null
    _min: DropdownOptionMinAggregateOutputType | null
    _max: DropdownOptionMaxAggregateOutputType | null
  }

  export type DropdownOptionMinAggregateOutputType = {
    id: string | null
    category: string | null
    value: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DropdownOptionMaxAggregateOutputType = {
    id: string | null
    category: string | null
    value: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DropdownOptionCountAggregateOutputType = {
    id: number
    category: number
    value: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DropdownOptionMinAggregateInputType = {
    id?: true
    category?: true
    value?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DropdownOptionMaxAggregateInputType = {
    id?: true
    category?: true
    value?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DropdownOptionCountAggregateInputType = {
    id?: true
    category?: true
    value?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DropdownOptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DropdownOption to aggregate.
     */
    where?: DropdownOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DropdownOptions to fetch.
     */
    orderBy?: DropdownOptionOrderByWithRelationInput | DropdownOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DropdownOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DropdownOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DropdownOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DropdownOptions
    **/
    _count?: true | DropdownOptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DropdownOptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DropdownOptionMaxAggregateInputType
  }

  export type GetDropdownOptionAggregateType<T extends DropdownOptionAggregateArgs> = {
        [P in keyof T & keyof AggregateDropdownOption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDropdownOption[P]>
      : GetScalarType<T[P], AggregateDropdownOption[P]>
  }




  export type DropdownOptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DropdownOptionWhereInput
    orderBy?: DropdownOptionOrderByWithAggregationInput | DropdownOptionOrderByWithAggregationInput[]
    by: DropdownOptionScalarFieldEnum[] | DropdownOptionScalarFieldEnum
    having?: DropdownOptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DropdownOptionCountAggregateInputType | true
    _min?: DropdownOptionMinAggregateInputType
    _max?: DropdownOptionMaxAggregateInputType
  }

  export type DropdownOptionGroupByOutputType = {
    id: string
    category: string
    value: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: DropdownOptionCountAggregateOutputType | null
    _min: DropdownOptionMinAggregateOutputType | null
    _max: DropdownOptionMaxAggregateOutputType | null
  }

  type GetDropdownOptionGroupByPayload<T extends DropdownOptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DropdownOptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DropdownOptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DropdownOptionGroupByOutputType[P]>
            : GetScalarType<T[P], DropdownOptionGroupByOutputType[P]>
        }
      >
    >


  export type DropdownOptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    value?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    defaultFor?: boolean | DropdownOption$defaultForArgs<ExtArgs>
  }, ExtArgs["result"]["dropdownOption"]>

  export type DropdownOptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    value?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["dropdownOption"]>

  export type DropdownOptionSelectScalar = {
    id?: boolean
    category?: boolean
    value?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DropdownOptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    defaultFor?: boolean | DropdownOption$defaultForArgs<ExtArgs>
  }
  export type DropdownOptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DropdownOptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DropdownOption"
    objects: {
      defaultFor: Prisma.$CategoryDefaultPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      category: string
      value: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dropdownOption"]>
    composites: {}
  }

  type DropdownOptionGetPayload<S extends boolean | null | undefined | DropdownOptionDefaultArgs> = $Result.GetResult<Prisma.$DropdownOptionPayload, S>

  type DropdownOptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DropdownOptionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DropdownOptionCountAggregateInputType | true
    }

  export interface DropdownOptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DropdownOption'], meta: { name: 'DropdownOption' } }
    /**
     * Find zero or one DropdownOption that matches the filter.
     * @param {DropdownOptionFindUniqueArgs} args - Arguments to find a DropdownOption
     * @example
     * // Get one DropdownOption
     * const dropdownOption = await prisma.dropdownOption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DropdownOptionFindUniqueArgs>(args: SelectSubset<T, DropdownOptionFindUniqueArgs<ExtArgs>>): Prisma__DropdownOptionClient<$Result.GetResult<Prisma.$DropdownOptionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DropdownOption that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DropdownOptionFindUniqueOrThrowArgs} args - Arguments to find a DropdownOption
     * @example
     * // Get one DropdownOption
     * const dropdownOption = await prisma.dropdownOption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DropdownOptionFindUniqueOrThrowArgs>(args: SelectSubset<T, DropdownOptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DropdownOptionClient<$Result.GetResult<Prisma.$DropdownOptionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DropdownOption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DropdownOptionFindFirstArgs} args - Arguments to find a DropdownOption
     * @example
     * // Get one DropdownOption
     * const dropdownOption = await prisma.dropdownOption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DropdownOptionFindFirstArgs>(args?: SelectSubset<T, DropdownOptionFindFirstArgs<ExtArgs>>): Prisma__DropdownOptionClient<$Result.GetResult<Prisma.$DropdownOptionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DropdownOption that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DropdownOptionFindFirstOrThrowArgs} args - Arguments to find a DropdownOption
     * @example
     * // Get one DropdownOption
     * const dropdownOption = await prisma.dropdownOption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DropdownOptionFindFirstOrThrowArgs>(args?: SelectSubset<T, DropdownOptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__DropdownOptionClient<$Result.GetResult<Prisma.$DropdownOptionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DropdownOptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DropdownOptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DropdownOptions
     * const dropdownOptions = await prisma.dropdownOption.findMany()
     * 
     * // Get first 10 DropdownOptions
     * const dropdownOptions = await prisma.dropdownOption.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dropdownOptionWithIdOnly = await prisma.dropdownOption.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DropdownOptionFindManyArgs>(args?: SelectSubset<T, DropdownOptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DropdownOptionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DropdownOption.
     * @param {DropdownOptionCreateArgs} args - Arguments to create a DropdownOption.
     * @example
     * // Create one DropdownOption
     * const DropdownOption = await prisma.dropdownOption.create({
     *   data: {
     *     // ... data to create a DropdownOption
     *   }
     * })
     * 
     */
    create<T extends DropdownOptionCreateArgs>(args: SelectSubset<T, DropdownOptionCreateArgs<ExtArgs>>): Prisma__DropdownOptionClient<$Result.GetResult<Prisma.$DropdownOptionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DropdownOptions.
     * @param {DropdownOptionCreateManyArgs} args - Arguments to create many DropdownOptions.
     * @example
     * // Create many DropdownOptions
     * const dropdownOption = await prisma.dropdownOption.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DropdownOptionCreateManyArgs>(args?: SelectSubset<T, DropdownOptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DropdownOptions and returns the data saved in the database.
     * @param {DropdownOptionCreateManyAndReturnArgs} args - Arguments to create many DropdownOptions.
     * @example
     * // Create many DropdownOptions
     * const dropdownOption = await prisma.dropdownOption.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DropdownOptions and only return the `id`
     * const dropdownOptionWithIdOnly = await prisma.dropdownOption.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DropdownOptionCreateManyAndReturnArgs>(args?: SelectSubset<T, DropdownOptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DropdownOptionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DropdownOption.
     * @param {DropdownOptionDeleteArgs} args - Arguments to delete one DropdownOption.
     * @example
     * // Delete one DropdownOption
     * const DropdownOption = await prisma.dropdownOption.delete({
     *   where: {
     *     // ... filter to delete one DropdownOption
     *   }
     * })
     * 
     */
    delete<T extends DropdownOptionDeleteArgs>(args: SelectSubset<T, DropdownOptionDeleteArgs<ExtArgs>>): Prisma__DropdownOptionClient<$Result.GetResult<Prisma.$DropdownOptionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DropdownOption.
     * @param {DropdownOptionUpdateArgs} args - Arguments to update one DropdownOption.
     * @example
     * // Update one DropdownOption
     * const dropdownOption = await prisma.dropdownOption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DropdownOptionUpdateArgs>(args: SelectSubset<T, DropdownOptionUpdateArgs<ExtArgs>>): Prisma__DropdownOptionClient<$Result.GetResult<Prisma.$DropdownOptionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DropdownOptions.
     * @param {DropdownOptionDeleteManyArgs} args - Arguments to filter DropdownOptions to delete.
     * @example
     * // Delete a few DropdownOptions
     * const { count } = await prisma.dropdownOption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DropdownOptionDeleteManyArgs>(args?: SelectSubset<T, DropdownOptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DropdownOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DropdownOptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DropdownOptions
     * const dropdownOption = await prisma.dropdownOption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DropdownOptionUpdateManyArgs>(args: SelectSubset<T, DropdownOptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DropdownOption.
     * @param {DropdownOptionUpsertArgs} args - Arguments to update or create a DropdownOption.
     * @example
     * // Update or create a DropdownOption
     * const dropdownOption = await prisma.dropdownOption.upsert({
     *   create: {
     *     // ... data to create a DropdownOption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DropdownOption we want to update
     *   }
     * })
     */
    upsert<T extends DropdownOptionUpsertArgs>(args: SelectSubset<T, DropdownOptionUpsertArgs<ExtArgs>>): Prisma__DropdownOptionClient<$Result.GetResult<Prisma.$DropdownOptionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DropdownOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DropdownOptionCountArgs} args - Arguments to filter DropdownOptions to count.
     * @example
     * // Count the number of DropdownOptions
     * const count = await prisma.dropdownOption.count({
     *   where: {
     *     // ... the filter for the DropdownOptions we want to count
     *   }
     * })
    **/
    count<T extends DropdownOptionCountArgs>(
      args?: Subset<T, DropdownOptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DropdownOptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DropdownOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DropdownOptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DropdownOptionAggregateArgs>(args: Subset<T, DropdownOptionAggregateArgs>): Prisma.PrismaPromise<GetDropdownOptionAggregateType<T>>

    /**
     * Group by DropdownOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DropdownOptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DropdownOptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DropdownOptionGroupByArgs['orderBy'] }
        : { orderBy?: DropdownOptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DropdownOptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDropdownOptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DropdownOption model
   */
  readonly fields: DropdownOptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DropdownOption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DropdownOptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    defaultFor<T extends DropdownOption$defaultForArgs<ExtArgs> = {}>(args?: Subset<T, DropdownOption$defaultForArgs<ExtArgs>>): Prisma__CategoryDefaultClient<$Result.GetResult<Prisma.$CategoryDefaultPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DropdownOption model
   */ 
  interface DropdownOptionFieldRefs {
    readonly id: FieldRef<"DropdownOption", 'String'>
    readonly category: FieldRef<"DropdownOption", 'String'>
    readonly value: FieldRef<"DropdownOption", 'String'>
    readonly isActive: FieldRef<"DropdownOption", 'Boolean'>
    readonly createdAt: FieldRef<"DropdownOption", 'DateTime'>
    readonly updatedAt: FieldRef<"DropdownOption", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DropdownOption findUnique
   */
  export type DropdownOptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropdownOption
     */
    select?: DropdownOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DropdownOptionInclude<ExtArgs> | null
    /**
     * Filter, which DropdownOption to fetch.
     */
    where: DropdownOptionWhereUniqueInput
  }

  /**
   * DropdownOption findUniqueOrThrow
   */
  export type DropdownOptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropdownOption
     */
    select?: DropdownOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DropdownOptionInclude<ExtArgs> | null
    /**
     * Filter, which DropdownOption to fetch.
     */
    where: DropdownOptionWhereUniqueInput
  }

  /**
   * DropdownOption findFirst
   */
  export type DropdownOptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropdownOption
     */
    select?: DropdownOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DropdownOptionInclude<ExtArgs> | null
    /**
     * Filter, which DropdownOption to fetch.
     */
    where?: DropdownOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DropdownOptions to fetch.
     */
    orderBy?: DropdownOptionOrderByWithRelationInput | DropdownOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DropdownOptions.
     */
    cursor?: DropdownOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DropdownOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DropdownOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DropdownOptions.
     */
    distinct?: DropdownOptionScalarFieldEnum | DropdownOptionScalarFieldEnum[]
  }

  /**
   * DropdownOption findFirstOrThrow
   */
  export type DropdownOptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropdownOption
     */
    select?: DropdownOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DropdownOptionInclude<ExtArgs> | null
    /**
     * Filter, which DropdownOption to fetch.
     */
    where?: DropdownOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DropdownOptions to fetch.
     */
    orderBy?: DropdownOptionOrderByWithRelationInput | DropdownOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DropdownOptions.
     */
    cursor?: DropdownOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DropdownOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DropdownOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DropdownOptions.
     */
    distinct?: DropdownOptionScalarFieldEnum | DropdownOptionScalarFieldEnum[]
  }

  /**
   * DropdownOption findMany
   */
  export type DropdownOptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropdownOption
     */
    select?: DropdownOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DropdownOptionInclude<ExtArgs> | null
    /**
     * Filter, which DropdownOptions to fetch.
     */
    where?: DropdownOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DropdownOptions to fetch.
     */
    orderBy?: DropdownOptionOrderByWithRelationInput | DropdownOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DropdownOptions.
     */
    cursor?: DropdownOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DropdownOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DropdownOptions.
     */
    skip?: number
    distinct?: DropdownOptionScalarFieldEnum | DropdownOptionScalarFieldEnum[]
  }

  /**
   * DropdownOption create
   */
  export type DropdownOptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropdownOption
     */
    select?: DropdownOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DropdownOptionInclude<ExtArgs> | null
    /**
     * The data needed to create a DropdownOption.
     */
    data: XOR<DropdownOptionCreateInput, DropdownOptionUncheckedCreateInput>
  }

  /**
   * DropdownOption createMany
   */
  export type DropdownOptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DropdownOptions.
     */
    data: DropdownOptionCreateManyInput | DropdownOptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DropdownOption createManyAndReturn
   */
  export type DropdownOptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropdownOption
     */
    select?: DropdownOptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DropdownOptions.
     */
    data: DropdownOptionCreateManyInput | DropdownOptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DropdownOption update
   */
  export type DropdownOptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropdownOption
     */
    select?: DropdownOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DropdownOptionInclude<ExtArgs> | null
    /**
     * The data needed to update a DropdownOption.
     */
    data: XOR<DropdownOptionUpdateInput, DropdownOptionUncheckedUpdateInput>
    /**
     * Choose, which DropdownOption to update.
     */
    where: DropdownOptionWhereUniqueInput
  }

  /**
   * DropdownOption updateMany
   */
  export type DropdownOptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DropdownOptions.
     */
    data: XOR<DropdownOptionUpdateManyMutationInput, DropdownOptionUncheckedUpdateManyInput>
    /**
     * Filter which DropdownOptions to update
     */
    where?: DropdownOptionWhereInput
  }

  /**
   * DropdownOption upsert
   */
  export type DropdownOptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropdownOption
     */
    select?: DropdownOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DropdownOptionInclude<ExtArgs> | null
    /**
     * The filter to search for the DropdownOption to update in case it exists.
     */
    where: DropdownOptionWhereUniqueInput
    /**
     * In case the DropdownOption found by the `where` argument doesn't exist, create a new DropdownOption with this data.
     */
    create: XOR<DropdownOptionCreateInput, DropdownOptionUncheckedCreateInput>
    /**
     * In case the DropdownOption was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DropdownOptionUpdateInput, DropdownOptionUncheckedUpdateInput>
  }

  /**
   * DropdownOption delete
   */
  export type DropdownOptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropdownOption
     */
    select?: DropdownOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DropdownOptionInclude<ExtArgs> | null
    /**
     * Filter which DropdownOption to delete.
     */
    where: DropdownOptionWhereUniqueInput
  }

  /**
   * DropdownOption deleteMany
   */
  export type DropdownOptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DropdownOptions to delete
     */
    where?: DropdownOptionWhereInput
  }

  /**
   * DropdownOption.defaultFor
   */
  export type DropdownOption$defaultForArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryDefault
     */
    select?: CategoryDefaultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryDefaultInclude<ExtArgs> | null
    where?: CategoryDefaultWhereInput
  }

  /**
   * DropdownOption without action
   */
  export type DropdownOptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropdownOption
     */
    select?: DropdownOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DropdownOptionInclude<ExtArgs> | null
  }


  /**
   * Model CategoryDefault
   */

  export type AggregateCategoryDefault = {
    _count: CategoryDefaultCountAggregateOutputType | null
    _min: CategoryDefaultMinAggregateOutputType | null
    _max: CategoryDefaultMaxAggregateOutputType | null
  }

  export type CategoryDefaultMinAggregateOutputType = {
    id: string | null
    category: string | null
    optionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryDefaultMaxAggregateOutputType = {
    id: string | null
    category: string | null
    optionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryDefaultCountAggregateOutputType = {
    id: number
    category: number
    optionId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CategoryDefaultMinAggregateInputType = {
    id?: true
    category?: true
    optionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryDefaultMaxAggregateInputType = {
    id?: true
    category?: true
    optionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryDefaultCountAggregateInputType = {
    id?: true
    category?: true
    optionId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CategoryDefaultAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CategoryDefault to aggregate.
     */
    where?: CategoryDefaultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoryDefaults to fetch.
     */
    orderBy?: CategoryDefaultOrderByWithRelationInput | CategoryDefaultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryDefaultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoryDefaults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoryDefaults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CategoryDefaults
    **/
    _count?: true | CategoryDefaultCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryDefaultMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryDefaultMaxAggregateInputType
  }

  export type GetCategoryDefaultAggregateType<T extends CategoryDefaultAggregateArgs> = {
        [P in keyof T & keyof AggregateCategoryDefault]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategoryDefault[P]>
      : GetScalarType<T[P], AggregateCategoryDefault[P]>
  }




  export type CategoryDefaultGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryDefaultWhereInput
    orderBy?: CategoryDefaultOrderByWithAggregationInput | CategoryDefaultOrderByWithAggregationInput[]
    by: CategoryDefaultScalarFieldEnum[] | CategoryDefaultScalarFieldEnum
    having?: CategoryDefaultScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryDefaultCountAggregateInputType | true
    _min?: CategoryDefaultMinAggregateInputType
    _max?: CategoryDefaultMaxAggregateInputType
  }

  export type CategoryDefaultGroupByOutputType = {
    id: string
    category: string
    optionId: string
    createdAt: Date
    updatedAt: Date
    _count: CategoryDefaultCountAggregateOutputType | null
    _min: CategoryDefaultMinAggregateOutputType | null
    _max: CategoryDefaultMaxAggregateOutputType | null
  }

  type GetCategoryDefaultGroupByPayload<T extends CategoryDefaultGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryDefaultGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryDefaultGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryDefaultGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryDefaultGroupByOutputType[P]>
        }
      >
    >


  export type CategoryDefaultSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    optionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    option?: boolean | DropdownOptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categoryDefault"]>

  export type CategoryDefaultSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    optionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    option?: boolean | DropdownOptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categoryDefault"]>

  export type CategoryDefaultSelectScalar = {
    id?: boolean
    category?: boolean
    optionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CategoryDefaultInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    option?: boolean | DropdownOptionDefaultArgs<ExtArgs>
  }
  export type CategoryDefaultIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    option?: boolean | DropdownOptionDefaultArgs<ExtArgs>
  }

  export type $CategoryDefaultPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CategoryDefault"
    objects: {
      option: Prisma.$DropdownOptionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      category: string
      optionId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["categoryDefault"]>
    composites: {}
  }

  type CategoryDefaultGetPayload<S extends boolean | null | undefined | CategoryDefaultDefaultArgs> = $Result.GetResult<Prisma.$CategoryDefaultPayload, S>

  type CategoryDefaultCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CategoryDefaultFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CategoryDefaultCountAggregateInputType | true
    }

  export interface CategoryDefaultDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CategoryDefault'], meta: { name: 'CategoryDefault' } }
    /**
     * Find zero or one CategoryDefault that matches the filter.
     * @param {CategoryDefaultFindUniqueArgs} args - Arguments to find a CategoryDefault
     * @example
     * // Get one CategoryDefault
     * const categoryDefault = await prisma.categoryDefault.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryDefaultFindUniqueArgs>(args: SelectSubset<T, CategoryDefaultFindUniqueArgs<ExtArgs>>): Prisma__CategoryDefaultClient<$Result.GetResult<Prisma.$CategoryDefaultPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CategoryDefault that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CategoryDefaultFindUniqueOrThrowArgs} args - Arguments to find a CategoryDefault
     * @example
     * // Get one CategoryDefault
     * const categoryDefault = await prisma.categoryDefault.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryDefaultFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryDefaultFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryDefaultClient<$Result.GetResult<Prisma.$CategoryDefaultPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CategoryDefault that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryDefaultFindFirstArgs} args - Arguments to find a CategoryDefault
     * @example
     * // Get one CategoryDefault
     * const categoryDefault = await prisma.categoryDefault.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryDefaultFindFirstArgs>(args?: SelectSubset<T, CategoryDefaultFindFirstArgs<ExtArgs>>): Prisma__CategoryDefaultClient<$Result.GetResult<Prisma.$CategoryDefaultPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CategoryDefault that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryDefaultFindFirstOrThrowArgs} args - Arguments to find a CategoryDefault
     * @example
     * // Get one CategoryDefault
     * const categoryDefault = await prisma.categoryDefault.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryDefaultFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryDefaultFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryDefaultClient<$Result.GetResult<Prisma.$CategoryDefaultPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CategoryDefaults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryDefaultFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CategoryDefaults
     * const categoryDefaults = await prisma.categoryDefault.findMany()
     * 
     * // Get first 10 CategoryDefaults
     * const categoryDefaults = await prisma.categoryDefault.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryDefaultWithIdOnly = await prisma.categoryDefault.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryDefaultFindManyArgs>(args?: SelectSubset<T, CategoryDefaultFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryDefaultPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CategoryDefault.
     * @param {CategoryDefaultCreateArgs} args - Arguments to create a CategoryDefault.
     * @example
     * // Create one CategoryDefault
     * const CategoryDefault = await prisma.categoryDefault.create({
     *   data: {
     *     // ... data to create a CategoryDefault
     *   }
     * })
     * 
     */
    create<T extends CategoryDefaultCreateArgs>(args: SelectSubset<T, CategoryDefaultCreateArgs<ExtArgs>>): Prisma__CategoryDefaultClient<$Result.GetResult<Prisma.$CategoryDefaultPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CategoryDefaults.
     * @param {CategoryDefaultCreateManyArgs} args - Arguments to create many CategoryDefaults.
     * @example
     * // Create many CategoryDefaults
     * const categoryDefault = await prisma.categoryDefault.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryDefaultCreateManyArgs>(args?: SelectSubset<T, CategoryDefaultCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CategoryDefaults and returns the data saved in the database.
     * @param {CategoryDefaultCreateManyAndReturnArgs} args - Arguments to create many CategoryDefaults.
     * @example
     * // Create many CategoryDefaults
     * const categoryDefault = await prisma.categoryDefault.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CategoryDefaults and only return the `id`
     * const categoryDefaultWithIdOnly = await prisma.categoryDefault.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryDefaultCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryDefaultCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryDefaultPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CategoryDefault.
     * @param {CategoryDefaultDeleteArgs} args - Arguments to delete one CategoryDefault.
     * @example
     * // Delete one CategoryDefault
     * const CategoryDefault = await prisma.categoryDefault.delete({
     *   where: {
     *     // ... filter to delete one CategoryDefault
     *   }
     * })
     * 
     */
    delete<T extends CategoryDefaultDeleteArgs>(args: SelectSubset<T, CategoryDefaultDeleteArgs<ExtArgs>>): Prisma__CategoryDefaultClient<$Result.GetResult<Prisma.$CategoryDefaultPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CategoryDefault.
     * @param {CategoryDefaultUpdateArgs} args - Arguments to update one CategoryDefault.
     * @example
     * // Update one CategoryDefault
     * const categoryDefault = await prisma.categoryDefault.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryDefaultUpdateArgs>(args: SelectSubset<T, CategoryDefaultUpdateArgs<ExtArgs>>): Prisma__CategoryDefaultClient<$Result.GetResult<Prisma.$CategoryDefaultPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CategoryDefaults.
     * @param {CategoryDefaultDeleteManyArgs} args - Arguments to filter CategoryDefaults to delete.
     * @example
     * // Delete a few CategoryDefaults
     * const { count } = await prisma.categoryDefault.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDefaultDeleteManyArgs>(args?: SelectSubset<T, CategoryDefaultDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CategoryDefaults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryDefaultUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CategoryDefaults
     * const categoryDefault = await prisma.categoryDefault.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryDefaultUpdateManyArgs>(args: SelectSubset<T, CategoryDefaultUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CategoryDefault.
     * @param {CategoryDefaultUpsertArgs} args - Arguments to update or create a CategoryDefault.
     * @example
     * // Update or create a CategoryDefault
     * const categoryDefault = await prisma.categoryDefault.upsert({
     *   create: {
     *     // ... data to create a CategoryDefault
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CategoryDefault we want to update
     *   }
     * })
     */
    upsert<T extends CategoryDefaultUpsertArgs>(args: SelectSubset<T, CategoryDefaultUpsertArgs<ExtArgs>>): Prisma__CategoryDefaultClient<$Result.GetResult<Prisma.$CategoryDefaultPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CategoryDefaults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryDefaultCountArgs} args - Arguments to filter CategoryDefaults to count.
     * @example
     * // Count the number of CategoryDefaults
     * const count = await prisma.categoryDefault.count({
     *   where: {
     *     // ... the filter for the CategoryDefaults we want to count
     *   }
     * })
    **/
    count<T extends CategoryDefaultCountArgs>(
      args?: Subset<T, CategoryDefaultCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryDefaultCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CategoryDefault.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryDefaultAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryDefaultAggregateArgs>(args: Subset<T, CategoryDefaultAggregateArgs>): Prisma.PrismaPromise<GetCategoryDefaultAggregateType<T>>

    /**
     * Group by CategoryDefault.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryDefaultGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryDefaultGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryDefaultGroupByArgs['orderBy'] }
        : { orderBy?: CategoryDefaultGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryDefaultGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryDefaultGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CategoryDefault model
   */
  readonly fields: CategoryDefaultFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CategoryDefault.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryDefaultClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    option<T extends DropdownOptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DropdownOptionDefaultArgs<ExtArgs>>): Prisma__DropdownOptionClient<$Result.GetResult<Prisma.$DropdownOptionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CategoryDefault model
   */ 
  interface CategoryDefaultFieldRefs {
    readonly id: FieldRef<"CategoryDefault", 'String'>
    readonly category: FieldRef<"CategoryDefault", 'String'>
    readonly optionId: FieldRef<"CategoryDefault", 'String'>
    readonly createdAt: FieldRef<"CategoryDefault", 'DateTime'>
    readonly updatedAt: FieldRef<"CategoryDefault", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CategoryDefault findUnique
   */
  export type CategoryDefaultFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryDefault
     */
    select?: CategoryDefaultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryDefaultInclude<ExtArgs> | null
    /**
     * Filter, which CategoryDefault to fetch.
     */
    where: CategoryDefaultWhereUniqueInput
  }

  /**
   * CategoryDefault findUniqueOrThrow
   */
  export type CategoryDefaultFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryDefault
     */
    select?: CategoryDefaultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryDefaultInclude<ExtArgs> | null
    /**
     * Filter, which CategoryDefault to fetch.
     */
    where: CategoryDefaultWhereUniqueInput
  }

  /**
   * CategoryDefault findFirst
   */
  export type CategoryDefaultFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryDefault
     */
    select?: CategoryDefaultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryDefaultInclude<ExtArgs> | null
    /**
     * Filter, which CategoryDefault to fetch.
     */
    where?: CategoryDefaultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoryDefaults to fetch.
     */
    orderBy?: CategoryDefaultOrderByWithRelationInput | CategoryDefaultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CategoryDefaults.
     */
    cursor?: CategoryDefaultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoryDefaults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoryDefaults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CategoryDefaults.
     */
    distinct?: CategoryDefaultScalarFieldEnum | CategoryDefaultScalarFieldEnum[]
  }

  /**
   * CategoryDefault findFirstOrThrow
   */
  export type CategoryDefaultFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryDefault
     */
    select?: CategoryDefaultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryDefaultInclude<ExtArgs> | null
    /**
     * Filter, which CategoryDefault to fetch.
     */
    where?: CategoryDefaultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoryDefaults to fetch.
     */
    orderBy?: CategoryDefaultOrderByWithRelationInput | CategoryDefaultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CategoryDefaults.
     */
    cursor?: CategoryDefaultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoryDefaults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoryDefaults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CategoryDefaults.
     */
    distinct?: CategoryDefaultScalarFieldEnum | CategoryDefaultScalarFieldEnum[]
  }

  /**
   * CategoryDefault findMany
   */
  export type CategoryDefaultFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryDefault
     */
    select?: CategoryDefaultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryDefaultInclude<ExtArgs> | null
    /**
     * Filter, which CategoryDefaults to fetch.
     */
    where?: CategoryDefaultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoryDefaults to fetch.
     */
    orderBy?: CategoryDefaultOrderByWithRelationInput | CategoryDefaultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CategoryDefaults.
     */
    cursor?: CategoryDefaultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoryDefaults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoryDefaults.
     */
    skip?: number
    distinct?: CategoryDefaultScalarFieldEnum | CategoryDefaultScalarFieldEnum[]
  }

  /**
   * CategoryDefault create
   */
  export type CategoryDefaultCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryDefault
     */
    select?: CategoryDefaultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryDefaultInclude<ExtArgs> | null
    /**
     * The data needed to create a CategoryDefault.
     */
    data: XOR<CategoryDefaultCreateInput, CategoryDefaultUncheckedCreateInput>
  }

  /**
   * CategoryDefault createMany
   */
  export type CategoryDefaultCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CategoryDefaults.
     */
    data: CategoryDefaultCreateManyInput | CategoryDefaultCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CategoryDefault createManyAndReturn
   */
  export type CategoryDefaultCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryDefault
     */
    select?: CategoryDefaultSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CategoryDefaults.
     */
    data: CategoryDefaultCreateManyInput | CategoryDefaultCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryDefaultIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CategoryDefault update
   */
  export type CategoryDefaultUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryDefault
     */
    select?: CategoryDefaultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryDefaultInclude<ExtArgs> | null
    /**
     * The data needed to update a CategoryDefault.
     */
    data: XOR<CategoryDefaultUpdateInput, CategoryDefaultUncheckedUpdateInput>
    /**
     * Choose, which CategoryDefault to update.
     */
    where: CategoryDefaultWhereUniqueInput
  }

  /**
   * CategoryDefault updateMany
   */
  export type CategoryDefaultUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CategoryDefaults.
     */
    data: XOR<CategoryDefaultUpdateManyMutationInput, CategoryDefaultUncheckedUpdateManyInput>
    /**
     * Filter which CategoryDefaults to update
     */
    where?: CategoryDefaultWhereInput
  }

  /**
   * CategoryDefault upsert
   */
  export type CategoryDefaultUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryDefault
     */
    select?: CategoryDefaultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryDefaultInclude<ExtArgs> | null
    /**
     * The filter to search for the CategoryDefault to update in case it exists.
     */
    where: CategoryDefaultWhereUniqueInput
    /**
     * In case the CategoryDefault found by the `where` argument doesn't exist, create a new CategoryDefault with this data.
     */
    create: XOR<CategoryDefaultCreateInput, CategoryDefaultUncheckedCreateInput>
    /**
     * In case the CategoryDefault was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryDefaultUpdateInput, CategoryDefaultUncheckedUpdateInput>
  }

  /**
   * CategoryDefault delete
   */
  export type CategoryDefaultDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryDefault
     */
    select?: CategoryDefaultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryDefaultInclude<ExtArgs> | null
    /**
     * Filter which CategoryDefault to delete.
     */
    where: CategoryDefaultWhereUniqueInput
  }

  /**
   * CategoryDefault deleteMany
   */
  export type CategoryDefaultDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CategoryDefaults to delete
     */
    where?: CategoryDefaultWhereInput
  }

  /**
   * CategoryDefault without action
   */
  export type CategoryDefaultDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryDefault
     */
    select?: CategoryDefaultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryDefaultInclude<ExtArgs> | null
  }


  /**
   * Model TransportRequest
   */

  export type AggregateTransportRequest = {
    _count: TransportRequestCountAggregateOutputType | null
    _avg: TransportRequestAvgAggregateOutputType | null
    _sum: TransportRequestSumAggregateOutputType | null
    _min: TransportRequestMinAggregateOutputType | null
    _max: TransportRequestMaxAggregateOutputType | null
  }

  export type TransportRequestAvgAggregateOutputType = {
    notificationRadius: number | null
  }

  export type TransportRequestSumAggregateOutputType = {
    notificationRadius: number | null
  }

  export type TransportRequestMinAggregateOutputType = {
    id: string | null
    tripNumber: string | null
    patientId: string | null
    patientWeight: string | null
    specialNeeds: string | null
    originFacilityId: string | null
    destinationFacilityId: string | null
    fromLocation: string | null
    toLocation: string | null
    fromLocationId: string | null
    isMultiLocationFacility: boolean | null
    scheduledTime: Date | null
    transportLevel: string | null
    urgencyLevel: string | null
    priority: string | null
    status: string | null
    specialRequirements: string | null
    diagnosis: string | null
    mobilityLevel: string | null
    oxygenRequired: boolean | null
    monitoringRequired: boolean | null
    generateQRCode: boolean | null
    qrCodeData: string | null
    notificationRadius: number | null
    requestTimestamp: Date | null
    acceptedTimestamp: Date | null
    pickupTimestamp: Date | null
    arrivalTimestamp: Date | null
    departureTimestamp: Date | null
    completionTimestamp: Date | null
    pickupLocationId: string | null
    assignedAgencyId: string | null
    assignedUnitId: string | null
    createdById: string | null
    healthcareCreatedById: string | null
    isolation: boolean | null
    bariatric: boolean | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransportRequestMaxAggregateOutputType = {
    id: string | null
    tripNumber: string | null
    patientId: string | null
    patientWeight: string | null
    specialNeeds: string | null
    originFacilityId: string | null
    destinationFacilityId: string | null
    fromLocation: string | null
    toLocation: string | null
    fromLocationId: string | null
    isMultiLocationFacility: boolean | null
    scheduledTime: Date | null
    transportLevel: string | null
    urgencyLevel: string | null
    priority: string | null
    status: string | null
    specialRequirements: string | null
    diagnosis: string | null
    mobilityLevel: string | null
    oxygenRequired: boolean | null
    monitoringRequired: boolean | null
    generateQRCode: boolean | null
    qrCodeData: string | null
    notificationRadius: number | null
    requestTimestamp: Date | null
    acceptedTimestamp: Date | null
    pickupTimestamp: Date | null
    arrivalTimestamp: Date | null
    departureTimestamp: Date | null
    completionTimestamp: Date | null
    pickupLocationId: string | null
    assignedAgencyId: string | null
    assignedUnitId: string | null
    createdById: string | null
    healthcareCreatedById: string | null
    isolation: boolean | null
    bariatric: boolean | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransportRequestCountAggregateOutputType = {
    id: number
    tripNumber: number
    patientId: number
    patientWeight: number
    specialNeeds: number
    originFacilityId: number
    destinationFacilityId: number
    fromLocation: number
    toLocation: number
    fromLocationId: number
    isMultiLocationFacility: number
    scheduledTime: number
    transportLevel: number
    urgencyLevel: number
    priority: number
    status: number
    specialRequirements: number
    diagnosis: number
    mobilityLevel: number
    oxygenRequired: number
    monitoringRequired: number
    generateQRCode: number
    qrCodeData: number
    selectedAgencies: number
    notificationRadius: number
    requestTimestamp: number
    acceptedTimestamp: number
    pickupTimestamp: number
    arrivalTimestamp: number
    departureTimestamp: number
    completionTimestamp: number
    pickupLocationId: number
    assignedAgencyId: number
    assignedUnitId: number
    createdById: number
    healthcareCreatedById: number
    isolation: number
    bariatric: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TransportRequestAvgAggregateInputType = {
    notificationRadius?: true
  }

  export type TransportRequestSumAggregateInputType = {
    notificationRadius?: true
  }

  export type TransportRequestMinAggregateInputType = {
    id?: true
    tripNumber?: true
    patientId?: true
    patientWeight?: true
    specialNeeds?: true
    originFacilityId?: true
    destinationFacilityId?: true
    fromLocation?: true
    toLocation?: true
    fromLocationId?: true
    isMultiLocationFacility?: true
    scheduledTime?: true
    transportLevel?: true
    urgencyLevel?: true
    priority?: true
    status?: true
    specialRequirements?: true
    diagnosis?: true
    mobilityLevel?: true
    oxygenRequired?: true
    monitoringRequired?: true
    generateQRCode?: true
    qrCodeData?: true
    notificationRadius?: true
    requestTimestamp?: true
    acceptedTimestamp?: true
    pickupTimestamp?: true
    arrivalTimestamp?: true
    departureTimestamp?: true
    completionTimestamp?: true
    pickupLocationId?: true
    assignedAgencyId?: true
    assignedUnitId?: true
    createdById?: true
    healthcareCreatedById?: true
    isolation?: true
    bariatric?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransportRequestMaxAggregateInputType = {
    id?: true
    tripNumber?: true
    patientId?: true
    patientWeight?: true
    specialNeeds?: true
    originFacilityId?: true
    destinationFacilityId?: true
    fromLocation?: true
    toLocation?: true
    fromLocationId?: true
    isMultiLocationFacility?: true
    scheduledTime?: true
    transportLevel?: true
    urgencyLevel?: true
    priority?: true
    status?: true
    specialRequirements?: true
    diagnosis?: true
    mobilityLevel?: true
    oxygenRequired?: true
    monitoringRequired?: true
    generateQRCode?: true
    qrCodeData?: true
    notificationRadius?: true
    requestTimestamp?: true
    acceptedTimestamp?: true
    pickupTimestamp?: true
    arrivalTimestamp?: true
    departureTimestamp?: true
    completionTimestamp?: true
    pickupLocationId?: true
    assignedAgencyId?: true
    assignedUnitId?: true
    createdById?: true
    healthcareCreatedById?: true
    isolation?: true
    bariatric?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransportRequestCountAggregateInputType = {
    id?: true
    tripNumber?: true
    patientId?: true
    patientWeight?: true
    specialNeeds?: true
    originFacilityId?: true
    destinationFacilityId?: true
    fromLocation?: true
    toLocation?: true
    fromLocationId?: true
    isMultiLocationFacility?: true
    scheduledTime?: true
    transportLevel?: true
    urgencyLevel?: true
    priority?: true
    status?: true
    specialRequirements?: true
    diagnosis?: true
    mobilityLevel?: true
    oxygenRequired?: true
    monitoringRequired?: true
    generateQRCode?: true
    qrCodeData?: true
    selectedAgencies?: true
    notificationRadius?: true
    requestTimestamp?: true
    acceptedTimestamp?: true
    pickupTimestamp?: true
    arrivalTimestamp?: true
    departureTimestamp?: true
    completionTimestamp?: true
    pickupLocationId?: true
    assignedAgencyId?: true
    assignedUnitId?: true
    createdById?: true
    healthcareCreatedById?: true
    isolation?: true
    bariatric?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TransportRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransportRequest to aggregate.
     */
    where?: TransportRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransportRequests to fetch.
     */
    orderBy?: TransportRequestOrderByWithRelationInput | TransportRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransportRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransportRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransportRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TransportRequests
    **/
    _count?: true | TransportRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransportRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransportRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransportRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransportRequestMaxAggregateInputType
  }

  export type GetTransportRequestAggregateType<T extends TransportRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateTransportRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransportRequest[P]>
      : GetScalarType<T[P], AggregateTransportRequest[P]>
  }




  export type TransportRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransportRequestWhereInput
    orderBy?: TransportRequestOrderByWithAggregationInput | TransportRequestOrderByWithAggregationInput[]
    by: TransportRequestScalarFieldEnum[] | TransportRequestScalarFieldEnum
    having?: TransportRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransportRequestCountAggregateInputType | true
    _avg?: TransportRequestAvgAggregateInputType
    _sum?: TransportRequestSumAggregateInputType
    _min?: TransportRequestMinAggregateInputType
    _max?: TransportRequestMaxAggregateInputType
  }

  export type TransportRequestGroupByOutputType = {
    id: string
    tripNumber: string | null
    patientId: string
    patientWeight: string | null
    specialNeeds: string | null
    originFacilityId: string | null
    destinationFacilityId: string | null
    fromLocation: string | null
    toLocation: string | null
    fromLocationId: string | null
    isMultiLocationFacility: boolean
    scheduledTime: Date | null
    transportLevel: string
    urgencyLevel: string | null
    priority: string
    status: string
    specialRequirements: string | null
    diagnosis: string | null
    mobilityLevel: string | null
    oxygenRequired: boolean
    monitoringRequired: boolean
    generateQRCode: boolean
    qrCodeData: string | null
    selectedAgencies: string[]
    notificationRadius: number | null
    requestTimestamp: Date
    acceptedTimestamp: Date | null
    pickupTimestamp: Date | null
    arrivalTimestamp: Date | null
    departureTimestamp: Date | null
    completionTimestamp: Date | null
    pickupLocationId: string | null
    assignedAgencyId: string | null
    assignedUnitId: string | null
    createdById: string | null
    healthcareCreatedById: string | null
    isolation: boolean
    bariatric: boolean
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: TransportRequestCountAggregateOutputType | null
    _avg: TransportRequestAvgAggregateOutputType | null
    _sum: TransportRequestSumAggregateOutputType | null
    _min: TransportRequestMinAggregateOutputType | null
    _max: TransportRequestMaxAggregateOutputType | null
  }

  type GetTransportRequestGroupByPayload<T extends TransportRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransportRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransportRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransportRequestGroupByOutputType[P]>
            : GetScalarType<T[P], TransportRequestGroupByOutputType[P]>
        }
      >
    >


  export type TransportRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tripNumber?: boolean
    patientId?: boolean
    patientWeight?: boolean
    specialNeeds?: boolean
    originFacilityId?: boolean
    destinationFacilityId?: boolean
    fromLocation?: boolean
    toLocation?: boolean
    fromLocationId?: boolean
    isMultiLocationFacility?: boolean
    scheduledTime?: boolean
    transportLevel?: boolean
    urgencyLevel?: boolean
    priority?: boolean
    status?: boolean
    specialRequirements?: boolean
    diagnosis?: boolean
    mobilityLevel?: boolean
    oxygenRequired?: boolean
    monitoringRequired?: boolean
    generateQRCode?: boolean
    qrCodeData?: boolean
    selectedAgencies?: boolean
    notificationRadius?: boolean
    requestTimestamp?: boolean
    acceptedTimestamp?: boolean
    pickupTimestamp?: boolean
    arrivalTimestamp?: boolean
    departureTimestamp?: boolean
    completionTimestamp?: boolean
    pickupLocationId?: boolean
    assignedAgencyId?: boolean
    assignedUnitId?: boolean
    createdById?: boolean
    healthcareCreatedById?: boolean
    isolation?: boolean
    bariatric?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    originFacility?: boolean | TransportRequest$originFacilityArgs<ExtArgs>
    destinationFacility?: boolean | TransportRequest$destinationFacilityArgs<ExtArgs>
    pickupLocation?: boolean | TransportRequest$pickupLocationArgs<ExtArgs>
    assignedUnit?: boolean | TransportRequest$assignedUnitArgs<ExtArgs>
    healthcareLocation?: boolean | TransportRequest$healthcareLocationArgs<ExtArgs>
  }, ExtArgs["result"]["transportRequest"]>

  export type TransportRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tripNumber?: boolean
    patientId?: boolean
    patientWeight?: boolean
    specialNeeds?: boolean
    originFacilityId?: boolean
    destinationFacilityId?: boolean
    fromLocation?: boolean
    toLocation?: boolean
    fromLocationId?: boolean
    isMultiLocationFacility?: boolean
    scheduledTime?: boolean
    transportLevel?: boolean
    urgencyLevel?: boolean
    priority?: boolean
    status?: boolean
    specialRequirements?: boolean
    diagnosis?: boolean
    mobilityLevel?: boolean
    oxygenRequired?: boolean
    monitoringRequired?: boolean
    generateQRCode?: boolean
    qrCodeData?: boolean
    selectedAgencies?: boolean
    notificationRadius?: boolean
    requestTimestamp?: boolean
    acceptedTimestamp?: boolean
    pickupTimestamp?: boolean
    arrivalTimestamp?: boolean
    departureTimestamp?: boolean
    completionTimestamp?: boolean
    pickupLocationId?: boolean
    assignedAgencyId?: boolean
    assignedUnitId?: boolean
    createdById?: boolean
    healthcareCreatedById?: boolean
    isolation?: boolean
    bariatric?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    originFacility?: boolean | TransportRequest$originFacilityArgs<ExtArgs>
    destinationFacility?: boolean | TransportRequest$destinationFacilityArgs<ExtArgs>
    pickupLocation?: boolean | TransportRequest$pickupLocationArgs<ExtArgs>
    assignedUnit?: boolean | TransportRequest$assignedUnitArgs<ExtArgs>
    healthcareLocation?: boolean | TransportRequest$healthcareLocationArgs<ExtArgs>
  }, ExtArgs["result"]["transportRequest"]>

  export type TransportRequestSelectScalar = {
    id?: boolean
    tripNumber?: boolean
    patientId?: boolean
    patientWeight?: boolean
    specialNeeds?: boolean
    originFacilityId?: boolean
    destinationFacilityId?: boolean
    fromLocation?: boolean
    toLocation?: boolean
    fromLocationId?: boolean
    isMultiLocationFacility?: boolean
    scheduledTime?: boolean
    transportLevel?: boolean
    urgencyLevel?: boolean
    priority?: boolean
    status?: boolean
    specialRequirements?: boolean
    diagnosis?: boolean
    mobilityLevel?: boolean
    oxygenRequired?: boolean
    monitoringRequired?: boolean
    generateQRCode?: boolean
    qrCodeData?: boolean
    selectedAgencies?: boolean
    notificationRadius?: boolean
    requestTimestamp?: boolean
    acceptedTimestamp?: boolean
    pickupTimestamp?: boolean
    arrivalTimestamp?: boolean
    departureTimestamp?: boolean
    completionTimestamp?: boolean
    pickupLocationId?: boolean
    assignedAgencyId?: boolean
    assignedUnitId?: boolean
    createdById?: boolean
    healthcareCreatedById?: boolean
    isolation?: boolean
    bariatric?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TransportRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    originFacility?: boolean | TransportRequest$originFacilityArgs<ExtArgs>
    destinationFacility?: boolean | TransportRequest$destinationFacilityArgs<ExtArgs>
    pickupLocation?: boolean | TransportRequest$pickupLocationArgs<ExtArgs>
    assignedUnit?: boolean | TransportRequest$assignedUnitArgs<ExtArgs>
    healthcareLocation?: boolean | TransportRequest$healthcareLocationArgs<ExtArgs>
  }
  export type TransportRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    originFacility?: boolean | TransportRequest$originFacilityArgs<ExtArgs>
    destinationFacility?: boolean | TransportRequest$destinationFacilityArgs<ExtArgs>
    pickupLocation?: boolean | TransportRequest$pickupLocationArgs<ExtArgs>
    assignedUnit?: boolean | TransportRequest$assignedUnitArgs<ExtArgs>
    healthcareLocation?: boolean | TransportRequest$healthcareLocationArgs<ExtArgs>
  }

  export type $TransportRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TransportRequest"
    objects: {
      originFacility: Prisma.$FacilityPayload<ExtArgs> | null
      destinationFacility: Prisma.$FacilityPayload<ExtArgs> | null
      pickupLocation: Prisma.$pickup_locationsPayload<ExtArgs> | null
      assignedUnit: Prisma.$UnitPayload<ExtArgs> | null
      healthcareLocation: Prisma.$HealthcareLocationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tripNumber: string | null
      patientId: string
      patientWeight: string | null
      specialNeeds: string | null
      originFacilityId: string | null
      destinationFacilityId: string | null
      fromLocation: string | null
      toLocation: string | null
      fromLocationId: string | null
      isMultiLocationFacility: boolean
      scheduledTime: Date | null
      transportLevel: string
      urgencyLevel: string | null
      priority: string
      status: string
      specialRequirements: string | null
      diagnosis: string | null
      mobilityLevel: string | null
      oxygenRequired: boolean
      monitoringRequired: boolean
      generateQRCode: boolean
      qrCodeData: string | null
      selectedAgencies: string[]
      notificationRadius: number | null
      requestTimestamp: Date
      acceptedTimestamp: Date | null
      pickupTimestamp: Date | null
      arrivalTimestamp: Date | null
      departureTimestamp: Date | null
      completionTimestamp: Date | null
      pickupLocationId: string | null
      assignedAgencyId: string | null
      assignedUnitId: string | null
      createdById: string | null
      healthcareCreatedById: string | null
      isolation: boolean
      bariatric: boolean
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["transportRequest"]>
    composites: {}
  }

  type TransportRequestGetPayload<S extends boolean | null | undefined | TransportRequestDefaultArgs> = $Result.GetResult<Prisma.$TransportRequestPayload, S>

  type TransportRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TransportRequestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TransportRequestCountAggregateInputType | true
    }

  export interface TransportRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TransportRequest'], meta: { name: 'TransportRequest' } }
    /**
     * Find zero or one TransportRequest that matches the filter.
     * @param {TransportRequestFindUniqueArgs} args - Arguments to find a TransportRequest
     * @example
     * // Get one TransportRequest
     * const transportRequest = await prisma.transportRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransportRequestFindUniqueArgs>(args: SelectSubset<T, TransportRequestFindUniqueArgs<ExtArgs>>): Prisma__TransportRequestClient<$Result.GetResult<Prisma.$TransportRequestPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TransportRequest that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TransportRequestFindUniqueOrThrowArgs} args - Arguments to find a TransportRequest
     * @example
     * // Get one TransportRequest
     * const transportRequest = await prisma.transportRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransportRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, TransportRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransportRequestClient<$Result.GetResult<Prisma.$TransportRequestPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TransportRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransportRequestFindFirstArgs} args - Arguments to find a TransportRequest
     * @example
     * // Get one TransportRequest
     * const transportRequest = await prisma.transportRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransportRequestFindFirstArgs>(args?: SelectSubset<T, TransportRequestFindFirstArgs<ExtArgs>>): Prisma__TransportRequestClient<$Result.GetResult<Prisma.$TransportRequestPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TransportRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransportRequestFindFirstOrThrowArgs} args - Arguments to find a TransportRequest
     * @example
     * // Get one TransportRequest
     * const transportRequest = await prisma.transportRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransportRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, TransportRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransportRequestClient<$Result.GetResult<Prisma.$TransportRequestPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TransportRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransportRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TransportRequests
     * const transportRequests = await prisma.transportRequest.findMany()
     * 
     * // Get first 10 TransportRequests
     * const transportRequests = await prisma.transportRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transportRequestWithIdOnly = await prisma.transportRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransportRequestFindManyArgs>(args?: SelectSubset<T, TransportRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransportRequestPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TransportRequest.
     * @param {TransportRequestCreateArgs} args - Arguments to create a TransportRequest.
     * @example
     * // Create one TransportRequest
     * const TransportRequest = await prisma.transportRequest.create({
     *   data: {
     *     // ... data to create a TransportRequest
     *   }
     * })
     * 
     */
    create<T extends TransportRequestCreateArgs>(args: SelectSubset<T, TransportRequestCreateArgs<ExtArgs>>): Prisma__TransportRequestClient<$Result.GetResult<Prisma.$TransportRequestPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TransportRequests.
     * @param {TransportRequestCreateManyArgs} args - Arguments to create many TransportRequests.
     * @example
     * // Create many TransportRequests
     * const transportRequest = await prisma.transportRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransportRequestCreateManyArgs>(args?: SelectSubset<T, TransportRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TransportRequests and returns the data saved in the database.
     * @param {TransportRequestCreateManyAndReturnArgs} args - Arguments to create many TransportRequests.
     * @example
     * // Create many TransportRequests
     * const transportRequest = await prisma.transportRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TransportRequests and only return the `id`
     * const transportRequestWithIdOnly = await prisma.transportRequest.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransportRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, TransportRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransportRequestPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TransportRequest.
     * @param {TransportRequestDeleteArgs} args - Arguments to delete one TransportRequest.
     * @example
     * // Delete one TransportRequest
     * const TransportRequest = await prisma.transportRequest.delete({
     *   where: {
     *     // ... filter to delete one TransportRequest
     *   }
     * })
     * 
     */
    delete<T extends TransportRequestDeleteArgs>(args: SelectSubset<T, TransportRequestDeleteArgs<ExtArgs>>): Prisma__TransportRequestClient<$Result.GetResult<Prisma.$TransportRequestPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TransportRequest.
     * @param {TransportRequestUpdateArgs} args - Arguments to update one TransportRequest.
     * @example
     * // Update one TransportRequest
     * const transportRequest = await prisma.transportRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransportRequestUpdateArgs>(args: SelectSubset<T, TransportRequestUpdateArgs<ExtArgs>>): Prisma__TransportRequestClient<$Result.GetResult<Prisma.$TransportRequestPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TransportRequests.
     * @param {TransportRequestDeleteManyArgs} args - Arguments to filter TransportRequests to delete.
     * @example
     * // Delete a few TransportRequests
     * const { count } = await prisma.transportRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransportRequestDeleteManyArgs>(args?: SelectSubset<T, TransportRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransportRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransportRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TransportRequests
     * const transportRequest = await prisma.transportRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransportRequestUpdateManyArgs>(args: SelectSubset<T, TransportRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TransportRequest.
     * @param {TransportRequestUpsertArgs} args - Arguments to update or create a TransportRequest.
     * @example
     * // Update or create a TransportRequest
     * const transportRequest = await prisma.transportRequest.upsert({
     *   create: {
     *     // ... data to create a TransportRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TransportRequest we want to update
     *   }
     * })
     */
    upsert<T extends TransportRequestUpsertArgs>(args: SelectSubset<T, TransportRequestUpsertArgs<ExtArgs>>): Prisma__TransportRequestClient<$Result.GetResult<Prisma.$TransportRequestPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TransportRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransportRequestCountArgs} args - Arguments to filter TransportRequests to count.
     * @example
     * // Count the number of TransportRequests
     * const count = await prisma.transportRequest.count({
     *   where: {
     *     // ... the filter for the TransportRequests we want to count
     *   }
     * })
    **/
    count<T extends TransportRequestCountArgs>(
      args?: Subset<T, TransportRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransportRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TransportRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransportRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransportRequestAggregateArgs>(args: Subset<T, TransportRequestAggregateArgs>): Prisma.PrismaPromise<GetTransportRequestAggregateType<T>>

    /**
     * Group by TransportRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransportRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransportRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransportRequestGroupByArgs['orderBy'] }
        : { orderBy?: TransportRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransportRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransportRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TransportRequest model
   */
  readonly fields: TransportRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TransportRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransportRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    originFacility<T extends TransportRequest$originFacilityArgs<ExtArgs> = {}>(args?: Subset<T, TransportRequest$originFacilityArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    destinationFacility<T extends TransportRequest$destinationFacilityArgs<ExtArgs> = {}>(args?: Subset<T, TransportRequest$destinationFacilityArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    pickupLocation<T extends TransportRequest$pickupLocationArgs<ExtArgs> = {}>(args?: Subset<T, TransportRequest$pickupLocationArgs<ExtArgs>>): Prisma__pickup_locationsClient<$Result.GetResult<Prisma.$pickup_locationsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    assignedUnit<T extends TransportRequest$assignedUnitArgs<ExtArgs> = {}>(args?: Subset<T, TransportRequest$assignedUnitArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    healthcareLocation<T extends TransportRequest$healthcareLocationArgs<ExtArgs> = {}>(args?: Subset<T, TransportRequest$healthcareLocationArgs<ExtArgs>>): Prisma__HealthcareLocationClient<$Result.GetResult<Prisma.$HealthcareLocationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TransportRequest model
   */ 
  interface TransportRequestFieldRefs {
    readonly id: FieldRef<"TransportRequest", 'String'>
    readonly tripNumber: FieldRef<"TransportRequest", 'String'>
    readonly patientId: FieldRef<"TransportRequest", 'String'>
    readonly patientWeight: FieldRef<"TransportRequest", 'String'>
    readonly specialNeeds: FieldRef<"TransportRequest", 'String'>
    readonly originFacilityId: FieldRef<"TransportRequest", 'String'>
    readonly destinationFacilityId: FieldRef<"TransportRequest", 'String'>
    readonly fromLocation: FieldRef<"TransportRequest", 'String'>
    readonly toLocation: FieldRef<"TransportRequest", 'String'>
    readonly fromLocationId: FieldRef<"TransportRequest", 'String'>
    readonly isMultiLocationFacility: FieldRef<"TransportRequest", 'Boolean'>
    readonly scheduledTime: FieldRef<"TransportRequest", 'DateTime'>
    readonly transportLevel: FieldRef<"TransportRequest", 'String'>
    readonly urgencyLevel: FieldRef<"TransportRequest", 'String'>
    readonly priority: FieldRef<"TransportRequest", 'String'>
    readonly status: FieldRef<"TransportRequest", 'String'>
    readonly specialRequirements: FieldRef<"TransportRequest", 'String'>
    readonly diagnosis: FieldRef<"TransportRequest", 'String'>
    readonly mobilityLevel: FieldRef<"TransportRequest", 'String'>
    readonly oxygenRequired: FieldRef<"TransportRequest", 'Boolean'>
    readonly monitoringRequired: FieldRef<"TransportRequest", 'Boolean'>
    readonly generateQRCode: FieldRef<"TransportRequest", 'Boolean'>
    readonly qrCodeData: FieldRef<"TransportRequest", 'String'>
    readonly selectedAgencies: FieldRef<"TransportRequest", 'String[]'>
    readonly notificationRadius: FieldRef<"TransportRequest", 'Int'>
    readonly requestTimestamp: FieldRef<"TransportRequest", 'DateTime'>
    readonly acceptedTimestamp: FieldRef<"TransportRequest", 'DateTime'>
    readonly pickupTimestamp: FieldRef<"TransportRequest", 'DateTime'>
    readonly arrivalTimestamp: FieldRef<"TransportRequest", 'DateTime'>
    readonly departureTimestamp: FieldRef<"TransportRequest", 'DateTime'>
    readonly completionTimestamp: FieldRef<"TransportRequest", 'DateTime'>
    readonly pickupLocationId: FieldRef<"TransportRequest", 'String'>
    readonly assignedAgencyId: FieldRef<"TransportRequest", 'String'>
    readonly assignedUnitId: FieldRef<"TransportRequest", 'String'>
    readonly createdById: FieldRef<"TransportRequest", 'String'>
    readonly healthcareCreatedById: FieldRef<"TransportRequest", 'String'>
    readonly isolation: FieldRef<"TransportRequest", 'Boolean'>
    readonly bariatric: FieldRef<"TransportRequest", 'Boolean'>
    readonly notes: FieldRef<"TransportRequest", 'String'>
    readonly createdAt: FieldRef<"TransportRequest", 'DateTime'>
    readonly updatedAt: FieldRef<"TransportRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TransportRequest findUnique
   */
  export type TransportRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransportRequest
     */
    select?: TransportRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportRequestInclude<ExtArgs> | null
    /**
     * Filter, which TransportRequest to fetch.
     */
    where: TransportRequestWhereUniqueInput
  }

  /**
   * TransportRequest findUniqueOrThrow
   */
  export type TransportRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransportRequest
     */
    select?: TransportRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportRequestInclude<ExtArgs> | null
    /**
     * Filter, which TransportRequest to fetch.
     */
    where: TransportRequestWhereUniqueInput
  }

  /**
   * TransportRequest findFirst
   */
  export type TransportRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransportRequest
     */
    select?: TransportRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportRequestInclude<ExtArgs> | null
    /**
     * Filter, which TransportRequest to fetch.
     */
    where?: TransportRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransportRequests to fetch.
     */
    orderBy?: TransportRequestOrderByWithRelationInput | TransportRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransportRequests.
     */
    cursor?: TransportRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransportRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransportRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransportRequests.
     */
    distinct?: TransportRequestScalarFieldEnum | TransportRequestScalarFieldEnum[]
  }

  /**
   * TransportRequest findFirstOrThrow
   */
  export type TransportRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransportRequest
     */
    select?: TransportRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportRequestInclude<ExtArgs> | null
    /**
     * Filter, which TransportRequest to fetch.
     */
    where?: TransportRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransportRequests to fetch.
     */
    orderBy?: TransportRequestOrderByWithRelationInput | TransportRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransportRequests.
     */
    cursor?: TransportRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransportRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransportRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransportRequests.
     */
    distinct?: TransportRequestScalarFieldEnum | TransportRequestScalarFieldEnum[]
  }

  /**
   * TransportRequest findMany
   */
  export type TransportRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransportRequest
     */
    select?: TransportRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportRequestInclude<ExtArgs> | null
    /**
     * Filter, which TransportRequests to fetch.
     */
    where?: TransportRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransportRequests to fetch.
     */
    orderBy?: TransportRequestOrderByWithRelationInput | TransportRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TransportRequests.
     */
    cursor?: TransportRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransportRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransportRequests.
     */
    skip?: number
    distinct?: TransportRequestScalarFieldEnum | TransportRequestScalarFieldEnum[]
  }

  /**
   * TransportRequest create
   */
  export type TransportRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransportRequest
     */
    select?: TransportRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a TransportRequest.
     */
    data: XOR<TransportRequestCreateInput, TransportRequestUncheckedCreateInput>
  }

  /**
   * TransportRequest createMany
   */
  export type TransportRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TransportRequests.
     */
    data: TransportRequestCreateManyInput | TransportRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TransportRequest createManyAndReturn
   */
  export type TransportRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransportRequest
     */
    select?: TransportRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TransportRequests.
     */
    data: TransportRequestCreateManyInput | TransportRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TransportRequest update
   */
  export type TransportRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransportRequest
     */
    select?: TransportRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a TransportRequest.
     */
    data: XOR<TransportRequestUpdateInput, TransportRequestUncheckedUpdateInput>
    /**
     * Choose, which TransportRequest to update.
     */
    where: TransportRequestWhereUniqueInput
  }

  /**
   * TransportRequest updateMany
   */
  export type TransportRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TransportRequests.
     */
    data: XOR<TransportRequestUpdateManyMutationInput, TransportRequestUncheckedUpdateManyInput>
    /**
     * Filter which TransportRequests to update
     */
    where?: TransportRequestWhereInput
  }

  /**
   * TransportRequest upsert
   */
  export type TransportRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransportRequest
     */
    select?: TransportRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the TransportRequest to update in case it exists.
     */
    where: TransportRequestWhereUniqueInput
    /**
     * In case the TransportRequest found by the `where` argument doesn't exist, create a new TransportRequest with this data.
     */
    create: XOR<TransportRequestCreateInput, TransportRequestUncheckedCreateInput>
    /**
     * In case the TransportRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransportRequestUpdateInput, TransportRequestUncheckedUpdateInput>
  }

  /**
   * TransportRequest delete
   */
  export type TransportRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransportRequest
     */
    select?: TransportRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportRequestInclude<ExtArgs> | null
    /**
     * Filter which TransportRequest to delete.
     */
    where: TransportRequestWhereUniqueInput
  }

  /**
   * TransportRequest deleteMany
   */
  export type TransportRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransportRequests to delete
     */
    where?: TransportRequestWhereInput
  }

  /**
   * TransportRequest.originFacility
   */
  export type TransportRequest$originFacilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    where?: FacilityWhereInput
  }

  /**
   * TransportRequest.destinationFacility
   */
  export type TransportRequest$destinationFacilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    where?: FacilityWhereInput
  }

  /**
   * TransportRequest.pickupLocation
   */
  export type TransportRequest$pickupLocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pickup_locations
     */
    select?: pickup_locationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pickup_locationsInclude<ExtArgs> | null
    where?: pickup_locationsWhereInput
  }

  /**
   * TransportRequest.assignedUnit
   */
  export type TransportRequest$assignedUnitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    where?: UnitWhereInput
  }

  /**
   * TransportRequest.healthcareLocation
   */
  export type TransportRequest$healthcareLocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthcareLocation
     */
    select?: HealthcareLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthcareLocationInclude<ExtArgs> | null
    where?: HealthcareLocationWhereInput
  }

  /**
   * TransportRequest without action
   */
  export type TransportRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransportRequest
     */
    select?: TransportRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportRequestInclude<ExtArgs> | null
  }


  /**
   * Model Facility
   */

  export type AggregateFacility = {
    _count: FacilityCountAggregateOutputType | null
    _avg: FacilityAvgAggregateOutputType | null
    _sum: FacilitySumAggregateOutputType | null
    _min: FacilityMinAggregateOutputType | null
    _max: FacilityMaxAggregateOutputType | null
  }

  export type FacilityAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type FacilitySumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type FacilityMinAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    phone: string | null
    email: string | null
    type: string | null
    region: string | null
    latitude: number | null
    longitude: number | null
    operatingHours: string | null
    isActive: boolean | null
    requiresReview: boolean | null
    approvedAt: Date | null
    approvedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FacilityMaxAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    phone: string | null
    email: string | null
    type: string | null
    region: string | null
    latitude: number | null
    longitude: number | null
    operatingHours: string | null
    isActive: boolean | null
    requiresReview: boolean | null
    approvedAt: Date | null
    approvedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FacilityCountAggregateOutputType = {
    id: number
    name: number
    address: number
    city: number
    state: number
    zipCode: number
    phone: number
    email: number
    type: number
    capabilities: number
    region: number
    coordinates: number
    latitude: number
    longitude: number
    operatingHours: number
    isActive: number
    requiresReview: number
    approvedAt: number
    approvedBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FacilityAvgAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type FacilitySumAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type FacilityMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    city?: true
    state?: true
    zipCode?: true
    phone?: true
    email?: true
    type?: true
    region?: true
    latitude?: true
    longitude?: true
    operatingHours?: true
    isActive?: true
    requiresReview?: true
    approvedAt?: true
    approvedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FacilityMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    city?: true
    state?: true
    zipCode?: true
    phone?: true
    email?: true
    type?: true
    region?: true
    latitude?: true
    longitude?: true
    operatingHours?: true
    isActive?: true
    requiresReview?: true
    approvedAt?: true
    approvedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FacilityCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    city?: true
    state?: true
    zipCode?: true
    phone?: true
    email?: true
    type?: true
    capabilities?: true
    region?: true
    coordinates?: true
    latitude?: true
    longitude?: true
    operatingHours?: true
    isActive?: true
    requiresReview?: true
    approvedAt?: true
    approvedBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FacilityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Facility to aggregate.
     */
    where?: FacilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Facilities to fetch.
     */
    orderBy?: FacilityOrderByWithRelationInput | FacilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FacilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Facilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Facilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Facilities
    **/
    _count?: true | FacilityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FacilityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FacilitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FacilityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FacilityMaxAggregateInputType
  }

  export type GetFacilityAggregateType<T extends FacilityAggregateArgs> = {
        [P in keyof T & keyof AggregateFacility]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFacility[P]>
      : GetScalarType<T[P], AggregateFacility[P]>
  }




  export type FacilityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FacilityWhereInput
    orderBy?: FacilityOrderByWithAggregationInput | FacilityOrderByWithAggregationInput[]
    by: FacilityScalarFieldEnum[] | FacilityScalarFieldEnum
    having?: FacilityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FacilityCountAggregateInputType | true
    _avg?: FacilityAvgAggregateInputType
    _sum?: FacilitySumAggregateInputType
    _min?: FacilityMinAggregateInputType
    _max?: FacilityMaxAggregateInputType
  }

  export type FacilityGroupByOutputType = {
    id: string
    name: string
    address: string
    city: string
    state: string
    zipCode: string
    phone: string | null
    email: string | null
    type: string
    capabilities: string[]
    region: string
    coordinates: JsonValue | null
    latitude: number | null
    longitude: number | null
    operatingHours: string | null
    isActive: boolean
    requiresReview: boolean
    approvedAt: Date | null
    approvedBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: FacilityCountAggregateOutputType | null
    _avg: FacilityAvgAggregateOutputType | null
    _sum: FacilitySumAggregateOutputType | null
    _min: FacilityMinAggregateOutputType | null
    _max: FacilityMaxAggregateOutputType | null
  }

  type GetFacilityGroupByPayload<T extends FacilityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FacilityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FacilityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FacilityGroupByOutputType[P]>
            : GetScalarType<T[P], FacilityGroupByOutputType[P]>
        }
      >
    >


  export type FacilitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    phone?: boolean
    email?: boolean
    type?: boolean
    capabilities?: boolean
    region?: boolean
    coordinates?: boolean
    latitude?: boolean
    longitude?: boolean
    operatingHours?: boolean
    isActive?: boolean
    requiresReview?: boolean
    approvedAt?: boolean
    approvedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    originTrips?: boolean | Facility$originTripsArgs<ExtArgs>
    destinationTrips?: boolean | Facility$destinationTripsArgs<ExtArgs>
    _count?: boolean | FacilityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["facility"]>

  export type FacilitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    phone?: boolean
    email?: boolean
    type?: boolean
    capabilities?: boolean
    region?: boolean
    coordinates?: boolean
    latitude?: boolean
    longitude?: boolean
    operatingHours?: boolean
    isActive?: boolean
    requiresReview?: boolean
    approvedAt?: boolean
    approvedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["facility"]>

  export type FacilitySelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    phone?: boolean
    email?: boolean
    type?: boolean
    capabilities?: boolean
    region?: boolean
    coordinates?: boolean
    latitude?: boolean
    longitude?: boolean
    operatingHours?: boolean
    isActive?: boolean
    requiresReview?: boolean
    approvedAt?: boolean
    approvedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FacilityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    originTrips?: boolean | Facility$originTripsArgs<ExtArgs>
    destinationTrips?: boolean | Facility$destinationTripsArgs<ExtArgs>
    _count?: boolean | FacilityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FacilityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $FacilityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Facility"
    objects: {
      originTrips: Prisma.$TransportRequestPayload<ExtArgs>[]
      destinationTrips: Prisma.$TransportRequestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      address: string
      city: string
      state: string
      zipCode: string
      phone: string | null
      email: string | null
      type: string
      capabilities: string[]
      region: string
      coordinates: Prisma.JsonValue | null
      latitude: number | null
      longitude: number | null
      operatingHours: string | null
      isActive: boolean
      requiresReview: boolean
      approvedAt: Date | null
      approvedBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["facility"]>
    composites: {}
  }

  type FacilityGetPayload<S extends boolean | null | undefined | FacilityDefaultArgs> = $Result.GetResult<Prisma.$FacilityPayload, S>

  type FacilityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FacilityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FacilityCountAggregateInputType | true
    }

  export interface FacilityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Facility'], meta: { name: 'Facility' } }
    /**
     * Find zero or one Facility that matches the filter.
     * @param {FacilityFindUniqueArgs} args - Arguments to find a Facility
     * @example
     * // Get one Facility
     * const facility = await prisma.facility.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FacilityFindUniqueArgs>(args: SelectSubset<T, FacilityFindUniqueArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Facility that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FacilityFindUniqueOrThrowArgs} args - Arguments to find a Facility
     * @example
     * // Get one Facility
     * const facility = await prisma.facility.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FacilityFindUniqueOrThrowArgs>(args: SelectSubset<T, FacilityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Facility that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityFindFirstArgs} args - Arguments to find a Facility
     * @example
     * // Get one Facility
     * const facility = await prisma.facility.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FacilityFindFirstArgs>(args?: SelectSubset<T, FacilityFindFirstArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Facility that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityFindFirstOrThrowArgs} args - Arguments to find a Facility
     * @example
     * // Get one Facility
     * const facility = await prisma.facility.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FacilityFindFirstOrThrowArgs>(args?: SelectSubset<T, FacilityFindFirstOrThrowArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Facilities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Facilities
     * const facilities = await prisma.facility.findMany()
     * 
     * // Get first 10 Facilities
     * const facilities = await prisma.facility.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const facilityWithIdOnly = await prisma.facility.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FacilityFindManyArgs>(args?: SelectSubset<T, FacilityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Facility.
     * @param {FacilityCreateArgs} args - Arguments to create a Facility.
     * @example
     * // Create one Facility
     * const Facility = await prisma.facility.create({
     *   data: {
     *     // ... data to create a Facility
     *   }
     * })
     * 
     */
    create<T extends FacilityCreateArgs>(args: SelectSubset<T, FacilityCreateArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Facilities.
     * @param {FacilityCreateManyArgs} args - Arguments to create many Facilities.
     * @example
     * // Create many Facilities
     * const facility = await prisma.facility.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FacilityCreateManyArgs>(args?: SelectSubset<T, FacilityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Facilities and returns the data saved in the database.
     * @param {FacilityCreateManyAndReturnArgs} args - Arguments to create many Facilities.
     * @example
     * // Create many Facilities
     * const facility = await prisma.facility.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Facilities and only return the `id`
     * const facilityWithIdOnly = await prisma.facility.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FacilityCreateManyAndReturnArgs>(args?: SelectSubset<T, FacilityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Facility.
     * @param {FacilityDeleteArgs} args - Arguments to delete one Facility.
     * @example
     * // Delete one Facility
     * const Facility = await prisma.facility.delete({
     *   where: {
     *     // ... filter to delete one Facility
     *   }
     * })
     * 
     */
    delete<T extends FacilityDeleteArgs>(args: SelectSubset<T, FacilityDeleteArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Facility.
     * @param {FacilityUpdateArgs} args - Arguments to update one Facility.
     * @example
     * // Update one Facility
     * const facility = await prisma.facility.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FacilityUpdateArgs>(args: SelectSubset<T, FacilityUpdateArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Facilities.
     * @param {FacilityDeleteManyArgs} args - Arguments to filter Facilities to delete.
     * @example
     * // Delete a few Facilities
     * const { count } = await prisma.facility.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FacilityDeleteManyArgs>(args?: SelectSubset<T, FacilityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Facilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Facilities
     * const facility = await prisma.facility.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FacilityUpdateManyArgs>(args: SelectSubset<T, FacilityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Facility.
     * @param {FacilityUpsertArgs} args - Arguments to update or create a Facility.
     * @example
     * // Update or create a Facility
     * const facility = await prisma.facility.upsert({
     *   create: {
     *     // ... data to create a Facility
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Facility we want to update
     *   }
     * })
     */
    upsert<T extends FacilityUpsertArgs>(args: SelectSubset<T, FacilityUpsertArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Facilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityCountArgs} args - Arguments to filter Facilities to count.
     * @example
     * // Count the number of Facilities
     * const count = await prisma.facility.count({
     *   where: {
     *     // ... the filter for the Facilities we want to count
     *   }
     * })
    **/
    count<T extends FacilityCountArgs>(
      args?: Subset<T, FacilityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FacilityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Facility.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FacilityAggregateArgs>(args: Subset<T, FacilityAggregateArgs>): Prisma.PrismaPromise<GetFacilityAggregateType<T>>

    /**
     * Group by Facility.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FacilityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FacilityGroupByArgs['orderBy'] }
        : { orderBy?: FacilityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FacilityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFacilityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Facility model
   */
  readonly fields: FacilityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Facility.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FacilityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    originTrips<T extends Facility$originTripsArgs<ExtArgs> = {}>(args?: Subset<T, Facility$originTripsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransportRequestPayload<ExtArgs>, T, "findMany"> | Null>
    destinationTrips<T extends Facility$destinationTripsArgs<ExtArgs> = {}>(args?: Subset<T, Facility$destinationTripsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransportRequestPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Facility model
   */ 
  interface FacilityFieldRefs {
    readonly id: FieldRef<"Facility", 'String'>
    readonly name: FieldRef<"Facility", 'String'>
    readonly address: FieldRef<"Facility", 'String'>
    readonly city: FieldRef<"Facility", 'String'>
    readonly state: FieldRef<"Facility", 'String'>
    readonly zipCode: FieldRef<"Facility", 'String'>
    readonly phone: FieldRef<"Facility", 'String'>
    readonly email: FieldRef<"Facility", 'String'>
    readonly type: FieldRef<"Facility", 'String'>
    readonly capabilities: FieldRef<"Facility", 'String[]'>
    readonly region: FieldRef<"Facility", 'String'>
    readonly coordinates: FieldRef<"Facility", 'Json'>
    readonly latitude: FieldRef<"Facility", 'Float'>
    readonly longitude: FieldRef<"Facility", 'Float'>
    readonly operatingHours: FieldRef<"Facility", 'String'>
    readonly isActive: FieldRef<"Facility", 'Boolean'>
    readonly requiresReview: FieldRef<"Facility", 'Boolean'>
    readonly approvedAt: FieldRef<"Facility", 'DateTime'>
    readonly approvedBy: FieldRef<"Facility", 'String'>
    readonly createdAt: FieldRef<"Facility", 'DateTime'>
    readonly updatedAt: FieldRef<"Facility", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Facility findUnique
   */
  export type FacilityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    /**
     * Filter, which Facility to fetch.
     */
    where: FacilityWhereUniqueInput
  }

  /**
   * Facility findUniqueOrThrow
   */
  export type FacilityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    /**
     * Filter, which Facility to fetch.
     */
    where: FacilityWhereUniqueInput
  }

  /**
   * Facility findFirst
   */
  export type FacilityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    /**
     * Filter, which Facility to fetch.
     */
    where?: FacilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Facilities to fetch.
     */
    orderBy?: FacilityOrderByWithRelationInput | FacilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Facilities.
     */
    cursor?: FacilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Facilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Facilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Facilities.
     */
    distinct?: FacilityScalarFieldEnum | FacilityScalarFieldEnum[]
  }

  /**
   * Facility findFirstOrThrow
   */
  export type FacilityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    /**
     * Filter, which Facility to fetch.
     */
    where?: FacilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Facilities to fetch.
     */
    orderBy?: FacilityOrderByWithRelationInput | FacilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Facilities.
     */
    cursor?: FacilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Facilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Facilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Facilities.
     */
    distinct?: FacilityScalarFieldEnum | FacilityScalarFieldEnum[]
  }

  /**
   * Facility findMany
   */
  export type FacilityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    /**
     * Filter, which Facilities to fetch.
     */
    where?: FacilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Facilities to fetch.
     */
    orderBy?: FacilityOrderByWithRelationInput | FacilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Facilities.
     */
    cursor?: FacilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Facilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Facilities.
     */
    skip?: number
    distinct?: FacilityScalarFieldEnum | FacilityScalarFieldEnum[]
  }

  /**
   * Facility create
   */
  export type FacilityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    /**
     * The data needed to create a Facility.
     */
    data: XOR<FacilityCreateInput, FacilityUncheckedCreateInput>
  }

  /**
   * Facility createMany
   */
  export type FacilityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Facilities.
     */
    data: FacilityCreateManyInput | FacilityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Facility createManyAndReturn
   */
  export type FacilityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Facilities.
     */
    data: FacilityCreateManyInput | FacilityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Facility update
   */
  export type FacilityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    /**
     * The data needed to update a Facility.
     */
    data: XOR<FacilityUpdateInput, FacilityUncheckedUpdateInput>
    /**
     * Choose, which Facility to update.
     */
    where: FacilityWhereUniqueInput
  }

  /**
   * Facility updateMany
   */
  export type FacilityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Facilities.
     */
    data: XOR<FacilityUpdateManyMutationInput, FacilityUncheckedUpdateManyInput>
    /**
     * Filter which Facilities to update
     */
    where?: FacilityWhereInput
  }

  /**
   * Facility upsert
   */
  export type FacilityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    /**
     * The filter to search for the Facility to update in case it exists.
     */
    where: FacilityWhereUniqueInput
    /**
     * In case the Facility found by the `where` argument doesn't exist, create a new Facility with this data.
     */
    create: XOR<FacilityCreateInput, FacilityUncheckedCreateInput>
    /**
     * In case the Facility was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FacilityUpdateInput, FacilityUncheckedUpdateInput>
  }

  /**
   * Facility delete
   */
  export type FacilityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    /**
     * Filter which Facility to delete.
     */
    where: FacilityWhereUniqueInput
  }

  /**
   * Facility deleteMany
   */
  export type FacilityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Facilities to delete
     */
    where?: FacilityWhereInput
  }

  /**
   * Facility.originTrips
   */
  export type Facility$originTripsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransportRequest
     */
    select?: TransportRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportRequestInclude<ExtArgs> | null
    where?: TransportRequestWhereInput
    orderBy?: TransportRequestOrderByWithRelationInput | TransportRequestOrderByWithRelationInput[]
    cursor?: TransportRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransportRequestScalarFieldEnum | TransportRequestScalarFieldEnum[]
  }

  /**
   * Facility.destinationTrips
   */
  export type Facility$destinationTripsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransportRequest
     */
    select?: TransportRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportRequestInclude<ExtArgs> | null
    where?: TransportRequestWhereInput
    orderBy?: TransportRequestOrderByWithRelationInput | TransportRequestOrderByWithRelationInput[]
    cursor?: TransportRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransportRequestScalarFieldEnum | TransportRequestScalarFieldEnum[]
  }

  /**
   * Facility without action
   */
  export type FacilityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const CenterUserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    name: 'name',
    userType: 'userType',
    phone: 'phone',
    emailNotifications: 'emailNotifications',
    smsNotifications: 'smsNotifications',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CenterUserScalarFieldEnum = (typeof CenterUserScalarFieldEnum)[keyof typeof CenterUserScalarFieldEnum]


  export const HealthcareUserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    name: 'name',
    facilityName: 'facilityName',
    facilityType: 'facilityType',
    userType: 'userType',
    isActive: 'isActive',
    manageMultipleLocations: 'manageMultipleLocations',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HealthcareUserScalarFieldEnum = (typeof HealthcareUserScalarFieldEnum)[keyof typeof HealthcareUserScalarFieldEnum]


  export const HealthcareLocationScalarFieldEnum: {
    id: 'id',
    healthcareUserId: 'healthcareUserId',
    locationName: 'locationName',
    address: 'address',
    city: 'city',
    state: 'state',
    zipCode: 'zipCode',
    phone: 'phone',
    facilityType: 'facilityType',
    isActive: 'isActive',
    isPrimary: 'isPrimary',
    latitude: 'latitude',
    longitude: 'longitude',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HealthcareLocationScalarFieldEnum = (typeof HealthcareLocationScalarFieldEnum)[keyof typeof HealthcareLocationScalarFieldEnum]


  export const HospitalScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    city: 'city',
    state: 'state',
    zipCode: 'zipCode',
    phone: 'phone',
    email: 'email',
    type: 'type',
    capabilities: 'capabilities',
    region: 'region',
    coordinates: 'coordinates',
    latitude: 'latitude',
    longitude: 'longitude',
    operatingHours: 'operatingHours',
    isActive: 'isActive',
    requiresReview: 'requiresReview',
    approvedAt: 'approvedAt',
    approvedBy: 'approvedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HospitalScalarFieldEnum = (typeof HospitalScalarFieldEnum)[keyof typeof HospitalScalarFieldEnum]


  export const EMSUserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    name: 'name',
    agencyName: 'agencyName',
    agencyId: 'agencyId',
    isActive: 'isActive',
    userType: 'userType',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EMSUserScalarFieldEnum = (typeof EMSUserScalarFieldEnum)[keyof typeof EMSUserScalarFieldEnum]


  export const EMSAgencyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    contactName: 'contactName',
    phone: 'phone',
    email: 'email',
    address: 'address',
    city: 'city',
    state: 'state',
    zipCode: 'zipCode',
    serviceArea: 'serviceArea',
    operatingHours: 'operatingHours',
    capabilities: 'capabilities',
    pricingStructure: 'pricingStructure',
    isActive: 'isActive',
    status: 'status',
    addedBy: 'addedBy',
    addedAt: 'addedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    acceptsNotifications: 'acceptsNotifications',
    approvedAt: 'approvedAt',
    approvedBy: 'approvedBy',
    availableUnits: 'availableUnits',
    lastUpdated: 'lastUpdated',
    latitude: 'latitude',
    longitude: 'longitude',
    notificationMethods: 'notificationMethods',
    requiresReview: 'requiresReview',
    serviceRadius: 'serviceRadius',
    totalUnits: 'totalUnits'
  };

  export type EMSAgencyScalarFieldEnum = (typeof EMSAgencyScalarFieldEnum)[keyof typeof EMSAgencyScalarFieldEnum]


  export const TripScalarFieldEnum: {
    id: 'id',
    tripNumber: 'tripNumber',
    patientId: 'patientId',
    patientWeight: 'patientWeight',
    specialNeeds: 'specialNeeds',
    fromLocation: 'fromLocation',
    toLocation: 'toLocation',
    scheduledTime: 'scheduledTime',
    transportLevel: 'transportLevel',
    urgencyLevel: 'urgencyLevel',
    diagnosis: 'diagnosis',
    mobilityLevel: 'mobilityLevel',
    oxygenRequired: 'oxygenRequired',
    monitoringRequired: 'monitoringRequired',
    generateQRCode: 'generateQRCode',
    qrCodeData: 'qrCodeData',
    selectedAgencies: 'selectedAgencies',
    notificationRadius: 'notificationRadius',
    transferRequestTime: 'transferRequestTime',
    transferAcceptedTime: 'transferAcceptedTime',
    emsArrivalTime: 'emsArrivalTime',
    emsDepartureTime: 'emsDepartureTime',
    actualStartTime: 'actualStartTime',
    actualEndTime: 'actualEndTime',
    status: 'status',
    priority: 'priority',
    notes: 'notes',
    assignedTo: 'assignedTo',
    assignedAgencyId: 'assignedAgencyId',
    assignedUnitId: 'assignedUnitId',
    acceptedTimestamp: 'acceptedTimestamp',
    pickupTimestamp: 'pickupTimestamp',
    completionTimestamp: 'completionTimestamp',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    actualTripTimeMinutes: 'actualTripTimeMinutes',
    backhaulOpportunity: 'backhaulOpportunity',
    completionTimeMinutes: 'completionTimeMinutes',
    customerSatisfaction: 'customerSatisfaction',
    deadheadMiles: 'deadheadMiles',
    destinationLatitude: 'destinationLatitude',
    destinationLongitude: 'destinationLongitude',
    distanceMiles: 'distanceMiles',
    efficiency: 'efficiency',
    estimatedTripTimeMinutes: 'estimatedTripTimeMinutes',
    insuranceCompany: 'insuranceCompany',
    insurancePayRate: 'insurancePayRate',
    loadedMiles: 'loadedMiles',
    originLatitude: 'originLatitude',
    originLongitude: 'originLongitude',
    perMileRate: 'perMileRate',
    performanceScore: 'performanceScore',
    requestTimestamp: 'requestTimestamp',
    responseTimeMinutes: 'responseTimeMinutes',
    revenuePerHour: 'revenuePerHour',
    tripCost: 'tripCost',
    pickupLocationId: 'pickupLocationId',
    maxResponses: 'maxResponses',
    responseDeadline: 'responseDeadline',
    responseStatus: 'responseStatus',
    selectionMode: 'selectionMode'
  };

  export type TripScalarFieldEnum = (typeof TripScalarFieldEnum)[keyof typeof TripScalarFieldEnum]


  export const AgencyResponseScalarFieldEnum: {
    id: 'id',
    tripId: 'tripId',
    agencyId: 'agencyId',
    response: 'response',
    responseTimestamp: 'responseTimestamp',
    responseNotes: 'responseNotes',
    estimatedArrival: 'estimatedArrival',
    isSelected: 'isSelected',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AgencyResponseScalarFieldEnum = (typeof AgencyResponseScalarFieldEnum)[keyof typeof AgencyResponseScalarFieldEnum]


  export const SystemAnalyticsScalarFieldEnum: {
    id: 'id',
    metricName: 'metricName',
    metricValue: 'metricValue',
    timestamp: 'timestamp',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type SystemAnalyticsScalarFieldEnum = (typeof SystemAnalyticsScalarFieldEnum)[keyof typeof SystemAnalyticsScalarFieldEnum]


  export const TripCostBreakdownScalarFieldEnum: {
    id: 'id',
    tripId: 'tripId',
    baseRevenue: 'baseRevenue',
    mileageRevenue: 'mileageRevenue',
    priorityRevenue: 'priorityRevenue',
    specialRequirementsRevenue: 'specialRequirementsRevenue',
    insuranceAdjustment: 'insuranceAdjustment',
    totalRevenue: 'totalRevenue',
    crewLaborCost: 'crewLaborCost',
    vehicleCost: 'vehicleCost',
    fuelCost: 'fuelCost',
    maintenanceCost: 'maintenanceCost',
    overheadCost: 'overheadCost',
    totalCost: 'totalCost',
    grossProfit: 'grossProfit',
    profitMargin: 'profitMargin',
    revenuePerMile: 'revenuePerMile',
    costPerMile: 'costPerMile',
    loadedMileRatio: 'loadedMileRatio',
    deadheadMileRatio: 'deadheadMileRatio',
    utilizationRate: 'utilizationRate',
    tripDistance: 'tripDistance',
    loadedMiles: 'loadedMiles',
    deadheadMiles: 'deadheadMiles',
    tripDurationHours: 'tripDurationHours',
    transportLevel: 'transportLevel',
    priorityLevel: 'priorityLevel',
    costCenterId: 'costCenterId',
    costCenterName: 'costCenterName',
    calculatedAt: 'calculatedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TripCostBreakdownScalarFieldEnum = (typeof TripCostBreakdownScalarFieldEnum)[keyof typeof TripCostBreakdownScalarFieldEnum]


  export const CostCenterScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    code: 'code',
    overheadRate: 'overheadRate',
    fixedCosts: 'fixedCosts',
    variableCosts: 'variableCosts',
    allocationMethod: 'allocationMethod',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CostCenterScalarFieldEnum = (typeof CostCenterScalarFieldEnum)[keyof typeof CostCenterScalarFieldEnum]


  export const Backhaul_opportunitiesScalarFieldEnum: {
    id: 'id',
    tripId1: 'tripId1',
    tripId2: 'tripId2',
    revenueBonus: 'revenueBonus',
    efficiency: 'efficiency',
    createdAt: 'createdAt',
    isActive: 'isActive'
  };

  export type Backhaul_opportunitiesScalarFieldEnum = (typeof Backhaul_opportunitiesScalarFieldEnum)[keyof typeof Backhaul_opportunitiesScalarFieldEnum]


  export const Pickup_locationsScalarFieldEnum: {
    id: 'id',
    hospitalId: 'hospitalId',
    name: 'name',
    description: 'description',
    contactPhone: 'contactPhone',
    contactEmail: 'contactEmail',
    floor: 'floor',
    room: 'room',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Pickup_locationsScalarFieldEnum = (typeof Pickup_locationsScalarFieldEnum)[keyof typeof Pickup_locationsScalarFieldEnum]


  export const Pricing_modelsScalarFieldEnum: {
    id: 'id',
    agencyId: 'agencyId',
    name: 'name',
    isActive: 'isActive',
    baseRates: 'baseRates',
    perMileRates: 'perMileRates',
    priorityMultipliers: 'priorityMultipliers',
    peakHourMultipliers: 'peakHourMultipliers',
    weekendMultipliers: 'weekendMultipliers',
    seasonalMultipliers: 'seasonalMultipliers',
    zoneMultipliers: 'zoneMultipliers',
    distanceTiers: 'distanceTiers',
    specialRequirements: 'specialRequirements',
    isolationPricing: 'isolationPricing',
    bariatricPricing: 'bariatricPricing',
    oxygenPricing: 'oxygenPricing',
    monitoringPricing: 'monitoringPricing',
    insuranceRates: 'insuranceRates',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Pricing_modelsScalarFieldEnum = (typeof Pricing_modelsScalarFieldEnum)[keyof typeof Pricing_modelsScalarFieldEnum]


  export const Route_optimization_settingsScalarFieldEnum: {
    id: 'id',
    agencyId: 'agencyId',
    deadheadMileWeight: 'deadheadMileWeight',
    waitTimeWeight: 'waitTimeWeight',
    backhaulBonusWeight: 'backhaulBonusWeight',
    overtimeRiskWeight: 'overtimeRiskWeight',
    revenueWeight: 'revenueWeight',
    maxDeadheadMiles: 'maxDeadheadMiles',
    maxWaitTimeMinutes: 'maxWaitTimeMinutes',
    maxOvertimeHours: 'maxOvertimeHours',
    maxResponseTimeMinutes: 'maxResponseTimeMinutes',
    maxServiceDistance: 'maxServiceDistance',
    backhaulTimeWindow: 'backhaulTimeWindow',
    backhaulDistanceLimit: 'backhaulDistanceLimit',
    backhaulRevenueBonus: 'backhaulRevenueBonus',
    enableBackhaulOptimization: 'enableBackhaulOptimization',
    targetLoadedMileRatio: 'targetLoadedMileRatio',
    targetRevenuePerHour: 'targetRevenuePerHour',
    targetResponseTime: 'targetResponseTime',
    targetEfficiency: 'targetEfficiency',
    optimizationAlgorithm: 'optimizationAlgorithm',
    maxOptimizationTime: 'maxOptimizationTime',
    enableRealTimeOptimization: 'enableRealTimeOptimization',
    crewAvailabilityWeight: 'crewAvailabilityWeight',
    equipmentCompatibilityWeight: 'equipmentCompatibilityWeight',
    patientPriorityWeight: 'patientPriorityWeight',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Route_optimization_settingsScalarFieldEnum = (typeof Route_optimization_settingsScalarFieldEnum)[keyof typeof Route_optimization_settingsScalarFieldEnum]


  export const UnitScalarFieldEnum: {
    id: 'id',
    agencyId: 'agencyId',
    unitNumber: 'unitNumber',
    type: 'type',
    status: 'status',
    currentStatus: 'currentStatus',
    currentLocation: 'currentLocation',
    capabilities: 'capabilities',
    crewSize: 'crewSize',
    equipment: 'equipment',
    location: 'location',
    latitude: 'latitude',
    longitude: 'longitude',
    lastMaintenance: 'lastMaintenance',
    nextMaintenance: 'nextMaintenance',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UnitScalarFieldEnum = (typeof UnitScalarFieldEnum)[keyof typeof UnitScalarFieldEnum]


  export const Unit_analyticsScalarFieldEnum: {
    id: 'id',
    unitId: 'unitId',
    performanceScore: 'performanceScore',
    efficiency: 'efficiency',
    totalTrips: 'totalTrips',
    totalTripsCompleted: 'totalTripsCompleted',
    averageResponseTime: 'averageResponseTime',
    lastUpdated: 'lastUpdated'
  };

  export type Unit_analyticsScalarFieldEnum = (typeof Unit_analyticsScalarFieldEnum)[keyof typeof Unit_analyticsScalarFieldEnum]


  export const NotificationPreferenceScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    notificationType: 'notificationType',
    emailEnabled: 'emailEnabled',
    smsEnabled: 'smsEnabled',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationPreferenceScalarFieldEnum = (typeof NotificationPreferenceScalarFieldEnum)[keyof typeof NotificationPreferenceScalarFieldEnum]


  export const NotificationLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    notificationType: 'notificationType',
    channel: 'channel',
    status: 'status',
    sentAt: 'sentAt',
    deliveredAt: 'deliveredAt',
    errorMessage: 'errorMessage'
  };

  export type NotificationLogScalarFieldEnum = (typeof NotificationLogScalarFieldEnum)[keyof typeof NotificationLogScalarFieldEnum]


  export const DropdownOptionScalarFieldEnum: {
    id: 'id',
    category: 'category',
    value: 'value',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DropdownOptionScalarFieldEnum = (typeof DropdownOptionScalarFieldEnum)[keyof typeof DropdownOptionScalarFieldEnum]


  export const CategoryDefaultScalarFieldEnum: {
    id: 'id',
    category: 'category',
    optionId: 'optionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CategoryDefaultScalarFieldEnum = (typeof CategoryDefaultScalarFieldEnum)[keyof typeof CategoryDefaultScalarFieldEnum]


  export const TransportRequestScalarFieldEnum: {
    id: 'id',
    tripNumber: 'tripNumber',
    patientId: 'patientId',
    patientWeight: 'patientWeight',
    specialNeeds: 'specialNeeds',
    originFacilityId: 'originFacilityId',
    destinationFacilityId: 'destinationFacilityId',
    fromLocation: 'fromLocation',
    toLocation: 'toLocation',
    fromLocationId: 'fromLocationId',
    isMultiLocationFacility: 'isMultiLocationFacility',
    scheduledTime: 'scheduledTime',
    transportLevel: 'transportLevel',
    urgencyLevel: 'urgencyLevel',
    priority: 'priority',
    status: 'status',
    specialRequirements: 'specialRequirements',
    diagnosis: 'diagnosis',
    mobilityLevel: 'mobilityLevel',
    oxygenRequired: 'oxygenRequired',
    monitoringRequired: 'monitoringRequired',
    generateQRCode: 'generateQRCode',
    qrCodeData: 'qrCodeData',
    selectedAgencies: 'selectedAgencies',
    notificationRadius: 'notificationRadius',
    requestTimestamp: 'requestTimestamp',
    acceptedTimestamp: 'acceptedTimestamp',
    pickupTimestamp: 'pickupTimestamp',
    arrivalTimestamp: 'arrivalTimestamp',
    departureTimestamp: 'departureTimestamp',
    completionTimestamp: 'completionTimestamp',
    pickupLocationId: 'pickupLocationId',
    assignedAgencyId: 'assignedAgencyId',
    assignedUnitId: 'assignedUnitId',
    createdById: 'createdById',
    healthcareCreatedById: 'healthcareCreatedById',
    isolation: 'isolation',
    bariatric: 'bariatric',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TransportRequestScalarFieldEnum = (typeof TransportRequestScalarFieldEnum)[keyof typeof TransportRequestScalarFieldEnum]


  export const FacilityScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    city: 'city',
    state: 'state',
    zipCode: 'zipCode',
    phone: 'phone',
    email: 'email',
    type: 'type',
    capabilities: 'capabilities',
    region: 'region',
    coordinates: 'coordinates',
    latitude: 'latitude',
    longitude: 'longitude',
    operatingHours: 'operatingHours',
    isActive: 'isActive',
    requiresReview: 'requiresReview',
    approvedAt: 'approvedAt',
    approvedBy: 'approvedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FacilityScalarFieldEnum = (typeof FacilityScalarFieldEnum)[keyof typeof FacilityScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    
  /**
   * Deep Input Types
   */


  export type CenterUserWhereInput = {
    AND?: CenterUserWhereInput | CenterUserWhereInput[]
    OR?: CenterUserWhereInput[]
    NOT?: CenterUserWhereInput | CenterUserWhereInput[]
    id?: StringFilter<"CenterUser"> | string
    email?: StringFilter<"CenterUser"> | string
    password?: StringFilter<"CenterUser"> | string
    name?: StringFilter<"CenterUser"> | string
    userType?: StringFilter<"CenterUser"> | string
    phone?: StringNullableFilter<"CenterUser"> | string | null
    emailNotifications?: BoolFilter<"CenterUser"> | boolean
    smsNotifications?: BoolFilter<"CenterUser"> | boolean
    isActive?: BoolFilter<"CenterUser"> | boolean
    createdAt?: DateTimeFilter<"CenterUser"> | Date | string
    updatedAt?: DateTimeFilter<"CenterUser"> | Date | string
    notificationLogs?: NotificationLogListRelationFilter
    notificationPreferences?: NotificationPreferenceListRelationFilter
  }

  export type CenterUserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    userType?: SortOrder
    phone?: SortOrderInput | SortOrder
    emailNotifications?: SortOrder
    smsNotifications?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    notificationLogs?: NotificationLogOrderByRelationAggregateInput
    notificationPreferences?: NotificationPreferenceOrderByRelationAggregateInput
  }

  export type CenterUserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: CenterUserWhereInput | CenterUserWhereInput[]
    OR?: CenterUserWhereInput[]
    NOT?: CenterUserWhereInput | CenterUserWhereInput[]
    password?: StringFilter<"CenterUser"> | string
    name?: StringFilter<"CenterUser"> | string
    userType?: StringFilter<"CenterUser"> | string
    phone?: StringNullableFilter<"CenterUser"> | string | null
    emailNotifications?: BoolFilter<"CenterUser"> | boolean
    smsNotifications?: BoolFilter<"CenterUser"> | boolean
    isActive?: BoolFilter<"CenterUser"> | boolean
    createdAt?: DateTimeFilter<"CenterUser"> | Date | string
    updatedAt?: DateTimeFilter<"CenterUser"> | Date | string
    notificationLogs?: NotificationLogListRelationFilter
    notificationPreferences?: NotificationPreferenceListRelationFilter
  }, "id" | "email">

  export type CenterUserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    userType?: SortOrder
    phone?: SortOrderInput | SortOrder
    emailNotifications?: SortOrder
    smsNotifications?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CenterUserCountOrderByAggregateInput
    _max?: CenterUserMaxOrderByAggregateInput
    _min?: CenterUserMinOrderByAggregateInput
  }

  export type CenterUserScalarWhereWithAggregatesInput = {
    AND?: CenterUserScalarWhereWithAggregatesInput | CenterUserScalarWhereWithAggregatesInput[]
    OR?: CenterUserScalarWhereWithAggregatesInput[]
    NOT?: CenterUserScalarWhereWithAggregatesInput | CenterUserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CenterUser"> | string
    email?: StringWithAggregatesFilter<"CenterUser"> | string
    password?: StringWithAggregatesFilter<"CenterUser"> | string
    name?: StringWithAggregatesFilter<"CenterUser"> | string
    userType?: StringWithAggregatesFilter<"CenterUser"> | string
    phone?: StringNullableWithAggregatesFilter<"CenterUser"> | string | null
    emailNotifications?: BoolWithAggregatesFilter<"CenterUser"> | boolean
    smsNotifications?: BoolWithAggregatesFilter<"CenterUser"> | boolean
    isActive?: BoolWithAggregatesFilter<"CenterUser"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CenterUser"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CenterUser"> | Date | string
  }

  export type HealthcareUserWhereInput = {
    AND?: HealthcareUserWhereInput | HealthcareUserWhereInput[]
    OR?: HealthcareUserWhereInput[]
    NOT?: HealthcareUserWhereInput | HealthcareUserWhereInput[]
    id?: StringFilter<"HealthcareUser"> | string
    email?: StringFilter<"HealthcareUser"> | string
    password?: StringFilter<"HealthcareUser"> | string
    name?: StringFilter<"HealthcareUser"> | string
    facilityName?: StringFilter<"HealthcareUser"> | string
    facilityType?: StringFilter<"HealthcareUser"> | string
    userType?: StringFilter<"HealthcareUser"> | string
    isActive?: BoolFilter<"HealthcareUser"> | boolean
    manageMultipleLocations?: BoolFilter<"HealthcareUser"> | boolean
    createdAt?: DateTimeFilter<"HealthcareUser"> | Date | string
    updatedAt?: DateTimeFilter<"HealthcareUser"> | Date | string
    locations?: HealthcareLocationListRelationFilter
  }

  export type HealthcareUserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    facilityName?: SortOrder
    facilityType?: SortOrder
    userType?: SortOrder
    isActive?: SortOrder
    manageMultipleLocations?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    locations?: HealthcareLocationOrderByRelationAggregateInput
  }

  export type HealthcareUserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: HealthcareUserWhereInput | HealthcareUserWhereInput[]
    OR?: HealthcareUserWhereInput[]
    NOT?: HealthcareUserWhereInput | HealthcareUserWhereInput[]
    password?: StringFilter<"HealthcareUser"> | string
    name?: StringFilter<"HealthcareUser"> | string
    facilityName?: StringFilter<"HealthcareUser"> | string
    facilityType?: StringFilter<"HealthcareUser"> | string
    userType?: StringFilter<"HealthcareUser"> | string
    isActive?: BoolFilter<"HealthcareUser"> | boolean
    manageMultipleLocations?: BoolFilter<"HealthcareUser"> | boolean
    createdAt?: DateTimeFilter<"HealthcareUser"> | Date | string
    updatedAt?: DateTimeFilter<"HealthcareUser"> | Date | string
    locations?: HealthcareLocationListRelationFilter
  }, "id" | "email">

  export type HealthcareUserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    facilityName?: SortOrder
    facilityType?: SortOrder
    userType?: SortOrder
    isActive?: SortOrder
    manageMultipleLocations?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HealthcareUserCountOrderByAggregateInput
    _max?: HealthcareUserMaxOrderByAggregateInput
    _min?: HealthcareUserMinOrderByAggregateInput
  }

  export type HealthcareUserScalarWhereWithAggregatesInput = {
    AND?: HealthcareUserScalarWhereWithAggregatesInput | HealthcareUserScalarWhereWithAggregatesInput[]
    OR?: HealthcareUserScalarWhereWithAggregatesInput[]
    NOT?: HealthcareUserScalarWhereWithAggregatesInput | HealthcareUserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HealthcareUser"> | string
    email?: StringWithAggregatesFilter<"HealthcareUser"> | string
    password?: StringWithAggregatesFilter<"HealthcareUser"> | string
    name?: StringWithAggregatesFilter<"HealthcareUser"> | string
    facilityName?: StringWithAggregatesFilter<"HealthcareUser"> | string
    facilityType?: StringWithAggregatesFilter<"HealthcareUser"> | string
    userType?: StringWithAggregatesFilter<"HealthcareUser"> | string
    isActive?: BoolWithAggregatesFilter<"HealthcareUser"> | boolean
    manageMultipleLocations?: BoolWithAggregatesFilter<"HealthcareUser"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"HealthcareUser"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"HealthcareUser"> | Date | string
  }

  export type HealthcareLocationWhereInput = {
    AND?: HealthcareLocationWhereInput | HealthcareLocationWhereInput[]
    OR?: HealthcareLocationWhereInput[]
    NOT?: HealthcareLocationWhereInput | HealthcareLocationWhereInput[]
    id?: StringFilter<"HealthcareLocation"> | string
    healthcareUserId?: StringFilter<"HealthcareLocation"> | string
    locationName?: StringFilter<"HealthcareLocation"> | string
    address?: StringFilter<"HealthcareLocation"> | string
    city?: StringFilter<"HealthcareLocation"> | string
    state?: StringFilter<"HealthcareLocation"> | string
    zipCode?: StringFilter<"HealthcareLocation"> | string
    phone?: StringNullableFilter<"HealthcareLocation"> | string | null
    facilityType?: StringFilter<"HealthcareLocation"> | string
    isActive?: BoolFilter<"HealthcareLocation"> | boolean
    isPrimary?: BoolFilter<"HealthcareLocation"> | boolean
    latitude?: FloatNullableFilter<"HealthcareLocation"> | number | null
    longitude?: FloatNullableFilter<"HealthcareLocation"> | number | null
    createdAt?: DateTimeFilter<"HealthcareLocation"> | Date | string
    updatedAt?: DateTimeFilter<"HealthcareLocation"> | Date | string
    healthcareUser?: XOR<HealthcareUserRelationFilter, HealthcareUserWhereInput>
    transportRequests?: TransportRequestListRelationFilter
  }

  export type HealthcareLocationOrderByWithRelationInput = {
    id?: SortOrder
    healthcareUserId?: SortOrder
    locationName?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    phone?: SortOrderInput | SortOrder
    facilityType?: SortOrder
    isActive?: SortOrder
    isPrimary?: SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    healthcareUser?: HealthcareUserOrderByWithRelationInput
    transportRequests?: TransportRequestOrderByRelationAggregateInput
  }

  export type HealthcareLocationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HealthcareLocationWhereInput | HealthcareLocationWhereInput[]
    OR?: HealthcareLocationWhereInput[]
    NOT?: HealthcareLocationWhereInput | HealthcareLocationWhereInput[]
    healthcareUserId?: StringFilter<"HealthcareLocation"> | string
    locationName?: StringFilter<"HealthcareLocation"> | string
    address?: StringFilter<"HealthcareLocation"> | string
    city?: StringFilter<"HealthcareLocation"> | string
    state?: StringFilter<"HealthcareLocation"> | string
    zipCode?: StringFilter<"HealthcareLocation"> | string
    phone?: StringNullableFilter<"HealthcareLocation"> | string | null
    facilityType?: StringFilter<"HealthcareLocation"> | string
    isActive?: BoolFilter<"HealthcareLocation"> | boolean
    isPrimary?: BoolFilter<"HealthcareLocation"> | boolean
    latitude?: FloatNullableFilter<"HealthcareLocation"> | number | null
    longitude?: FloatNullableFilter<"HealthcareLocation"> | number | null
    createdAt?: DateTimeFilter<"HealthcareLocation"> | Date | string
    updatedAt?: DateTimeFilter<"HealthcareLocation"> | Date | string
    healthcareUser?: XOR<HealthcareUserRelationFilter, HealthcareUserWhereInput>
    transportRequests?: TransportRequestListRelationFilter
  }, "id">

  export type HealthcareLocationOrderByWithAggregationInput = {
    id?: SortOrder
    healthcareUserId?: SortOrder
    locationName?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    phone?: SortOrderInput | SortOrder
    facilityType?: SortOrder
    isActive?: SortOrder
    isPrimary?: SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HealthcareLocationCountOrderByAggregateInput
    _avg?: HealthcareLocationAvgOrderByAggregateInput
    _max?: HealthcareLocationMaxOrderByAggregateInput
    _min?: HealthcareLocationMinOrderByAggregateInput
    _sum?: HealthcareLocationSumOrderByAggregateInput
  }

  export type HealthcareLocationScalarWhereWithAggregatesInput = {
    AND?: HealthcareLocationScalarWhereWithAggregatesInput | HealthcareLocationScalarWhereWithAggregatesInput[]
    OR?: HealthcareLocationScalarWhereWithAggregatesInput[]
    NOT?: HealthcareLocationScalarWhereWithAggregatesInput | HealthcareLocationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HealthcareLocation"> | string
    healthcareUserId?: StringWithAggregatesFilter<"HealthcareLocation"> | string
    locationName?: StringWithAggregatesFilter<"HealthcareLocation"> | string
    address?: StringWithAggregatesFilter<"HealthcareLocation"> | string
    city?: StringWithAggregatesFilter<"HealthcareLocation"> | string
    state?: StringWithAggregatesFilter<"HealthcareLocation"> | string
    zipCode?: StringWithAggregatesFilter<"HealthcareLocation"> | string
    phone?: StringNullableWithAggregatesFilter<"HealthcareLocation"> | string | null
    facilityType?: StringWithAggregatesFilter<"HealthcareLocation"> | string
    isActive?: BoolWithAggregatesFilter<"HealthcareLocation"> | boolean
    isPrimary?: BoolWithAggregatesFilter<"HealthcareLocation"> | boolean
    latitude?: FloatNullableWithAggregatesFilter<"HealthcareLocation"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"HealthcareLocation"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"HealthcareLocation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"HealthcareLocation"> | Date | string
  }

  export type HospitalWhereInput = {
    AND?: HospitalWhereInput | HospitalWhereInput[]
    OR?: HospitalWhereInput[]
    NOT?: HospitalWhereInput | HospitalWhereInput[]
    id?: StringFilter<"Hospital"> | string
    name?: StringFilter<"Hospital"> | string
    address?: StringFilter<"Hospital"> | string
    city?: StringFilter<"Hospital"> | string
    state?: StringFilter<"Hospital"> | string
    zipCode?: StringFilter<"Hospital"> | string
    phone?: StringNullableFilter<"Hospital"> | string | null
    email?: StringNullableFilter<"Hospital"> | string | null
    type?: StringFilter<"Hospital"> | string
    capabilities?: StringNullableListFilter<"Hospital">
    region?: StringFilter<"Hospital"> | string
    coordinates?: JsonNullableFilter<"Hospital">
    latitude?: FloatNullableFilter<"Hospital"> | number | null
    longitude?: FloatNullableFilter<"Hospital"> | number | null
    operatingHours?: StringNullableFilter<"Hospital"> | string | null
    isActive?: BoolFilter<"Hospital"> | boolean
    requiresReview?: BoolFilter<"Hospital"> | boolean
    approvedAt?: DateTimeNullableFilter<"Hospital"> | Date | string | null
    approvedBy?: StringNullableFilter<"Hospital"> | string | null
    createdAt?: DateTimeFilter<"Hospital"> | Date | string
    updatedAt?: DateTimeFilter<"Hospital"> | Date | string
  }

  export type HospitalOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    type?: SortOrder
    capabilities?: SortOrder
    region?: SortOrder
    coordinates?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    operatingHours?: SortOrderInput | SortOrder
    isActive?: SortOrder
    requiresReview?: SortOrder
    approvedAt?: SortOrderInput | SortOrder
    approvedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HospitalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HospitalWhereInput | HospitalWhereInput[]
    OR?: HospitalWhereInput[]
    NOT?: HospitalWhereInput | HospitalWhereInput[]
    name?: StringFilter<"Hospital"> | string
    address?: StringFilter<"Hospital"> | string
    city?: StringFilter<"Hospital"> | string
    state?: StringFilter<"Hospital"> | string
    zipCode?: StringFilter<"Hospital"> | string
    phone?: StringNullableFilter<"Hospital"> | string | null
    email?: StringNullableFilter<"Hospital"> | string | null
    type?: StringFilter<"Hospital"> | string
    capabilities?: StringNullableListFilter<"Hospital">
    region?: StringFilter<"Hospital"> | string
    coordinates?: JsonNullableFilter<"Hospital">
    latitude?: FloatNullableFilter<"Hospital"> | number | null
    longitude?: FloatNullableFilter<"Hospital"> | number | null
    operatingHours?: StringNullableFilter<"Hospital"> | string | null
    isActive?: BoolFilter<"Hospital"> | boolean
    requiresReview?: BoolFilter<"Hospital"> | boolean
    approvedAt?: DateTimeNullableFilter<"Hospital"> | Date | string | null
    approvedBy?: StringNullableFilter<"Hospital"> | string | null
    createdAt?: DateTimeFilter<"Hospital"> | Date | string
    updatedAt?: DateTimeFilter<"Hospital"> | Date | string
  }, "id">

  export type HospitalOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    type?: SortOrder
    capabilities?: SortOrder
    region?: SortOrder
    coordinates?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    operatingHours?: SortOrderInput | SortOrder
    isActive?: SortOrder
    requiresReview?: SortOrder
    approvedAt?: SortOrderInput | SortOrder
    approvedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HospitalCountOrderByAggregateInput
    _avg?: HospitalAvgOrderByAggregateInput
    _max?: HospitalMaxOrderByAggregateInput
    _min?: HospitalMinOrderByAggregateInput
    _sum?: HospitalSumOrderByAggregateInput
  }

  export type HospitalScalarWhereWithAggregatesInput = {
    AND?: HospitalScalarWhereWithAggregatesInput | HospitalScalarWhereWithAggregatesInput[]
    OR?: HospitalScalarWhereWithAggregatesInput[]
    NOT?: HospitalScalarWhereWithAggregatesInput | HospitalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Hospital"> | string
    name?: StringWithAggregatesFilter<"Hospital"> | string
    address?: StringWithAggregatesFilter<"Hospital"> | string
    city?: StringWithAggregatesFilter<"Hospital"> | string
    state?: StringWithAggregatesFilter<"Hospital"> | string
    zipCode?: StringWithAggregatesFilter<"Hospital"> | string
    phone?: StringNullableWithAggregatesFilter<"Hospital"> | string | null
    email?: StringNullableWithAggregatesFilter<"Hospital"> | string | null
    type?: StringWithAggregatesFilter<"Hospital"> | string
    capabilities?: StringNullableListFilter<"Hospital">
    region?: StringWithAggregatesFilter<"Hospital"> | string
    coordinates?: JsonNullableWithAggregatesFilter<"Hospital">
    latitude?: FloatNullableWithAggregatesFilter<"Hospital"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"Hospital"> | number | null
    operatingHours?: StringNullableWithAggregatesFilter<"Hospital"> | string | null
    isActive?: BoolWithAggregatesFilter<"Hospital"> | boolean
    requiresReview?: BoolWithAggregatesFilter<"Hospital"> | boolean
    approvedAt?: DateTimeNullableWithAggregatesFilter<"Hospital"> | Date | string | null
    approvedBy?: StringNullableWithAggregatesFilter<"Hospital"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Hospital"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Hospital"> | Date | string
  }

  export type EMSUserWhereInput = {
    AND?: EMSUserWhereInput | EMSUserWhereInput[]
    OR?: EMSUserWhereInput[]
    NOT?: EMSUserWhereInput | EMSUserWhereInput[]
    id?: StringFilter<"EMSUser"> | string
    email?: StringFilter<"EMSUser"> | string
    password?: StringFilter<"EMSUser"> | string
    name?: StringFilter<"EMSUser"> | string
    agencyName?: StringFilter<"EMSUser"> | string
    agencyId?: StringNullableFilter<"EMSUser"> | string | null
    isActive?: BoolFilter<"EMSUser"> | boolean
    userType?: StringFilter<"EMSUser"> | string
    createdAt?: DateTimeFilter<"EMSUser"> | Date | string
    updatedAt?: DateTimeFilter<"EMSUser"> | Date | string
    agency?: XOR<EMSAgencyNullableRelationFilter, EMSAgencyWhereInput> | null
  }

  export type EMSUserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    agencyName?: SortOrder
    agencyId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    userType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    agency?: EMSAgencyOrderByWithRelationInput
  }

  export type EMSUserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: EMSUserWhereInput | EMSUserWhereInput[]
    OR?: EMSUserWhereInput[]
    NOT?: EMSUserWhereInput | EMSUserWhereInput[]
    password?: StringFilter<"EMSUser"> | string
    name?: StringFilter<"EMSUser"> | string
    agencyName?: StringFilter<"EMSUser"> | string
    agencyId?: StringNullableFilter<"EMSUser"> | string | null
    isActive?: BoolFilter<"EMSUser"> | boolean
    userType?: StringFilter<"EMSUser"> | string
    createdAt?: DateTimeFilter<"EMSUser"> | Date | string
    updatedAt?: DateTimeFilter<"EMSUser"> | Date | string
    agency?: XOR<EMSAgencyNullableRelationFilter, EMSAgencyWhereInput> | null
  }, "id" | "email">

  export type EMSUserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    agencyName?: SortOrder
    agencyId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    userType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EMSUserCountOrderByAggregateInput
    _max?: EMSUserMaxOrderByAggregateInput
    _min?: EMSUserMinOrderByAggregateInput
  }

  export type EMSUserScalarWhereWithAggregatesInput = {
    AND?: EMSUserScalarWhereWithAggregatesInput | EMSUserScalarWhereWithAggregatesInput[]
    OR?: EMSUserScalarWhereWithAggregatesInput[]
    NOT?: EMSUserScalarWhereWithAggregatesInput | EMSUserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EMSUser"> | string
    email?: StringWithAggregatesFilter<"EMSUser"> | string
    password?: StringWithAggregatesFilter<"EMSUser"> | string
    name?: StringWithAggregatesFilter<"EMSUser"> | string
    agencyName?: StringWithAggregatesFilter<"EMSUser"> | string
    agencyId?: StringNullableWithAggregatesFilter<"EMSUser"> | string | null
    isActive?: BoolWithAggregatesFilter<"EMSUser"> | boolean
    userType?: StringWithAggregatesFilter<"EMSUser"> | string
    createdAt?: DateTimeWithAggregatesFilter<"EMSUser"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EMSUser"> | Date | string
  }

  export type EMSAgencyWhereInput = {
    AND?: EMSAgencyWhereInput | EMSAgencyWhereInput[]
    OR?: EMSAgencyWhereInput[]
    NOT?: EMSAgencyWhereInput | EMSAgencyWhereInput[]
    id?: StringFilter<"EMSAgency"> | string
    name?: StringFilter<"EMSAgency"> | string
    contactName?: StringFilter<"EMSAgency"> | string
    phone?: StringFilter<"EMSAgency"> | string
    email?: StringFilter<"EMSAgency"> | string
    address?: StringFilter<"EMSAgency"> | string
    city?: StringFilter<"EMSAgency"> | string
    state?: StringFilter<"EMSAgency"> | string
    zipCode?: StringFilter<"EMSAgency"> | string
    serviceArea?: StringNullableListFilter<"EMSAgency">
    operatingHours?: JsonNullableFilter<"EMSAgency">
    capabilities?: StringNullableListFilter<"EMSAgency">
    pricingStructure?: JsonNullableFilter<"EMSAgency">
    isActive?: BoolFilter<"EMSAgency"> | boolean
    status?: StringFilter<"EMSAgency"> | string
    addedBy?: StringNullableFilter<"EMSAgency"> | string | null
    addedAt?: DateTimeFilter<"EMSAgency"> | Date | string
    createdAt?: DateTimeFilter<"EMSAgency"> | Date | string
    updatedAt?: DateTimeFilter<"EMSAgency"> | Date | string
    acceptsNotifications?: BoolFilter<"EMSAgency"> | boolean
    approvedAt?: DateTimeNullableFilter<"EMSAgency"> | Date | string | null
    approvedBy?: StringNullableFilter<"EMSAgency"> | string | null
    availableUnits?: IntFilter<"EMSAgency"> | number
    lastUpdated?: DateTimeFilter<"EMSAgency"> | Date | string
    latitude?: FloatNullableFilter<"EMSAgency"> | number | null
    longitude?: FloatNullableFilter<"EMSAgency"> | number | null
    notificationMethods?: StringNullableListFilter<"EMSAgency">
    requiresReview?: BoolFilter<"EMSAgency"> | boolean
    serviceRadius?: IntNullableFilter<"EMSAgency"> | number | null
    totalUnits?: IntFilter<"EMSAgency"> | number
    units?: UnitListRelationFilter
    users?: EMSUserListRelationFilter
  }

  export type EMSAgencyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    contactName?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    serviceArea?: SortOrder
    operatingHours?: SortOrderInput | SortOrder
    capabilities?: SortOrder
    pricingStructure?: SortOrderInput | SortOrder
    isActive?: SortOrder
    status?: SortOrder
    addedBy?: SortOrderInput | SortOrder
    addedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    acceptsNotifications?: SortOrder
    approvedAt?: SortOrderInput | SortOrder
    approvedBy?: SortOrderInput | SortOrder
    availableUnits?: SortOrder
    lastUpdated?: SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    notificationMethods?: SortOrder
    requiresReview?: SortOrder
    serviceRadius?: SortOrderInput | SortOrder
    totalUnits?: SortOrder
    units?: UnitOrderByRelationAggregateInput
    users?: EMSUserOrderByRelationAggregateInput
  }

  export type EMSAgencyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EMSAgencyWhereInput | EMSAgencyWhereInput[]
    OR?: EMSAgencyWhereInput[]
    NOT?: EMSAgencyWhereInput | EMSAgencyWhereInput[]
    name?: StringFilter<"EMSAgency"> | string
    contactName?: StringFilter<"EMSAgency"> | string
    phone?: StringFilter<"EMSAgency"> | string
    email?: StringFilter<"EMSAgency"> | string
    address?: StringFilter<"EMSAgency"> | string
    city?: StringFilter<"EMSAgency"> | string
    state?: StringFilter<"EMSAgency"> | string
    zipCode?: StringFilter<"EMSAgency"> | string
    serviceArea?: StringNullableListFilter<"EMSAgency">
    operatingHours?: JsonNullableFilter<"EMSAgency">
    capabilities?: StringNullableListFilter<"EMSAgency">
    pricingStructure?: JsonNullableFilter<"EMSAgency">
    isActive?: BoolFilter<"EMSAgency"> | boolean
    status?: StringFilter<"EMSAgency"> | string
    addedBy?: StringNullableFilter<"EMSAgency"> | string | null
    addedAt?: DateTimeFilter<"EMSAgency"> | Date | string
    createdAt?: DateTimeFilter<"EMSAgency"> | Date | string
    updatedAt?: DateTimeFilter<"EMSAgency"> | Date | string
    acceptsNotifications?: BoolFilter<"EMSAgency"> | boolean
    approvedAt?: DateTimeNullableFilter<"EMSAgency"> | Date | string | null
    approvedBy?: StringNullableFilter<"EMSAgency"> | string | null
    availableUnits?: IntFilter<"EMSAgency"> | number
    lastUpdated?: DateTimeFilter<"EMSAgency"> | Date | string
    latitude?: FloatNullableFilter<"EMSAgency"> | number | null
    longitude?: FloatNullableFilter<"EMSAgency"> | number | null
    notificationMethods?: StringNullableListFilter<"EMSAgency">
    requiresReview?: BoolFilter<"EMSAgency"> | boolean
    serviceRadius?: IntNullableFilter<"EMSAgency"> | number | null
    totalUnits?: IntFilter<"EMSAgency"> | number
    units?: UnitListRelationFilter
    users?: EMSUserListRelationFilter
  }, "id">

  export type EMSAgencyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    contactName?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    serviceArea?: SortOrder
    operatingHours?: SortOrderInput | SortOrder
    capabilities?: SortOrder
    pricingStructure?: SortOrderInput | SortOrder
    isActive?: SortOrder
    status?: SortOrder
    addedBy?: SortOrderInput | SortOrder
    addedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    acceptsNotifications?: SortOrder
    approvedAt?: SortOrderInput | SortOrder
    approvedBy?: SortOrderInput | SortOrder
    availableUnits?: SortOrder
    lastUpdated?: SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    notificationMethods?: SortOrder
    requiresReview?: SortOrder
    serviceRadius?: SortOrderInput | SortOrder
    totalUnits?: SortOrder
    _count?: EMSAgencyCountOrderByAggregateInput
    _avg?: EMSAgencyAvgOrderByAggregateInput
    _max?: EMSAgencyMaxOrderByAggregateInput
    _min?: EMSAgencyMinOrderByAggregateInput
    _sum?: EMSAgencySumOrderByAggregateInput
  }

  export type EMSAgencyScalarWhereWithAggregatesInput = {
    AND?: EMSAgencyScalarWhereWithAggregatesInput | EMSAgencyScalarWhereWithAggregatesInput[]
    OR?: EMSAgencyScalarWhereWithAggregatesInput[]
    NOT?: EMSAgencyScalarWhereWithAggregatesInput | EMSAgencyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EMSAgency"> | string
    name?: StringWithAggregatesFilter<"EMSAgency"> | string
    contactName?: StringWithAggregatesFilter<"EMSAgency"> | string
    phone?: StringWithAggregatesFilter<"EMSAgency"> | string
    email?: StringWithAggregatesFilter<"EMSAgency"> | string
    address?: StringWithAggregatesFilter<"EMSAgency"> | string
    city?: StringWithAggregatesFilter<"EMSAgency"> | string
    state?: StringWithAggregatesFilter<"EMSAgency"> | string
    zipCode?: StringWithAggregatesFilter<"EMSAgency"> | string
    serviceArea?: StringNullableListFilter<"EMSAgency">
    operatingHours?: JsonNullableWithAggregatesFilter<"EMSAgency">
    capabilities?: StringNullableListFilter<"EMSAgency">
    pricingStructure?: JsonNullableWithAggregatesFilter<"EMSAgency">
    isActive?: BoolWithAggregatesFilter<"EMSAgency"> | boolean
    status?: StringWithAggregatesFilter<"EMSAgency"> | string
    addedBy?: StringNullableWithAggregatesFilter<"EMSAgency"> | string | null
    addedAt?: DateTimeWithAggregatesFilter<"EMSAgency"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"EMSAgency"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EMSAgency"> | Date | string
    acceptsNotifications?: BoolWithAggregatesFilter<"EMSAgency"> | boolean
    approvedAt?: DateTimeNullableWithAggregatesFilter<"EMSAgency"> | Date | string | null
    approvedBy?: StringNullableWithAggregatesFilter<"EMSAgency"> | string | null
    availableUnits?: IntWithAggregatesFilter<"EMSAgency"> | number
    lastUpdated?: DateTimeWithAggregatesFilter<"EMSAgency"> | Date | string
    latitude?: FloatNullableWithAggregatesFilter<"EMSAgency"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"EMSAgency"> | number | null
    notificationMethods?: StringNullableListFilter<"EMSAgency">
    requiresReview?: BoolWithAggregatesFilter<"EMSAgency"> | boolean
    serviceRadius?: IntNullableWithAggregatesFilter<"EMSAgency"> | number | null
    totalUnits?: IntWithAggregatesFilter<"EMSAgency"> | number
  }

  export type TripWhereInput = {
    AND?: TripWhereInput | TripWhereInput[]
    OR?: TripWhereInput[]
    NOT?: TripWhereInput | TripWhereInput[]
    id?: StringFilter<"Trip"> | string
    tripNumber?: StringFilter<"Trip"> | string
    patientId?: StringFilter<"Trip"> | string
    patientWeight?: StringNullableFilter<"Trip"> | string | null
    specialNeeds?: StringNullableFilter<"Trip"> | string | null
    fromLocation?: StringFilter<"Trip"> | string
    toLocation?: StringFilter<"Trip"> | string
    scheduledTime?: DateTimeFilter<"Trip"> | Date | string
    transportLevel?: StringFilter<"Trip"> | string
    urgencyLevel?: StringFilter<"Trip"> | string
    diagnosis?: StringNullableFilter<"Trip"> | string | null
    mobilityLevel?: StringNullableFilter<"Trip"> | string | null
    oxygenRequired?: BoolFilter<"Trip"> | boolean
    monitoringRequired?: BoolFilter<"Trip"> | boolean
    generateQRCode?: BoolFilter<"Trip"> | boolean
    qrCodeData?: StringNullableFilter<"Trip"> | string | null
    selectedAgencies?: StringNullableListFilter<"Trip">
    notificationRadius?: IntNullableFilter<"Trip"> | number | null
    transferRequestTime?: DateTimeNullableFilter<"Trip"> | Date | string | null
    transferAcceptedTime?: DateTimeNullableFilter<"Trip"> | Date | string | null
    emsArrivalTime?: DateTimeNullableFilter<"Trip"> | Date | string | null
    emsDepartureTime?: DateTimeNullableFilter<"Trip"> | Date | string | null
    actualStartTime?: DateTimeNullableFilter<"Trip"> | Date | string | null
    actualEndTime?: DateTimeNullableFilter<"Trip"> | Date | string | null
    status?: StringFilter<"Trip"> | string
    priority?: StringFilter<"Trip"> | string
    notes?: StringNullableFilter<"Trip"> | string | null
    assignedTo?: StringNullableFilter<"Trip"> | string | null
    assignedAgencyId?: StringNullableFilter<"Trip"> | string | null
    assignedUnitId?: StringNullableFilter<"Trip"> | string | null
    acceptedTimestamp?: DateTimeNullableFilter<"Trip"> | Date | string | null
    pickupTimestamp?: DateTimeNullableFilter<"Trip"> | Date | string | null
    completionTimestamp?: DateTimeNullableFilter<"Trip"> | Date | string | null
    createdAt?: DateTimeFilter<"Trip"> | Date | string
    updatedAt?: DateTimeFilter<"Trip"> | Date | string
    actualTripTimeMinutes?: IntNullableFilter<"Trip"> | number | null
    backhaulOpportunity?: BoolFilter<"Trip"> | boolean
    completionTimeMinutes?: IntNullableFilter<"Trip"> | number | null
    customerSatisfaction?: IntNullableFilter<"Trip"> | number | null
    deadheadMiles?: FloatNullableFilter<"Trip"> | number | null
    destinationLatitude?: FloatNullableFilter<"Trip"> | number | null
    destinationLongitude?: FloatNullableFilter<"Trip"> | number | null
    distanceMiles?: FloatNullableFilter<"Trip"> | number | null
    efficiency?: DecimalNullableFilter<"Trip"> | Decimal | DecimalJsLike | number | string | null
    estimatedTripTimeMinutes?: IntNullableFilter<"Trip"> | number | null
    insuranceCompany?: StringNullableFilter<"Trip"> | string | null
    insurancePayRate?: DecimalNullableFilter<"Trip"> | Decimal | DecimalJsLike | number | string | null
    loadedMiles?: DecimalNullableFilter<"Trip"> | Decimal | DecimalJsLike | number | string | null
    originLatitude?: FloatNullableFilter<"Trip"> | number | null
    originLongitude?: FloatNullableFilter<"Trip"> | number | null
    perMileRate?: DecimalNullableFilter<"Trip"> | Decimal | DecimalJsLike | number | string | null
    performanceScore?: DecimalNullableFilter<"Trip"> | Decimal | DecimalJsLike | number | string | null
    requestTimestamp?: DateTimeNullableFilter<"Trip"> | Date | string | null
    responseTimeMinutes?: IntNullableFilter<"Trip"> | number | null
    revenuePerHour?: DecimalNullableFilter<"Trip"> | Decimal | DecimalJsLike | number | string | null
    tripCost?: DecimalNullableFilter<"Trip"> | Decimal | DecimalJsLike | number | string | null
    pickupLocationId?: StringNullableFilter<"Trip"> | string | null
    maxResponses?: IntFilter<"Trip"> | number
    responseDeadline?: DateTimeNullableFilter<"Trip"> | Date | string | null
    responseStatus?: StringFilter<"Trip"> | string
    selectionMode?: StringFilter<"Trip"> | string
    agencyResponses?: AgencyResponseListRelationFilter
    pickup_locations?: XOR<Pickup_locationsNullableRelationFilter, pickup_locationsWhereInput> | null
  }

  export type TripOrderByWithRelationInput = {
    id?: SortOrder
    tripNumber?: SortOrder
    patientId?: SortOrder
    patientWeight?: SortOrderInput | SortOrder
    specialNeeds?: SortOrderInput | SortOrder
    fromLocation?: SortOrder
    toLocation?: SortOrder
    scheduledTime?: SortOrder
    transportLevel?: SortOrder
    urgencyLevel?: SortOrder
    diagnosis?: SortOrderInput | SortOrder
    mobilityLevel?: SortOrderInput | SortOrder
    oxygenRequired?: SortOrder
    monitoringRequired?: SortOrder
    generateQRCode?: SortOrder
    qrCodeData?: SortOrderInput | SortOrder
    selectedAgencies?: SortOrder
    notificationRadius?: SortOrderInput | SortOrder
    transferRequestTime?: SortOrderInput | SortOrder
    transferAcceptedTime?: SortOrderInput | SortOrder
    emsArrivalTime?: SortOrderInput | SortOrder
    emsDepartureTime?: SortOrderInput | SortOrder
    actualStartTime?: SortOrderInput | SortOrder
    actualEndTime?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    notes?: SortOrderInput | SortOrder
    assignedTo?: SortOrderInput | SortOrder
    assignedAgencyId?: SortOrderInput | SortOrder
    assignedUnitId?: SortOrderInput | SortOrder
    acceptedTimestamp?: SortOrderInput | SortOrder
    pickupTimestamp?: SortOrderInput | SortOrder
    completionTimestamp?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    actualTripTimeMinutes?: SortOrderInput | SortOrder
    backhaulOpportunity?: SortOrder
    completionTimeMinutes?: SortOrderInput | SortOrder
    customerSatisfaction?: SortOrderInput | SortOrder
    deadheadMiles?: SortOrderInput | SortOrder
    destinationLatitude?: SortOrderInput | SortOrder
    destinationLongitude?: SortOrderInput | SortOrder
    distanceMiles?: SortOrderInput | SortOrder
    efficiency?: SortOrderInput | SortOrder
    estimatedTripTimeMinutes?: SortOrderInput | SortOrder
    insuranceCompany?: SortOrderInput | SortOrder
    insurancePayRate?: SortOrderInput | SortOrder
    loadedMiles?: SortOrderInput | SortOrder
    originLatitude?: SortOrderInput | SortOrder
    originLongitude?: SortOrderInput | SortOrder
    perMileRate?: SortOrderInput | SortOrder
    performanceScore?: SortOrderInput | SortOrder
    requestTimestamp?: SortOrderInput | SortOrder
    responseTimeMinutes?: SortOrderInput | SortOrder
    revenuePerHour?: SortOrderInput | SortOrder
    tripCost?: SortOrderInput | SortOrder
    pickupLocationId?: SortOrderInput | SortOrder
    maxResponses?: SortOrder
    responseDeadline?: SortOrderInput | SortOrder
    responseStatus?: SortOrder
    selectionMode?: SortOrder
    agencyResponses?: AgencyResponseOrderByRelationAggregateInput
    pickup_locations?: pickup_locationsOrderByWithRelationInput
  }

  export type TripWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tripNumber?: string
    AND?: TripWhereInput | TripWhereInput[]
    OR?: TripWhereInput[]
    NOT?: TripWhereInput | TripWhereInput[]
    patientId?: StringFilter<"Trip"> | string
    patientWeight?: StringNullableFilter<"Trip"> | string | null
    specialNeeds?: StringNullableFilter<"Trip"> | string | null
    fromLocation?: StringFilter<"Trip"> | string
    toLocation?: StringFilter<"Trip"> | string
    scheduledTime?: DateTimeFilter<"Trip"> | Date | string
    transportLevel?: StringFilter<"Trip"> | string
    urgencyLevel?: StringFilter<"Trip"> | string
    diagnosis?: StringNullableFilter<"Trip"> | string | null
    mobilityLevel?: StringNullableFilter<"Trip"> | string | null
    oxygenRequired?: BoolFilter<"Trip"> | boolean
    monitoringRequired?: BoolFilter<"Trip"> | boolean
    generateQRCode?: BoolFilter<"Trip"> | boolean
    qrCodeData?: StringNullableFilter<"Trip"> | string | null
    selectedAgencies?: StringNullableListFilter<"Trip">
    notificationRadius?: IntNullableFilter<"Trip"> | number | null
    transferRequestTime?: DateTimeNullableFilter<"Trip"> | Date | string | null
    transferAcceptedTime?: DateTimeNullableFilter<"Trip"> | Date | string | null
    emsArrivalTime?: DateTimeNullableFilter<"Trip"> | Date | string | null
    emsDepartureTime?: DateTimeNullableFilter<"Trip"> | Date | string | null
    actualStartTime?: DateTimeNullableFilter<"Trip"> | Date | string | null
    actualEndTime?: DateTimeNullableFilter<"Trip"> | Date | string | null
    status?: StringFilter<"Trip"> | string
    priority?: StringFilter<"Trip"> | string
    notes?: StringNullableFilter<"Trip"> | string | null
    assignedTo?: StringNullableFilter<"Trip"> | string | null
    assignedAgencyId?: StringNullableFilter<"Trip"> | string | null
    assignedUnitId?: StringNullableFilter<"Trip"> | string | null
    acceptedTimestamp?: DateTimeNullableFilter<"Trip"> | Date | string | null
    pickupTimestamp?: DateTimeNullableFilter<"Trip"> | Date | string | null
    completionTimestamp?: DateTimeNullableFilter<"Trip"> | Date | string | null
    createdAt?: DateTimeFilter<"Trip"> | Date | string
    updatedAt?: DateTimeFilter<"Trip"> | Date | string
    actualTripTimeMinutes?: IntNullableFilter<"Trip"> | number | null
    backhaulOpportunity?: BoolFilter<"Trip"> | boolean
    completionTimeMinutes?: IntNullableFilter<"Trip"> | number | null
    customerSatisfaction?: IntNullableFilter<"Trip"> | number | null
    deadheadMiles?: FloatNullableFilter<"Trip"> | number | null
    destinationLatitude?: FloatNullableFilter<"Trip"> | number | null
    destinationLongitude?: FloatNullableFilter<"Trip"> | number | null
    distanceMiles?: FloatNullableFilter<"Trip"> | number | null
    efficiency?: DecimalNullableFilter<"Trip"> | Decimal | DecimalJsLike | number | string | null
    estimatedTripTimeMinutes?: IntNullableFilter<"Trip"> | number | null
    insuranceCompany?: StringNullableFilter<"Trip"> | string | null
    insurancePayRate?: DecimalNullableFilter<"Trip"> | Decimal | DecimalJsLike | number | string | null
    loadedMiles?: DecimalNullableFilter<"Trip"> | Decimal | DecimalJsLike | number | string | null
    originLatitude?: FloatNullableFilter<"Trip"> | number | null
    originLongitude?: FloatNullableFilter<"Trip"> | number | null
    perMileRate?: DecimalNullableFilter<"Trip"> | Decimal | DecimalJsLike | number | string | null
    performanceScore?: DecimalNullableFilter<"Trip"> | Decimal | DecimalJsLike | number | string | null
    requestTimestamp?: DateTimeNullableFilter<"Trip"> | Date | string | null
    responseTimeMinutes?: IntNullableFilter<"Trip"> | number | null
    revenuePerHour?: DecimalNullableFilter<"Trip"> | Decimal | DecimalJsLike | number | string | null
    tripCost?: DecimalNullableFilter<"Trip"> | Decimal | DecimalJsLike | number | string | null
    pickupLocationId?: StringNullableFilter<"Trip"> | string | null
    maxResponses?: IntFilter<"Trip"> | number
    responseDeadline?: DateTimeNullableFilter<"Trip"> | Date | string | null
    responseStatus?: StringFilter<"Trip"> | string
    selectionMode?: StringFilter<"Trip"> | string
    agencyResponses?: AgencyResponseListRelationFilter
    pickup_locations?: XOR<Pickup_locationsNullableRelationFilter, pickup_locationsWhereInput> | null
  }, "id" | "tripNumber">

  export type TripOrderByWithAggregationInput = {
    id?: SortOrder
    tripNumber?: SortOrder
    patientId?: SortOrder
    patientWeight?: SortOrderInput | SortOrder
    specialNeeds?: SortOrderInput | SortOrder
    fromLocation?: SortOrder
    toLocation?: SortOrder
    scheduledTime?: SortOrder
    transportLevel?: SortOrder
    urgencyLevel?: SortOrder
    diagnosis?: SortOrderInput | SortOrder
    mobilityLevel?: SortOrderInput | SortOrder
    oxygenRequired?: SortOrder
    monitoringRequired?: SortOrder
    generateQRCode?: SortOrder
    qrCodeData?: SortOrderInput | SortOrder
    selectedAgencies?: SortOrder
    notificationRadius?: SortOrderInput | SortOrder
    transferRequestTime?: SortOrderInput | SortOrder
    transferAcceptedTime?: SortOrderInput | SortOrder
    emsArrivalTime?: SortOrderInput | SortOrder
    emsDepartureTime?: SortOrderInput | SortOrder
    actualStartTime?: SortOrderInput | SortOrder
    actualEndTime?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    notes?: SortOrderInput | SortOrder
    assignedTo?: SortOrderInput | SortOrder
    assignedAgencyId?: SortOrderInput | SortOrder
    assignedUnitId?: SortOrderInput | SortOrder
    acceptedTimestamp?: SortOrderInput | SortOrder
    pickupTimestamp?: SortOrderInput | SortOrder
    completionTimestamp?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    actualTripTimeMinutes?: SortOrderInput | SortOrder
    backhaulOpportunity?: SortOrder
    completionTimeMinutes?: SortOrderInput | SortOrder
    customerSatisfaction?: SortOrderInput | SortOrder
    deadheadMiles?: SortOrderInput | SortOrder
    destinationLatitude?: SortOrderInput | SortOrder
    destinationLongitude?: SortOrderInput | SortOrder
    distanceMiles?: SortOrderInput | SortOrder
    efficiency?: SortOrderInput | SortOrder
    estimatedTripTimeMinutes?: SortOrderInput | SortOrder
    insuranceCompany?: SortOrderInput | SortOrder
    insurancePayRate?: SortOrderInput | SortOrder
    loadedMiles?: SortOrderInput | SortOrder
    originLatitude?: SortOrderInput | SortOrder
    originLongitude?: SortOrderInput | SortOrder
    perMileRate?: SortOrderInput | SortOrder
    performanceScore?: SortOrderInput | SortOrder
    requestTimestamp?: SortOrderInput | SortOrder
    responseTimeMinutes?: SortOrderInput | SortOrder
    revenuePerHour?: SortOrderInput | SortOrder
    tripCost?: SortOrderInput | SortOrder
    pickupLocationId?: SortOrderInput | SortOrder
    maxResponses?: SortOrder
    responseDeadline?: SortOrderInput | SortOrder
    responseStatus?: SortOrder
    selectionMode?: SortOrder
    _count?: TripCountOrderByAggregateInput
    _avg?: TripAvgOrderByAggregateInput
    _max?: TripMaxOrderByAggregateInput
    _min?: TripMinOrderByAggregateInput
    _sum?: TripSumOrderByAggregateInput
  }

  export type TripScalarWhereWithAggregatesInput = {
    AND?: TripScalarWhereWithAggregatesInput | TripScalarWhereWithAggregatesInput[]
    OR?: TripScalarWhereWithAggregatesInput[]
    NOT?: TripScalarWhereWithAggregatesInput | TripScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Trip"> | string
    tripNumber?: StringWithAggregatesFilter<"Trip"> | string
    patientId?: StringWithAggregatesFilter<"Trip"> | string
    patientWeight?: StringNullableWithAggregatesFilter<"Trip"> | string | null
    specialNeeds?: StringNullableWithAggregatesFilter<"Trip"> | string | null
    fromLocation?: StringWithAggregatesFilter<"Trip"> | string
    toLocation?: StringWithAggregatesFilter<"Trip"> | string
    scheduledTime?: DateTimeWithAggregatesFilter<"Trip"> | Date | string
    transportLevel?: StringWithAggregatesFilter<"Trip"> | string
    urgencyLevel?: StringWithAggregatesFilter<"Trip"> | string
    diagnosis?: StringNullableWithAggregatesFilter<"Trip"> | string | null
    mobilityLevel?: StringNullableWithAggregatesFilter<"Trip"> | string | null
    oxygenRequired?: BoolWithAggregatesFilter<"Trip"> | boolean
    monitoringRequired?: BoolWithAggregatesFilter<"Trip"> | boolean
    generateQRCode?: BoolWithAggregatesFilter<"Trip"> | boolean
    qrCodeData?: StringNullableWithAggregatesFilter<"Trip"> | string | null
    selectedAgencies?: StringNullableListFilter<"Trip">
    notificationRadius?: IntNullableWithAggregatesFilter<"Trip"> | number | null
    transferRequestTime?: DateTimeNullableWithAggregatesFilter<"Trip"> | Date | string | null
    transferAcceptedTime?: DateTimeNullableWithAggregatesFilter<"Trip"> | Date | string | null
    emsArrivalTime?: DateTimeNullableWithAggregatesFilter<"Trip"> | Date | string | null
    emsDepartureTime?: DateTimeNullableWithAggregatesFilter<"Trip"> | Date | string | null
    actualStartTime?: DateTimeNullableWithAggregatesFilter<"Trip"> | Date | string | null
    actualEndTime?: DateTimeNullableWithAggregatesFilter<"Trip"> | Date | string | null
    status?: StringWithAggregatesFilter<"Trip"> | string
    priority?: StringWithAggregatesFilter<"Trip"> | string
    notes?: StringNullableWithAggregatesFilter<"Trip"> | string | null
    assignedTo?: StringNullableWithAggregatesFilter<"Trip"> | string | null
    assignedAgencyId?: StringNullableWithAggregatesFilter<"Trip"> | string | null
    assignedUnitId?: StringNullableWithAggregatesFilter<"Trip"> | string | null
    acceptedTimestamp?: DateTimeNullableWithAggregatesFilter<"Trip"> | Date | string | null
    pickupTimestamp?: DateTimeNullableWithAggregatesFilter<"Trip"> | Date | string | null
    completionTimestamp?: DateTimeNullableWithAggregatesFilter<"Trip"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Trip"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Trip"> | Date | string
    actualTripTimeMinutes?: IntNullableWithAggregatesFilter<"Trip"> | number | null
    backhaulOpportunity?: BoolWithAggregatesFilter<"Trip"> | boolean
    completionTimeMinutes?: IntNullableWithAggregatesFilter<"Trip"> | number | null
    customerSatisfaction?: IntNullableWithAggregatesFilter<"Trip"> | number | null
    deadheadMiles?: FloatNullableWithAggregatesFilter<"Trip"> | number | null
    destinationLatitude?: FloatNullableWithAggregatesFilter<"Trip"> | number | null
    destinationLongitude?: FloatNullableWithAggregatesFilter<"Trip"> | number | null
    distanceMiles?: FloatNullableWithAggregatesFilter<"Trip"> | number | null
    efficiency?: DecimalNullableWithAggregatesFilter<"Trip"> | Decimal | DecimalJsLike | number | string | null
    estimatedTripTimeMinutes?: IntNullableWithAggregatesFilter<"Trip"> | number | null
    insuranceCompany?: StringNullableWithAggregatesFilter<"Trip"> | string | null
    insurancePayRate?: DecimalNullableWithAggregatesFilter<"Trip"> | Decimal | DecimalJsLike | number | string | null
    loadedMiles?: DecimalNullableWithAggregatesFilter<"Trip"> | Decimal | DecimalJsLike | number | string | null
    originLatitude?: FloatNullableWithAggregatesFilter<"Trip"> | number | null
    originLongitude?: FloatNullableWithAggregatesFilter<"Trip"> | number | null
    perMileRate?: DecimalNullableWithAggregatesFilter<"Trip"> | Decimal | DecimalJsLike | number | string | null
    performanceScore?: DecimalNullableWithAggregatesFilter<"Trip"> | Decimal | DecimalJsLike | number | string | null
    requestTimestamp?: DateTimeNullableWithAggregatesFilter<"Trip"> | Date | string | null
    responseTimeMinutes?: IntNullableWithAggregatesFilter<"Trip"> | number | null
    revenuePerHour?: DecimalNullableWithAggregatesFilter<"Trip"> | Decimal | DecimalJsLike | number | string | null
    tripCost?: DecimalNullableWithAggregatesFilter<"Trip"> | Decimal | DecimalJsLike | number | string | null
    pickupLocationId?: StringNullableWithAggregatesFilter<"Trip"> | string | null
    maxResponses?: IntWithAggregatesFilter<"Trip"> | number
    responseDeadline?: DateTimeNullableWithAggregatesFilter<"Trip"> | Date | string | null
    responseStatus?: StringWithAggregatesFilter<"Trip"> | string
    selectionMode?: StringWithAggregatesFilter<"Trip"> | string
  }

  export type AgencyResponseWhereInput = {
    AND?: AgencyResponseWhereInput | AgencyResponseWhereInput[]
    OR?: AgencyResponseWhereInput[]
    NOT?: AgencyResponseWhereInput | AgencyResponseWhereInput[]
    id?: StringFilter<"AgencyResponse"> | string
    tripId?: StringFilter<"AgencyResponse"> | string
    agencyId?: StringFilter<"AgencyResponse"> | string
    response?: StringFilter<"AgencyResponse"> | string
    responseTimestamp?: DateTimeFilter<"AgencyResponse"> | Date | string
    responseNotes?: StringNullableFilter<"AgencyResponse"> | string | null
    estimatedArrival?: DateTimeNullableFilter<"AgencyResponse"> | Date | string | null
    isSelected?: BoolFilter<"AgencyResponse"> | boolean
    createdAt?: DateTimeFilter<"AgencyResponse"> | Date | string
    updatedAt?: DateTimeFilter<"AgencyResponse"> | Date | string
    trip?: XOR<TripRelationFilter, TripWhereInput>
  }

  export type AgencyResponseOrderByWithRelationInput = {
    id?: SortOrder
    tripId?: SortOrder
    agencyId?: SortOrder
    response?: SortOrder
    responseTimestamp?: SortOrder
    responseNotes?: SortOrderInput | SortOrder
    estimatedArrival?: SortOrderInput | SortOrder
    isSelected?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    trip?: TripOrderByWithRelationInput
  }

  export type AgencyResponseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AgencyResponseWhereInput | AgencyResponseWhereInput[]
    OR?: AgencyResponseWhereInput[]
    NOT?: AgencyResponseWhereInput | AgencyResponseWhereInput[]
    tripId?: StringFilter<"AgencyResponse"> | string
    agencyId?: StringFilter<"AgencyResponse"> | string
    response?: StringFilter<"AgencyResponse"> | string
    responseTimestamp?: DateTimeFilter<"AgencyResponse"> | Date | string
    responseNotes?: StringNullableFilter<"AgencyResponse"> | string | null
    estimatedArrival?: DateTimeNullableFilter<"AgencyResponse"> | Date | string | null
    isSelected?: BoolFilter<"AgencyResponse"> | boolean
    createdAt?: DateTimeFilter<"AgencyResponse"> | Date | string
    updatedAt?: DateTimeFilter<"AgencyResponse"> | Date | string
    trip?: XOR<TripRelationFilter, TripWhereInput>
  }, "id">

  export type AgencyResponseOrderByWithAggregationInput = {
    id?: SortOrder
    tripId?: SortOrder
    agencyId?: SortOrder
    response?: SortOrder
    responseTimestamp?: SortOrder
    responseNotes?: SortOrderInput | SortOrder
    estimatedArrival?: SortOrderInput | SortOrder
    isSelected?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AgencyResponseCountOrderByAggregateInput
    _max?: AgencyResponseMaxOrderByAggregateInput
    _min?: AgencyResponseMinOrderByAggregateInput
  }

  export type AgencyResponseScalarWhereWithAggregatesInput = {
    AND?: AgencyResponseScalarWhereWithAggregatesInput | AgencyResponseScalarWhereWithAggregatesInput[]
    OR?: AgencyResponseScalarWhereWithAggregatesInput[]
    NOT?: AgencyResponseScalarWhereWithAggregatesInput | AgencyResponseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AgencyResponse"> | string
    tripId?: StringWithAggregatesFilter<"AgencyResponse"> | string
    agencyId?: StringWithAggregatesFilter<"AgencyResponse"> | string
    response?: StringWithAggregatesFilter<"AgencyResponse"> | string
    responseTimestamp?: DateTimeWithAggregatesFilter<"AgencyResponse"> | Date | string
    responseNotes?: StringNullableWithAggregatesFilter<"AgencyResponse"> | string | null
    estimatedArrival?: DateTimeNullableWithAggregatesFilter<"AgencyResponse"> | Date | string | null
    isSelected?: BoolWithAggregatesFilter<"AgencyResponse"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"AgencyResponse"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AgencyResponse"> | Date | string
  }

  export type SystemAnalyticsWhereInput = {
    AND?: SystemAnalyticsWhereInput | SystemAnalyticsWhereInput[]
    OR?: SystemAnalyticsWhereInput[]
    NOT?: SystemAnalyticsWhereInput | SystemAnalyticsWhereInput[]
    id?: StringFilter<"SystemAnalytics"> | string
    metricName?: StringFilter<"SystemAnalytics"> | string
    metricValue?: JsonFilter<"SystemAnalytics">
    timestamp?: DateTimeFilter<"SystemAnalytics"> | Date | string
    userId?: StringNullableFilter<"SystemAnalytics"> | string | null
    createdAt?: DateTimeFilter<"SystemAnalytics"> | Date | string
  }

  export type SystemAnalyticsOrderByWithRelationInput = {
    id?: SortOrder
    metricName?: SortOrder
    metricValue?: SortOrder
    timestamp?: SortOrder
    userId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type SystemAnalyticsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SystemAnalyticsWhereInput | SystemAnalyticsWhereInput[]
    OR?: SystemAnalyticsWhereInput[]
    NOT?: SystemAnalyticsWhereInput | SystemAnalyticsWhereInput[]
    metricName?: StringFilter<"SystemAnalytics"> | string
    metricValue?: JsonFilter<"SystemAnalytics">
    timestamp?: DateTimeFilter<"SystemAnalytics"> | Date | string
    userId?: StringNullableFilter<"SystemAnalytics"> | string | null
    createdAt?: DateTimeFilter<"SystemAnalytics"> | Date | string
  }, "id">

  export type SystemAnalyticsOrderByWithAggregationInput = {
    id?: SortOrder
    metricName?: SortOrder
    metricValue?: SortOrder
    timestamp?: SortOrder
    userId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SystemAnalyticsCountOrderByAggregateInput
    _max?: SystemAnalyticsMaxOrderByAggregateInput
    _min?: SystemAnalyticsMinOrderByAggregateInput
  }

  export type SystemAnalyticsScalarWhereWithAggregatesInput = {
    AND?: SystemAnalyticsScalarWhereWithAggregatesInput | SystemAnalyticsScalarWhereWithAggregatesInput[]
    OR?: SystemAnalyticsScalarWhereWithAggregatesInput[]
    NOT?: SystemAnalyticsScalarWhereWithAggregatesInput | SystemAnalyticsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SystemAnalytics"> | string
    metricName?: StringWithAggregatesFilter<"SystemAnalytics"> | string
    metricValue?: JsonWithAggregatesFilter<"SystemAnalytics">
    timestamp?: DateTimeWithAggregatesFilter<"SystemAnalytics"> | Date | string
    userId?: StringNullableWithAggregatesFilter<"SystemAnalytics"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SystemAnalytics"> | Date | string
  }

  export type TripCostBreakdownWhereInput = {
    AND?: TripCostBreakdownWhereInput | TripCostBreakdownWhereInput[]
    OR?: TripCostBreakdownWhereInput[]
    NOT?: TripCostBreakdownWhereInput | TripCostBreakdownWhereInput[]
    id?: StringFilter<"TripCostBreakdown"> | string
    tripId?: StringFilter<"TripCostBreakdown"> | string
    baseRevenue?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    mileageRevenue?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    priorityRevenue?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    specialRequirementsRevenue?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    insuranceAdjustment?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    totalRevenue?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    crewLaborCost?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    vehicleCost?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    fuelCost?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    maintenanceCost?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    overheadCost?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    grossProfit?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    profitMargin?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    revenuePerMile?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    costPerMile?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    loadedMileRatio?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    deadheadMileRatio?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    utilizationRate?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    tripDistance?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    loadedMiles?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    deadheadMiles?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    tripDurationHours?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    transportLevel?: StringFilter<"TripCostBreakdown"> | string
    priorityLevel?: StringFilter<"TripCostBreakdown"> | string
    costCenterId?: StringNullableFilter<"TripCostBreakdown"> | string | null
    costCenterName?: StringNullableFilter<"TripCostBreakdown"> | string | null
    calculatedAt?: DateTimeFilter<"TripCostBreakdown"> | Date | string
    createdAt?: DateTimeFilter<"TripCostBreakdown"> | Date | string
    updatedAt?: DateTimeFilter<"TripCostBreakdown"> | Date | string
  }

  export type TripCostBreakdownOrderByWithRelationInput = {
    id?: SortOrder
    tripId?: SortOrder
    baseRevenue?: SortOrder
    mileageRevenue?: SortOrder
    priorityRevenue?: SortOrder
    specialRequirementsRevenue?: SortOrder
    insuranceAdjustment?: SortOrder
    totalRevenue?: SortOrder
    crewLaborCost?: SortOrder
    vehicleCost?: SortOrder
    fuelCost?: SortOrder
    maintenanceCost?: SortOrder
    overheadCost?: SortOrder
    totalCost?: SortOrder
    grossProfit?: SortOrder
    profitMargin?: SortOrder
    revenuePerMile?: SortOrder
    costPerMile?: SortOrder
    loadedMileRatio?: SortOrder
    deadheadMileRatio?: SortOrder
    utilizationRate?: SortOrder
    tripDistance?: SortOrder
    loadedMiles?: SortOrder
    deadheadMiles?: SortOrder
    tripDurationHours?: SortOrder
    transportLevel?: SortOrder
    priorityLevel?: SortOrder
    costCenterId?: SortOrderInput | SortOrder
    costCenterName?: SortOrderInput | SortOrder
    calculatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TripCostBreakdownWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TripCostBreakdownWhereInput | TripCostBreakdownWhereInput[]
    OR?: TripCostBreakdownWhereInput[]
    NOT?: TripCostBreakdownWhereInput | TripCostBreakdownWhereInput[]
    tripId?: StringFilter<"TripCostBreakdown"> | string
    baseRevenue?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    mileageRevenue?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    priorityRevenue?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    specialRequirementsRevenue?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    insuranceAdjustment?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    totalRevenue?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    crewLaborCost?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    vehicleCost?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    fuelCost?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    maintenanceCost?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    overheadCost?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    grossProfit?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    profitMargin?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    revenuePerMile?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    costPerMile?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    loadedMileRatio?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    deadheadMileRatio?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    utilizationRate?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    tripDistance?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    loadedMiles?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    deadheadMiles?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    tripDurationHours?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    transportLevel?: StringFilter<"TripCostBreakdown"> | string
    priorityLevel?: StringFilter<"TripCostBreakdown"> | string
    costCenterId?: StringNullableFilter<"TripCostBreakdown"> | string | null
    costCenterName?: StringNullableFilter<"TripCostBreakdown"> | string | null
    calculatedAt?: DateTimeFilter<"TripCostBreakdown"> | Date | string
    createdAt?: DateTimeFilter<"TripCostBreakdown"> | Date | string
    updatedAt?: DateTimeFilter<"TripCostBreakdown"> | Date | string
  }, "id">

  export type TripCostBreakdownOrderByWithAggregationInput = {
    id?: SortOrder
    tripId?: SortOrder
    baseRevenue?: SortOrder
    mileageRevenue?: SortOrder
    priorityRevenue?: SortOrder
    specialRequirementsRevenue?: SortOrder
    insuranceAdjustment?: SortOrder
    totalRevenue?: SortOrder
    crewLaborCost?: SortOrder
    vehicleCost?: SortOrder
    fuelCost?: SortOrder
    maintenanceCost?: SortOrder
    overheadCost?: SortOrder
    totalCost?: SortOrder
    grossProfit?: SortOrder
    profitMargin?: SortOrder
    revenuePerMile?: SortOrder
    costPerMile?: SortOrder
    loadedMileRatio?: SortOrder
    deadheadMileRatio?: SortOrder
    utilizationRate?: SortOrder
    tripDistance?: SortOrder
    loadedMiles?: SortOrder
    deadheadMiles?: SortOrder
    tripDurationHours?: SortOrder
    transportLevel?: SortOrder
    priorityLevel?: SortOrder
    costCenterId?: SortOrderInput | SortOrder
    costCenterName?: SortOrderInput | SortOrder
    calculatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TripCostBreakdownCountOrderByAggregateInput
    _avg?: TripCostBreakdownAvgOrderByAggregateInput
    _max?: TripCostBreakdownMaxOrderByAggregateInput
    _min?: TripCostBreakdownMinOrderByAggregateInput
    _sum?: TripCostBreakdownSumOrderByAggregateInput
  }

  export type TripCostBreakdownScalarWhereWithAggregatesInput = {
    AND?: TripCostBreakdownScalarWhereWithAggregatesInput | TripCostBreakdownScalarWhereWithAggregatesInput[]
    OR?: TripCostBreakdownScalarWhereWithAggregatesInput[]
    NOT?: TripCostBreakdownScalarWhereWithAggregatesInput | TripCostBreakdownScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TripCostBreakdown"> | string
    tripId?: StringWithAggregatesFilter<"TripCostBreakdown"> | string
    baseRevenue?: DecimalWithAggregatesFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    mileageRevenue?: DecimalWithAggregatesFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    priorityRevenue?: DecimalWithAggregatesFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    specialRequirementsRevenue?: DecimalWithAggregatesFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    insuranceAdjustment?: DecimalWithAggregatesFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    totalRevenue?: DecimalWithAggregatesFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    crewLaborCost?: DecimalWithAggregatesFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    vehicleCost?: DecimalWithAggregatesFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    fuelCost?: DecimalWithAggregatesFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    maintenanceCost?: DecimalWithAggregatesFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    overheadCost?: DecimalWithAggregatesFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalWithAggregatesFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    grossProfit?: DecimalWithAggregatesFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    profitMargin?: DecimalWithAggregatesFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    revenuePerMile?: DecimalWithAggregatesFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    costPerMile?: DecimalWithAggregatesFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    loadedMileRatio?: DecimalWithAggregatesFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    deadheadMileRatio?: DecimalWithAggregatesFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    utilizationRate?: DecimalWithAggregatesFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    tripDistance?: DecimalWithAggregatesFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    loadedMiles?: DecimalWithAggregatesFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    deadheadMiles?: DecimalWithAggregatesFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    tripDurationHours?: DecimalWithAggregatesFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    transportLevel?: StringWithAggregatesFilter<"TripCostBreakdown"> | string
    priorityLevel?: StringWithAggregatesFilter<"TripCostBreakdown"> | string
    costCenterId?: StringNullableWithAggregatesFilter<"TripCostBreakdown"> | string | null
    costCenterName?: StringNullableWithAggregatesFilter<"TripCostBreakdown"> | string | null
    calculatedAt?: DateTimeWithAggregatesFilter<"TripCostBreakdown"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"TripCostBreakdown"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TripCostBreakdown"> | Date | string
  }

  export type CostCenterWhereInput = {
    AND?: CostCenterWhereInput | CostCenterWhereInput[]
    OR?: CostCenterWhereInput[]
    NOT?: CostCenterWhereInput | CostCenterWhereInput[]
    id?: StringFilter<"CostCenter"> | string
    name?: StringFilter<"CostCenter"> | string
    description?: StringNullableFilter<"CostCenter"> | string | null
    code?: StringFilter<"CostCenter"> | string
    overheadRate?: DecimalFilter<"CostCenter"> | Decimal | DecimalJsLike | number | string
    fixedCosts?: DecimalFilter<"CostCenter"> | Decimal | DecimalJsLike | number | string
    variableCosts?: DecimalFilter<"CostCenter"> | Decimal | DecimalJsLike | number | string
    allocationMethod?: StringFilter<"CostCenter"> | string
    isActive?: BoolFilter<"CostCenter"> | boolean
    createdAt?: DateTimeFilter<"CostCenter"> | Date | string
    updatedAt?: DateTimeFilter<"CostCenter"> | Date | string
  }

  export type CostCenterOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    code?: SortOrder
    overheadRate?: SortOrder
    fixedCosts?: SortOrder
    variableCosts?: SortOrder
    allocationMethod?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CostCenterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: CostCenterWhereInput | CostCenterWhereInput[]
    OR?: CostCenterWhereInput[]
    NOT?: CostCenterWhereInput | CostCenterWhereInput[]
    name?: StringFilter<"CostCenter"> | string
    description?: StringNullableFilter<"CostCenter"> | string | null
    overheadRate?: DecimalFilter<"CostCenter"> | Decimal | DecimalJsLike | number | string
    fixedCosts?: DecimalFilter<"CostCenter"> | Decimal | DecimalJsLike | number | string
    variableCosts?: DecimalFilter<"CostCenter"> | Decimal | DecimalJsLike | number | string
    allocationMethod?: StringFilter<"CostCenter"> | string
    isActive?: BoolFilter<"CostCenter"> | boolean
    createdAt?: DateTimeFilter<"CostCenter"> | Date | string
    updatedAt?: DateTimeFilter<"CostCenter"> | Date | string
  }, "id" | "code">

  export type CostCenterOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    code?: SortOrder
    overheadRate?: SortOrder
    fixedCosts?: SortOrder
    variableCosts?: SortOrder
    allocationMethod?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CostCenterCountOrderByAggregateInput
    _avg?: CostCenterAvgOrderByAggregateInput
    _max?: CostCenterMaxOrderByAggregateInput
    _min?: CostCenterMinOrderByAggregateInput
    _sum?: CostCenterSumOrderByAggregateInput
  }

  export type CostCenterScalarWhereWithAggregatesInput = {
    AND?: CostCenterScalarWhereWithAggregatesInput | CostCenterScalarWhereWithAggregatesInput[]
    OR?: CostCenterScalarWhereWithAggregatesInput[]
    NOT?: CostCenterScalarWhereWithAggregatesInput | CostCenterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CostCenter"> | string
    name?: StringWithAggregatesFilter<"CostCenter"> | string
    description?: StringNullableWithAggregatesFilter<"CostCenter"> | string | null
    code?: StringWithAggregatesFilter<"CostCenter"> | string
    overheadRate?: DecimalWithAggregatesFilter<"CostCenter"> | Decimal | DecimalJsLike | number | string
    fixedCosts?: DecimalWithAggregatesFilter<"CostCenter"> | Decimal | DecimalJsLike | number | string
    variableCosts?: DecimalWithAggregatesFilter<"CostCenter"> | Decimal | DecimalJsLike | number | string
    allocationMethod?: StringWithAggregatesFilter<"CostCenter"> | string
    isActive?: BoolWithAggregatesFilter<"CostCenter"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CostCenter"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CostCenter"> | Date | string
  }

  export type backhaul_opportunitiesWhereInput = {
    AND?: backhaul_opportunitiesWhereInput | backhaul_opportunitiesWhereInput[]
    OR?: backhaul_opportunitiesWhereInput[]
    NOT?: backhaul_opportunitiesWhereInput | backhaul_opportunitiesWhereInput[]
    id?: StringFilter<"backhaul_opportunities"> | string
    tripId1?: StringFilter<"backhaul_opportunities"> | string
    tripId2?: StringFilter<"backhaul_opportunities"> | string
    revenueBonus?: DecimalNullableFilter<"backhaul_opportunities"> | Decimal | DecimalJsLike | number | string | null
    efficiency?: DecimalNullableFilter<"backhaul_opportunities"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"backhaul_opportunities"> | Date | string
    isActive?: BoolFilter<"backhaul_opportunities"> | boolean
  }

  export type backhaul_opportunitiesOrderByWithRelationInput = {
    id?: SortOrder
    tripId1?: SortOrder
    tripId2?: SortOrder
    revenueBonus?: SortOrderInput | SortOrder
    efficiency?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    isActive?: SortOrder
  }

  export type backhaul_opportunitiesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: backhaul_opportunitiesWhereInput | backhaul_opportunitiesWhereInput[]
    OR?: backhaul_opportunitiesWhereInput[]
    NOT?: backhaul_opportunitiesWhereInput | backhaul_opportunitiesWhereInput[]
    tripId1?: StringFilter<"backhaul_opportunities"> | string
    tripId2?: StringFilter<"backhaul_opportunities"> | string
    revenueBonus?: DecimalNullableFilter<"backhaul_opportunities"> | Decimal | DecimalJsLike | number | string | null
    efficiency?: DecimalNullableFilter<"backhaul_opportunities"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"backhaul_opportunities"> | Date | string
    isActive?: BoolFilter<"backhaul_opportunities"> | boolean
  }, "id">

  export type backhaul_opportunitiesOrderByWithAggregationInput = {
    id?: SortOrder
    tripId1?: SortOrder
    tripId2?: SortOrder
    revenueBonus?: SortOrderInput | SortOrder
    efficiency?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    isActive?: SortOrder
    _count?: backhaul_opportunitiesCountOrderByAggregateInput
    _avg?: backhaul_opportunitiesAvgOrderByAggregateInput
    _max?: backhaul_opportunitiesMaxOrderByAggregateInput
    _min?: backhaul_opportunitiesMinOrderByAggregateInput
    _sum?: backhaul_opportunitiesSumOrderByAggregateInput
  }

  export type backhaul_opportunitiesScalarWhereWithAggregatesInput = {
    AND?: backhaul_opportunitiesScalarWhereWithAggregatesInput | backhaul_opportunitiesScalarWhereWithAggregatesInput[]
    OR?: backhaul_opportunitiesScalarWhereWithAggregatesInput[]
    NOT?: backhaul_opportunitiesScalarWhereWithAggregatesInput | backhaul_opportunitiesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"backhaul_opportunities"> | string
    tripId1?: StringWithAggregatesFilter<"backhaul_opportunities"> | string
    tripId2?: StringWithAggregatesFilter<"backhaul_opportunities"> | string
    revenueBonus?: DecimalNullableWithAggregatesFilter<"backhaul_opportunities"> | Decimal | DecimalJsLike | number | string | null
    efficiency?: DecimalNullableWithAggregatesFilter<"backhaul_opportunities"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeWithAggregatesFilter<"backhaul_opportunities"> | Date | string
    isActive?: BoolWithAggregatesFilter<"backhaul_opportunities"> | boolean
  }

  export type pickup_locationsWhereInput = {
    AND?: pickup_locationsWhereInput | pickup_locationsWhereInput[]
    OR?: pickup_locationsWhereInput[]
    NOT?: pickup_locationsWhereInput | pickup_locationsWhereInput[]
    id?: StringFilter<"pickup_locations"> | string
    hospitalId?: StringFilter<"pickup_locations"> | string
    name?: StringFilter<"pickup_locations"> | string
    description?: StringNullableFilter<"pickup_locations"> | string | null
    contactPhone?: StringNullableFilter<"pickup_locations"> | string | null
    contactEmail?: StringNullableFilter<"pickup_locations"> | string | null
    floor?: StringNullableFilter<"pickup_locations"> | string | null
    room?: StringNullableFilter<"pickup_locations"> | string | null
    isActive?: BoolFilter<"pickup_locations"> | boolean
    createdAt?: DateTimeFilter<"pickup_locations"> | Date | string
    updatedAt?: DateTimeFilter<"pickup_locations"> | Date | string
    trips?: TransportRequestListRelationFilter
    legacyTrips?: TripListRelationFilter
  }

  export type pickup_locationsOrderByWithRelationInput = {
    id?: SortOrder
    hospitalId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    contactPhone?: SortOrderInput | SortOrder
    contactEmail?: SortOrderInput | SortOrder
    floor?: SortOrderInput | SortOrder
    room?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    trips?: TransportRequestOrderByRelationAggregateInput
    legacyTrips?: TripOrderByRelationAggregateInput
  }

  export type pickup_locationsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: pickup_locationsWhereInput | pickup_locationsWhereInput[]
    OR?: pickup_locationsWhereInput[]
    NOT?: pickup_locationsWhereInput | pickup_locationsWhereInput[]
    hospitalId?: StringFilter<"pickup_locations"> | string
    name?: StringFilter<"pickup_locations"> | string
    description?: StringNullableFilter<"pickup_locations"> | string | null
    contactPhone?: StringNullableFilter<"pickup_locations"> | string | null
    contactEmail?: StringNullableFilter<"pickup_locations"> | string | null
    floor?: StringNullableFilter<"pickup_locations"> | string | null
    room?: StringNullableFilter<"pickup_locations"> | string | null
    isActive?: BoolFilter<"pickup_locations"> | boolean
    createdAt?: DateTimeFilter<"pickup_locations"> | Date | string
    updatedAt?: DateTimeFilter<"pickup_locations"> | Date | string
    trips?: TransportRequestListRelationFilter
    legacyTrips?: TripListRelationFilter
  }, "id">

  export type pickup_locationsOrderByWithAggregationInput = {
    id?: SortOrder
    hospitalId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    contactPhone?: SortOrderInput | SortOrder
    contactEmail?: SortOrderInput | SortOrder
    floor?: SortOrderInput | SortOrder
    room?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: pickup_locationsCountOrderByAggregateInput
    _max?: pickup_locationsMaxOrderByAggregateInput
    _min?: pickup_locationsMinOrderByAggregateInput
  }

  export type pickup_locationsScalarWhereWithAggregatesInput = {
    AND?: pickup_locationsScalarWhereWithAggregatesInput | pickup_locationsScalarWhereWithAggregatesInput[]
    OR?: pickup_locationsScalarWhereWithAggregatesInput[]
    NOT?: pickup_locationsScalarWhereWithAggregatesInput | pickup_locationsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"pickup_locations"> | string
    hospitalId?: StringWithAggregatesFilter<"pickup_locations"> | string
    name?: StringWithAggregatesFilter<"pickup_locations"> | string
    description?: StringNullableWithAggregatesFilter<"pickup_locations"> | string | null
    contactPhone?: StringNullableWithAggregatesFilter<"pickup_locations"> | string | null
    contactEmail?: StringNullableWithAggregatesFilter<"pickup_locations"> | string | null
    floor?: StringNullableWithAggregatesFilter<"pickup_locations"> | string | null
    room?: StringNullableWithAggregatesFilter<"pickup_locations"> | string | null
    isActive?: BoolWithAggregatesFilter<"pickup_locations"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"pickup_locations"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"pickup_locations"> | Date | string
  }

  export type pricing_modelsWhereInput = {
    AND?: pricing_modelsWhereInput | pricing_modelsWhereInput[]
    OR?: pricing_modelsWhereInput[]
    NOT?: pricing_modelsWhereInput | pricing_modelsWhereInput[]
    id?: StringFilter<"pricing_models"> | string
    agencyId?: StringNullableFilter<"pricing_models"> | string | null
    name?: StringFilter<"pricing_models"> | string
    isActive?: BoolFilter<"pricing_models"> | boolean
    baseRates?: JsonFilter<"pricing_models">
    perMileRates?: JsonFilter<"pricing_models">
    priorityMultipliers?: JsonFilter<"pricing_models">
    peakHourMultipliers?: JsonFilter<"pricing_models">
    weekendMultipliers?: JsonFilter<"pricing_models">
    seasonalMultipliers?: JsonFilter<"pricing_models">
    zoneMultipliers?: JsonFilter<"pricing_models">
    distanceTiers?: JsonFilter<"pricing_models">
    specialRequirements?: JsonFilter<"pricing_models">
    isolationPricing?: DecimalNullableFilter<"pricing_models"> | Decimal | DecimalJsLike | number | string | null
    bariatricPricing?: DecimalNullableFilter<"pricing_models"> | Decimal | DecimalJsLike | number | string | null
    oxygenPricing?: DecimalNullableFilter<"pricing_models"> | Decimal | DecimalJsLike | number | string | null
    monitoringPricing?: DecimalNullableFilter<"pricing_models"> | Decimal | DecimalJsLike | number | string | null
    insuranceRates?: JsonFilter<"pricing_models">
    createdAt?: DateTimeFilter<"pricing_models"> | Date | string
    updatedAt?: DateTimeFilter<"pricing_models"> | Date | string
  }

  export type pricing_modelsOrderByWithRelationInput = {
    id?: SortOrder
    agencyId?: SortOrderInput | SortOrder
    name?: SortOrder
    isActive?: SortOrder
    baseRates?: SortOrder
    perMileRates?: SortOrder
    priorityMultipliers?: SortOrder
    peakHourMultipliers?: SortOrder
    weekendMultipliers?: SortOrder
    seasonalMultipliers?: SortOrder
    zoneMultipliers?: SortOrder
    distanceTiers?: SortOrder
    specialRequirements?: SortOrder
    isolationPricing?: SortOrderInput | SortOrder
    bariatricPricing?: SortOrderInput | SortOrder
    oxygenPricing?: SortOrderInput | SortOrder
    monitoringPricing?: SortOrderInput | SortOrder
    insuranceRates?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type pricing_modelsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: pricing_modelsWhereInput | pricing_modelsWhereInput[]
    OR?: pricing_modelsWhereInput[]
    NOT?: pricing_modelsWhereInput | pricing_modelsWhereInput[]
    agencyId?: StringNullableFilter<"pricing_models"> | string | null
    name?: StringFilter<"pricing_models"> | string
    isActive?: BoolFilter<"pricing_models"> | boolean
    baseRates?: JsonFilter<"pricing_models">
    perMileRates?: JsonFilter<"pricing_models">
    priorityMultipliers?: JsonFilter<"pricing_models">
    peakHourMultipliers?: JsonFilter<"pricing_models">
    weekendMultipliers?: JsonFilter<"pricing_models">
    seasonalMultipliers?: JsonFilter<"pricing_models">
    zoneMultipliers?: JsonFilter<"pricing_models">
    distanceTiers?: JsonFilter<"pricing_models">
    specialRequirements?: JsonFilter<"pricing_models">
    isolationPricing?: DecimalNullableFilter<"pricing_models"> | Decimal | DecimalJsLike | number | string | null
    bariatricPricing?: DecimalNullableFilter<"pricing_models"> | Decimal | DecimalJsLike | number | string | null
    oxygenPricing?: DecimalNullableFilter<"pricing_models"> | Decimal | DecimalJsLike | number | string | null
    monitoringPricing?: DecimalNullableFilter<"pricing_models"> | Decimal | DecimalJsLike | number | string | null
    insuranceRates?: JsonFilter<"pricing_models">
    createdAt?: DateTimeFilter<"pricing_models"> | Date | string
    updatedAt?: DateTimeFilter<"pricing_models"> | Date | string
  }, "id">

  export type pricing_modelsOrderByWithAggregationInput = {
    id?: SortOrder
    agencyId?: SortOrderInput | SortOrder
    name?: SortOrder
    isActive?: SortOrder
    baseRates?: SortOrder
    perMileRates?: SortOrder
    priorityMultipliers?: SortOrder
    peakHourMultipliers?: SortOrder
    weekendMultipliers?: SortOrder
    seasonalMultipliers?: SortOrder
    zoneMultipliers?: SortOrder
    distanceTiers?: SortOrder
    specialRequirements?: SortOrder
    isolationPricing?: SortOrderInput | SortOrder
    bariatricPricing?: SortOrderInput | SortOrder
    oxygenPricing?: SortOrderInput | SortOrder
    monitoringPricing?: SortOrderInput | SortOrder
    insuranceRates?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: pricing_modelsCountOrderByAggregateInput
    _avg?: pricing_modelsAvgOrderByAggregateInput
    _max?: pricing_modelsMaxOrderByAggregateInput
    _min?: pricing_modelsMinOrderByAggregateInput
    _sum?: pricing_modelsSumOrderByAggregateInput
  }

  export type pricing_modelsScalarWhereWithAggregatesInput = {
    AND?: pricing_modelsScalarWhereWithAggregatesInput | pricing_modelsScalarWhereWithAggregatesInput[]
    OR?: pricing_modelsScalarWhereWithAggregatesInput[]
    NOT?: pricing_modelsScalarWhereWithAggregatesInput | pricing_modelsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"pricing_models"> | string
    agencyId?: StringNullableWithAggregatesFilter<"pricing_models"> | string | null
    name?: StringWithAggregatesFilter<"pricing_models"> | string
    isActive?: BoolWithAggregatesFilter<"pricing_models"> | boolean
    baseRates?: JsonWithAggregatesFilter<"pricing_models">
    perMileRates?: JsonWithAggregatesFilter<"pricing_models">
    priorityMultipliers?: JsonWithAggregatesFilter<"pricing_models">
    peakHourMultipliers?: JsonWithAggregatesFilter<"pricing_models">
    weekendMultipliers?: JsonWithAggregatesFilter<"pricing_models">
    seasonalMultipliers?: JsonWithAggregatesFilter<"pricing_models">
    zoneMultipliers?: JsonWithAggregatesFilter<"pricing_models">
    distanceTiers?: JsonWithAggregatesFilter<"pricing_models">
    specialRequirements?: JsonWithAggregatesFilter<"pricing_models">
    isolationPricing?: DecimalNullableWithAggregatesFilter<"pricing_models"> | Decimal | DecimalJsLike | number | string | null
    bariatricPricing?: DecimalNullableWithAggregatesFilter<"pricing_models"> | Decimal | DecimalJsLike | number | string | null
    oxygenPricing?: DecimalNullableWithAggregatesFilter<"pricing_models"> | Decimal | DecimalJsLike | number | string | null
    monitoringPricing?: DecimalNullableWithAggregatesFilter<"pricing_models"> | Decimal | DecimalJsLike | number | string | null
    insuranceRates?: JsonWithAggregatesFilter<"pricing_models">
    createdAt?: DateTimeWithAggregatesFilter<"pricing_models"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"pricing_models"> | Date | string
  }

  export type route_optimization_settingsWhereInput = {
    AND?: route_optimization_settingsWhereInput | route_optimization_settingsWhereInput[]
    OR?: route_optimization_settingsWhereInput[]
    NOT?: route_optimization_settingsWhereInput | route_optimization_settingsWhereInput[]
    id?: StringFilter<"route_optimization_settings"> | string
    agencyId?: StringNullableFilter<"route_optimization_settings"> | string | null
    deadheadMileWeight?: DecimalFilter<"route_optimization_settings"> | Decimal | DecimalJsLike | number | string
    waitTimeWeight?: DecimalFilter<"route_optimization_settings"> | Decimal | DecimalJsLike | number | string
    backhaulBonusWeight?: DecimalFilter<"route_optimization_settings"> | Decimal | DecimalJsLike | number | string
    overtimeRiskWeight?: DecimalFilter<"route_optimization_settings"> | Decimal | DecimalJsLike | number | string
    revenueWeight?: DecimalFilter<"route_optimization_settings"> | Decimal | DecimalJsLike | number | string
    maxDeadheadMiles?: DecimalFilter<"route_optimization_settings"> | Decimal | DecimalJsLike | number | string
    maxWaitTimeMinutes?: IntFilter<"route_optimization_settings"> | number
    maxOvertimeHours?: DecimalFilter<"route_optimization_settings"> | Decimal | DecimalJsLike | number | string
    maxResponseTimeMinutes?: IntFilter<"route_optimization_settings"> | number
    maxServiceDistance?: DecimalFilter<"route_optimization_settings"> | Decimal | DecimalJsLike | number | string
    backhaulTimeWindow?: IntFilter<"route_optimization_settings"> | number
    backhaulDistanceLimit?: DecimalFilter<"route_optimization_settings"> | Decimal | DecimalJsLike | number | string
    backhaulRevenueBonus?: DecimalFilter<"route_optimization_settings"> | Decimal | DecimalJsLike | number | string
    enableBackhaulOptimization?: BoolFilter<"route_optimization_settings"> | boolean
    targetLoadedMileRatio?: DecimalFilter<"route_optimization_settings"> | Decimal | DecimalJsLike | number | string
    targetRevenuePerHour?: DecimalFilter<"route_optimization_settings"> | Decimal | DecimalJsLike | number | string
    targetResponseTime?: IntFilter<"route_optimization_settings"> | number
    targetEfficiency?: DecimalFilter<"route_optimization_settings"> | Decimal | DecimalJsLike | number | string
    optimizationAlgorithm?: StringFilter<"route_optimization_settings"> | string
    maxOptimizationTime?: IntFilter<"route_optimization_settings"> | number
    enableRealTimeOptimization?: BoolFilter<"route_optimization_settings"> | boolean
    crewAvailabilityWeight?: DecimalFilter<"route_optimization_settings"> | Decimal | DecimalJsLike | number | string
    equipmentCompatibilityWeight?: DecimalFilter<"route_optimization_settings"> | Decimal | DecimalJsLike | number | string
    patientPriorityWeight?: DecimalFilter<"route_optimization_settings"> | Decimal | DecimalJsLike | number | string
    isActive?: BoolFilter<"route_optimization_settings"> | boolean
    createdAt?: DateTimeFilter<"route_optimization_settings"> | Date | string
    updatedAt?: DateTimeFilter<"route_optimization_settings"> | Date | string
  }

  export type route_optimization_settingsOrderByWithRelationInput = {
    id?: SortOrder
    agencyId?: SortOrderInput | SortOrder
    deadheadMileWeight?: SortOrder
    waitTimeWeight?: SortOrder
    backhaulBonusWeight?: SortOrder
    overtimeRiskWeight?: SortOrder
    revenueWeight?: SortOrder
    maxDeadheadMiles?: SortOrder
    maxWaitTimeMinutes?: SortOrder
    maxOvertimeHours?: SortOrder
    maxResponseTimeMinutes?: SortOrder
    maxServiceDistance?: SortOrder
    backhaulTimeWindow?: SortOrder
    backhaulDistanceLimit?: SortOrder
    backhaulRevenueBonus?: SortOrder
    enableBackhaulOptimization?: SortOrder
    targetLoadedMileRatio?: SortOrder
    targetRevenuePerHour?: SortOrder
    targetResponseTime?: SortOrder
    targetEfficiency?: SortOrder
    optimizationAlgorithm?: SortOrder
    maxOptimizationTime?: SortOrder
    enableRealTimeOptimization?: SortOrder
    crewAvailabilityWeight?: SortOrder
    equipmentCompatibilityWeight?: SortOrder
    patientPriorityWeight?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type route_optimization_settingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: route_optimization_settingsWhereInput | route_optimization_settingsWhereInput[]
    OR?: route_optimization_settingsWhereInput[]
    NOT?: route_optimization_settingsWhereInput | route_optimization_settingsWhereInput[]
    agencyId?: StringNullableFilter<"route_optimization_settings"> | string | null
    deadheadMileWeight?: DecimalFilter<"route_optimization_settings"> | Decimal | DecimalJsLike | number | string
    waitTimeWeight?: DecimalFilter<"route_optimization_settings"> | Decimal | DecimalJsLike | number | string
    backhaulBonusWeight?: DecimalFilter<"route_optimization_settings"> | Decimal | DecimalJsLike | number | string
    overtimeRiskWeight?: DecimalFilter<"route_optimization_settings"> | Decimal | DecimalJsLike | number | string
    revenueWeight?: DecimalFilter<"route_optimization_settings"> | Decimal | DecimalJsLike | number | string
    maxDeadheadMiles?: DecimalFilter<"route_optimization_settings"> | Decimal | DecimalJsLike | number | string
    maxWaitTimeMinutes?: IntFilter<"route_optimization_settings"> | number
    maxOvertimeHours?: DecimalFilter<"route_optimization_settings"> | Decimal | DecimalJsLike | number | string
    maxResponseTimeMinutes?: IntFilter<"route_optimization_settings"> | number
    maxServiceDistance?: DecimalFilter<"route_optimization_settings"> | Decimal | DecimalJsLike | number | string
    backhaulTimeWindow?: IntFilter<"route_optimization_settings"> | number
    backhaulDistanceLimit?: DecimalFilter<"route_optimization_settings"> | Decimal | DecimalJsLike | number | string
    backhaulRevenueBonus?: DecimalFilter<"route_optimization_settings"> | Decimal | DecimalJsLike | number | string
    enableBackhaulOptimization?: BoolFilter<"route_optimization_settings"> | boolean
    targetLoadedMileRatio?: DecimalFilter<"route_optimization_settings"> | Decimal | DecimalJsLike | number | string
    targetRevenuePerHour?: DecimalFilter<"route_optimization_settings"> | Decimal | DecimalJsLike | number | string
    targetResponseTime?: IntFilter<"route_optimization_settings"> | number
    targetEfficiency?: DecimalFilter<"route_optimization_settings"> | Decimal | DecimalJsLike | number | string
    optimizationAlgorithm?: StringFilter<"route_optimization_settings"> | string
    maxOptimizationTime?: IntFilter<"route_optimization_settings"> | number
    enableRealTimeOptimization?: BoolFilter<"route_optimization_settings"> | boolean
    crewAvailabilityWeight?: DecimalFilter<"route_optimization_settings"> | Decimal | DecimalJsLike | number | string
    equipmentCompatibilityWeight?: DecimalFilter<"route_optimization_settings"> | Decimal | DecimalJsLike | number | string
    patientPriorityWeight?: DecimalFilter<"route_optimization_settings"> | Decimal | DecimalJsLike | number | string
    isActive?: BoolFilter<"route_optimization_settings"> | boolean
    createdAt?: DateTimeFilter<"route_optimization_settings"> | Date | string
    updatedAt?: DateTimeFilter<"route_optimization_settings"> | Date | string
  }, "id">

  export type route_optimization_settingsOrderByWithAggregationInput = {
    id?: SortOrder
    agencyId?: SortOrderInput | SortOrder
    deadheadMileWeight?: SortOrder
    waitTimeWeight?: SortOrder
    backhaulBonusWeight?: SortOrder
    overtimeRiskWeight?: SortOrder
    revenueWeight?: SortOrder
    maxDeadheadMiles?: SortOrder
    maxWaitTimeMinutes?: SortOrder
    maxOvertimeHours?: SortOrder
    maxResponseTimeMinutes?: SortOrder
    maxServiceDistance?: SortOrder
    backhaulTimeWindow?: SortOrder
    backhaulDistanceLimit?: SortOrder
    backhaulRevenueBonus?: SortOrder
    enableBackhaulOptimization?: SortOrder
    targetLoadedMileRatio?: SortOrder
    targetRevenuePerHour?: SortOrder
    targetResponseTime?: SortOrder
    targetEfficiency?: SortOrder
    optimizationAlgorithm?: SortOrder
    maxOptimizationTime?: SortOrder
    enableRealTimeOptimization?: SortOrder
    crewAvailabilityWeight?: SortOrder
    equipmentCompatibilityWeight?: SortOrder
    patientPriorityWeight?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: route_optimization_settingsCountOrderByAggregateInput
    _avg?: route_optimization_settingsAvgOrderByAggregateInput
    _max?: route_optimization_settingsMaxOrderByAggregateInput
    _min?: route_optimization_settingsMinOrderByAggregateInput
    _sum?: route_optimization_settingsSumOrderByAggregateInput
  }

  export type route_optimization_settingsScalarWhereWithAggregatesInput = {
    AND?: route_optimization_settingsScalarWhereWithAggregatesInput | route_optimization_settingsScalarWhereWithAggregatesInput[]
    OR?: route_optimization_settingsScalarWhereWithAggregatesInput[]
    NOT?: route_optimization_settingsScalarWhereWithAggregatesInput | route_optimization_settingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"route_optimization_settings"> | string
    agencyId?: StringNullableWithAggregatesFilter<"route_optimization_settings"> | string | null
    deadheadMileWeight?: DecimalWithAggregatesFilter<"route_optimization_settings"> | Decimal | DecimalJsLike | number | string
    waitTimeWeight?: DecimalWithAggregatesFilter<"route_optimization_settings"> | Decimal | DecimalJsLike | number | string
    backhaulBonusWeight?: DecimalWithAggregatesFilter<"route_optimization_settings"> | Decimal | DecimalJsLike | number | string
    overtimeRiskWeight?: DecimalWithAggregatesFilter<"route_optimization_settings"> | Decimal | DecimalJsLike | number | string
    revenueWeight?: DecimalWithAggregatesFilter<"route_optimization_settings"> | Decimal | DecimalJsLike | number | string
    maxDeadheadMiles?: DecimalWithAggregatesFilter<"route_optimization_settings"> | Decimal | DecimalJsLike | number | string
    maxWaitTimeMinutes?: IntWithAggregatesFilter<"route_optimization_settings"> | number
    maxOvertimeHours?: DecimalWithAggregatesFilter<"route_optimization_settings"> | Decimal | DecimalJsLike | number | string
    maxResponseTimeMinutes?: IntWithAggregatesFilter<"route_optimization_settings"> | number
    maxServiceDistance?: DecimalWithAggregatesFilter<"route_optimization_settings"> | Decimal | DecimalJsLike | number | string
    backhaulTimeWindow?: IntWithAggregatesFilter<"route_optimization_settings"> | number
    backhaulDistanceLimit?: DecimalWithAggregatesFilter<"route_optimization_settings"> | Decimal | DecimalJsLike | number | string
    backhaulRevenueBonus?: DecimalWithAggregatesFilter<"route_optimization_settings"> | Decimal | DecimalJsLike | number | string
    enableBackhaulOptimization?: BoolWithAggregatesFilter<"route_optimization_settings"> | boolean
    targetLoadedMileRatio?: DecimalWithAggregatesFilter<"route_optimization_settings"> | Decimal | DecimalJsLike | number | string
    targetRevenuePerHour?: DecimalWithAggregatesFilter<"route_optimization_settings"> | Decimal | DecimalJsLike | number | string
    targetResponseTime?: IntWithAggregatesFilter<"route_optimization_settings"> | number
    targetEfficiency?: DecimalWithAggregatesFilter<"route_optimization_settings"> | Decimal | DecimalJsLike | number | string
    optimizationAlgorithm?: StringWithAggregatesFilter<"route_optimization_settings"> | string
    maxOptimizationTime?: IntWithAggregatesFilter<"route_optimization_settings"> | number
    enableRealTimeOptimization?: BoolWithAggregatesFilter<"route_optimization_settings"> | boolean
    crewAvailabilityWeight?: DecimalWithAggregatesFilter<"route_optimization_settings"> | Decimal | DecimalJsLike | number | string
    equipmentCompatibilityWeight?: DecimalWithAggregatesFilter<"route_optimization_settings"> | Decimal | DecimalJsLike | number | string
    patientPriorityWeight?: DecimalWithAggregatesFilter<"route_optimization_settings"> | Decimal | DecimalJsLike | number | string
    isActive?: BoolWithAggregatesFilter<"route_optimization_settings"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"route_optimization_settings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"route_optimization_settings"> | Date | string
  }

  export type UnitWhereInput = {
    AND?: UnitWhereInput | UnitWhereInput[]
    OR?: UnitWhereInput[]
    NOT?: UnitWhereInput | UnitWhereInput[]
    id?: StringFilter<"Unit"> | string
    agencyId?: StringFilter<"Unit"> | string
    unitNumber?: StringFilter<"Unit"> | string
    type?: StringFilter<"Unit"> | string
    status?: StringFilter<"Unit"> | string
    currentStatus?: StringFilter<"Unit"> | string
    currentLocation?: StringNullableFilter<"Unit"> | string | null
    capabilities?: StringNullableListFilter<"Unit">
    crewSize?: IntFilter<"Unit"> | number
    equipment?: StringNullableListFilter<"Unit">
    location?: JsonNullableFilter<"Unit">
    latitude?: FloatNullableFilter<"Unit"> | number | null
    longitude?: FloatNullableFilter<"Unit"> | number | null
    lastMaintenance?: DateTimeNullableFilter<"Unit"> | Date | string | null
    nextMaintenance?: DateTimeNullableFilter<"Unit"> | Date | string | null
    isActive?: BoolFilter<"Unit"> | boolean
    createdAt?: DateTimeFilter<"Unit"> | Date | string
    updatedAt?: DateTimeFilter<"Unit"> | Date | string
    analytics?: XOR<Unit_analyticsNullableRelationFilter, unit_analyticsWhereInput> | null
    agency?: XOR<EMSAgencyRelationFilter, EMSAgencyWhereInput>
    assignedTrips?: TransportRequestListRelationFilter
  }

  export type UnitOrderByWithRelationInput = {
    id?: SortOrder
    agencyId?: SortOrder
    unitNumber?: SortOrder
    type?: SortOrder
    status?: SortOrder
    currentStatus?: SortOrder
    currentLocation?: SortOrderInput | SortOrder
    capabilities?: SortOrder
    crewSize?: SortOrder
    equipment?: SortOrder
    location?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    lastMaintenance?: SortOrderInput | SortOrder
    nextMaintenance?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    analytics?: unit_analyticsOrderByWithRelationInput
    agency?: EMSAgencyOrderByWithRelationInput
    assignedTrips?: TransportRequestOrderByRelationAggregateInput
  }

  export type UnitWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    agencyId_unitNumber?: UnitAgencyIdUnitNumberCompoundUniqueInput
    AND?: UnitWhereInput | UnitWhereInput[]
    OR?: UnitWhereInput[]
    NOT?: UnitWhereInput | UnitWhereInput[]
    agencyId?: StringFilter<"Unit"> | string
    unitNumber?: StringFilter<"Unit"> | string
    type?: StringFilter<"Unit"> | string
    status?: StringFilter<"Unit"> | string
    currentStatus?: StringFilter<"Unit"> | string
    currentLocation?: StringNullableFilter<"Unit"> | string | null
    capabilities?: StringNullableListFilter<"Unit">
    crewSize?: IntFilter<"Unit"> | number
    equipment?: StringNullableListFilter<"Unit">
    location?: JsonNullableFilter<"Unit">
    latitude?: FloatNullableFilter<"Unit"> | number | null
    longitude?: FloatNullableFilter<"Unit"> | number | null
    lastMaintenance?: DateTimeNullableFilter<"Unit"> | Date | string | null
    nextMaintenance?: DateTimeNullableFilter<"Unit"> | Date | string | null
    isActive?: BoolFilter<"Unit"> | boolean
    createdAt?: DateTimeFilter<"Unit"> | Date | string
    updatedAt?: DateTimeFilter<"Unit"> | Date | string
    analytics?: XOR<Unit_analyticsNullableRelationFilter, unit_analyticsWhereInput> | null
    agency?: XOR<EMSAgencyRelationFilter, EMSAgencyWhereInput>
    assignedTrips?: TransportRequestListRelationFilter
  }, "id" | "agencyId_unitNumber">

  export type UnitOrderByWithAggregationInput = {
    id?: SortOrder
    agencyId?: SortOrder
    unitNumber?: SortOrder
    type?: SortOrder
    status?: SortOrder
    currentStatus?: SortOrder
    currentLocation?: SortOrderInput | SortOrder
    capabilities?: SortOrder
    crewSize?: SortOrder
    equipment?: SortOrder
    location?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    lastMaintenance?: SortOrderInput | SortOrder
    nextMaintenance?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UnitCountOrderByAggregateInput
    _avg?: UnitAvgOrderByAggregateInput
    _max?: UnitMaxOrderByAggregateInput
    _min?: UnitMinOrderByAggregateInput
    _sum?: UnitSumOrderByAggregateInput
  }

  export type UnitScalarWhereWithAggregatesInput = {
    AND?: UnitScalarWhereWithAggregatesInput | UnitScalarWhereWithAggregatesInput[]
    OR?: UnitScalarWhereWithAggregatesInput[]
    NOT?: UnitScalarWhereWithAggregatesInput | UnitScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Unit"> | string
    agencyId?: StringWithAggregatesFilter<"Unit"> | string
    unitNumber?: StringWithAggregatesFilter<"Unit"> | string
    type?: StringWithAggregatesFilter<"Unit"> | string
    status?: StringWithAggregatesFilter<"Unit"> | string
    currentStatus?: StringWithAggregatesFilter<"Unit"> | string
    currentLocation?: StringNullableWithAggregatesFilter<"Unit"> | string | null
    capabilities?: StringNullableListFilter<"Unit">
    crewSize?: IntWithAggregatesFilter<"Unit"> | number
    equipment?: StringNullableListFilter<"Unit">
    location?: JsonNullableWithAggregatesFilter<"Unit">
    latitude?: FloatNullableWithAggregatesFilter<"Unit"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"Unit"> | number | null
    lastMaintenance?: DateTimeNullableWithAggregatesFilter<"Unit"> | Date | string | null
    nextMaintenance?: DateTimeNullableWithAggregatesFilter<"Unit"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"Unit"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Unit"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Unit"> | Date | string
  }

  export type unit_analyticsWhereInput = {
    AND?: unit_analyticsWhereInput | unit_analyticsWhereInput[]
    OR?: unit_analyticsWhereInput[]
    NOT?: unit_analyticsWhereInput | unit_analyticsWhereInput[]
    id?: StringFilter<"unit_analytics"> | string
    unitId?: StringFilter<"unit_analytics"> | string
    performanceScore?: DecimalNullableFilter<"unit_analytics"> | Decimal | DecimalJsLike | number | string | null
    efficiency?: DecimalNullableFilter<"unit_analytics"> | Decimal | DecimalJsLike | number | string | null
    totalTrips?: IntFilter<"unit_analytics"> | number
    totalTripsCompleted?: IntFilter<"unit_analytics"> | number
    averageResponseTime?: DecimalNullableFilter<"unit_analytics"> | Decimal | DecimalJsLike | number | string | null
    lastUpdated?: DateTimeFilter<"unit_analytics"> | Date | string
    unit?: XOR<UnitRelationFilter, UnitWhereInput>
  }

  export type unit_analyticsOrderByWithRelationInput = {
    id?: SortOrder
    unitId?: SortOrder
    performanceScore?: SortOrderInput | SortOrder
    efficiency?: SortOrderInput | SortOrder
    totalTrips?: SortOrder
    totalTripsCompleted?: SortOrder
    averageResponseTime?: SortOrderInput | SortOrder
    lastUpdated?: SortOrder
    unit?: UnitOrderByWithRelationInput
  }

  export type unit_analyticsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    unitId?: string
    AND?: unit_analyticsWhereInput | unit_analyticsWhereInput[]
    OR?: unit_analyticsWhereInput[]
    NOT?: unit_analyticsWhereInput | unit_analyticsWhereInput[]
    performanceScore?: DecimalNullableFilter<"unit_analytics"> | Decimal | DecimalJsLike | number | string | null
    efficiency?: DecimalNullableFilter<"unit_analytics"> | Decimal | DecimalJsLike | number | string | null
    totalTrips?: IntFilter<"unit_analytics"> | number
    totalTripsCompleted?: IntFilter<"unit_analytics"> | number
    averageResponseTime?: DecimalNullableFilter<"unit_analytics"> | Decimal | DecimalJsLike | number | string | null
    lastUpdated?: DateTimeFilter<"unit_analytics"> | Date | string
    unit?: XOR<UnitRelationFilter, UnitWhereInput>
  }, "id" | "unitId">

  export type unit_analyticsOrderByWithAggregationInput = {
    id?: SortOrder
    unitId?: SortOrder
    performanceScore?: SortOrderInput | SortOrder
    efficiency?: SortOrderInput | SortOrder
    totalTrips?: SortOrder
    totalTripsCompleted?: SortOrder
    averageResponseTime?: SortOrderInput | SortOrder
    lastUpdated?: SortOrder
    _count?: unit_analyticsCountOrderByAggregateInput
    _avg?: unit_analyticsAvgOrderByAggregateInput
    _max?: unit_analyticsMaxOrderByAggregateInput
    _min?: unit_analyticsMinOrderByAggregateInput
    _sum?: unit_analyticsSumOrderByAggregateInput
  }

  export type unit_analyticsScalarWhereWithAggregatesInput = {
    AND?: unit_analyticsScalarWhereWithAggregatesInput | unit_analyticsScalarWhereWithAggregatesInput[]
    OR?: unit_analyticsScalarWhereWithAggregatesInput[]
    NOT?: unit_analyticsScalarWhereWithAggregatesInput | unit_analyticsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"unit_analytics"> | string
    unitId?: StringWithAggregatesFilter<"unit_analytics"> | string
    performanceScore?: DecimalNullableWithAggregatesFilter<"unit_analytics"> | Decimal | DecimalJsLike | number | string | null
    efficiency?: DecimalNullableWithAggregatesFilter<"unit_analytics"> | Decimal | DecimalJsLike | number | string | null
    totalTrips?: IntWithAggregatesFilter<"unit_analytics"> | number
    totalTripsCompleted?: IntWithAggregatesFilter<"unit_analytics"> | number
    averageResponseTime?: DecimalNullableWithAggregatesFilter<"unit_analytics"> | Decimal | DecimalJsLike | number | string | null
    lastUpdated?: DateTimeWithAggregatesFilter<"unit_analytics"> | Date | string
  }

  export type NotificationPreferenceWhereInput = {
    AND?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    OR?: NotificationPreferenceWhereInput[]
    NOT?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    id?: StringFilter<"NotificationPreference"> | string
    userId?: StringFilter<"NotificationPreference"> | string
    notificationType?: StringFilter<"NotificationPreference"> | string
    emailEnabled?: BoolFilter<"NotificationPreference"> | boolean
    smsEnabled?: BoolFilter<"NotificationPreference"> | boolean
    createdAt?: DateTimeFilter<"NotificationPreference"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationPreference"> | Date | string
    user?: XOR<CenterUserRelationFilter, CenterUserWhereInput>
  }

  export type NotificationPreferenceOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    notificationType?: SortOrder
    emailEnabled?: SortOrder
    smsEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: CenterUserOrderByWithRelationInput
  }

  export type NotificationPreferenceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_notificationType?: NotificationPreferenceUserIdNotificationTypeCompoundUniqueInput
    AND?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    OR?: NotificationPreferenceWhereInput[]
    NOT?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    userId?: StringFilter<"NotificationPreference"> | string
    notificationType?: StringFilter<"NotificationPreference"> | string
    emailEnabled?: BoolFilter<"NotificationPreference"> | boolean
    smsEnabled?: BoolFilter<"NotificationPreference"> | boolean
    createdAt?: DateTimeFilter<"NotificationPreference"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationPreference"> | Date | string
    user?: XOR<CenterUserRelationFilter, CenterUserWhereInput>
  }, "id" | "userId_notificationType">

  export type NotificationPreferenceOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    notificationType?: SortOrder
    emailEnabled?: SortOrder
    smsEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationPreferenceCountOrderByAggregateInput
    _max?: NotificationPreferenceMaxOrderByAggregateInput
    _min?: NotificationPreferenceMinOrderByAggregateInput
  }

  export type NotificationPreferenceScalarWhereWithAggregatesInput = {
    AND?: NotificationPreferenceScalarWhereWithAggregatesInput | NotificationPreferenceScalarWhereWithAggregatesInput[]
    OR?: NotificationPreferenceScalarWhereWithAggregatesInput[]
    NOT?: NotificationPreferenceScalarWhereWithAggregatesInput | NotificationPreferenceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NotificationPreference"> | string
    userId?: StringWithAggregatesFilter<"NotificationPreference"> | string
    notificationType?: StringWithAggregatesFilter<"NotificationPreference"> | string
    emailEnabled?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    smsEnabled?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"NotificationPreference"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NotificationPreference"> | Date | string
  }

  export type NotificationLogWhereInput = {
    AND?: NotificationLogWhereInput | NotificationLogWhereInput[]
    OR?: NotificationLogWhereInput[]
    NOT?: NotificationLogWhereInput | NotificationLogWhereInput[]
    id?: StringFilter<"NotificationLog"> | string
    userId?: StringFilter<"NotificationLog"> | string
    notificationType?: StringFilter<"NotificationLog"> | string
    channel?: StringFilter<"NotificationLog"> | string
    status?: StringFilter<"NotificationLog"> | string
    sentAt?: DateTimeFilter<"NotificationLog"> | Date | string
    deliveredAt?: DateTimeNullableFilter<"NotificationLog"> | Date | string | null
    errorMessage?: StringNullableFilter<"NotificationLog"> | string | null
    user?: XOR<CenterUserRelationFilter, CenterUserWhereInput>
  }

  export type NotificationLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    notificationType?: SortOrder
    channel?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    user?: CenterUserOrderByWithRelationInput
  }

  export type NotificationLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationLogWhereInput | NotificationLogWhereInput[]
    OR?: NotificationLogWhereInput[]
    NOT?: NotificationLogWhereInput | NotificationLogWhereInput[]
    userId?: StringFilter<"NotificationLog"> | string
    notificationType?: StringFilter<"NotificationLog"> | string
    channel?: StringFilter<"NotificationLog"> | string
    status?: StringFilter<"NotificationLog"> | string
    sentAt?: DateTimeFilter<"NotificationLog"> | Date | string
    deliveredAt?: DateTimeNullableFilter<"NotificationLog"> | Date | string | null
    errorMessage?: StringNullableFilter<"NotificationLog"> | string | null
    user?: XOR<CenterUserRelationFilter, CenterUserWhereInput>
  }, "id">

  export type NotificationLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    notificationType?: SortOrder
    channel?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    _count?: NotificationLogCountOrderByAggregateInput
    _max?: NotificationLogMaxOrderByAggregateInput
    _min?: NotificationLogMinOrderByAggregateInput
  }

  export type NotificationLogScalarWhereWithAggregatesInput = {
    AND?: NotificationLogScalarWhereWithAggregatesInput | NotificationLogScalarWhereWithAggregatesInput[]
    OR?: NotificationLogScalarWhereWithAggregatesInput[]
    NOT?: NotificationLogScalarWhereWithAggregatesInput | NotificationLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NotificationLog"> | string
    userId?: StringWithAggregatesFilter<"NotificationLog"> | string
    notificationType?: StringWithAggregatesFilter<"NotificationLog"> | string
    channel?: StringWithAggregatesFilter<"NotificationLog"> | string
    status?: StringWithAggregatesFilter<"NotificationLog"> | string
    sentAt?: DateTimeWithAggregatesFilter<"NotificationLog"> | Date | string
    deliveredAt?: DateTimeNullableWithAggregatesFilter<"NotificationLog"> | Date | string | null
    errorMessage?: StringNullableWithAggregatesFilter<"NotificationLog"> | string | null
  }

  export type DropdownOptionWhereInput = {
    AND?: DropdownOptionWhereInput | DropdownOptionWhereInput[]
    OR?: DropdownOptionWhereInput[]
    NOT?: DropdownOptionWhereInput | DropdownOptionWhereInput[]
    id?: StringFilter<"DropdownOption"> | string
    category?: StringFilter<"DropdownOption"> | string
    value?: StringFilter<"DropdownOption"> | string
    isActive?: BoolFilter<"DropdownOption"> | boolean
    createdAt?: DateTimeFilter<"DropdownOption"> | Date | string
    updatedAt?: DateTimeFilter<"DropdownOption"> | Date | string
    defaultFor?: XOR<CategoryDefaultNullableRelationFilter, CategoryDefaultWhereInput> | null
  }

  export type DropdownOptionOrderByWithRelationInput = {
    id?: SortOrder
    category?: SortOrder
    value?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    defaultFor?: CategoryDefaultOrderByWithRelationInput
  }

  export type DropdownOptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    category_value?: DropdownOptionCategoryValueCompoundUniqueInput
    AND?: DropdownOptionWhereInput | DropdownOptionWhereInput[]
    OR?: DropdownOptionWhereInput[]
    NOT?: DropdownOptionWhereInput | DropdownOptionWhereInput[]
    category?: StringFilter<"DropdownOption"> | string
    value?: StringFilter<"DropdownOption"> | string
    isActive?: BoolFilter<"DropdownOption"> | boolean
    createdAt?: DateTimeFilter<"DropdownOption"> | Date | string
    updatedAt?: DateTimeFilter<"DropdownOption"> | Date | string
    defaultFor?: XOR<CategoryDefaultNullableRelationFilter, CategoryDefaultWhereInput> | null
  }, "id" | "category_value">

  export type DropdownOptionOrderByWithAggregationInput = {
    id?: SortOrder
    category?: SortOrder
    value?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DropdownOptionCountOrderByAggregateInput
    _max?: DropdownOptionMaxOrderByAggregateInput
    _min?: DropdownOptionMinOrderByAggregateInput
  }

  export type DropdownOptionScalarWhereWithAggregatesInput = {
    AND?: DropdownOptionScalarWhereWithAggregatesInput | DropdownOptionScalarWhereWithAggregatesInput[]
    OR?: DropdownOptionScalarWhereWithAggregatesInput[]
    NOT?: DropdownOptionScalarWhereWithAggregatesInput | DropdownOptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DropdownOption"> | string
    category?: StringWithAggregatesFilter<"DropdownOption"> | string
    value?: StringWithAggregatesFilter<"DropdownOption"> | string
    isActive?: BoolWithAggregatesFilter<"DropdownOption"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"DropdownOption"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DropdownOption"> | Date | string
  }

  export type CategoryDefaultWhereInput = {
    AND?: CategoryDefaultWhereInput | CategoryDefaultWhereInput[]
    OR?: CategoryDefaultWhereInput[]
    NOT?: CategoryDefaultWhereInput | CategoryDefaultWhereInput[]
    id?: StringFilter<"CategoryDefault"> | string
    category?: StringFilter<"CategoryDefault"> | string
    optionId?: StringFilter<"CategoryDefault"> | string
    createdAt?: DateTimeFilter<"CategoryDefault"> | Date | string
    updatedAt?: DateTimeFilter<"CategoryDefault"> | Date | string
    option?: XOR<DropdownOptionRelationFilter, DropdownOptionWhereInput>
  }

  export type CategoryDefaultOrderByWithRelationInput = {
    id?: SortOrder
    category?: SortOrder
    optionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    option?: DropdownOptionOrderByWithRelationInput
  }

  export type CategoryDefaultWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    category?: string
    optionId?: string
    AND?: CategoryDefaultWhereInput | CategoryDefaultWhereInput[]
    OR?: CategoryDefaultWhereInput[]
    NOT?: CategoryDefaultWhereInput | CategoryDefaultWhereInput[]
    createdAt?: DateTimeFilter<"CategoryDefault"> | Date | string
    updatedAt?: DateTimeFilter<"CategoryDefault"> | Date | string
    option?: XOR<DropdownOptionRelationFilter, DropdownOptionWhereInput>
  }, "id" | "category" | "optionId">

  export type CategoryDefaultOrderByWithAggregationInput = {
    id?: SortOrder
    category?: SortOrder
    optionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CategoryDefaultCountOrderByAggregateInput
    _max?: CategoryDefaultMaxOrderByAggregateInput
    _min?: CategoryDefaultMinOrderByAggregateInput
  }

  export type CategoryDefaultScalarWhereWithAggregatesInput = {
    AND?: CategoryDefaultScalarWhereWithAggregatesInput | CategoryDefaultScalarWhereWithAggregatesInput[]
    OR?: CategoryDefaultScalarWhereWithAggregatesInput[]
    NOT?: CategoryDefaultScalarWhereWithAggregatesInput | CategoryDefaultScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CategoryDefault"> | string
    category?: StringWithAggregatesFilter<"CategoryDefault"> | string
    optionId?: StringWithAggregatesFilter<"CategoryDefault"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CategoryDefault"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CategoryDefault"> | Date | string
  }

  export type TransportRequestWhereInput = {
    AND?: TransportRequestWhereInput | TransportRequestWhereInput[]
    OR?: TransportRequestWhereInput[]
    NOT?: TransportRequestWhereInput | TransportRequestWhereInput[]
    id?: StringFilter<"TransportRequest"> | string
    tripNumber?: StringNullableFilter<"TransportRequest"> | string | null
    patientId?: StringFilter<"TransportRequest"> | string
    patientWeight?: StringNullableFilter<"TransportRequest"> | string | null
    specialNeeds?: StringNullableFilter<"TransportRequest"> | string | null
    originFacilityId?: StringNullableFilter<"TransportRequest"> | string | null
    destinationFacilityId?: StringNullableFilter<"TransportRequest"> | string | null
    fromLocation?: StringNullableFilter<"TransportRequest"> | string | null
    toLocation?: StringNullableFilter<"TransportRequest"> | string | null
    fromLocationId?: StringNullableFilter<"TransportRequest"> | string | null
    isMultiLocationFacility?: BoolFilter<"TransportRequest"> | boolean
    scheduledTime?: DateTimeNullableFilter<"TransportRequest"> | Date | string | null
    transportLevel?: StringFilter<"TransportRequest"> | string
    urgencyLevel?: StringNullableFilter<"TransportRequest"> | string | null
    priority?: StringFilter<"TransportRequest"> | string
    status?: StringFilter<"TransportRequest"> | string
    specialRequirements?: StringNullableFilter<"TransportRequest"> | string | null
    diagnosis?: StringNullableFilter<"TransportRequest"> | string | null
    mobilityLevel?: StringNullableFilter<"TransportRequest"> | string | null
    oxygenRequired?: BoolFilter<"TransportRequest"> | boolean
    monitoringRequired?: BoolFilter<"TransportRequest"> | boolean
    generateQRCode?: BoolFilter<"TransportRequest"> | boolean
    qrCodeData?: StringNullableFilter<"TransportRequest"> | string | null
    selectedAgencies?: StringNullableListFilter<"TransportRequest">
    notificationRadius?: IntNullableFilter<"TransportRequest"> | number | null
    requestTimestamp?: DateTimeFilter<"TransportRequest"> | Date | string
    acceptedTimestamp?: DateTimeNullableFilter<"TransportRequest"> | Date | string | null
    pickupTimestamp?: DateTimeNullableFilter<"TransportRequest"> | Date | string | null
    arrivalTimestamp?: DateTimeNullableFilter<"TransportRequest"> | Date | string | null
    departureTimestamp?: DateTimeNullableFilter<"TransportRequest"> | Date | string | null
    completionTimestamp?: DateTimeNullableFilter<"TransportRequest"> | Date | string | null
    pickupLocationId?: StringNullableFilter<"TransportRequest"> | string | null
    assignedAgencyId?: StringNullableFilter<"TransportRequest"> | string | null
    assignedUnitId?: StringNullableFilter<"TransportRequest"> | string | null
    createdById?: StringNullableFilter<"TransportRequest"> | string | null
    healthcareCreatedById?: StringNullableFilter<"TransportRequest"> | string | null
    isolation?: BoolFilter<"TransportRequest"> | boolean
    bariatric?: BoolFilter<"TransportRequest"> | boolean
    notes?: StringNullableFilter<"TransportRequest"> | string | null
    createdAt?: DateTimeFilter<"TransportRequest"> | Date | string
    updatedAt?: DateTimeFilter<"TransportRequest"> | Date | string
    originFacility?: XOR<FacilityNullableRelationFilter, FacilityWhereInput> | null
    destinationFacility?: XOR<FacilityNullableRelationFilter, FacilityWhereInput> | null
    pickupLocation?: XOR<Pickup_locationsNullableRelationFilter, pickup_locationsWhereInput> | null
    assignedUnit?: XOR<UnitNullableRelationFilter, UnitWhereInput> | null
    healthcareLocation?: XOR<HealthcareLocationNullableRelationFilter, HealthcareLocationWhereInput> | null
  }

  export type TransportRequestOrderByWithRelationInput = {
    id?: SortOrder
    tripNumber?: SortOrderInput | SortOrder
    patientId?: SortOrder
    patientWeight?: SortOrderInput | SortOrder
    specialNeeds?: SortOrderInput | SortOrder
    originFacilityId?: SortOrderInput | SortOrder
    destinationFacilityId?: SortOrderInput | SortOrder
    fromLocation?: SortOrderInput | SortOrder
    toLocation?: SortOrderInput | SortOrder
    fromLocationId?: SortOrderInput | SortOrder
    isMultiLocationFacility?: SortOrder
    scheduledTime?: SortOrderInput | SortOrder
    transportLevel?: SortOrder
    urgencyLevel?: SortOrderInput | SortOrder
    priority?: SortOrder
    status?: SortOrder
    specialRequirements?: SortOrderInput | SortOrder
    diagnosis?: SortOrderInput | SortOrder
    mobilityLevel?: SortOrderInput | SortOrder
    oxygenRequired?: SortOrder
    monitoringRequired?: SortOrder
    generateQRCode?: SortOrder
    qrCodeData?: SortOrderInput | SortOrder
    selectedAgencies?: SortOrder
    notificationRadius?: SortOrderInput | SortOrder
    requestTimestamp?: SortOrder
    acceptedTimestamp?: SortOrderInput | SortOrder
    pickupTimestamp?: SortOrderInput | SortOrder
    arrivalTimestamp?: SortOrderInput | SortOrder
    departureTimestamp?: SortOrderInput | SortOrder
    completionTimestamp?: SortOrderInput | SortOrder
    pickupLocationId?: SortOrderInput | SortOrder
    assignedAgencyId?: SortOrderInput | SortOrder
    assignedUnitId?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    healthcareCreatedById?: SortOrderInput | SortOrder
    isolation?: SortOrder
    bariatric?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    originFacility?: FacilityOrderByWithRelationInput
    destinationFacility?: FacilityOrderByWithRelationInput
    pickupLocation?: pickup_locationsOrderByWithRelationInput
    assignedUnit?: UnitOrderByWithRelationInput
    healthcareLocation?: HealthcareLocationOrderByWithRelationInput
  }

  export type TransportRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tripNumber?: string
    AND?: TransportRequestWhereInput | TransportRequestWhereInput[]
    OR?: TransportRequestWhereInput[]
    NOT?: TransportRequestWhereInput | TransportRequestWhereInput[]
    patientId?: StringFilter<"TransportRequest"> | string
    patientWeight?: StringNullableFilter<"TransportRequest"> | string | null
    specialNeeds?: StringNullableFilter<"TransportRequest"> | string | null
    originFacilityId?: StringNullableFilter<"TransportRequest"> | string | null
    destinationFacilityId?: StringNullableFilter<"TransportRequest"> | string | null
    fromLocation?: StringNullableFilter<"TransportRequest"> | string | null
    toLocation?: StringNullableFilter<"TransportRequest"> | string | null
    fromLocationId?: StringNullableFilter<"TransportRequest"> | string | null
    isMultiLocationFacility?: BoolFilter<"TransportRequest"> | boolean
    scheduledTime?: DateTimeNullableFilter<"TransportRequest"> | Date | string | null
    transportLevel?: StringFilter<"TransportRequest"> | string
    urgencyLevel?: StringNullableFilter<"TransportRequest"> | string | null
    priority?: StringFilter<"TransportRequest"> | string
    status?: StringFilter<"TransportRequest"> | string
    specialRequirements?: StringNullableFilter<"TransportRequest"> | string | null
    diagnosis?: StringNullableFilter<"TransportRequest"> | string | null
    mobilityLevel?: StringNullableFilter<"TransportRequest"> | string | null
    oxygenRequired?: BoolFilter<"TransportRequest"> | boolean
    monitoringRequired?: BoolFilter<"TransportRequest"> | boolean
    generateQRCode?: BoolFilter<"TransportRequest"> | boolean
    qrCodeData?: StringNullableFilter<"TransportRequest"> | string | null
    selectedAgencies?: StringNullableListFilter<"TransportRequest">
    notificationRadius?: IntNullableFilter<"TransportRequest"> | number | null
    requestTimestamp?: DateTimeFilter<"TransportRequest"> | Date | string
    acceptedTimestamp?: DateTimeNullableFilter<"TransportRequest"> | Date | string | null
    pickupTimestamp?: DateTimeNullableFilter<"TransportRequest"> | Date | string | null
    arrivalTimestamp?: DateTimeNullableFilter<"TransportRequest"> | Date | string | null
    departureTimestamp?: DateTimeNullableFilter<"TransportRequest"> | Date | string | null
    completionTimestamp?: DateTimeNullableFilter<"TransportRequest"> | Date | string | null
    pickupLocationId?: StringNullableFilter<"TransportRequest"> | string | null
    assignedAgencyId?: StringNullableFilter<"TransportRequest"> | string | null
    assignedUnitId?: StringNullableFilter<"TransportRequest"> | string | null
    createdById?: StringNullableFilter<"TransportRequest"> | string | null
    healthcareCreatedById?: StringNullableFilter<"TransportRequest"> | string | null
    isolation?: BoolFilter<"TransportRequest"> | boolean
    bariatric?: BoolFilter<"TransportRequest"> | boolean
    notes?: StringNullableFilter<"TransportRequest"> | string | null
    createdAt?: DateTimeFilter<"TransportRequest"> | Date | string
    updatedAt?: DateTimeFilter<"TransportRequest"> | Date | string
    originFacility?: XOR<FacilityNullableRelationFilter, FacilityWhereInput> | null
    destinationFacility?: XOR<FacilityNullableRelationFilter, FacilityWhereInput> | null
    pickupLocation?: XOR<Pickup_locationsNullableRelationFilter, pickup_locationsWhereInput> | null
    assignedUnit?: XOR<UnitNullableRelationFilter, UnitWhereInput> | null
    healthcareLocation?: XOR<HealthcareLocationNullableRelationFilter, HealthcareLocationWhereInput> | null
  }, "id" | "tripNumber">

  export type TransportRequestOrderByWithAggregationInput = {
    id?: SortOrder
    tripNumber?: SortOrderInput | SortOrder
    patientId?: SortOrder
    patientWeight?: SortOrderInput | SortOrder
    specialNeeds?: SortOrderInput | SortOrder
    originFacilityId?: SortOrderInput | SortOrder
    destinationFacilityId?: SortOrderInput | SortOrder
    fromLocation?: SortOrderInput | SortOrder
    toLocation?: SortOrderInput | SortOrder
    fromLocationId?: SortOrderInput | SortOrder
    isMultiLocationFacility?: SortOrder
    scheduledTime?: SortOrderInput | SortOrder
    transportLevel?: SortOrder
    urgencyLevel?: SortOrderInput | SortOrder
    priority?: SortOrder
    status?: SortOrder
    specialRequirements?: SortOrderInput | SortOrder
    diagnosis?: SortOrderInput | SortOrder
    mobilityLevel?: SortOrderInput | SortOrder
    oxygenRequired?: SortOrder
    monitoringRequired?: SortOrder
    generateQRCode?: SortOrder
    qrCodeData?: SortOrderInput | SortOrder
    selectedAgencies?: SortOrder
    notificationRadius?: SortOrderInput | SortOrder
    requestTimestamp?: SortOrder
    acceptedTimestamp?: SortOrderInput | SortOrder
    pickupTimestamp?: SortOrderInput | SortOrder
    arrivalTimestamp?: SortOrderInput | SortOrder
    departureTimestamp?: SortOrderInput | SortOrder
    completionTimestamp?: SortOrderInput | SortOrder
    pickupLocationId?: SortOrderInput | SortOrder
    assignedAgencyId?: SortOrderInput | SortOrder
    assignedUnitId?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    healthcareCreatedById?: SortOrderInput | SortOrder
    isolation?: SortOrder
    bariatric?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TransportRequestCountOrderByAggregateInput
    _avg?: TransportRequestAvgOrderByAggregateInput
    _max?: TransportRequestMaxOrderByAggregateInput
    _min?: TransportRequestMinOrderByAggregateInput
    _sum?: TransportRequestSumOrderByAggregateInput
  }

  export type TransportRequestScalarWhereWithAggregatesInput = {
    AND?: TransportRequestScalarWhereWithAggregatesInput | TransportRequestScalarWhereWithAggregatesInput[]
    OR?: TransportRequestScalarWhereWithAggregatesInput[]
    NOT?: TransportRequestScalarWhereWithAggregatesInput | TransportRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TransportRequest"> | string
    tripNumber?: StringNullableWithAggregatesFilter<"TransportRequest"> | string | null
    patientId?: StringWithAggregatesFilter<"TransportRequest"> | string
    patientWeight?: StringNullableWithAggregatesFilter<"TransportRequest"> | string | null
    specialNeeds?: StringNullableWithAggregatesFilter<"TransportRequest"> | string | null
    originFacilityId?: StringNullableWithAggregatesFilter<"TransportRequest"> | string | null
    destinationFacilityId?: StringNullableWithAggregatesFilter<"TransportRequest"> | string | null
    fromLocation?: StringNullableWithAggregatesFilter<"TransportRequest"> | string | null
    toLocation?: StringNullableWithAggregatesFilter<"TransportRequest"> | string | null
    fromLocationId?: StringNullableWithAggregatesFilter<"TransportRequest"> | string | null
    isMultiLocationFacility?: BoolWithAggregatesFilter<"TransportRequest"> | boolean
    scheduledTime?: DateTimeNullableWithAggregatesFilter<"TransportRequest"> | Date | string | null
    transportLevel?: StringWithAggregatesFilter<"TransportRequest"> | string
    urgencyLevel?: StringNullableWithAggregatesFilter<"TransportRequest"> | string | null
    priority?: StringWithAggregatesFilter<"TransportRequest"> | string
    status?: StringWithAggregatesFilter<"TransportRequest"> | string
    specialRequirements?: StringNullableWithAggregatesFilter<"TransportRequest"> | string | null
    diagnosis?: StringNullableWithAggregatesFilter<"TransportRequest"> | string | null
    mobilityLevel?: StringNullableWithAggregatesFilter<"TransportRequest"> | string | null
    oxygenRequired?: BoolWithAggregatesFilter<"TransportRequest"> | boolean
    monitoringRequired?: BoolWithAggregatesFilter<"TransportRequest"> | boolean
    generateQRCode?: BoolWithAggregatesFilter<"TransportRequest"> | boolean
    qrCodeData?: StringNullableWithAggregatesFilter<"TransportRequest"> | string | null
    selectedAgencies?: StringNullableListFilter<"TransportRequest">
    notificationRadius?: IntNullableWithAggregatesFilter<"TransportRequest"> | number | null
    requestTimestamp?: DateTimeWithAggregatesFilter<"TransportRequest"> | Date | string
    acceptedTimestamp?: DateTimeNullableWithAggregatesFilter<"TransportRequest"> | Date | string | null
    pickupTimestamp?: DateTimeNullableWithAggregatesFilter<"TransportRequest"> | Date | string | null
    arrivalTimestamp?: DateTimeNullableWithAggregatesFilter<"TransportRequest"> | Date | string | null
    departureTimestamp?: DateTimeNullableWithAggregatesFilter<"TransportRequest"> | Date | string | null
    completionTimestamp?: DateTimeNullableWithAggregatesFilter<"TransportRequest"> | Date | string | null
    pickupLocationId?: StringNullableWithAggregatesFilter<"TransportRequest"> | string | null
    assignedAgencyId?: StringNullableWithAggregatesFilter<"TransportRequest"> | string | null
    assignedUnitId?: StringNullableWithAggregatesFilter<"TransportRequest"> | string | null
    createdById?: StringNullableWithAggregatesFilter<"TransportRequest"> | string | null
    healthcareCreatedById?: StringNullableWithAggregatesFilter<"TransportRequest"> | string | null
    isolation?: BoolWithAggregatesFilter<"TransportRequest"> | boolean
    bariatric?: BoolWithAggregatesFilter<"TransportRequest"> | boolean
    notes?: StringNullableWithAggregatesFilter<"TransportRequest"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TransportRequest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TransportRequest"> | Date | string
  }

  export type FacilityWhereInput = {
    AND?: FacilityWhereInput | FacilityWhereInput[]
    OR?: FacilityWhereInput[]
    NOT?: FacilityWhereInput | FacilityWhereInput[]
    id?: StringFilter<"Facility"> | string
    name?: StringFilter<"Facility"> | string
    address?: StringFilter<"Facility"> | string
    city?: StringFilter<"Facility"> | string
    state?: StringFilter<"Facility"> | string
    zipCode?: StringFilter<"Facility"> | string
    phone?: StringNullableFilter<"Facility"> | string | null
    email?: StringNullableFilter<"Facility"> | string | null
    type?: StringFilter<"Facility"> | string
    capabilities?: StringNullableListFilter<"Facility">
    region?: StringFilter<"Facility"> | string
    coordinates?: JsonNullableFilter<"Facility">
    latitude?: FloatNullableFilter<"Facility"> | number | null
    longitude?: FloatNullableFilter<"Facility"> | number | null
    operatingHours?: StringNullableFilter<"Facility"> | string | null
    isActive?: BoolFilter<"Facility"> | boolean
    requiresReview?: BoolFilter<"Facility"> | boolean
    approvedAt?: DateTimeNullableFilter<"Facility"> | Date | string | null
    approvedBy?: StringNullableFilter<"Facility"> | string | null
    createdAt?: DateTimeFilter<"Facility"> | Date | string
    updatedAt?: DateTimeFilter<"Facility"> | Date | string
    originTrips?: TransportRequestListRelationFilter
    destinationTrips?: TransportRequestListRelationFilter
  }

  export type FacilityOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    type?: SortOrder
    capabilities?: SortOrder
    region?: SortOrder
    coordinates?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    operatingHours?: SortOrderInput | SortOrder
    isActive?: SortOrder
    requiresReview?: SortOrder
    approvedAt?: SortOrderInput | SortOrder
    approvedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    originTrips?: TransportRequestOrderByRelationAggregateInput
    destinationTrips?: TransportRequestOrderByRelationAggregateInput
  }

  export type FacilityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FacilityWhereInput | FacilityWhereInput[]
    OR?: FacilityWhereInput[]
    NOT?: FacilityWhereInput | FacilityWhereInput[]
    name?: StringFilter<"Facility"> | string
    address?: StringFilter<"Facility"> | string
    city?: StringFilter<"Facility"> | string
    state?: StringFilter<"Facility"> | string
    zipCode?: StringFilter<"Facility"> | string
    phone?: StringNullableFilter<"Facility"> | string | null
    email?: StringNullableFilter<"Facility"> | string | null
    type?: StringFilter<"Facility"> | string
    capabilities?: StringNullableListFilter<"Facility">
    region?: StringFilter<"Facility"> | string
    coordinates?: JsonNullableFilter<"Facility">
    latitude?: FloatNullableFilter<"Facility"> | number | null
    longitude?: FloatNullableFilter<"Facility"> | number | null
    operatingHours?: StringNullableFilter<"Facility"> | string | null
    isActive?: BoolFilter<"Facility"> | boolean
    requiresReview?: BoolFilter<"Facility"> | boolean
    approvedAt?: DateTimeNullableFilter<"Facility"> | Date | string | null
    approvedBy?: StringNullableFilter<"Facility"> | string | null
    createdAt?: DateTimeFilter<"Facility"> | Date | string
    updatedAt?: DateTimeFilter<"Facility"> | Date | string
    originTrips?: TransportRequestListRelationFilter
    destinationTrips?: TransportRequestListRelationFilter
  }, "id">

  export type FacilityOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    type?: SortOrder
    capabilities?: SortOrder
    region?: SortOrder
    coordinates?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    operatingHours?: SortOrderInput | SortOrder
    isActive?: SortOrder
    requiresReview?: SortOrder
    approvedAt?: SortOrderInput | SortOrder
    approvedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FacilityCountOrderByAggregateInput
    _avg?: FacilityAvgOrderByAggregateInput
    _max?: FacilityMaxOrderByAggregateInput
    _min?: FacilityMinOrderByAggregateInput
    _sum?: FacilitySumOrderByAggregateInput
  }

  export type FacilityScalarWhereWithAggregatesInput = {
    AND?: FacilityScalarWhereWithAggregatesInput | FacilityScalarWhereWithAggregatesInput[]
    OR?: FacilityScalarWhereWithAggregatesInput[]
    NOT?: FacilityScalarWhereWithAggregatesInput | FacilityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Facility"> | string
    name?: StringWithAggregatesFilter<"Facility"> | string
    address?: StringWithAggregatesFilter<"Facility"> | string
    city?: StringWithAggregatesFilter<"Facility"> | string
    state?: StringWithAggregatesFilter<"Facility"> | string
    zipCode?: StringWithAggregatesFilter<"Facility"> | string
    phone?: StringNullableWithAggregatesFilter<"Facility"> | string | null
    email?: StringNullableWithAggregatesFilter<"Facility"> | string | null
    type?: StringWithAggregatesFilter<"Facility"> | string
    capabilities?: StringNullableListFilter<"Facility">
    region?: StringWithAggregatesFilter<"Facility"> | string
    coordinates?: JsonNullableWithAggregatesFilter<"Facility">
    latitude?: FloatNullableWithAggregatesFilter<"Facility"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"Facility"> | number | null
    operatingHours?: StringNullableWithAggregatesFilter<"Facility"> | string | null
    isActive?: BoolWithAggregatesFilter<"Facility"> | boolean
    requiresReview?: BoolWithAggregatesFilter<"Facility"> | boolean
    approvedAt?: DateTimeNullableWithAggregatesFilter<"Facility"> | Date | string | null
    approvedBy?: StringNullableWithAggregatesFilter<"Facility"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Facility"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Facility"> | Date | string
  }

  export type CenterUserCreateInput = {
    id?: string
    email: string
    password: string
    name: string
    userType: string
    phone?: string | null
    emailNotifications?: boolean
    smsNotifications?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    notificationLogs?: NotificationLogCreateNestedManyWithoutUserInput
    notificationPreferences?: NotificationPreferenceCreateNestedManyWithoutUserInput
  }

  export type CenterUserUncheckedCreateInput = {
    id?: string
    email: string
    password: string
    name: string
    userType: string
    phone?: string | null
    emailNotifications?: boolean
    smsNotifications?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    notificationLogs?: NotificationLogUncheckedCreateNestedManyWithoutUserInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
  }

  export type CenterUserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    smsNotifications?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notificationLogs?: NotificationLogUpdateManyWithoutUserNestedInput
    notificationPreferences?: NotificationPreferenceUpdateManyWithoutUserNestedInput
  }

  export type CenterUserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    smsNotifications?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notificationLogs?: NotificationLogUncheckedUpdateManyWithoutUserNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CenterUserCreateManyInput = {
    id?: string
    email: string
    password: string
    name: string
    userType: string
    phone?: string | null
    emailNotifications?: boolean
    smsNotifications?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CenterUserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    smsNotifications?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CenterUserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    smsNotifications?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HealthcareUserCreateInput = {
    id?: string
    email: string
    password: string
    name: string
    facilityName: string
    facilityType: string
    userType?: string
    isActive?: boolean
    manageMultipleLocations?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: HealthcareLocationCreateNestedManyWithoutHealthcareUserInput
  }

  export type HealthcareUserUncheckedCreateInput = {
    id?: string
    email: string
    password: string
    name: string
    facilityName: string
    facilityType: string
    userType?: string
    isActive?: boolean
    manageMultipleLocations?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: HealthcareLocationUncheckedCreateNestedManyWithoutHealthcareUserInput
  }

  export type HealthcareUserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    facilityName?: StringFieldUpdateOperationsInput | string
    facilityType?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    manageMultipleLocations?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: HealthcareLocationUpdateManyWithoutHealthcareUserNestedInput
  }

  export type HealthcareUserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    facilityName?: StringFieldUpdateOperationsInput | string
    facilityType?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    manageMultipleLocations?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: HealthcareLocationUncheckedUpdateManyWithoutHealthcareUserNestedInput
  }

  export type HealthcareUserCreateManyInput = {
    id?: string
    email: string
    password: string
    name: string
    facilityName: string
    facilityType: string
    userType?: string
    isActive?: boolean
    manageMultipleLocations?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HealthcareUserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    facilityName?: StringFieldUpdateOperationsInput | string
    facilityType?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    manageMultipleLocations?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HealthcareUserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    facilityName?: StringFieldUpdateOperationsInput | string
    facilityType?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    manageMultipleLocations?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HealthcareLocationCreateInput = {
    id?: string
    locationName: string
    address: string
    city: string
    state: string
    zipCode: string
    phone?: string | null
    facilityType: string
    isActive?: boolean
    isPrimary?: boolean
    latitude?: number | null
    longitude?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    healthcareUser: HealthcareUserCreateNestedOneWithoutLocationsInput
    transportRequests?: TransportRequestCreateNestedManyWithoutHealthcareLocationInput
  }

  export type HealthcareLocationUncheckedCreateInput = {
    id?: string
    healthcareUserId: string
    locationName: string
    address: string
    city: string
    state: string
    zipCode: string
    phone?: string | null
    facilityType: string
    isActive?: boolean
    isPrimary?: boolean
    latitude?: number | null
    longitude?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transportRequests?: TransportRequestUncheckedCreateNestedManyWithoutHealthcareLocationInput
  }

  export type HealthcareLocationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    facilityType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    healthcareUser?: HealthcareUserUpdateOneRequiredWithoutLocationsNestedInput
    transportRequests?: TransportRequestUpdateManyWithoutHealthcareLocationNestedInput
  }

  export type HealthcareLocationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    healthcareUserId?: StringFieldUpdateOperationsInput | string
    locationName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    facilityType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transportRequests?: TransportRequestUncheckedUpdateManyWithoutHealthcareLocationNestedInput
  }

  export type HealthcareLocationCreateManyInput = {
    id?: string
    healthcareUserId: string
    locationName: string
    address: string
    city: string
    state: string
    zipCode: string
    phone?: string | null
    facilityType: string
    isActive?: boolean
    isPrimary?: boolean
    latitude?: number | null
    longitude?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HealthcareLocationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    facilityType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HealthcareLocationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    healthcareUserId?: StringFieldUpdateOperationsInput | string
    locationName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    facilityType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HospitalCreateInput = {
    id?: string
    name: string
    address: string
    city: string
    state: string
    zipCode: string
    phone?: string | null
    email?: string | null
    type: string
    capabilities?: HospitalCreatecapabilitiesInput | string[]
    region: string
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    latitude?: number | null
    longitude?: number | null
    operatingHours?: string | null
    isActive?: boolean
    requiresReview?: boolean
    approvedAt?: Date | string | null
    approvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HospitalUncheckedCreateInput = {
    id?: string
    name: string
    address: string
    city: string
    state: string
    zipCode: string
    phone?: string | null
    email?: string | null
    type: string
    capabilities?: HospitalCreatecapabilitiesInput | string[]
    region: string
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    latitude?: number | null
    longitude?: number | null
    operatingHours?: string | null
    isActive?: boolean
    requiresReview?: boolean
    approvedAt?: Date | string | null
    approvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HospitalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    capabilities?: HospitalUpdatecapabilitiesInput | string[]
    region?: StringFieldUpdateOperationsInput | string
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    operatingHours?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requiresReview?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HospitalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    capabilities?: HospitalUpdatecapabilitiesInput | string[]
    region?: StringFieldUpdateOperationsInput | string
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    operatingHours?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requiresReview?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HospitalCreateManyInput = {
    id?: string
    name: string
    address: string
    city: string
    state: string
    zipCode: string
    phone?: string | null
    email?: string | null
    type: string
    capabilities?: HospitalCreatecapabilitiesInput | string[]
    region: string
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    latitude?: number | null
    longitude?: number | null
    operatingHours?: string | null
    isActive?: boolean
    requiresReview?: boolean
    approvedAt?: Date | string | null
    approvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HospitalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    capabilities?: HospitalUpdatecapabilitiesInput | string[]
    region?: StringFieldUpdateOperationsInput | string
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    operatingHours?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requiresReview?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HospitalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    capabilities?: HospitalUpdatecapabilitiesInput | string[]
    region?: StringFieldUpdateOperationsInput | string
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    operatingHours?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requiresReview?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EMSUserCreateInput = {
    id?: string
    email: string
    password: string
    name: string
    agencyName: string
    isActive?: boolean
    userType?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    agency?: EMSAgencyCreateNestedOneWithoutUsersInput
  }

  export type EMSUserUncheckedCreateInput = {
    id?: string
    email: string
    password: string
    name: string
    agencyName: string
    agencyId?: string | null
    isActive?: boolean
    userType?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EMSUserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    agencyName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    userType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agency?: EMSAgencyUpdateOneWithoutUsersNestedInput
  }

  export type EMSUserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    agencyName?: StringFieldUpdateOperationsInput | string
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    userType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EMSUserCreateManyInput = {
    id?: string
    email: string
    password: string
    name: string
    agencyName: string
    agencyId?: string | null
    isActive?: boolean
    userType?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EMSUserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    agencyName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    userType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EMSUserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    agencyName?: StringFieldUpdateOperationsInput | string
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    userType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EMSAgencyCreateInput = {
    id?: string
    name: string
    contactName: string
    phone: string
    email: string
    address: string
    city: string
    state: string
    zipCode: string
    serviceArea?: EMSAgencyCreateserviceAreaInput | string[]
    operatingHours?: NullableJsonNullValueInput | InputJsonValue
    capabilities?: EMSAgencyCreatecapabilitiesInput | string[]
    pricingStructure?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    status?: string
    addedBy?: string | null
    addedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    acceptsNotifications?: boolean
    approvedAt?: Date | string | null
    approvedBy?: string | null
    availableUnits?: number
    lastUpdated?: Date | string
    latitude?: number | null
    longitude?: number | null
    notificationMethods?: EMSAgencyCreatenotificationMethodsInput | string[]
    requiresReview?: boolean
    serviceRadius?: number | null
    totalUnits?: number
    units?: UnitCreateNestedManyWithoutAgencyInput
    users?: EMSUserCreateNestedManyWithoutAgencyInput
  }

  export type EMSAgencyUncheckedCreateInput = {
    id?: string
    name: string
    contactName: string
    phone: string
    email: string
    address: string
    city: string
    state: string
    zipCode: string
    serviceArea?: EMSAgencyCreateserviceAreaInput | string[]
    operatingHours?: NullableJsonNullValueInput | InputJsonValue
    capabilities?: EMSAgencyCreatecapabilitiesInput | string[]
    pricingStructure?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    status?: string
    addedBy?: string | null
    addedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    acceptsNotifications?: boolean
    approvedAt?: Date | string | null
    approvedBy?: string | null
    availableUnits?: number
    lastUpdated?: Date | string
    latitude?: number | null
    longitude?: number | null
    notificationMethods?: EMSAgencyCreatenotificationMethodsInput | string[]
    requiresReview?: boolean
    serviceRadius?: number | null
    totalUnits?: number
    units?: UnitUncheckedCreateNestedManyWithoutAgencyInput
    users?: EMSUserUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type EMSAgencyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    serviceArea?: EMSAgencyUpdateserviceAreaInput | string[]
    operatingHours?: NullableJsonNullValueInput | InputJsonValue
    capabilities?: EMSAgencyUpdatecapabilitiesInput | string[]
    pricingStructure?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    addedBy?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptsNotifications?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    availableUnits?: IntFieldUpdateOperationsInput | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    notificationMethods?: EMSAgencyUpdatenotificationMethodsInput | string[]
    requiresReview?: BoolFieldUpdateOperationsInput | boolean
    serviceRadius?: NullableIntFieldUpdateOperationsInput | number | null
    totalUnits?: IntFieldUpdateOperationsInput | number
    units?: UnitUpdateManyWithoutAgencyNestedInput
    users?: EMSUserUpdateManyWithoutAgencyNestedInput
  }

  export type EMSAgencyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    serviceArea?: EMSAgencyUpdateserviceAreaInput | string[]
    operatingHours?: NullableJsonNullValueInput | InputJsonValue
    capabilities?: EMSAgencyUpdatecapabilitiesInput | string[]
    pricingStructure?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    addedBy?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptsNotifications?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    availableUnits?: IntFieldUpdateOperationsInput | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    notificationMethods?: EMSAgencyUpdatenotificationMethodsInput | string[]
    requiresReview?: BoolFieldUpdateOperationsInput | boolean
    serviceRadius?: NullableIntFieldUpdateOperationsInput | number | null
    totalUnits?: IntFieldUpdateOperationsInput | number
    units?: UnitUncheckedUpdateManyWithoutAgencyNestedInput
    users?: EMSUserUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type EMSAgencyCreateManyInput = {
    id?: string
    name: string
    contactName: string
    phone: string
    email: string
    address: string
    city: string
    state: string
    zipCode: string
    serviceArea?: EMSAgencyCreateserviceAreaInput | string[]
    operatingHours?: NullableJsonNullValueInput | InputJsonValue
    capabilities?: EMSAgencyCreatecapabilitiesInput | string[]
    pricingStructure?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    status?: string
    addedBy?: string | null
    addedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    acceptsNotifications?: boolean
    approvedAt?: Date | string | null
    approvedBy?: string | null
    availableUnits?: number
    lastUpdated?: Date | string
    latitude?: number | null
    longitude?: number | null
    notificationMethods?: EMSAgencyCreatenotificationMethodsInput | string[]
    requiresReview?: boolean
    serviceRadius?: number | null
    totalUnits?: number
  }

  export type EMSAgencyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    serviceArea?: EMSAgencyUpdateserviceAreaInput | string[]
    operatingHours?: NullableJsonNullValueInput | InputJsonValue
    capabilities?: EMSAgencyUpdatecapabilitiesInput | string[]
    pricingStructure?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    addedBy?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptsNotifications?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    availableUnits?: IntFieldUpdateOperationsInput | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    notificationMethods?: EMSAgencyUpdatenotificationMethodsInput | string[]
    requiresReview?: BoolFieldUpdateOperationsInput | boolean
    serviceRadius?: NullableIntFieldUpdateOperationsInput | number | null
    totalUnits?: IntFieldUpdateOperationsInput | number
  }

  export type EMSAgencyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    serviceArea?: EMSAgencyUpdateserviceAreaInput | string[]
    operatingHours?: NullableJsonNullValueInput | InputJsonValue
    capabilities?: EMSAgencyUpdatecapabilitiesInput | string[]
    pricingStructure?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    addedBy?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptsNotifications?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    availableUnits?: IntFieldUpdateOperationsInput | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    notificationMethods?: EMSAgencyUpdatenotificationMethodsInput | string[]
    requiresReview?: BoolFieldUpdateOperationsInput | boolean
    serviceRadius?: NullableIntFieldUpdateOperationsInput | number | null
    totalUnits?: IntFieldUpdateOperationsInput | number
  }

  export type TripCreateInput = {
    id?: string
    tripNumber: string
    patientId: string
    patientWeight?: string | null
    specialNeeds?: string | null
    fromLocation: string
    toLocation: string
    scheduledTime: Date | string
    transportLevel: string
    urgencyLevel: string
    diagnosis?: string | null
    mobilityLevel?: string | null
    oxygenRequired?: boolean
    monitoringRequired?: boolean
    generateQRCode?: boolean
    qrCodeData?: string | null
    selectedAgencies?: TripCreateselectedAgenciesInput | string[]
    notificationRadius?: number | null
    transferRequestTime?: Date | string | null
    transferAcceptedTime?: Date | string | null
    emsArrivalTime?: Date | string | null
    emsDepartureTime?: Date | string | null
    actualStartTime?: Date | string | null
    actualEndTime?: Date | string | null
    status: string
    priority: string
    notes?: string | null
    assignedTo?: string | null
    assignedAgencyId?: string | null
    assignedUnitId?: string | null
    acceptedTimestamp?: Date | string | null
    pickupTimestamp?: Date | string | null
    completionTimestamp?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    actualTripTimeMinutes?: number | null
    backhaulOpportunity?: boolean
    completionTimeMinutes?: number | null
    customerSatisfaction?: number | null
    deadheadMiles?: number | null
    destinationLatitude?: number | null
    destinationLongitude?: number | null
    distanceMiles?: number | null
    efficiency?: Decimal | DecimalJsLike | number | string | null
    estimatedTripTimeMinutes?: number | null
    insuranceCompany?: string | null
    insurancePayRate?: Decimal | DecimalJsLike | number | string | null
    loadedMiles?: Decimal | DecimalJsLike | number | string | null
    originLatitude?: number | null
    originLongitude?: number | null
    perMileRate?: Decimal | DecimalJsLike | number | string | null
    performanceScore?: Decimal | DecimalJsLike | number | string | null
    requestTimestamp?: Date | string | null
    responseTimeMinutes?: number | null
    revenuePerHour?: Decimal | DecimalJsLike | number | string | null
    tripCost?: Decimal | DecimalJsLike | number | string | null
    maxResponses?: number
    responseDeadline?: Date | string | null
    responseStatus?: string
    selectionMode?: string
    agencyResponses?: AgencyResponseCreateNestedManyWithoutTripInput
    pickup_locations?: pickup_locationsCreateNestedOneWithoutLegacyTripsInput
  }

  export type TripUncheckedCreateInput = {
    id?: string
    tripNumber: string
    patientId: string
    patientWeight?: string | null
    specialNeeds?: string | null
    fromLocation: string
    toLocation: string
    scheduledTime: Date | string
    transportLevel: string
    urgencyLevel: string
    diagnosis?: string | null
    mobilityLevel?: string | null
    oxygenRequired?: boolean
    monitoringRequired?: boolean
    generateQRCode?: boolean
    qrCodeData?: string | null
    selectedAgencies?: TripCreateselectedAgenciesInput | string[]
    notificationRadius?: number | null
    transferRequestTime?: Date | string | null
    transferAcceptedTime?: Date | string | null
    emsArrivalTime?: Date | string | null
    emsDepartureTime?: Date | string | null
    actualStartTime?: Date | string | null
    actualEndTime?: Date | string | null
    status: string
    priority: string
    notes?: string | null
    assignedTo?: string | null
    assignedAgencyId?: string | null
    assignedUnitId?: string | null
    acceptedTimestamp?: Date | string | null
    pickupTimestamp?: Date | string | null
    completionTimestamp?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    actualTripTimeMinutes?: number | null
    backhaulOpportunity?: boolean
    completionTimeMinutes?: number | null
    customerSatisfaction?: number | null
    deadheadMiles?: number | null
    destinationLatitude?: number | null
    destinationLongitude?: number | null
    distanceMiles?: number | null
    efficiency?: Decimal | DecimalJsLike | number | string | null
    estimatedTripTimeMinutes?: number | null
    insuranceCompany?: string | null
    insurancePayRate?: Decimal | DecimalJsLike | number | string | null
    loadedMiles?: Decimal | DecimalJsLike | number | string | null
    originLatitude?: number | null
    originLongitude?: number | null
    perMileRate?: Decimal | DecimalJsLike | number | string | null
    performanceScore?: Decimal | DecimalJsLike | number | string | null
    requestTimestamp?: Date | string | null
    responseTimeMinutes?: number | null
    revenuePerHour?: Decimal | DecimalJsLike | number | string | null
    tripCost?: Decimal | DecimalJsLike | number | string | null
    pickupLocationId?: string | null
    maxResponses?: number
    responseDeadline?: Date | string | null
    responseStatus?: string
    selectionMode?: string
    agencyResponses?: AgencyResponseUncheckedCreateNestedManyWithoutTripInput
  }

  export type TripUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripNumber?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    patientWeight?: NullableStringFieldUpdateOperationsInput | string | null
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocation?: StringFieldUpdateOperationsInput | string
    toLocation?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    transportLevel?: StringFieldUpdateOperationsInput | string
    urgencyLevel?: StringFieldUpdateOperationsInput | string
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    mobilityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    oxygenRequired?: BoolFieldUpdateOperationsInput | boolean
    monitoringRequired?: BoolFieldUpdateOperationsInput | boolean
    generateQRCode?: BoolFieldUpdateOperationsInput | boolean
    qrCodeData?: NullableStringFieldUpdateOperationsInput | string | null
    selectedAgencies?: TripUpdateselectedAgenciesInput | string[]
    notificationRadius?: NullableIntFieldUpdateOperationsInput | number | null
    transferRequestTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferAcceptedTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emsArrivalTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emsDepartureTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAgencyId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actualTripTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    backhaulOpportunity?: BoolFieldUpdateOperationsInput | boolean
    completionTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    customerSatisfaction?: NullableIntFieldUpdateOperationsInput | number | null
    deadheadMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    distanceMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    efficiency?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    estimatedTripTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    insuranceCompany?: NullableStringFieldUpdateOperationsInput | string | null
    insurancePayRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loadedMiles?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    originLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    perMileRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    performanceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    requestTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    revenuePerHour?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tripCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxResponses?: IntFieldUpdateOperationsInput | number
    responseDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseStatus?: StringFieldUpdateOperationsInput | string
    selectionMode?: StringFieldUpdateOperationsInput | string
    agencyResponses?: AgencyResponseUpdateManyWithoutTripNestedInput
    pickup_locations?: pickup_locationsUpdateOneWithoutLegacyTripsNestedInput
  }

  export type TripUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripNumber?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    patientWeight?: NullableStringFieldUpdateOperationsInput | string | null
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocation?: StringFieldUpdateOperationsInput | string
    toLocation?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    transportLevel?: StringFieldUpdateOperationsInput | string
    urgencyLevel?: StringFieldUpdateOperationsInput | string
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    mobilityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    oxygenRequired?: BoolFieldUpdateOperationsInput | boolean
    monitoringRequired?: BoolFieldUpdateOperationsInput | boolean
    generateQRCode?: BoolFieldUpdateOperationsInput | boolean
    qrCodeData?: NullableStringFieldUpdateOperationsInput | string | null
    selectedAgencies?: TripUpdateselectedAgenciesInput | string[]
    notificationRadius?: NullableIntFieldUpdateOperationsInput | number | null
    transferRequestTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferAcceptedTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emsArrivalTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emsDepartureTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAgencyId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actualTripTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    backhaulOpportunity?: BoolFieldUpdateOperationsInput | boolean
    completionTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    customerSatisfaction?: NullableIntFieldUpdateOperationsInput | number | null
    deadheadMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    distanceMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    efficiency?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    estimatedTripTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    insuranceCompany?: NullableStringFieldUpdateOperationsInput | string | null
    insurancePayRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loadedMiles?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    originLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    perMileRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    performanceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    requestTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    revenuePerHour?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tripCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pickupLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    maxResponses?: IntFieldUpdateOperationsInput | number
    responseDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseStatus?: StringFieldUpdateOperationsInput | string
    selectionMode?: StringFieldUpdateOperationsInput | string
    agencyResponses?: AgencyResponseUncheckedUpdateManyWithoutTripNestedInput
  }

  export type TripCreateManyInput = {
    id?: string
    tripNumber: string
    patientId: string
    patientWeight?: string | null
    specialNeeds?: string | null
    fromLocation: string
    toLocation: string
    scheduledTime: Date | string
    transportLevel: string
    urgencyLevel: string
    diagnosis?: string | null
    mobilityLevel?: string | null
    oxygenRequired?: boolean
    monitoringRequired?: boolean
    generateQRCode?: boolean
    qrCodeData?: string | null
    selectedAgencies?: TripCreateselectedAgenciesInput | string[]
    notificationRadius?: number | null
    transferRequestTime?: Date | string | null
    transferAcceptedTime?: Date | string | null
    emsArrivalTime?: Date | string | null
    emsDepartureTime?: Date | string | null
    actualStartTime?: Date | string | null
    actualEndTime?: Date | string | null
    status: string
    priority: string
    notes?: string | null
    assignedTo?: string | null
    assignedAgencyId?: string | null
    assignedUnitId?: string | null
    acceptedTimestamp?: Date | string | null
    pickupTimestamp?: Date | string | null
    completionTimestamp?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    actualTripTimeMinutes?: number | null
    backhaulOpportunity?: boolean
    completionTimeMinutes?: number | null
    customerSatisfaction?: number | null
    deadheadMiles?: number | null
    destinationLatitude?: number | null
    destinationLongitude?: number | null
    distanceMiles?: number | null
    efficiency?: Decimal | DecimalJsLike | number | string | null
    estimatedTripTimeMinutes?: number | null
    insuranceCompany?: string | null
    insurancePayRate?: Decimal | DecimalJsLike | number | string | null
    loadedMiles?: Decimal | DecimalJsLike | number | string | null
    originLatitude?: number | null
    originLongitude?: number | null
    perMileRate?: Decimal | DecimalJsLike | number | string | null
    performanceScore?: Decimal | DecimalJsLike | number | string | null
    requestTimestamp?: Date | string | null
    responseTimeMinutes?: number | null
    revenuePerHour?: Decimal | DecimalJsLike | number | string | null
    tripCost?: Decimal | DecimalJsLike | number | string | null
    pickupLocationId?: string | null
    maxResponses?: number
    responseDeadline?: Date | string | null
    responseStatus?: string
    selectionMode?: string
  }

  export type TripUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripNumber?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    patientWeight?: NullableStringFieldUpdateOperationsInput | string | null
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocation?: StringFieldUpdateOperationsInput | string
    toLocation?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    transportLevel?: StringFieldUpdateOperationsInput | string
    urgencyLevel?: StringFieldUpdateOperationsInput | string
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    mobilityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    oxygenRequired?: BoolFieldUpdateOperationsInput | boolean
    monitoringRequired?: BoolFieldUpdateOperationsInput | boolean
    generateQRCode?: BoolFieldUpdateOperationsInput | boolean
    qrCodeData?: NullableStringFieldUpdateOperationsInput | string | null
    selectedAgencies?: TripUpdateselectedAgenciesInput | string[]
    notificationRadius?: NullableIntFieldUpdateOperationsInput | number | null
    transferRequestTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferAcceptedTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emsArrivalTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emsDepartureTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAgencyId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actualTripTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    backhaulOpportunity?: BoolFieldUpdateOperationsInput | boolean
    completionTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    customerSatisfaction?: NullableIntFieldUpdateOperationsInput | number | null
    deadheadMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    distanceMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    efficiency?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    estimatedTripTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    insuranceCompany?: NullableStringFieldUpdateOperationsInput | string | null
    insurancePayRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loadedMiles?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    originLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    perMileRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    performanceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    requestTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    revenuePerHour?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tripCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxResponses?: IntFieldUpdateOperationsInput | number
    responseDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseStatus?: StringFieldUpdateOperationsInput | string
    selectionMode?: StringFieldUpdateOperationsInput | string
  }

  export type TripUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripNumber?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    patientWeight?: NullableStringFieldUpdateOperationsInput | string | null
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocation?: StringFieldUpdateOperationsInput | string
    toLocation?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    transportLevel?: StringFieldUpdateOperationsInput | string
    urgencyLevel?: StringFieldUpdateOperationsInput | string
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    mobilityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    oxygenRequired?: BoolFieldUpdateOperationsInput | boolean
    monitoringRequired?: BoolFieldUpdateOperationsInput | boolean
    generateQRCode?: BoolFieldUpdateOperationsInput | boolean
    qrCodeData?: NullableStringFieldUpdateOperationsInput | string | null
    selectedAgencies?: TripUpdateselectedAgenciesInput | string[]
    notificationRadius?: NullableIntFieldUpdateOperationsInput | number | null
    transferRequestTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferAcceptedTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emsArrivalTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emsDepartureTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAgencyId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actualTripTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    backhaulOpportunity?: BoolFieldUpdateOperationsInput | boolean
    completionTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    customerSatisfaction?: NullableIntFieldUpdateOperationsInput | number | null
    deadheadMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    distanceMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    efficiency?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    estimatedTripTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    insuranceCompany?: NullableStringFieldUpdateOperationsInput | string | null
    insurancePayRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loadedMiles?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    originLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    perMileRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    performanceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    requestTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    revenuePerHour?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tripCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pickupLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    maxResponses?: IntFieldUpdateOperationsInput | number
    responseDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseStatus?: StringFieldUpdateOperationsInput | string
    selectionMode?: StringFieldUpdateOperationsInput | string
  }

  export type AgencyResponseCreateInput = {
    id?: string
    agencyId: string
    response: string
    responseTimestamp?: Date | string
    responseNotes?: string | null
    estimatedArrival?: Date | string | null
    isSelected?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    trip: TripCreateNestedOneWithoutAgencyResponsesInput
  }

  export type AgencyResponseUncheckedCreateInput = {
    id?: string
    tripId: string
    agencyId: string
    response: string
    responseTimestamp?: Date | string
    responseNotes?: string | null
    estimatedArrival?: Date | string | null
    isSelected?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgencyResponseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    responseTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    responseNotes?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedArrival?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trip?: TripUpdateOneRequiredWithoutAgencyResponsesNestedInput
  }

  export type AgencyResponseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    responseTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    responseNotes?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedArrival?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyResponseCreateManyInput = {
    id?: string
    tripId: string
    agencyId: string
    response: string
    responseTimestamp?: Date | string
    responseNotes?: string | null
    estimatedArrival?: Date | string | null
    isSelected?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgencyResponseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    responseTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    responseNotes?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedArrival?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyResponseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    responseTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    responseNotes?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedArrival?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemAnalyticsCreateInput = {
    id?: string
    metricName: string
    metricValue: JsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    userId?: string | null
    createdAt?: Date | string
  }

  export type SystemAnalyticsUncheckedCreateInput = {
    id?: string
    metricName: string
    metricValue: JsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    userId?: string | null
    createdAt?: Date | string
  }

  export type SystemAnalyticsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    metricName?: StringFieldUpdateOperationsInput | string
    metricValue?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemAnalyticsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    metricName?: StringFieldUpdateOperationsInput | string
    metricValue?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemAnalyticsCreateManyInput = {
    id?: string
    metricName: string
    metricValue: JsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    userId?: string | null
    createdAt?: Date | string
  }

  export type SystemAnalyticsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    metricName?: StringFieldUpdateOperationsInput | string
    metricValue?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemAnalyticsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    metricName?: StringFieldUpdateOperationsInput | string
    metricValue?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TripCostBreakdownCreateInput = {
    id?: string
    tripId: string
    baseRevenue: Decimal | DecimalJsLike | number | string
    mileageRevenue: Decimal | DecimalJsLike | number | string
    priorityRevenue: Decimal | DecimalJsLike | number | string
    specialRequirementsRevenue: Decimal | DecimalJsLike | number | string
    insuranceAdjustment: Decimal | DecimalJsLike | number | string
    totalRevenue: Decimal | DecimalJsLike | number | string
    crewLaborCost: Decimal | DecimalJsLike | number | string
    vehicleCost: Decimal | DecimalJsLike | number | string
    fuelCost: Decimal | DecimalJsLike | number | string
    maintenanceCost: Decimal | DecimalJsLike | number | string
    overheadCost: Decimal | DecimalJsLike | number | string
    totalCost: Decimal | DecimalJsLike | number | string
    grossProfit: Decimal | DecimalJsLike | number | string
    profitMargin: Decimal | DecimalJsLike | number | string
    revenuePerMile: Decimal | DecimalJsLike | number | string
    costPerMile: Decimal | DecimalJsLike | number | string
    loadedMileRatio: Decimal | DecimalJsLike | number | string
    deadheadMileRatio: Decimal | DecimalJsLike | number | string
    utilizationRate: Decimal | DecimalJsLike | number | string
    tripDistance: Decimal | DecimalJsLike | number | string
    loadedMiles: Decimal | DecimalJsLike | number | string
    deadheadMiles: Decimal | DecimalJsLike | number | string
    tripDurationHours: Decimal | DecimalJsLike | number | string
    transportLevel: string
    priorityLevel: string
    costCenterId?: string | null
    costCenterName?: string | null
    calculatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TripCostBreakdownUncheckedCreateInput = {
    id?: string
    tripId: string
    baseRevenue: Decimal | DecimalJsLike | number | string
    mileageRevenue: Decimal | DecimalJsLike | number | string
    priorityRevenue: Decimal | DecimalJsLike | number | string
    specialRequirementsRevenue: Decimal | DecimalJsLike | number | string
    insuranceAdjustment: Decimal | DecimalJsLike | number | string
    totalRevenue: Decimal | DecimalJsLike | number | string
    crewLaborCost: Decimal | DecimalJsLike | number | string
    vehicleCost: Decimal | DecimalJsLike | number | string
    fuelCost: Decimal | DecimalJsLike | number | string
    maintenanceCost: Decimal | DecimalJsLike | number | string
    overheadCost: Decimal | DecimalJsLike | number | string
    totalCost: Decimal | DecimalJsLike | number | string
    grossProfit: Decimal | DecimalJsLike | number | string
    profitMargin: Decimal | DecimalJsLike | number | string
    revenuePerMile: Decimal | DecimalJsLike | number | string
    costPerMile: Decimal | DecimalJsLike | number | string
    loadedMileRatio: Decimal | DecimalJsLike | number | string
    deadheadMileRatio: Decimal | DecimalJsLike | number | string
    utilizationRate: Decimal | DecimalJsLike | number | string
    tripDistance: Decimal | DecimalJsLike | number | string
    loadedMiles: Decimal | DecimalJsLike | number | string
    deadheadMiles: Decimal | DecimalJsLike | number | string
    tripDurationHours: Decimal | DecimalJsLike | number | string
    transportLevel: string
    priorityLevel: string
    costCenterId?: string | null
    costCenterName?: string | null
    calculatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TripCostBreakdownUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    baseRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    mileageRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priorityRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    specialRequirementsRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    insuranceAdjustment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    crewLaborCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vehicleCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fuelCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maintenanceCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overheadCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grossProfit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    profitMargin?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    revenuePerMile?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPerMile?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loadedMileRatio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deadheadMileRatio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    utilizationRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tripDistance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loadedMiles?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deadheadMiles?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tripDurationHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    transportLevel?: StringFieldUpdateOperationsInput | string
    priorityLevel?: StringFieldUpdateOperationsInput | string
    costCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    costCenterName?: NullableStringFieldUpdateOperationsInput | string | null
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TripCostBreakdownUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    baseRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    mileageRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priorityRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    specialRequirementsRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    insuranceAdjustment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    crewLaborCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vehicleCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fuelCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maintenanceCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overheadCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grossProfit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    profitMargin?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    revenuePerMile?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPerMile?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loadedMileRatio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deadheadMileRatio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    utilizationRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tripDistance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loadedMiles?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deadheadMiles?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tripDurationHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    transportLevel?: StringFieldUpdateOperationsInput | string
    priorityLevel?: StringFieldUpdateOperationsInput | string
    costCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    costCenterName?: NullableStringFieldUpdateOperationsInput | string | null
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TripCostBreakdownCreateManyInput = {
    id?: string
    tripId: string
    baseRevenue: Decimal | DecimalJsLike | number | string
    mileageRevenue: Decimal | DecimalJsLike | number | string
    priorityRevenue: Decimal | DecimalJsLike | number | string
    specialRequirementsRevenue: Decimal | DecimalJsLike | number | string
    insuranceAdjustment: Decimal | DecimalJsLike | number | string
    totalRevenue: Decimal | DecimalJsLike | number | string
    crewLaborCost: Decimal | DecimalJsLike | number | string
    vehicleCost: Decimal | DecimalJsLike | number | string
    fuelCost: Decimal | DecimalJsLike | number | string
    maintenanceCost: Decimal | DecimalJsLike | number | string
    overheadCost: Decimal | DecimalJsLike | number | string
    totalCost: Decimal | DecimalJsLike | number | string
    grossProfit: Decimal | DecimalJsLike | number | string
    profitMargin: Decimal | DecimalJsLike | number | string
    revenuePerMile: Decimal | DecimalJsLike | number | string
    costPerMile: Decimal | DecimalJsLike | number | string
    loadedMileRatio: Decimal | DecimalJsLike | number | string
    deadheadMileRatio: Decimal | DecimalJsLike | number | string
    utilizationRate: Decimal | DecimalJsLike | number | string
    tripDistance: Decimal | DecimalJsLike | number | string
    loadedMiles: Decimal | DecimalJsLike | number | string
    deadheadMiles: Decimal | DecimalJsLike | number | string
    tripDurationHours: Decimal | DecimalJsLike | number | string
    transportLevel: string
    priorityLevel: string
    costCenterId?: string | null
    costCenterName?: string | null
    calculatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TripCostBreakdownUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    baseRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    mileageRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priorityRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    specialRequirementsRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    insuranceAdjustment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    crewLaborCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vehicleCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fuelCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maintenanceCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overheadCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grossProfit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    profitMargin?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    revenuePerMile?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPerMile?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loadedMileRatio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deadheadMileRatio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    utilizationRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tripDistance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loadedMiles?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deadheadMiles?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tripDurationHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    transportLevel?: StringFieldUpdateOperationsInput | string
    priorityLevel?: StringFieldUpdateOperationsInput | string
    costCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    costCenterName?: NullableStringFieldUpdateOperationsInput | string | null
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TripCostBreakdownUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    baseRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    mileageRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priorityRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    specialRequirementsRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    insuranceAdjustment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    crewLaborCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vehicleCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fuelCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maintenanceCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overheadCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grossProfit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    profitMargin?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    revenuePerMile?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPerMile?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loadedMileRatio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deadheadMileRatio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    utilizationRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tripDistance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loadedMiles?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deadheadMiles?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tripDurationHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    transportLevel?: StringFieldUpdateOperationsInput | string
    priorityLevel?: StringFieldUpdateOperationsInput | string
    costCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    costCenterName?: NullableStringFieldUpdateOperationsInput | string | null
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CostCenterCreateInput = {
    id?: string
    name: string
    description?: string | null
    code: string
    overheadRate?: Decimal | DecimalJsLike | number | string
    fixedCosts?: Decimal | DecimalJsLike | number | string
    variableCosts?: Decimal | DecimalJsLike | number | string
    allocationMethod?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CostCenterUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    code: string
    overheadRate?: Decimal | DecimalJsLike | number | string
    fixedCosts?: Decimal | DecimalJsLike | number | string
    variableCosts?: Decimal | DecimalJsLike | number | string
    allocationMethod?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CostCenterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    overheadRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fixedCosts?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    variableCosts?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allocationMethod?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CostCenterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    overheadRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fixedCosts?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    variableCosts?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allocationMethod?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CostCenterCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    code: string
    overheadRate?: Decimal | DecimalJsLike | number | string
    fixedCosts?: Decimal | DecimalJsLike | number | string
    variableCosts?: Decimal | DecimalJsLike | number | string
    allocationMethod?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CostCenterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    overheadRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fixedCosts?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    variableCosts?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allocationMethod?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CostCenterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    overheadRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fixedCosts?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    variableCosts?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allocationMethod?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type backhaul_opportunitiesCreateInput = {
    id: string
    tripId1: string
    tripId2: string
    revenueBonus?: Decimal | DecimalJsLike | number | string | null
    efficiency?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    isActive?: boolean
  }

  export type backhaul_opportunitiesUncheckedCreateInput = {
    id: string
    tripId1: string
    tripId2: string
    revenueBonus?: Decimal | DecimalJsLike | number | string | null
    efficiency?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    isActive?: boolean
  }

  export type backhaul_opportunitiesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId1?: StringFieldUpdateOperationsInput | string
    tripId2?: StringFieldUpdateOperationsInput | string
    revenueBonus?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    efficiency?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type backhaul_opportunitiesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId1?: StringFieldUpdateOperationsInput | string
    tripId2?: StringFieldUpdateOperationsInput | string
    revenueBonus?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    efficiency?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type backhaul_opportunitiesCreateManyInput = {
    id: string
    tripId1: string
    tripId2: string
    revenueBonus?: Decimal | DecimalJsLike | number | string | null
    efficiency?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    isActive?: boolean
  }

  export type backhaul_opportunitiesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId1?: StringFieldUpdateOperationsInput | string
    tripId2?: StringFieldUpdateOperationsInput | string
    revenueBonus?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    efficiency?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type backhaul_opportunitiesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId1?: StringFieldUpdateOperationsInput | string
    tripId2?: StringFieldUpdateOperationsInput | string
    revenueBonus?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    efficiency?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type pickup_locationsCreateInput = {
    id: string
    hospitalId: string
    name: string
    description?: string | null
    contactPhone?: string | null
    contactEmail?: string | null
    floor?: string | null
    room?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    trips?: TransportRequestCreateNestedManyWithoutPickupLocationInput
    legacyTrips?: TripCreateNestedManyWithoutPickup_locationsInput
  }

  export type pickup_locationsUncheckedCreateInput = {
    id: string
    hospitalId: string
    name: string
    description?: string | null
    contactPhone?: string | null
    contactEmail?: string | null
    floor?: string | null
    room?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    trips?: TransportRequestUncheckedCreateNestedManyWithoutPickupLocationInput
    legacyTrips?: TripUncheckedCreateNestedManyWithoutPickup_locationsInput
  }

  export type pickup_locationsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hospitalId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trips?: TransportRequestUpdateManyWithoutPickupLocationNestedInput
    legacyTrips?: TripUpdateManyWithoutPickup_locationsNestedInput
  }

  export type pickup_locationsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hospitalId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trips?: TransportRequestUncheckedUpdateManyWithoutPickupLocationNestedInput
    legacyTrips?: TripUncheckedUpdateManyWithoutPickup_locationsNestedInput
  }

  export type pickup_locationsCreateManyInput = {
    id: string
    hospitalId: string
    name: string
    description?: string | null
    contactPhone?: string | null
    contactEmail?: string | null
    floor?: string | null
    room?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type pickup_locationsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    hospitalId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pickup_locationsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    hospitalId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pricing_modelsCreateInput = {
    id: string
    agencyId?: string | null
    name: string
    isActive?: boolean
    baseRates: JsonNullValueInput | InputJsonValue
    perMileRates: JsonNullValueInput | InputJsonValue
    priorityMultipliers: JsonNullValueInput | InputJsonValue
    peakHourMultipliers: JsonNullValueInput | InputJsonValue
    weekendMultipliers: JsonNullValueInput | InputJsonValue
    seasonalMultipliers: JsonNullValueInput | InputJsonValue
    zoneMultipliers: JsonNullValueInput | InputJsonValue
    distanceTiers: JsonNullValueInput | InputJsonValue
    specialRequirements: JsonNullValueInput | InputJsonValue
    isolationPricing?: Decimal | DecimalJsLike | number | string | null
    bariatricPricing?: Decimal | DecimalJsLike | number | string | null
    oxygenPricing?: Decimal | DecimalJsLike | number | string | null
    monitoringPricing?: Decimal | DecimalJsLike | number | string | null
    insuranceRates: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type pricing_modelsUncheckedCreateInput = {
    id: string
    agencyId?: string | null
    name: string
    isActive?: boolean
    baseRates: JsonNullValueInput | InputJsonValue
    perMileRates: JsonNullValueInput | InputJsonValue
    priorityMultipliers: JsonNullValueInput | InputJsonValue
    peakHourMultipliers: JsonNullValueInput | InputJsonValue
    weekendMultipliers: JsonNullValueInput | InputJsonValue
    seasonalMultipliers: JsonNullValueInput | InputJsonValue
    zoneMultipliers: JsonNullValueInput | InputJsonValue
    distanceTiers: JsonNullValueInput | InputJsonValue
    specialRequirements: JsonNullValueInput | InputJsonValue
    isolationPricing?: Decimal | DecimalJsLike | number | string | null
    bariatricPricing?: Decimal | DecimalJsLike | number | string | null
    oxygenPricing?: Decimal | DecimalJsLike | number | string | null
    monitoringPricing?: Decimal | DecimalJsLike | number | string | null
    insuranceRates: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type pricing_modelsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    baseRates?: JsonNullValueInput | InputJsonValue
    perMileRates?: JsonNullValueInput | InputJsonValue
    priorityMultipliers?: JsonNullValueInput | InputJsonValue
    peakHourMultipliers?: JsonNullValueInput | InputJsonValue
    weekendMultipliers?: JsonNullValueInput | InputJsonValue
    seasonalMultipliers?: JsonNullValueInput | InputJsonValue
    zoneMultipliers?: JsonNullValueInput | InputJsonValue
    distanceTiers?: JsonNullValueInput | InputJsonValue
    specialRequirements?: JsonNullValueInput | InputJsonValue
    isolationPricing?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    bariatricPricing?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    oxygenPricing?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    monitoringPricing?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    insuranceRates?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pricing_modelsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    baseRates?: JsonNullValueInput | InputJsonValue
    perMileRates?: JsonNullValueInput | InputJsonValue
    priorityMultipliers?: JsonNullValueInput | InputJsonValue
    peakHourMultipliers?: JsonNullValueInput | InputJsonValue
    weekendMultipliers?: JsonNullValueInput | InputJsonValue
    seasonalMultipliers?: JsonNullValueInput | InputJsonValue
    zoneMultipliers?: JsonNullValueInput | InputJsonValue
    distanceTiers?: JsonNullValueInput | InputJsonValue
    specialRequirements?: JsonNullValueInput | InputJsonValue
    isolationPricing?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    bariatricPricing?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    oxygenPricing?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    monitoringPricing?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    insuranceRates?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pricing_modelsCreateManyInput = {
    id: string
    agencyId?: string | null
    name: string
    isActive?: boolean
    baseRates: JsonNullValueInput | InputJsonValue
    perMileRates: JsonNullValueInput | InputJsonValue
    priorityMultipliers: JsonNullValueInput | InputJsonValue
    peakHourMultipliers: JsonNullValueInput | InputJsonValue
    weekendMultipliers: JsonNullValueInput | InputJsonValue
    seasonalMultipliers: JsonNullValueInput | InputJsonValue
    zoneMultipliers: JsonNullValueInput | InputJsonValue
    distanceTiers: JsonNullValueInput | InputJsonValue
    specialRequirements: JsonNullValueInput | InputJsonValue
    isolationPricing?: Decimal | DecimalJsLike | number | string | null
    bariatricPricing?: Decimal | DecimalJsLike | number | string | null
    oxygenPricing?: Decimal | DecimalJsLike | number | string | null
    monitoringPricing?: Decimal | DecimalJsLike | number | string | null
    insuranceRates: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type pricing_modelsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    baseRates?: JsonNullValueInput | InputJsonValue
    perMileRates?: JsonNullValueInput | InputJsonValue
    priorityMultipliers?: JsonNullValueInput | InputJsonValue
    peakHourMultipliers?: JsonNullValueInput | InputJsonValue
    weekendMultipliers?: JsonNullValueInput | InputJsonValue
    seasonalMultipliers?: JsonNullValueInput | InputJsonValue
    zoneMultipliers?: JsonNullValueInput | InputJsonValue
    distanceTiers?: JsonNullValueInput | InputJsonValue
    specialRequirements?: JsonNullValueInput | InputJsonValue
    isolationPricing?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    bariatricPricing?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    oxygenPricing?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    monitoringPricing?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    insuranceRates?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pricing_modelsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    baseRates?: JsonNullValueInput | InputJsonValue
    perMileRates?: JsonNullValueInput | InputJsonValue
    priorityMultipliers?: JsonNullValueInput | InputJsonValue
    peakHourMultipliers?: JsonNullValueInput | InputJsonValue
    weekendMultipliers?: JsonNullValueInput | InputJsonValue
    seasonalMultipliers?: JsonNullValueInput | InputJsonValue
    zoneMultipliers?: JsonNullValueInput | InputJsonValue
    distanceTiers?: JsonNullValueInput | InputJsonValue
    specialRequirements?: JsonNullValueInput | InputJsonValue
    isolationPricing?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    bariatricPricing?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    oxygenPricing?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    monitoringPricing?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    insuranceRates?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type route_optimization_settingsCreateInput = {
    id: string
    agencyId?: string | null
    deadheadMileWeight?: Decimal | DecimalJsLike | number | string
    waitTimeWeight?: Decimal | DecimalJsLike | number | string
    backhaulBonusWeight?: Decimal | DecimalJsLike | number | string
    overtimeRiskWeight?: Decimal | DecimalJsLike | number | string
    revenueWeight?: Decimal | DecimalJsLike | number | string
    maxDeadheadMiles?: Decimal | DecimalJsLike | number | string
    maxWaitTimeMinutes?: number
    maxOvertimeHours?: Decimal | DecimalJsLike | number | string
    maxResponseTimeMinutes?: number
    maxServiceDistance?: Decimal | DecimalJsLike | number | string
    backhaulTimeWindow?: number
    backhaulDistanceLimit?: Decimal | DecimalJsLike | number | string
    backhaulRevenueBonus?: Decimal | DecimalJsLike | number | string
    enableBackhaulOptimization?: boolean
    targetLoadedMileRatio?: Decimal | DecimalJsLike | number | string
    targetRevenuePerHour?: Decimal | DecimalJsLike | number | string
    targetResponseTime?: number
    targetEfficiency?: Decimal | DecimalJsLike | number | string
    optimizationAlgorithm?: string
    maxOptimizationTime?: number
    enableRealTimeOptimization?: boolean
    crewAvailabilityWeight?: Decimal | DecimalJsLike | number | string
    equipmentCompatibilityWeight?: Decimal | DecimalJsLike | number | string
    patientPriorityWeight?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type route_optimization_settingsUncheckedCreateInput = {
    id: string
    agencyId?: string | null
    deadheadMileWeight?: Decimal | DecimalJsLike | number | string
    waitTimeWeight?: Decimal | DecimalJsLike | number | string
    backhaulBonusWeight?: Decimal | DecimalJsLike | number | string
    overtimeRiskWeight?: Decimal | DecimalJsLike | number | string
    revenueWeight?: Decimal | DecimalJsLike | number | string
    maxDeadheadMiles?: Decimal | DecimalJsLike | number | string
    maxWaitTimeMinutes?: number
    maxOvertimeHours?: Decimal | DecimalJsLike | number | string
    maxResponseTimeMinutes?: number
    maxServiceDistance?: Decimal | DecimalJsLike | number | string
    backhaulTimeWindow?: number
    backhaulDistanceLimit?: Decimal | DecimalJsLike | number | string
    backhaulRevenueBonus?: Decimal | DecimalJsLike | number | string
    enableBackhaulOptimization?: boolean
    targetLoadedMileRatio?: Decimal | DecimalJsLike | number | string
    targetRevenuePerHour?: Decimal | DecimalJsLike | number | string
    targetResponseTime?: number
    targetEfficiency?: Decimal | DecimalJsLike | number | string
    optimizationAlgorithm?: string
    maxOptimizationTime?: number
    enableRealTimeOptimization?: boolean
    crewAvailabilityWeight?: Decimal | DecimalJsLike | number | string
    equipmentCompatibilityWeight?: Decimal | DecimalJsLike | number | string
    patientPriorityWeight?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type route_optimization_settingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
    deadheadMileWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    waitTimeWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    backhaulBonusWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overtimeRiskWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    revenueWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxDeadheadMiles?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxWaitTimeMinutes?: IntFieldUpdateOperationsInput | number
    maxOvertimeHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxResponseTimeMinutes?: IntFieldUpdateOperationsInput | number
    maxServiceDistance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    backhaulTimeWindow?: IntFieldUpdateOperationsInput | number
    backhaulDistanceLimit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    backhaulRevenueBonus?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    enableBackhaulOptimization?: BoolFieldUpdateOperationsInput | boolean
    targetLoadedMileRatio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    targetRevenuePerHour?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    targetResponseTime?: IntFieldUpdateOperationsInput | number
    targetEfficiency?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    optimizationAlgorithm?: StringFieldUpdateOperationsInput | string
    maxOptimizationTime?: IntFieldUpdateOperationsInput | number
    enableRealTimeOptimization?: BoolFieldUpdateOperationsInput | boolean
    crewAvailabilityWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    equipmentCompatibilityWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    patientPriorityWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type route_optimization_settingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
    deadheadMileWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    waitTimeWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    backhaulBonusWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overtimeRiskWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    revenueWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxDeadheadMiles?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxWaitTimeMinutes?: IntFieldUpdateOperationsInput | number
    maxOvertimeHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxResponseTimeMinutes?: IntFieldUpdateOperationsInput | number
    maxServiceDistance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    backhaulTimeWindow?: IntFieldUpdateOperationsInput | number
    backhaulDistanceLimit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    backhaulRevenueBonus?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    enableBackhaulOptimization?: BoolFieldUpdateOperationsInput | boolean
    targetLoadedMileRatio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    targetRevenuePerHour?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    targetResponseTime?: IntFieldUpdateOperationsInput | number
    targetEfficiency?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    optimizationAlgorithm?: StringFieldUpdateOperationsInput | string
    maxOptimizationTime?: IntFieldUpdateOperationsInput | number
    enableRealTimeOptimization?: BoolFieldUpdateOperationsInput | boolean
    crewAvailabilityWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    equipmentCompatibilityWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    patientPriorityWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type route_optimization_settingsCreateManyInput = {
    id: string
    agencyId?: string | null
    deadheadMileWeight?: Decimal | DecimalJsLike | number | string
    waitTimeWeight?: Decimal | DecimalJsLike | number | string
    backhaulBonusWeight?: Decimal | DecimalJsLike | number | string
    overtimeRiskWeight?: Decimal | DecimalJsLike | number | string
    revenueWeight?: Decimal | DecimalJsLike | number | string
    maxDeadheadMiles?: Decimal | DecimalJsLike | number | string
    maxWaitTimeMinutes?: number
    maxOvertimeHours?: Decimal | DecimalJsLike | number | string
    maxResponseTimeMinutes?: number
    maxServiceDistance?: Decimal | DecimalJsLike | number | string
    backhaulTimeWindow?: number
    backhaulDistanceLimit?: Decimal | DecimalJsLike | number | string
    backhaulRevenueBonus?: Decimal | DecimalJsLike | number | string
    enableBackhaulOptimization?: boolean
    targetLoadedMileRatio?: Decimal | DecimalJsLike | number | string
    targetRevenuePerHour?: Decimal | DecimalJsLike | number | string
    targetResponseTime?: number
    targetEfficiency?: Decimal | DecimalJsLike | number | string
    optimizationAlgorithm?: string
    maxOptimizationTime?: number
    enableRealTimeOptimization?: boolean
    crewAvailabilityWeight?: Decimal | DecimalJsLike | number | string
    equipmentCompatibilityWeight?: Decimal | DecimalJsLike | number | string
    patientPriorityWeight?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type route_optimization_settingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
    deadheadMileWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    waitTimeWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    backhaulBonusWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overtimeRiskWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    revenueWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxDeadheadMiles?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxWaitTimeMinutes?: IntFieldUpdateOperationsInput | number
    maxOvertimeHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxResponseTimeMinutes?: IntFieldUpdateOperationsInput | number
    maxServiceDistance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    backhaulTimeWindow?: IntFieldUpdateOperationsInput | number
    backhaulDistanceLimit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    backhaulRevenueBonus?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    enableBackhaulOptimization?: BoolFieldUpdateOperationsInput | boolean
    targetLoadedMileRatio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    targetRevenuePerHour?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    targetResponseTime?: IntFieldUpdateOperationsInput | number
    targetEfficiency?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    optimizationAlgorithm?: StringFieldUpdateOperationsInput | string
    maxOptimizationTime?: IntFieldUpdateOperationsInput | number
    enableRealTimeOptimization?: BoolFieldUpdateOperationsInput | boolean
    crewAvailabilityWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    equipmentCompatibilityWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    patientPriorityWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type route_optimization_settingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
    deadheadMileWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    waitTimeWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    backhaulBonusWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overtimeRiskWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    revenueWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxDeadheadMiles?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxWaitTimeMinutes?: IntFieldUpdateOperationsInput | number
    maxOvertimeHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxResponseTimeMinutes?: IntFieldUpdateOperationsInput | number
    maxServiceDistance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    backhaulTimeWindow?: IntFieldUpdateOperationsInput | number
    backhaulDistanceLimit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    backhaulRevenueBonus?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    enableBackhaulOptimization?: BoolFieldUpdateOperationsInput | boolean
    targetLoadedMileRatio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    targetRevenuePerHour?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    targetResponseTime?: IntFieldUpdateOperationsInput | number
    targetEfficiency?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    optimizationAlgorithm?: StringFieldUpdateOperationsInput | string
    maxOptimizationTime?: IntFieldUpdateOperationsInput | number
    enableRealTimeOptimization?: BoolFieldUpdateOperationsInput | boolean
    crewAvailabilityWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    equipmentCompatibilityWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    patientPriorityWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitCreateInput = {
    id?: string
    unitNumber: string
    type: string
    status?: string
    currentStatus?: string
    currentLocation?: string | null
    capabilities?: UnitCreatecapabilitiesInput | string[]
    crewSize?: number
    equipment?: UnitCreateequipmentInput | string[]
    location?: NullableJsonNullValueInput | InputJsonValue
    latitude?: number | null
    longitude?: number | null
    lastMaintenance?: Date | string | null
    nextMaintenance?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    analytics?: unit_analyticsCreateNestedOneWithoutUnitInput
    agency: EMSAgencyCreateNestedOneWithoutUnitsInput
    assignedTrips?: TransportRequestCreateNestedManyWithoutAssignedUnitInput
  }

  export type UnitUncheckedCreateInput = {
    id?: string
    agencyId: string
    unitNumber: string
    type: string
    status?: string
    currentStatus?: string
    currentLocation?: string | null
    capabilities?: UnitCreatecapabilitiesInput | string[]
    crewSize?: number
    equipment?: UnitCreateequipmentInput | string[]
    location?: NullableJsonNullValueInput | InputJsonValue
    latitude?: number | null
    longitude?: number | null
    lastMaintenance?: Date | string | null
    nextMaintenance?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    analytics?: unit_analyticsUncheckedCreateNestedOneWithoutUnitInput
    assignedTrips?: TransportRequestUncheckedCreateNestedManyWithoutAssignedUnitInput
  }

  export type UnitUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitNumber?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentStatus?: StringFieldUpdateOperationsInput | string
    currentLocation?: NullableStringFieldUpdateOperationsInput | string | null
    capabilities?: UnitUpdatecapabilitiesInput | string[]
    crewSize?: IntFieldUpdateOperationsInput | number
    equipment?: UnitUpdateequipmentInput | string[]
    location?: NullableJsonNullValueInput | InputJsonValue
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analytics?: unit_analyticsUpdateOneWithoutUnitNestedInput
    agency?: EMSAgencyUpdateOneRequiredWithoutUnitsNestedInput
    assignedTrips?: TransportRequestUpdateManyWithoutAssignedUnitNestedInput
  }

  export type UnitUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    unitNumber?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentStatus?: StringFieldUpdateOperationsInput | string
    currentLocation?: NullableStringFieldUpdateOperationsInput | string | null
    capabilities?: UnitUpdatecapabilitiesInput | string[]
    crewSize?: IntFieldUpdateOperationsInput | number
    equipment?: UnitUpdateequipmentInput | string[]
    location?: NullableJsonNullValueInput | InputJsonValue
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analytics?: unit_analyticsUncheckedUpdateOneWithoutUnitNestedInput
    assignedTrips?: TransportRequestUncheckedUpdateManyWithoutAssignedUnitNestedInput
  }

  export type UnitCreateManyInput = {
    id?: string
    agencyId: string
    unitNumber: string
    type: string
    status?: string
    currentStatus?: string
    currentLocation?: string | null
    capabilities?: UnitCreatecapabilitiesInput | string[]
    crewSize?: number
    equipment?: UnitCreateequipmentInput | string[]
    location?: NullableJsonNullValueInput | InputJsonValue
    latitude?: number | null
    longitude?: number | null
    lastMaintenance?: Date | string | null
    nextMaintenance?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitNumber?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentStatus?: StringFieldUpdateOperationsInput | string
    currentLocation?: NullableStringFieldUpdateOperationsInput | string | null
    capabilities?: UnitUpdatecapabilitiesInput | string[]
    crewSize?: IntFieldUpdateOperationsInput | number
    equipment?: UnitUpdateequipmentInput | string[]
    location?: NullableJsonNullValueInput | InputJsonValue
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    unitNumber?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentStatus?: StringFieldUpdateOperationsInput | string
    currentLocation?: NullableStringFieldUpdateOperationsInput | string | null
    capabilities?: UnitUpdatecapabilitiesInput | string[]
    crewSize?: IntFieldUpdateOperationsInput | number
    equipment?: UnitUpdateequipmentInput | string[]
    location?: NullableJsonNullValueInput | InputJsonValue
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type unit_analyticsCreateInput = {
    id: string
    performanceScore?: Decimal | DecimalJsLike | number | string | null
    efficiency?: Decimal | DecimalJsLike | number | string | null
    totalTrips?: number
    totalTripsCompleted?: number
    averageResponseTime?: Decimal | DecimalJsLike | number | string | null
    lastUpdated?: Date | string
    unit: UnitCreateNestedOneWithoutAnalyticsInput
  }

  export type unit_analyticsUncheckedCreateInput = {
    id: string
    unitId: string
    performanceScore?: Decimal | DecimalJsLike | number | string | null
    efficiency?: Decimal | DecimalJsLike | number | string | null
    totalTrips?: number
    totalTripsCompleted?: number
    averageResponseTime?: Decimal | DecimalJsLike | number | string | null
    lastUpdated?: Date | string
  }

  export type unit_analyticsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    performanceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    efficiency?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalTrips?: IntFieldUpdateOperationsInput | number
    totalTripsCompleted?: IntFieldUpdateOperationsInput | number
    averageResponseTime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    unit?: UnitUpdateOneRequiredWithoutAnalyticsNestedInput
  }

  export type unit_analyticsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    performanceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    efficiency?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalTrips?: IntFieldUpdateOperationsInput | number
    totalTripsCompleted?: IntFieldUpdateOperationsInput | number
    averageResponseTime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type unit_analyticsCreateManyInput = {
    id: string
    unitId: string
    performanceScore?: Decimal | DecimalJsLike | number | string | null
    efficiency?: Decimal | DecimalJsLike | number | string | null
    totalTrips?: number
    totalTripsCompleted?: number
    averageResponseTime?: Decimal | DecimalJsLike | number | string | null
    lastUpdated?: Date | string
  }

  export type unit_analyticsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    performanceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    efficiency?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalTrips?: IntFieldUpdateOperationsInput | number
    totalTripsCompleted?: IntFieldUpdateOperationsInput | number
    averageResponseTime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type unit_analyticsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    performanceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    efficiency?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalTrips?: IntFieldUpdateOperationsInput | number
    totalTripsCompleted?: IntFieldUpdateOperationsInput | number
    averageResponseTime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceCreateInput = {
    id?: string
    notificationType: string
    emailEnabled?: boolean
    smsEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: CenterUserCreateNestedOneWithoutNotificationPreferencesInput
  }

  export type NotificationPreferenceUncheckedCreateInput = {
    id?: string
    userId: string
    notificationType: string
    emailEnabled?: boolean
    smsEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPreferenceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    notificationType?: StringFieldUpdateOperationsInput | string
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
    smsEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: CenterUserUpdateOneRequiredWithoutNotificationPreferencesNestedInput
  }

  export type NotificationPreferenceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    notificationType?: StringFieldUpdateOperationsInput | string
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
    smsEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceCreateManyInput = {
    id?: string
    userId: string
    notificationType: string
    emailEnabled?: boolean
    smsEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPreferenceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    notificationType?: StringFieldUpdateOperationsInput | string
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
    smsEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    notificationType?: StringFieldUpdateOperationsInput | string
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
    smsEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationLogCreateInput = {
    id?: string
    notificationType: string
    channel: string
    status: string
    sentAt?: Date | string
    deliveredAt?: Date | string | null
    errorMessage?: string | null
    user: CenterUserCreateNestedOneWithoutNotificationLogsInput
  }

  export type NotificationLogUncheckedCreateInput = {
    id?: string
    userId: string
    notificationType: string
    channel: string
    status: string
    sentAt?: Date | string
    deliveredAt?: Date | string | null
    errorMessage?: string | null
  }

  export type NotificationLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    notificationType?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    user?: CenterUserUpdateOneRequiredWithoutNotificationLogsNestedInput
  }

  export type NotificationLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    notificationType?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationLogCreateManyInput = {
    id?: string
    userId: string
    notificationType: string
    channel: string
    status: string
    sentAt?: Date | string
    deliveredAt?: Date | string | null
    errorMessage?: string | null
  }

  export type NotificationLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    notificationType?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    notificationType?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DropdownOptionCreateInput = {
    id?: string
    category: string
    value: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    defaultFor?: CategoryDefaultCreateNestedOneWithoutOptionInput
  }

  export type DropdownOptionUncheckedCreateInput = {
    id?: string
    category: string
    value: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    defaultFor?: CategoryDefaultUncheckedCreateNestedOneWithoutOptionInput
  }

  export type DropdownOptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defaultFor?: CategoryDefaultUpdateOneWithoutOptionNestedInput
  }

  export type DropdownOptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defaultFor?: CategoryDefaultUncheckedUpdateOneWithoutOptionNestedInput
  }

  export type DropdownOptionCreateManyInput = {
    id?: string
    category: string
    value: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DropdownOptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DropdownOptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryDefaultCreateInput = {
    id?: string
    category: string
    createdAt?: Date | string
    updatedAt?: Date | string
    option: DropdownOptionCreateNestedOneWithoutDefaultForInput
  }

  export type CategoryDefaultUncheckedCreateInput = {
    id?: string
    category: string
    optionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryDefaultUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    option?: DropdownOptionUpdateOneRequiredWithoutDefaultForNestedInput
  }

  export type CategoryDefaultUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    optionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryDefaultCreateManyInput = {
    id?: string
    category: string
    optionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryDefaultUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryDefaultUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    optionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransportRequestCreateInput = {
    id?: string
    tripNumber?: string | null
    patientId: string
    patientWeight?: string | null
    specialNeeds?: string | null
    fromLocation?: string | null
    toLocation?: string | null
    isMultiLocationFacility?: boolean
    scheduledTime?: Date | string | null
    transportLevel: string
    urgencyLevel?: string | null
    priority: string
    status?: string
    specialRequirements?: string | null
    diagnosis?: string | null
    mobilityLevel?: string | null
    oxygenRequired?: boolean
    monitoringRequired?: boolean
    generateQRCode?: boolean
    qrCodeData?: string | null
    selectedAgencies?: TransportRequestCreateselectedAgenciesInput | string[]
    notificationRadius?: number | null
    requestTimestamp?: Date | string
    acceptedTimestamp?: Date | string | null
    pickupTimestamp?: Date | string | null
    arrivalTimestamp?: Date | string | null
    departureTimestamp?: Date | string | null
    completionTimestamp?: Date | string | null
    assignedAgencyId?: string | null
    createdById?: string | null
    healthcareCreatedById?: string | null
    isolation?: boolean
    bariatric?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    originFacility?: FacilityCreateNestedOneWithoutOriginTripsInput
    destinationFacility?: FacilityCreateNestedOneWithoutDestinationTripsInput
    pickupLocation?: pickup_locationsCreateNestedOneWithoutTripsInput
    assignedUnit?: UnitCreateNestedOneWithoutAssignedTripsInput
    healthcareLocation?: HealthcareLocationCreateNestedOneWithoutTransportRequestsInput
  }

  export type TransportRequestUncheckedCreateInput = {
    id?: string
    tripNumber?: string | null
    patientId: string
    patientWeight?: string | null
    specialNeeds?: string | null
    originFacilityId?: string | null
    destinationFacilityId?: string | null
    fromLocation?: string | null
    toLocation?: string | null
    fromLocationId?: string | null
    isMultiLocationFacility?: boolean
    scheduledTime?: Date | string | null
    transportLevel: string
    urgencyLevel?: string | null
    priority: string
    status?: string
    specialRequirements?: string | null
    diagnosis?: string | null
    mobilityLevel?: string | null
    oxygenRequired?: boolean
    monitoringRequired?: boolean
    generateQRCode?: boolean
    qrCodeData?: string | null
    selectedAgencies?: TransportRequestCreateselectedAgenciesInput | string[]
    notificationRadius?: number | null
    requestTimestamp?: Date | string
    acceptedTimestamp?: Date | string | null
    pickupTimestamp?: Date | string | null
    arrivalTimestamp?: Date | string | null
    departureTimestamp?: Date | string | null
    completionTimestamp?: Date | string | null
    pickupLocationId?: string | null
    assignedAgencyId?: string | null
    assignedUnitId?: string | null
    createdById?: string | null
    healthcareCreatedById?: string | null
    isolation?: boolean
    bariatric?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransportRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripNumber?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    patientWeight?: NullableStringFieldUpdateOperationsInput | string | null
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocation?: NullableStringFieldUpdateOperationsInput | string | null
    toLocation?: NullableStringFieldUpdateOperationsInput | string | null
    isMultiLocationFacility?: BoolFieldUpdateOperationsInput | boolean
    scheduledTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transportLevel?: StringFieldUpdateOperationsInput | string
    urgencyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    specialRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    mobilityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    oxygenRequired?: BoolFieldUpdateOperationsInput | boolean
    monitoringRequired?: BoolFieldUpdateOperationsInput | boolean
    generateQRCode?: BoolFieldUpdateOperationsInput | boolean
    qrCodeData?: NullableStringFieldUpdateOperationsInput | string | null
    selectedAgencies?: TransportRequestUpdateselectedAgenciesInput | string[]
    notificationRadius?: NullableIntFieldUpdateOperationsInput | number | null
    requestTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    arrivalTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departureTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedAgencyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    healthcareCreatedById?: NullableStringFieldUpdateOperationsInput | string | null
    isolation?: BoolFieldUpdateOperationsInput | boolean
    bariatric?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    originFacility?: FacilityUpdateOneWithoutOriginTripsNestedInput
    destinationFacility?: FacilityUpdateOneWithoutDestinationTripsNestedInput
    pickupLocation?: pickup_locationsUpdateOneWithoutTripsNestedInput
    assignedUnit?: UnitUpdateOneWithoutAssignedTripsNestedInput
    healthcareLocation?: HealthcareLocationUpdateOneWithoutTransportRequestsNestedInput
  }

  export type TransportRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripNumber?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    patientWeight?: NullableStringFieldUpdateOperationsInput | string | null
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    originFacilityId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationFacilityId?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocation?: NullableStringFieldUpdateOperationsInput | string | null
    toLocation?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    isMultiLocationFacility?: BoolFieldUpdateOperationsInput | boolean
    scheduledTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transportLevel?: StringFieldUpdateOperationsInput | string
    urgencyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    specialRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    mobilityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    oxygenRequired?: BoolFieldUpdateOperationsInput | boolean
    monitoringRequired?: BoolFieldUpdateOperationsInput | boolean
    generateQRCode?: BoolFieldUpdateOperationsInput | boolean
    qrCodeData?: NullableStringFieldUpdateOperationsInput | string | null
    selectedAgencies?: TransportRequestUpdateselectedAgenciesInput | string[]
    notificationRadius?: NullableIntFieldUpdateOperationsInput | number | null
    requestTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    arrivalTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departureTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAgencyId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    healthcareCreatedById?: NullableStringFieldUpdateOperationsInput | string | null
    isolation?: BoolFieldUpdateOperationsInput | boolean
    bariatric?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransportRequestCreateManyInput = {
    id?: string
    tripNumber?: string | null
    patientId: string
    patientWeight?: string | null
    specialNeeds?: string | null
    originFacilityId?: string | null
    destinationFacilityId?: string | null
    fromLocation?: string | null
    toLocation?: string | null
    fromLocationId?: string | null
    isMultiLocationFacility?: boolean
    scheduledTime?: Date | string | null
    transportLevel: string
    urgencyLevel?: string | null
    priority: string
    status?: string
    specialRequirements?: string | null
    diagnosis?: string | null
    mobilityLevel?: string | null
    oxygenRequired?: boolean
    monitoringRequired?: boolean
    generateQRCode?: boolean
    qrCodeData?: string | null
    selectedAgencies?: TransportRequestCreateselectedAgenciesInput | string[]
    notificationRadius?: number | null
    requestTimestamp?: Date | string
    acceptedTimestamp?: Date | string | null
    pickupTimestamp?: Date | string | null
    arrivalTimestamp?: Date | string | null
    departureTimestamp?: Date | string | null
    completionTimestamp?: Date | string | null
    pickupLocationId?: string | null
    assignedAgencyId?: string | null
    assignedUnitId?: string | null
    createdById?: string | null
    healthcareCreatedById?: string | null
    isolation?: boolean
    bariatric?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransportRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripNumber?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    patientWeight?: NullableStringFieldUpdateOperationsInput | string | null
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocation?: NullableStringFieldUpdateOperationsInput | string | null
    toLocation?: NullableStringFieldUpdateOperationsInput | string | null
    isMultiLocationFacility?: BoolFieldUpdateOperationsInput | boolean
    scheduledTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transportLevel?: StringFieldUpdateOperationsInput | string
    urgencyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    specialRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    mobilityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    oxygenRequired?: BoolFieldUpdateOperationsInput | boolean
    monitoringRequired?: BoolFieldUpdateOperationsInput | boolean
    generateQRCode?: BoolFieldUpdateOperationsInput | boolean
    qrCodeData?: NullableStringFieldUpdateOperationsInput | string | null
    selectedAgencies?: TransportRequestUpdateselectedAgenciesInput | string[]
    notificationRadius?: NullableIntFieldUpdateOperationsInput | number | null
    requestTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    arrivalTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departureTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedAgencyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    healthcareCreatedById?: NullableStringFieldUpdateOperationsInput | string | null
    isolation?: BoolFieldUpdateOperationsInput | boolean
    bariatric?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransportRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripNumber?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    patientWeight?: NullableStringFieldUpdateOperationsInput | string | null
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    originFacilityId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationFacilityId?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocation?: NullableStringFieldUpdateOperationsInput | string | null
    toLocation?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    isMultiLocationFacility?: BoolFieldUpdateOperationsInput | boolean
    scheduledTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transportLevel?: StringFieldUpdateOperationsInput | string
    urgencyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    specialRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    mobilityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    oxygenRequired?: BoolFieldUpdateOperationsInput | boolean
    monitoringRequired?: BoolFieldUpdateOperationsInput | boolean
    generateQRCode?: BoolFieldUpdateOperationsInput | boolean
    qrCodeData?: NullableStringFieldUpdateOperationsInput | string | null
    selectedAgencies?: TransportRequestUpdateselectedAgenciesInput | string[]
    notificationRadius?: NullableIntFieldUpdateOperationsInput | number | null
    requestTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    arrivalTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departureTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAgencyId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    healthcareCreatedById?: NullableStringFieldUpdateOperationsInput | string | null
    isolation?: BoolFieldUpdateOperationsInput | boolean
    bariatric?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacilityCreateInput = {
    id?: string
    name: string
    address: string
    city: string
    state: string
    zipCode: string
    phone?: string | null
    email?: string | null
    type: string
    capabilities?: FacilityCreatecapabilitiesInput | string[]
    region: string
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    latitude?: number | null
    longitude?: number | null
    operatingHours?: string | null
    isActive?: boolean
    requiresReview?: boolean
    approvedAt?: Date | string | null
    approvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    originTrips?: TransportRequestCreateNestedManyWithoutOriginFacilityInput
    destinationTrips?: TransportRequestCreateNestedManyWithoutDestinationFacilityInput
  }

  export type FacilityUncheckedCreateInput = {
    id?: string
    name: string
    address: string
    city: string
    state: string
    zipCode: string
    phone?: string | null
    email?: string | null
    type: string
    capabilities?: FacilityCreatecapabilitiesInput | string[]
    region: string
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    latitude?: number | null
    longitude?: number | null
    operatingHours?: string | null
    isActive?: boolean
    requiresReview?: boolean
    approvedAt?: Date | string | null
    approvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    originTrips?: TransportRequestUncheckedCreateNestedManyWithoutOriginFacilityInput
    destinationTrips?: TransportRequestUncheckedCreateNestedManyWithoutDestinationFacilityInput
  }

  export type FacilityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    capabilities?: FacilityUpdatecapabilitiesInput | string[]
    region?: StringFieldUpdateOperationsInput | string
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    operatingHours?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requiresReview?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    originTrips?: TransportRequestUpdateManyWithoutOriginFacilityNestedInput
    destinationTrips?: TransportRequestUpdateManyWithoutDestinationFacilityNestedInput
  }

  export type FacilityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    capabilities?: FacilityUpdatecapabilitiesInput | string[]
    region?: StringFieldUpdateOperationsInput | string
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    operatingHours?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requiresReview?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    originTrips?: TransportRequestUncheckedUpdateManyWithoutOriginFacilityNestedInput
    destinationTrips?: TransportRequestUncheckedUpdateManyWithoutDestinationFacilityNestedInput
  }

  export type FacilityCreateManyInput = {
    id?: string
    name: string
    address: string
    city: string
    state: string
    zipCode: string
    phone?: string | null
    email?: string | null
    type: string
    capabilities?: FacilityCreatecapabilitiesInput | string[]
    region: string
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    latitude?: number | null
    longitude?: number | null
    operatingHours?: string | null
    isActive?: boolean
    requiresReview?: boolean
    approvedAt?: Date | string | null
    approvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacilityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    capabilities?: FacilityUpdatecapabilitiesInput | string[]
    region?: StringFieldUpdateOperationsInput | string
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    operatingHours?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requiresReview?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacilityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    capabilities?: FacilityUpdatecapabilitiesInput | string[]
    region?: StringFieldUpdateOperationsInput | string
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    operatingHours?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requiresReview?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NotificationLogListRelationFilter = {
    every?: NotificationLogWhereInput
    some?: NotificationLogWhereInput
    none?: NotificationLogWhereInput
  }

  export type NotificationPreferenceListRelationFilter = {
    every?: NotificationPreferenceWhereInput
    some?: NotificationPreferenceWhereInput
    none?: NotificationPreferenceWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type NotificationLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationPreferenceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CenterUserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    userType?: SortOrder
    phone?: SortOrder
    emailNotifications?: SortOrder
    smsNotifications?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CenterUserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    userType?: SortOrder
    phone?: SortOrder
    emailNotifications?: SortOrder
    smsNotifications?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CenterUserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    userType?: SortOrder
    phone?: SortOrder
    emailNotifications?: SortOrder
    smsNotifications?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type HealthcareLocationListRelationFilter = {
    every?: HealthcareLocationWhereInput
    some?: HealthcareLocationWhereInput
    none?: HealthcareLocationWhereInput
  }

  export type HealthcareLocationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HealthcareUserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    facilityName?: SortOrder
    facilityType?: SortOrder
    userType?: SortOrder
    isActive?: SortOrder
    manageMultipleLocations?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HealthcareUserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    facilityName?: SortOrder
    facilityType?: SortOrder
    userType?: SortOrder
    isActive?: SortOrder
    manageMultipleLocations?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HealthcareUserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    facilityName?: SortOrder
    facilityType?: SortOrder
    userType?: SortOrder
    isActive?: SortOrder
    manageMultipleLocations?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type HealthcareUserRelationFilter = {
    is?: HealthcareUserWhereInput
    isNot?: HealthcareUserWhereInput
  }

  export type TransportRequestListRelationFilter = {
    every?: TransportRequestWhereInput
    some?: TransportRequestWhereInput
    none?: TransportRequestWhereInput
  }

  export type TransportRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HealthcareLocationCountOrderByAggregateInput = {
    id?: SortOrder
    healthcareUserId?: SortOrder
    locationName?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    phone?: SortOrder
    facilityType?: SortOrder
    isActive?: SortOrder
    isPrimary?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HealthcareLocationAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type HealthcareLocationMaxOrderByAggregateInput = {
    id?: SortOrder
    healthcareUserId?: SortOrder
    locationName?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    phone?: SortOrder
    facilityType?: SortOrder
    isActive?: SortOrder
    isPrimary?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HealthcareLocationMinOrderByAggregateInput = {
    id?: SortOrder
    healthcareUserId?: SortOrder
    locationName?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    phone?: SortOrder
    facilityType?: SortOrder
    isActive?: SortOrder
    isPrimary?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HealthcareLocationSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type HospitalCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    type?: SortOrder
    capabilities?: SortOrder
    region?: SortOrder
    coordinates?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    operatingHours?: SortOrder
    isActive?: SortOrder
    requiresReview?: SortOrder
    approvedAt?: SortOrder
    approvedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HospitalAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type HospitalMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    type?: SortOrder
    region?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    operatingHours?: SortOrder
    isActive?: SortOrder
    requiresReview?: SortOrder
    approvedAt?: SortOrder
    approvedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HospitalMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    type?: SortOrder
    region?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    operatingHours?: SortOrder
    isActive?: SortOrder
    requiresReview?: SortOrder
    approvedAt?: SortOrder
    approvedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HospitalSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EMSAgencyNullableRelationFilter = {
    is?: EMSAgencyWhereInput | null
    isNot?: EMSAgencyWhereInput | null
  }

  export type EMSUserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    agencyName?: SortOrder
    agencyId?: SortOrder
    isActive?: SortOrder
    userType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EMSUserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    agencyName?: SortOrder
    agencyId?: SortOrder
    isActive?: SortOrder
    userType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EMSUserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    agencyName?: SortOrder
    agencyId?: SortOrder
    isActive?: SortOrder
    userType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UnitListRelationFilter = {
    every?: UnitWhereInput
    some?: UnitWhereInput
    none?: UnitWhereInput
  }

  export type EMSUserListRelationFilter = {
    every?: EMSUserWhereInput
    some?: EMSUserWhereInput
    none?: EMSUserWhereInput
  }

  export type UnitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EMSUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EMSAgencyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contactName?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    serviceArea?: SortOrder
    operatingHours?: SortOrder
    capabilities?: SortOrder
    pricingStructure?: SortOrder
    isActive?: SortOrder
    status?: SortOrder
    addedBy?: SortOrder
    addedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    acceptsNotifications?: SortOrder
    approvedAt?: SortOrder
    approvedBy?: SortOrder
    availableUnits?: SortOrder
    lastUpdated?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    notificationMethods?: SortOrder
    requiresReview?: SortOrder
    serviceRadius?: SortOrder
    totalUnits?: SortOrder
  }

  export type EMSAgencyAvgOrderByAggregateInput = {
    availableUnits?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    serviceRadius?: SortOrder
    totalUnits?: SortOrder
  }

  export type EMSAgencyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contactName?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    isActive?: SortOrder
    status?: SortOrder
    addedBy?: SortOrder
    addedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    acceptsNotifications?: SortOrder
    approvedAt?: SortOrder
    approvedBy?: SortOrder
    availableUnits?: SortOrder
    lastUpdated?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    requiresReview?: SortOrder
    serviceRadius?: SortOrder
    totalUnits?: SortOrder
  }

  export type EMSAgencyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contactName?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    isActive?: SortOrder
    status?: SortOrder
    addedBy?: SortOrder
    addedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    acceptsNotifications?: SortOrder
    approvedAt?: SortOrder
    approvedBy?: SortOrder
    availableUnits?: SortOrder
    lastUpdated?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    requiresReview?: SortOrder
    serviceRadius?: SortOrder
    totalUnits?: SortOrder
  }

  export type EMSAgencySumOrderByAggregateInput = {
    availableUnits?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    serviceRadius?: SortOrder
    totalUnits?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type AgencyResponseListRelationFilter = {
    every?: AgencyResponseWhereInput
    some?: AgencyResponseWhereInput
    none?: AgencyResponseWhereInput
  }

  export type Pickup_locationsNullableRelationFilter = {
    is?: pickup_locationsWhereInput | null
    isNot?: pickup_locationsWhereInput | null
  }

  export type AgencyResponseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TripCountOrderByAggregateInput = {
    id?: SortOrder
    tripNumber?: SortOrder
    patientId?: SortOrder
    patientWeight?: SortOrder
    specialNeeds?: SortOrder
    fromLocation?: SortOrder
    toLocation?: SortOrder
    scheduledTime?: SortOrder
    transportLevel?: SortOrder
    urgencyLevel?: SortOrder
    diagnosis?: SortOrder
    mobilityLevel?: SortOrder
    oxygenRequired?: SortOrder
    monitoringRequired?: SortOrder
    generateQRCode?: SortOrder
    qrCodeData?: SortOrder
    selectedAgencies?: SortOrder
    notificationRadius?: SortOrder
    transferRequestTime?: SortOrder
    transferAcceptedTime?: SortOrder
    emsArrivalTime?: SortOrder
    emsDepartureTime?: SortOrder
    actualStartTime?: SortOrder
    actualEndTime?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    notes?: SortOrder
    assignedTo?: SortOrder
    assignedAgencyId?: SortOrder
    assignedUnitId?: SortOrder
    acceptedTimestamp?: SortOrder
    pickupTimestamp?: SortOrder
    completionTimestamp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    actualTripTimeMinutes?: SortOrder
    backhaulOpportunity?: SortOrder
    completionTimeMinutes?: SortOrder
    customerSatisfaction?: SortOrder
    deadheadMiles?: SortOrder
    destinationLatitude?: SortOrder
    destinationLongitude?: SortOrder
    distanceMiles?: SortOrder
    efficiency?: SortOrder
    estimatedTripTimeMinutes?: SortOrder
    insuranceCompany?: SortOrder
    insurancePayRate?: SortOrder
    loadedMiles?: SortOrder
    originLatitude?: SortOrder
    originLongitude?: SortOrder
    perMileRate?: SortOrder
    performanceScore?: SortOrder
    requestTimestamp?: SortOrder
    responseTimeMinutes?: SortOrder
    revenuePerHour?: SortOrder
    tripCost?: SortOrder
    pickupLocationId?: SortOrder
    maxResponses?: SortOrder
    responseDeadline?: SortOrder
    responseStatus?: SortOrder
    selectionMode?: SortOrder
  }

  export type TripAvgOrderByAggregateInput = {
    notificationRadius?: SortOrder
    actualTripTimeMinutes?: SortOrder
    completionTimeMinutes?: SortOrder
    customerSatisfaction?: SortOrder
    deadheadMiles?: SortOrder
    destinationLatitude?: SortOrder
    destinationLongitude?: SortOrder
    distanceMiles?: SortOrder
    efficiency?: SortOrder
    estimatedTripTimeMinutes?: SortOrder
    insurancePayRate?: SortOrder
    loadedMiles?: SortOrder
    originLatitude?: SortOrder
    originLongitude?: SortOrder
    perMileRate?: SortOrder
    performanceScore?: SortOrder
    responseTimeMinutes?: SortOrder
    revenuePerHour?: SortOrder
    tripCost?: SortOrder
    maxResponses?: SortOrder
  }

  export type TripMaxOrderByAggregateInput = {
    id?: SortOrder
    tripNumber?: SortOrder
    patientId?: SortOrder
    patientWeight?: SortOrder
    specialNeeds?: SortOrder
    fromLocation?: SortOrder
    toLocation?: SortOrder
    scheduledTime?: SortOrder
    transportLevel?: SortOrder
    urgencyLevel?: SortOrder
    diagnosis?: SortOrder
    mobilityLevel?: SortOrder
    oxygenRequired?: SortOrder
    monitoringRequired?: SortOrder
    generateQRCode?: SortOrder
    qrCodeData?: SortOrder
    notificationRadius?: SortOrder
    transferRequestTime?: SortOrder
    transferAcceptedTime?: SortOrder
    emsArrivalTime?: SortOrder
    emsDepartureTime?: SortOrder
    actualStartTime?: SortOrder
    actualEndTime?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    notes?: SortOrder
    assignedTo?: SortOrder
    assignedAgencyId?: SortOrder
    assignedUnitId?: SortOrder
    acceptedTimestamp?: SortOrder
    pickupTimestamp?: SortOrder
    completionTimestamp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    actualTripTimeMinutes?: SortOrder
    backhaulOpportunity?: SortOrder
    completionTimeMinutes?: SortOrder
    customerSatisfaction?: SortOrder
    deadheadMiles?: SortOrder
    destinationLatitude?: SortOrder
    destinationLongitude?: SortOrder
    distanceMiles?: SortOrder
    efficiency?: SortOrder
    estimatedTripTimeMinutes?: SortOrder
    insuranceCompany?: SortOrder
    insurancePayRate?: SortOrder
    loadedMiles?: SortOrder
    originLatitude?: SortOrder
    originLongitude?: SortOrder
    perMileRate?: SortOrder
    performanceScore?: SortOrder
    requestTimestamp?: SortOrder
    responseTimeMinutes?: SortOrder
    revenuePerHour?: SortOrder
    tripCost?: SortOrder
    pickupLocationId?: SortOrder
    maxResponses?: SortOrder
    responseDeadline?: SortOrder
    responseStatus?: SortOrder
    selectionMode?: SortOrder
  }

  export type TripMinOrderByAggregateInput = {
    id?: SortOrder
    tripNumber?: SortOrder
    patientId?: SortOrder
    patientWeight?: SortOrder
    specialNeeds?: SortOrder
    fromLocation?: SortOrder
    toLocation?: SortOrder
    scheduledTime?: SortOrder
    transportLevel?: SortOrder
    urgencyLevel?: SortOrder
    diagnosis?: SortOrder
    mobilityLevel?: SortOrder
    oxygenRequired?: SortOrder
    monitoringRequired?: SortOrder
    generateQRCode?: SortOrder
    qrCodeData?: SortOrder
    notificationRadius?: SortOrder
    transferRequestTime?: SortOrder
    transferAcceptedTime?: SortOrder
    emsArrivalTime?: SortOrder
    emsDepartureTime?: SortOrder
    actualStartTime?: SortOrder
    actualEndTime?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    notes?: SortOrder
    assignedTo?: SortOrder
    assignedAgencyId?: SortOrder
    assignedUnitId?: SortOrder
    acceptedTimestamp?: SortOrder
    pickupTimestamp?: SortOrder
    completionTimestamp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    actualTripTimeMinutes?: SortOrder
    backhaulOpportunity?: SortOrder
    completionTimeMinutes?: SortOrder
    customerSatisfaction?: SortOrder
    deadheadMiles?: SortOrder
    destinationLatitude?: SortOrder
    destinationLongitude?: SortOrder
    distanceMiles?: SortOrder
    efficiency?: SortOrder
    estimatedTripTimeMinutes?: SortOrder
    insuranceCompany?: SortOrder
    insurancePayRate?: SortOrder
    loadedMiles?: SortOrder
    originLatitude?: SortOrder
    originLongitude?: SortOrder
    perMileRate?: SortOrder
    performanceScore?: SortOrder
    requestTimestamp?: SortOrder
    responseTimeMinutes?: SortOrder
    revenuePerHour?: SortOrder
    tripCost?: SortOrder
    pickupLocationId?: SortOrder
    maxResponses?: SortOrder
    responseDeadline?: SortOrder
    responseStatus?: SortOrder
    selectionMode?: SortOrder
  }

  export type TripSumOrderByAggregateInput = {
    notificationRadius?: SortOrder
    actualTripTimeMinutes?: SortOrder
    completionTimeMinutes?: SortOrder
    customerSatisfaction?: SortOrder
    deadheadMiles?: SortOrder
    destinationLatitude?: SortOrder
    destinationLongitude?: SortOrder
    distanceMiles?: SortOrder
    efficiency?: SortOrder
    estimatedTripTimeMinutes?: SortOrder
    insurancePayRate?: SortOrder
    loadedMiles?: SortOrder
    originLatitude?: SortOrder
    originLongitude?: SortOrder
    perMileRate?: SortOrder
    performanceScore?: SortOrder
    responseTimeMinutes?: SortOrder
    revenuePerHour?: SortOrder
    tripCost?: SortOrder
    maxResponses?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type TripRelationFilter = {
    is?: TripWhereInput
    isNot?: TripWhereInput
  }

  export type AgencyResponseCountOrderByAggregateInput = {
    id?: SortOrder
    tripId?: SortOrder
    agencyId?: SortOrder
    response?: SortOrder
    responseTimestamp?: SortOrder
    responseNotes?: SortOrder
    estimatedArrival?: SortOrder
    isSelected?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgencyResponseMaxOrderByAggregateInput = {
    id?: SortOrder
    tripId?: SortOrder
    agencyId?: SortOrder
    response?: SortOrder
    responseTimestamp?: SortOrder
    responseNotes?: SortOrder
    estimatedArrival?: SortOrder
    isSelected?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgencyResponseMinOrderByAggregateInput = {
    id?: SortOrder
    tripId?: SortOrder
    agencyId?: SortOrder
    response?: SortOrder
    responseTimestamp?: SortOrder
    responseNotes?: SortOrder
    estimatedArrival?: SortOrder
    isSelected?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type SystemAnalyticsCountOrderByAggregateInput = {
    id?: SortOrder
    metricName?: SortOrder
    metricValue?: SortOrder
    timestamp?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type SystemAnalyticsMaxOrderByAggregateInput = {
    id?: SortOrder
    metricName?: SortOrder
    timestamp?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type SystemAnalyticsMinOrderByAggregateInput = {
    id?: SortOrder
    metricName?: SortOrder
    timestamp?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type TripCostBreakdownCountOrderByAggregateInput = {
    id?: SortOrder
    tripId?: SortOrder
    baseRevenue?: SortOrder
    mileageRevenue?: SortOrder
    priorityRevenue?: SortOrder
    specialRequirementsRevenue?: SortOrder
    insuranceAdjustment?: SortOrder
    totalRevenue?: SortOrder
    crewLaborCost?: SortOrder
    vehicleCost?: SortOrder
    fuelCost?: SortOrder
    maintenanceCost?: SortOrder
    overheadCost?: SortOrder
    totalCost?: SortOrder
    grossProfit?: SortOrder
    profitMargin?: SortOrder
    revenuePerMile?: SortOrder
    costPerMile?: SortOrder
    loadedMileRatio?: SortOrder
    deadheadMileRatio?: SortOrder
    utilizationRate?: SortOrder
    tripDistance?: SortOrder
    loadedMiles?: SortOrder
    deadheadMiles?: SortOrder
    tripDurationHours?: SortOrder
    transportLevel?: SortOrder
    priorityLevel?: SortOrder
    costCenterId?: SortOrder
    costCenterName?: SortOrder
    calculatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TripCostBreakdownAvgOrderByAggregateInput = {
    baseRevenue?: SortOrder
    mileageRevenue?: SortOrder
    priorityRevenue?: SortOrder
    specialRequirementsRevenue?: SortOrder
    insuranceAdjustment?: SortOrder
    totalRevenue?: SortOrder
    crewLaborCost?: SortOrder
    vehicleCost?: SortOrder
    fuelCost?: SortOrder
    maintenanceCost?: SortOrder
    overheadCost?: SortOrder
    totalCost?: SortOrder
    grossProfit?: SortOrder
    profitMargin?: SortOrder
    revenuePerMile?: SortOrder
    costPerMile?: SortOrder
    loadedMileRatio?: SortOrder
    deadheadMileRatio?: SortOrder
    utilizationRate?: SortOrder
    tripDistance?: SortOrder
    loadedMiles?: SortOrder
    deadheadMiles?: SortOrder
    tripDurationHours?: SortOrder
  }

  export type TripCostBreakdownMaxOrderByAggregateInput = {
    id?: SortOrder
    tripId?: SortOrder
    baseRevenue?: SortOrder
    mileageRevenue?: SortOrder
    priorityRevenue?: SortOrder
    specialRequirementsRevenue?: SortOrder
    insuranceAdjustment?: SortOrder
    totalRevenue?: SortOrder
    crewLaborCost?: SortOrder
    vehicleCost?: SortOrder
    fuelCost?: SortOrder
    maintenanceCost?: SortOrder
    overheadCost?: SortOrder
    totalCost?: SortOrder
    grossProfit?: SortOrder
    profitMargin?: SortOrder
    revenuePerMile?: SortOrder
    costPerMile?: SortOrder
    loadedMileRatio?: SortOrder
    deadheadMileRatio?: SortOrder
    utilizationRate?: SortOrder
    tripDistance?: SortOrder
    loadedMiles?: SortOrder
    deadheadMiles?: SortOrder
    tripDurationHours?: SortOrder
    transportLevel?: SortOrder
    priorityLevel?: SortOrder
    costCenterId?: SortOrder
    costCenterName?: SortOrder
    calculatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TripCostBreakdownMinOrderByAggregateInput = {
    id?: SortOrder
    tripId?: SortOrder
    baseRevenue?: SortOrder
    mileageRevenue?: SortOrder
    priorityRevenue?: SortOrder
    specialRequirementsRevenue?: SortOrder
    insuranceAdjustment?: SortOrder
    totalRevenue?: SortOrder
    crewLaborCost?: SortOrder
    vehicleCost?: SortOrder
    fuelCost?: SortOrder
    maintenanceCost?: SortOrder
    overheadCost?: SortOrder
    totalCost?: SortOrder
    grossProfit?: SortOrder
    profitMargin?: SortOrder
    revenuePerMile?: SortOrder
    costPerMile?: SortOrder
    loadedMileRatio?: SortOrder
    deadheadMileRatio?: SortOrder
    utilizationRate?: SortOrder
    tripDistance?: SortOrder
    loadedMiles?: SortOrder
    deadheadMiles?: SortOrder
    tripDurationHours?: SortOrder
    transportLevel?: SortOrder
    priorityLevel?: SortOrder
    costCenterId?: SortOrder
    costCenterName?: SortOrder
    calculatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TripCostBreakdownSumOrderByAggregateInput = {
    baseRevenue?: SortOrder
    mileageRevenue?: SortOrder
    priorityRevenue?: SortOrder
    specialRequirementsRevenue?: SortOrder
    insuranceAdjustment?: SortOrder
    totalRevenue?: SortOrder
    crewLaborCost?: SortOrder
    vehicleCost?: SortOrder
    fuelCost?: SortOrder
    maintenanceCost?: SortOrder
    overheadCost?: SortOrder
    totalCost?: SortOrder
    grossProfit?: SortOrder
    profitMargin?: SortOrder
    revenuePerMile?: SortOrder
    costPerMile?: SortOrder
    loadedMileRatio?: SortOrder
    deadheadMileRatio?: SortOrder
    utilizationRate?: SortOrder
    tripDistance?: SortOrder
    loadedMiles?: SortOrder
    deadheadMiles?: SortOrder
    tripDurationHours?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type CostCenterCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    code?: SortOrder
    overheadRate?: SortOrder
    fixedCosts?: SortOrder
    variableCosts?: SortOrder
    allocationMethod?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CostCenterAvgOrderByAggregateInput = {
    overheadRate?: SortOrder
    fixedCosts?: SortOrder
    variableCosts?: SortOrder
  }

  export type CostCenterMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    code?: SortOrder
    overheadRate?: SortOrder
    fixedCosts?: SortOrder
    variableCosts?: SortOrder
    allocationMethod?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CostCenterMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    code?: SortOrder
    overheadRate?: SortOrder
    fixedCosts?: SortOrder
    variableCosts?: SortOrder
    allocationMethod?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CostCenterSumOrderByAggregateInput = {
    overheadRate?: SortOrder
    fixedCosts?: SortOrder
    variableCosts?: SortOrder
  }

  export type backhaul_opportunitiesCountOrderByAggregateInput = {
    id?: SortOrder
    tripId1?: SortOrder
    tripId2?: SortOrder
    revenueBonus?: SortOrder
    efficiency?: SortOrder
    createdAt?: SortOrder
    isActive?: SortOrder
  }

  export type backhaul_opportunitiesAvgOrderByAggregateInput = {
    revenueBonus?: SortOrder
    efficiency?: SortOrder
  }

  export type backhaul_opportunitiesMaxOrderByAggregateInput = {
    id?: SortOrder
    tripId1?: SortOrder
    tripId2?: SortOrder
    revenueBonus?: SortOrder
    efficiency?: SortOrder
    createdAt?: SortOrder
    isActive?: SortOrder
  }

  export type backhaul_opportunitiesMinOrderByAggregateInput = {
    id?: SortOrder
    tripId1?: SortOrder
    tripId2?: SortOrder
    revenueBonus?: SortOrder
    efficiency?: SortOrder
    createdAt?: SortOrder
    isActive?: SortOrder
  }

  export type backhaul_opportunitiesSumOrderByAggregateInput = {
    revenueBonus?: SortOrder
    efficiency?: SortOrder
  }

  export type TripListRelationFilter = {
    every?: TripWhereInput
    some?: TripWhereInput
    none?: TripWhereInput
  }

  export type TripOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type pickup_locationsCountOrderByAggregateInput = {
    id?: SortOrder
    hospitalId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    contactPhone?: SortOrder
    contactEmail?: SortOrder
    floor?: SortOrder
    room?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type pickup_locationsMaxOrderByAggregateInput = {
    id?: SortOrder
    hospitalId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    contactPhone?: SortOrder
    contactEmail?: SortOrder
    floor?: SortOrder
    room?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type pickup_locationsMinOrderByAggregateInput = {
    id?: SortOrder
    hospitalId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    contactPhone?: SortOrder
    contactEmail?: SortOrder
    floor?: SortOrder
    room?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type pricing_modelsCountOrderByAggregateInput = {
    id?: SortOrder
    agencyId?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    baseRates?: SortOrder
    perMileRates?: SortOrder
    priorityMultipliers?: SortOrder
    peakHourMultipliers?: SortOrder
    weekendMultipliers?: SortOrder
    seasonalMultipliers?: SortOrder
    zoneMultipliers?: SortOrder
    distanceTiers?: SortOrder
    specialRequirements?: SortOrder
    isolationPricing?: SortOrder
    bariatricPricing?: SortOrder
    oxygenPricing?: SortOrder
    monitoringPricing?: SortOrder
    insuranceRates?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type pricing_modelsAvgOrderByAggregateInput = {
    isolationPricing?: SortOrder
    bariatricPricing?: SortOrder
    oxygenPricing?: SortOrder
    monitoringPricing?: SortOrder
  }

  export type pricing_modelsMaxOrderByAggregateInput = {
    id?: SortOrder
    agencyId?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    isolationPricing?: SortOrder
    bariatricPricing?: SortOrder
    oxygenPricing?: SortOrder
    monitoringPricing?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type pricing_modelsMinOrderByAggregateInput = {
    id?: SortOrder
    agencyId?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    isolationPricing?: SortOrder
    bariatricPricing?: SortOrder
    oxygenPricing?: SortOrder
    monitoringPricing?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type pricing_modelsSumOrderByAggregateInput = {
    isolationPricing?: SortOrder
    bariatricPricing?: SortOrder
    oxygenPricing?: SortOrder
    monitoringPricing?: SortOrder
  }

  export type route_optimization_settingsCountOrderByAggregateInput = {
    id?: SortOrder
    agencyId?: SortOrder
    deadheadMileWeight?: SortOrder
    waitTimeWeight?: SortOrder
    backhaulBonusWeight?: SortOrder
    overtimeRiskWeight?: SortOrder
    revenueWeight?: SortOrder
    maxDeadheadMiles?: SortOrder
    maxWaitTimeMinutes?: SortOrder
    maxOvertimeHours?: SortOrder
    maxResponseTimeMinutes?: SortOrder
    maxServiceDistance?: SortOrder
    backhaulTimeWindow?: SortOrder
    backhaulDistanceLimit?: SortOrder
    backhaulRevenueBonus?: SortOrder
    enableBackhaulOptimization?: SortOrder
    targetLoadedMileRatio?: SortOrder
    targetRevenuePerHour?: SortOrder
    targetResponseTime?: SortOrder
    targetEfficiency?: SortOrder
    optimizationAlgorithm?: SortOrder
    maxOptimizationTime?: SortOrder
    enableRealTimeOptimization?: SortOrder
    crewAvailabilityWeight?: SortOrder
    equipmentCompatibilityWeight?: SortOrder
    patientPriorityWeight?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type route_optimization_settingsAvgOrderByAggregateInput = {
    deadheadMileWeight?: SortOrder
    waitTimeWeight?: SortOrder
    backhaulBonusWeight?: SortOrder
    overtimeRiskWeight?: SortOrder
    revenueWeight?: SortOrder
    maxDeadheadMiles?: SortOrder
    maxWaitTimeMinutes?: SortOrder
    maxOvertimeHours?: SortOrder
    maxResponseTimeMinutes?: SortOrder
    maxServiceDistance?: SortOrder
    backhaulTimeWindow?: SortOrder
    backhaulDistanceLimit?: SortOrder
    backhaulRevenueBonus?: SortOrder
    targetLoadedMileRatio?: SortOrder
    targetRevenuePerHour?: SortOrder
    targetResponseTime?: SortOrder
    targetEfficiency?: SortOrder
    maxOptimizationTime?: SortOrder
    crewAvailabilityWeight?: SortOrder
    equipmentCompatibilityWeight?: SortOrder
    patientPriorityWeight?: SortOrder
  }

  export type route_optimization_settingsMaxOrderByAggregateInput = {
    id?: SortOrder
    agencyId?: SortOrder
    deadheadMileWeight?: SortOrder
    waitTimeWeight?: SortOrder
    backhaulBonusWeight?: SortOrder
    overtimeRiskWeight?: SortOrder
    revenueWeight?: SortOrder
    maxDeadheadMiles?: SortOrder
    maxWaitTimeMinutes?: SortOrder
    maxOvertimeHours?: SortOrder
    maxResponseTimeMinutes?: SortOrder
    maxServiceDistance?: SortOrder
    backhaulTimeWindow?: SortOrder
    backhaulDistanceLimit?: SortOrder
    backhaulRevenueBonus?: SortOrder
    enableBackhaulOptimization?: SortOrder
    targetLoadedMileRatio?: SortOrder
    targetRevenuePerHour?: SortOrder
    targetResponseTime?: SortOrder
    targetEfficiency?: SortOrder
    optimizationAlgorithm?: SortOrder
    maxOptimizationTime?: SortOrder
    enableRealTimeOptimization?: SortOrder
    crewAvailabilityWeight?: SortOrder
    equipmentCompatibilityWeight?: SortOrder
    patientPriorityWeight?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type route_optimization_settingsMinOrderByAggregateInput = {
    id?: SortOrder
    agencyId?: SortOrder
    deadheadMileWeight?: SortOrder
    waitTimeWeight?: SortOrder
    backhaulBonusWeight?: SortOrder
    overtimeRiskWeight?: SortOrder
    revenueWeight?: SortOrder
    maxDeadheadMiles?: SortOrder
    maxWaitTimeMinutes?: SortOrder
    maxOvertimeHours?: SortOrder
    maxResponseTimeMinutes?: SortOrder
    maxServiceDistance?: SortOrder
    backhaulTimeWindow?: SortOrder
    backhaulDistanceLimit?: SortOrder
    backhaulRevenueBonus?: SortOrder
    enableBackhaulOptimization?: SortOrder
    targetLoadedMileRatio?: SortOrder
    targetRevenuePerHour?: SortOrder
    targetResponseTime?: SortOrder
    targetEfficiency?: SortOrder
    optimizationAlgorithm?: SortOrder
    maxOptimizationTime?: SortOrder
    enableRealTimeOptimization?: SortOrder
    crewAvailabilityWeight?: SortOrder
    equipmentCompatibilityWeight?: SortOrder
    patientPriorityWeight?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type route_optimization_settingsSumOrderByAggregateInput = {
    deadheadMileWeight?: SortOrder
    waitTimeWeight?: SortOrder
    backhaulBonusWeight?: SortOrder
    overtimeRiskWeight?: SortOrder
    revenueWeight?: SortOrder
    maxDeadheadMiles?: SortOrder
    maxWaitTimeMinutes?: SortOrder
    maxOvertimeHours?: SortOrder
    maxResponseTimeMinutes?: SortOrder
    maxServiceDistance?: SortOrder
    backhaulTimeWindow?: SortOrder
    backhaulDistanceLimit?: SortOrder
    backhaulRevenueBonus?: SortOrder
    targetLoadedMileRatio?: SortOrder
    targetRevenuePerHour?: SortOrder
    targetResponseTime?: SortOrder
    targetEfficiency?: SortOrder
    maxOptimizationTime?: SortOrder
    crewAvailabilityWeight?: SortOrder
    equipmentCompatibilityWeight?: SortOrder
    patientPriorityWeight?: SortOrder
  }

  export type Unit_analyticsNullableRelationFilter = {
    is?: unit_analyticsWhereInput | null
    isNot?: unit_analyticsWhereInput | null
  }

  export type EMSAgencyRelationFilter = {
    is?: EMSAgencyWhereInput
    isNot?: EMSAgencyWhereInput
  }

  export type UnitAgencyIdUnitNumberCompoundUniqueInput = {
    agencyId: string
    unitNumber: string
  }

  export type UnitCountOrderByAggregateInput = {
    id?: SortOrder
    agencyId?: SortOrder
    unitNumber?: SortOrder
    type?: SortOrder
    status?: SortOrder
    currentStatus?: SortOrder
    currentLocation?: SortOrder
    capabilities?: SortOrder
    crewSize?: SortOrder
    equipment?: SortOrder
    location?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    lastMaintenance?: SortOrder
    nextMaintenance?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitAvgOrderByAggregateInput = {
    crewSize?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type UnitMaxOrderByAggregateInput = {
    id?: SortOrder
    agencyId?: SortOrder
    unitNumber?: SortOrder
    type?: SortOrder
    status?: SortOrder
    currentStatus?: SortOrder
    currentLocation?: SortOrder
    crewSize?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    lastMaintenance?: SortOrder
    nextMaintenance?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitMinOrderByAggregateInput = {
    id?: SortOrder
    agencyId?: SortOrder
    unitNumber?: SortOrder
    type?: SortOrder
    status?: SortOrder
    currentStatus?: SortOrder
    currentLocation?: SortOrder
    crewSize?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    lastMaintenance?: SortOrder
    nextMaintenance?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitSumOrderByAggregateInput = {
    crewSize?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type UnitRelationFilter = {
    is?: UnitWhereInput
    isNot?: UnitWhereInput
  }

  export type unit_analyticsCountOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    performanceScore?: SortOrder
    efficiency?: SortOrder
    totalTrips?: SortOrder
    totalTripsCompleted?: SortOrder
    averageResponseTime?: SortOrder
    lastUpdated?: SortOrder
  }

  export type unit_analyticsAvgOrderByAggregateInput = {
    performanceScore?: SortOrder
    efficiency?: SortOrder
    totalTrips?: SortOrder
    totalTripsCompleted?: SortOrder
    averageResponseTime?: SortOrder
  }

  export type unit_analyticsMaxOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    performanceScore?: SortOrder
    efficiency?: SortOrder
    totalTrips?: SortOrder
    totalTripsCompleted?: SortOrder
    averageResponseTime?: SortOrder
    lastUpdated?: SortOrder
  }

  export type unit_analyticsMinOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    performanceScore?: SortOrder
    efficiency?: SortOrder
    totalTrips?: SortOrder
    totalTripsCompleted?: SortOrder
    averageResponseTime?: SortOrder
    lastUpdated?: SortOrder
  }

  export type unit_analyticsSumOrderByAggregateInput = {
    performanceScore?: SortOrder
    efficiency?: SortOrder
    totalTrips?: SortOrder
    totalTripsCompleted?: SortOrder
    averageResponseTime?: SortOrder
  }

  export type CenterUserRelationFilter = {
    is?: CenterUserWhereInput
    isNot?: CenterUserWhereInput
  }

  export type NotificationPreferenceUserIdNotificationTypeCompoundUniqueInput = {
    userId: string
    notificationType: string
  }

  export type NotificationPreferenceCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    notificationType?: SortOrder
    emailEnabled?: SortOrder
    smsEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationPreferenceMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    notificationType?: SortOrder
    emailEnabled?: SortOrder
    smsEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationPreferenceMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    notificationType?: SortOrder
    emailEnabled?: SortOrder
    smsEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    notificationType?: SortOrder
    channel?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    deliveredAt?: SortOrder
    errorMessage?: SortOrder
  }

  export type NotificationLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    notificationType?: SortOrder
    channel?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    deliveredAt?: SortOrder
    errorMessage?: SortOrder
  }

  export type NotificationLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    notificationType?: SortOrder
    channel?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    deliveredAt?: SortOrder
    errorMessage?: SortOrder
  }

  export type CategoryDefaultNullableRelationFilter = {
    is?: CategoryDefaultWhereInput | null
    isNot?: CategoryDefaultWhereInput | null
  }

  export type DropdownOptionCategoryValueCompoundUniqueInput = {
    category: string
    value: string
  }

  export type DropdownOptionCountOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    value?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DropdownOptionMaxOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    value?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DropdownOptionMinOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    value?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DropdownOptionRelationFilter = {
    is?: DropdownOptionWhereInput
    isNot?: DropdownOptionWhereInput
  }

  export type CategoryDefaultCountOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    optionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryDefaultMaxOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    optionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryDefaultMinOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    optionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacilityNullableRelationFilter = {
    is?: FacilityWhereInput | null
    isNot?: FacilityWhereInput | null
  }

  export type UnitNullableRelationFilter = {
    is?: UnitWhereInput | null
    isNot?: UnitWhereInput | null
  }

  export type HealthcareLocationNullableRelationFilter = {
    is?: HealthcareLocationWhereInput | null
    isNot?: HealthcareLocationWhereInput | null
  }

  export type TransportRequestCountOrderByAggregateInput = {
    id?: SortOrder
    tripNumber?: SortOrder
    patientId?: SortOrder
    patientWeight?: SortOrder
    specialNeeds?: SortOrder
    originFacilityId?: SortOrder
    destinationFacilityId?: SortOrder
    fromLocation?: SortOrder
    toLocation?: SortOrder
    fromLocationId?: SortOrder
    isMultiLocationFacility?: SortOrder
    scheduledTime?: SortOrder
    transportLevel?: SortOrder
    urgencyLevel?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    specialRequirements?: SortOrder
    diagnosis?: SortOrder
    mobilityLevel?: SortOrder
    oxygenRequired?: SortOrder
    monitoringRequired?: SortOrder
    generateQRCode?: SortOrder
    qrCodeData?: SortOrder
    selectedAgencies?: SortOrder
    notificationRadius?: SortOrder
    requestTimestamp?: SortOrder
    acceptedTimestamp?: SortOrder
    pickupTimestamp?: SortOrder
    arrivalTimestamp?: SortOrder
    departureTimestamp?: SortOrder
    completionTimestamp?: SortOrder
    pickupLocationId?: SortOrder
    assignedAgencyId?: SortOrder
    assignedUnitId?: SortOrder
    createdById?: SortOrder
    healthcareCreatedById?: SortOrder
    isolation?: SortOrder
    bariatric?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransportRequestAvgOrderByAggregateInput = {
    notificationRadius?: SortOrder
  }

  export type TransportRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    tripNumber?: SortOrder
    patientId?: SortOrder
    patientWeight?: SortOrder
    specialNeeds?: SortOrder
    originFacilityId?: SortOrder
    destinationFacilityId?: SortOrder
    fromLocation?: SortOrder
    toLocation?: SortOrder
    fromLocationId?: SortOrder
    isMultiLocationFacility?: SortOrder
    scheduledTime?: SortOrder
    transportLevel?: SortOrder
    urgencyLevel?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    specialRequirements?: SortOrder
    diagnosis?: SortOrder
    mobilityLevel?: SortOrder
    oxygenRequired?: SortOrder
    monitoringRequired?: SortOrder
    generateQRCode?: SortOrder
    qrCodeData?: SortOrder
    notificationRadius?: SortOrder
    requestTimestamp?: SortOrder
    acceptedTimestamp?: SortOrder
    pickupTimestamp?: SortOrder
    arrivalTimestamp?: SortOrder
    departureTimestamp?: SortOrder
    completionTimestamp?: SortOrder
    pickupLocationId?: SortOrder
    assignedAgencyId?: SortOrder
    assignedUnitId?: SortOrder
    createdById?: SortOrder
    healthcareCreatedById?: SortOrder
    isolation?: SortOrder
    bariatric?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransportRequestMinOrderByAggregateInput = {
    id?: SortOrder
    tripNumber?: SortOrder
    patientId?: SortOrder
    patientWeight?: SortOrder
    specialNeeds?: SortOrder
    originFacilityId?: SortOrder
    destinationFacilityId?: SortOrder
    fromLocation?: SortOrder
    toLocation?: SortOrder
    fromLocationId?: SortOrder
    isMultiLocationFacility?: SortOrder
    scheduledTime?: SortOrder
    transportLevel?: SortOrder
    urgencyLevel?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    specialRequirements?: SortOrder
    diagnosis?: SortOrder
    mobilityLevel?: SortOrder
    oxygenRequired?: SortOrder
    monitoringRequired?: SortOrder
    generateQRCode?: SortOrder
    qrCodeData?: SortOrder
    notificationRadius?: SortOrder
    requestTimestamp?: SortOrder
    acceptedTimestamp?: SortOrder
    pickupTimestamp?: SortOrder
    arrivalTimestamp?: SortOrder
    departureTimestamp?: SortOrder
    completionTimestamp?: SortOrder
    pickupLocationId?: SortOrder
    assignedAgencyId?: SortOrder
    assignedUnitId?: SortOrder
    createdById?: SortOrder
    healthcareCreatedById?: SortOrder
    isolation?: SortOrder
    bariatric?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransportRequestSumOrderByAggregateInput = {
    notificationRadius?: SortOrder
  }

  export type FacilityCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    type?: SortOrder
    capabilities?: SortOrder
    region?: SortOrder
    coordinates?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    operatingHours?: SortOrder
    isActive?: SortOrder
    requiresReview?: SortOrder
    approvedAt?: SortOrder
    approvedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacilityAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type FacilityMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    type?: SortOrder
    region?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    operatingHours?: SortOrder
    isActive?: SortOrder
    requiresReview?: SortOrder
    approvedAt?: SortOrder
    approvedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacilityMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    type?: SortOrder
    region?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    operatingHours?: SortOrder
    isActive?: SortOrder
    requiresReview?: SortOrder
    approvedAt?: SortOrder
    approvedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacilitySumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type NotificationLogCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationLogCreateWithoutUserInput, NotificationLogUncheckedCreateWithoutUserInput> | NotificationLogCreateWithoutUserInput[] | NotificationLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationLogCreateOrConnectWithoutUserInput | NotificationLogCreateOrConnectWithoutUserInput[]
    createMany?: NotificationLogCreateManyUserInputEnvelope
    connect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
  }

  export type NotificationPreferenceCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput> | NotificationPreferenceCreateWithoutUserInput[] | NotificationPreferenceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput | NotificationPreferenceCreateOrConnectWithoutUserInput[]
    createMany?: NotificationPreferenceCreateManyUserInputEnvelope
    connect?: NotificationPreferenceWhereUniqueInput | NotificationPreferenceWhereUniqueInput[]
  }

  export type NotificationLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationLogCreateWithoutUserInput, NotificationLogUncheckedCreateWithoutUserInput> | NotificationLogCreateWithoutUserInput[] | NotificationLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationLogCreateOrConnectWithoutUserInput | NotificationLogCreateOrConnectWithoutUserInput[]
    createMany?: NotificationLogCreateManyUserInputEnvelope
    connect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
  }

  export type NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput> | NotificationPreferenceCreateWithoutUserInput[] | NotificationPreferenceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput | NotificationPreferenceCreateOrConnectWithoutUserInput[]
    createMany?: NotificationPreferenceCreateManyUserInputEnvelope
    connect?: NotificationPreferenceWhereUniqueInput | NotificationPreferenceWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NotificationLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationLogCreateWithoutUserInput, NotificationLogUncheckedCreateWithoutUserInput> | NotificationLogCreateWithoutUserInput[] | NotificationLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationLogCreateOrConnectWithoutUserInput | NotificationLogCreateOrConnectWithoutUserInput[]
    upsert?: NotificationLogUpsertWithWhereUniqueWithoutUserInput | NotificationLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationLogCreateManyUserInputEnvelope
    set?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    disconnect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    delete?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    connect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    update?: NotificationLogUpdateWithWhereUniqueWithoutUserInput | NotificationLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationLogUpdateManyWithWhereWithoutUserInput | NotificationLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationLogScalarWhereInput | NotificationLogScalarWhereInput[]
  }

  export type NotificationPreferenceUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput> | NotificationPreferenceCreateWithoutUserInput[] | NotificationPreferenceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput | NotificationPreferenceCreateOrConnectWithoutUserInput[]
    upsert?: NotificationPreferenceUpsertWithWhereUniqueWithoutUserInput | NotificationPreferenceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationPreferenceCreateManyUserInputEnvelope
    set?: NotificationPreferenceWhereUniqueInput | NotificationPreferenceWhereUniqueInput[]
    disconnect?: NotificationPreferenceWhereUniqueInput | NotificationPreferenceWhereUniqueInput[]
    delete?: NotificationPreferenceWhereUniqueInput | NotificationPreferenceWhereUniqueInput[]
    connect?: NotificationPreferenceWhereUniqueInput | NotificationPreferenceWhereUniqueInput[]
    update?: NotificationPreferenceUpdateWithWhereUniqueWithoutUserInput | NotificationPreferenceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationPreferenceUpdateManyWithWhereWithoutUserInput | NotificationPreferenceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationPreferenceScalarWhereInput | NotificationPreferenceScalarWhereInput[]
  }

  export type NotificationLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationLogCreateWithoutUserInput, NotificationLogUncheckedCreateWithoutUserInput> | NotificationLogCreateWithoutUserInput[] | NotificationLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationLogCreateOrConnectWithoutUserInput | NotificationLogCreateOrConnectWithoutUserInput[]
    upsert?: NotificationLogUpsertWithWhereUniqueWithoutUserInput | NotificationLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationLogCreateManyUserInputEnvelope
    set?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    disconnect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    delete?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    connect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    update?: NotificationLogUpdateWithWhereUniqueWithoutUserInput | NotificationLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationLogUpdateManyWithWhereWithoutUserInput | NotificationLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationLogScalarWhereInput | NotificationLogScalarWhereInput[]
  }

  export type NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput> | NotificationPreferenceCreateWithoutUserInput[] | NotificationPreferenceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput | NotificationPreferenceCreateOrConnectWithoutUserInput[]
    upsert?: NotificationPreferenceUpsertWithWhereUniqueWithoutUserInput | NotificationPreferenceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationPreferenceCreateManyUserInputEnvelope
    set?: NotificationPreferenceWhereUniqueInput | NotificationPreferenceWhereUniqueInput[]
    disconnect?: NotificationPreferenceWhereUniqueInput | NotificationPreferenceWhereUniqueInput[]
    delete?: NotificationPreferenceWhereUniqueInput | NotificationPreferenceWhereUniqueInput[]
    connect?: NotificationPreferenceWhereUniqueInput | NotificationPreferenceWhereUniqueInput[]
    update?: NotificationPreferenceUpdateWithWhereUniqueWithoutUserInput | NotificationPreferenceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationPreferenceUpdateManyWithWhereWithoutUserInput | NotificationPreferenceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationPreferenceScalarWhereInput | NotificationPreferenceScalarWhereInput[]
  }

  export type HealthcareLocationCreateNestedManyWithoutHealthcareUserInput = {
    create?: XOR<HealthcareLocationCreateWithoutHealthcareUserInput, HealthcareLocationUncheckedCreateWithoutHealthcareUserInput> | HealthcareLocationCreateWithoutHealthcareUserInput[] | HealthcareLocationUncheckedCreateWithoutHealthcareUserInput[]
    connectOrCreate?: HealthcareLocationCreateOrConnectWithoutHealthcareUserInput | HealthcareLocationCreateOrConnectWithoutHealthcareUserInput[]
    createMany?: HealthcareLocationCreateManyHealthcareUserInputEnvelope
    connect?: HealthcareLocationWhereUniqueInput | HealthcareLocationWhereUniqueInput[]
  }

  export type HealthcareLocationUncheckedCreateNestedManyWithoutHealthcareUserInput = {
    create?: XOR<HealthcareLocationCreateWithoutHealthcareUserInput, HealthcareLocationUncheckedCreateWithoutHealthcareUserInput> | HealthcareLocationCreateWithoutHealthcareUserInput[] | HealthcareLocationUncheckedCreateWithoutHealthcareUserInput[]
    connectOrCreate?: HealthcareLocationCreateOrConnectWithoutHealthcareUserInput | HealthcareLocationCreateOrConnectWithoutHealthcareUserInput[]
    createMany?: HealthcareLocationCreateManyHealthcareUserInputEnvelope
    connect?: HealthcareLocationWhereUniqueInput | HealthcareLocationWhereUniqueInput[]
  }

  export type HealthcareLocationUpdateManyWithoutHealthcareUserNestedInput = {
    create?: XOR<HealthcareLocationCreateWithoutHealthcareUserInput, HealthcareLocationUncheckedCreateWithoutHealthcareUserInput> | HealthcareLocationCreateWithoutHealthcareUserInput[] | HealthcareLocationUncheckedCreateWithoutHealthcareUserInput[]
    connectOrCreate?: HealthcareLocationCreateOrConnectWithoutHealthcareUserInput | HealthcareLocationCreateOrConnectWithoutHealthcareUserInput[]
    upsert?: HealthcareLocationUpsertWithWhereUniqueWithoutHealthcareUserInput | HealthcareLocationUpsertWithWhereUniqueWithoutHealthcareUserInput[]
    createMany?: HealthcareLocationCreateManyHealthcareUserInputEnvelope
    set?: HealthcareLocationWhereUniqueInput | HealthcareLocationWhereUniqueInput[]
    disconnect?: HealthcareLocationWhereUniqueInput | HealthcareLocationWhereUniqueInput[]
    delete?: HealthcareLocationWhereUniqueInput | HealthcareLocationWhereUniqueInput[]
    connect?: HealthcareLocationWhereUniqueInput | HealthcareLocationWhereUniqueInput[]
    update?: HealthcareLocationUpdateWithWhereUniqueWithoutHealthcareUserInput | HealthcareLocationUpdateWithWhereUniqueWithoutHealthcareUserInput[]
    updateMany?: HealthcareLocationUpdateManyWithWhereWithoutHealthcareUserInput | HealthcareLocationUpdateManyWithWhereWithoutHealthcareUserInput[]
    deleteMany?: HealthcareLocationScalarWhereInput | HealthcareLocationScalarWhereInput[]
  }

  export type HealthcareLocationUncheckedUpdateManyWithoutHealthcareUserNestedInput = {
    create?: XOR<HealthcareLocationCreateWithoutHealthcareUserInput, HealthcareLocationUncheckedCreateWithoutHealthcareUserInput> | HealthcareLocationCreateWithoutHealthcareUserInput[] | HealthcareLocationUncheckedCreateWithoutHealthcareUserInput[]
    connectOrCreate?: HealthcareLocationCreateOrConnectWithoutHealthcareUserInput | HealthcareLocationCreateOrConnectWithoutHealthcareUserInput[]
    upsert?: HealthcareLocationUpsertWithWhereUniqueWithoutHealthcareUserInput | HealthcareLocationUpsertWithWhereUniqueWithoutHealthcareUserInput[]
    createMany?: HealthcareLocationCreateManyHealthcareUserInputEnvelope
    set?: HealthcareLocationWhereUniqueInput | HealthcareLocationWhereUniqueInput[]
    disconnect?: HealthcareLocationWhereUniqueInput | HealthcareLocationWhereUniqueInput[]
    delete?: HealthcareLocationWhereUniqueInput | HealthcareLocationWhereUniqueInput[]
    connect?: HealthcareLocationWhereUniqueInput | HealthcareLocationWhereUniqueInput[]
    update?: HealthcareLocationUpdateWithWhereUniqueWithoutHealthcareUserInput | HealthcareLocationUpdateWithWhereUniqueWithoutHealthcareUserInput[]
    updateMany?: HealthcareLocationUpdateManyWithWhereWithoutHealthcareUserInput | HealthcareLocationUpdateManyWithWhereWithoutHealthcareUserInput[]
    deleteMany?: HealthcareLocationScalarWhereInput | HealthcareLocationScalarWhereInput[]
  }

  export type HealthcareUserCreateNestedOneWithoutLocationsInput = {
    create?: XOR<HealthcareUserCreateWithoutLocationsInput, HealthcareUserUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: HealthcareUserCreateOrConnectWithoutLocationsInput
    connect?: HealthcareUserWhereUniqueInput
  }

  export type TransportRequestCreateNestedManyWithoutHealthcareLocationInput = {
    create?: XOR<TransportRequestCreateWithoutHealthcareLocationInput, TransportRequestUncheckedCreateWithoutHealthcareLocationInput> | TransportRequestCreateWithoutHealthcareLocationInput[] | TransportRequestUncheckedCreateWithoutHealthcareLocationInput[]
    connectOrCreate?: TransportRequestCreateOrConnectWithoutHealthcareLocationInput | TransportRequestCreateOrConnectWithoutHealthcareLocationInput[]
    createMany?: TransportRequestCreateManyHealthcareLocationInputEnvelope
    connect?: TransportRequestWhereUniqueInput | TransportRequestWhereUniqueInput[]
  }

  export type TransportRequestUncheckedCreateNestedManyWithoutHealthcareLocationInput = {
    create?: XOR<TransportRequestCreateWithoutHealthcareLocationInput, TransportRequestUncheckedCreateWithoutHealthcareLocationInput> | TransportRequestCreateWithoutHealthcareLocationInput[] | TransportRequestUncheckedCreateWithoutHealthcareLocationInput[]
    connectOrCreate?: TransportRequestCreateOrConnectWithoutHealthcareLocationInput | TransportRequestCreateOrConnectWithoutHealthcareLocationInput[]
    createMany?: TransportRequestCreateManyHealthcareLocationInputEnvelope
    connect?: TransportRequestWhereUniqueInput | TransportRequestWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type HealthcareUserUpdateOneRequiredWithoutLocationsNestedInput = {
    create?: XOR<HealthcareUserCreateWithoutLocationsInput, HealthcareUserUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: HealthcareUserCreateOrConnectWithoutLocationsInput
    upsert?: HealthcareUserUpsertWithoutLocationsInput
    connect?: HealthcareUserWhereUniqueInput
    update?: XOR<XOR<HealthcareUserUpdateToOneWithWhereWithoutLocationsInput, HealthcareUserUpdateWithoutLocationsInput>, HealthcareUserUncheckedUpdateWithoutLocationsInput>
  }

  export type TransportRequestUpdateManyWithoutHealthcareLocationNestedInput = {
    create?: XOR<TransportRequestCreateWithoutHealthcareLocationInput, TransportRequestUncheckedCreateWithoutHealthcareLocationInput> | TransportRequestCreateWithoutHealthcareLocationInput[] | TransportRequestUncheckedCreateWithoutHealthcareLocationInput[]
    connectOrCreate?: TransportRequestCreateOrConnectWithoutHealthcareLocationInput | TransportRequestCreateOrConnectWithoutHealthcareLocationInput[]
    upsert?: TransportRequestUpsertWithWhereUniqueWithoutHealthcareLocationInput | TransportRequestUpsertWithWhereUniqueWithoutHealthcareLocationInput[]
    createMany?: TransportRequestCreateManyHealthcareLocationInputEnvelope
    set?: TransportRequestWhereUniqueInput | TransportRequestWhereUniqueInput[]
    disconnect?: TransportRequestWhereUniqueInput | TransportRequestWhereUniqueInput[]
    delete?: TransportRequestWhereUniqueInput | TransportRequestWhereUniqueInput[]
    connect?: TransportRequestWhereUniqueInput | TransportRequestWhereUniqueInput[]
    update?: TransportRequestUpdateWithWhereUniqueWithoutHealthcareLocationInput | TransportRequestUpdateWithWhereUniqueWithoutHealthcareLocationInput[]
    updateMany?: TransportRequestUpdateManyWithWhereWithoutHealthcareLocationInput | TransportRequestUpdateManyWithWhereWithoutHealthcareLocationInput[]
    deleteMany?: TransportRequestScalarWhereInput | TransportRequestScalarWhereInput[]
  }

  export type TransportRequestUncheckedUpdateManyWithoutHealthcareLocationNestedInput = {
    create?: XOR<TransportRequestCreateWithoutHealthcareLocationInput, TransportRequestUncheckedCreateWithoutHealthcareLocationInput> | TransportRequestCreateWithoutHealthcareLocationInput[] | TransportRequestUncheckedCreateWithoutHealthcareLocationInput[]
    connectOrCreate?: TransportRequestCreateOrConnectWithoutHealthcareLocationInput | TransportRequestCreateOrConnectWithoutHealthcareLocationInput[]
    upsert?: TransportRequestUpsertWithWhereUniqueWithoutHealthcareLocationInput | TransportRequestUpsertWithWhereUniqueWithoutHealthcareLocationInput[]
    createMany?: TransportRequestCreateManyHealthcareLocationInputEnvelope
    set?: TransportRequestWhereUniqueInput | TransportRequestWhereUniqueInput[]
    disconnect?: TransportRequestWhereUniqueInput | TransportRequestWhereUniqueInput[]
    delete?: TransportRequestWhereUniqueInput | TransportRequestWhereUniqueInput[]
    connect?: TransportRequestWhereUniqueInput | TransportRequestWhereUniqueInput[]
    update?: TransportRequestUpdateWithWhereUniqueWithoutHealthcareLocationInput | TransportRequestUpdateWithWhereUniqueWithoutHealthcareLocationInput[]
    updateMany?: TransportRequestUpdateManyWithWhereWithoutHealthcareLocationInput | TransportRequestUpdateManyWithWhereWithoutHealthcareLocationInput[]
    deleteMany?: TransportRequestScalarWhereInput | TransportRequestScalarWhereInput[]
  }

  export type HospitalCreatecapabilitiesInput = {
    set: string[]
  }

  export type HospitalUpdatecapabilitiesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EMSAgencyCreateNestedOneWithoutUsersInput = {
    create?: XOR<EMSAgencyCreateWithoutUsersInput, EMSAgencyUncheckedCreateWithoutUsersInput>
    connectOrCreate?: EMSAgencyCreateOrConnectWithoutUsersInput
    connect?: EMSAgencyWhereUniqueInput
  }

  export type EMSAgencyUpdateOneWithoutUsersNestedInput = {
    create?: XOR<EMSAgencyCreateWithoutUsersInput, EMSAgencyUncheckedCreateWithoutUsersInput>
    connectOrCreate?: EMSAgencyCreateOrConnectWithoutUsersInput
    upsert?: EMSAgencyUpsertWithoutUsersInput
    disconnect?: EMSAgencyWhereInput | boolean
    delete?: EMSAgencyWhereInput | boolean
    connect?: EMSAgencyWhereUniqueInput
    update?: XOR<XOR<EMSAgencyUpdateToOneWithWhereWithoutUsersInput, EMSAgencyUpdateWithoutUsersInput>, EMSAgencyUncheckedUpdateWithoutUsersInput>
  }

  export type EMSAgencyCreateserviceAreaInput = {
    set: string[]
  }

  export type EMSAgencyCreatecapabilitiesInput = {
    set: string[]
  }

  export type EMSAgencyCreatenotificationMethodsInput = {
    set: string[]
  }

  export type UnitCreateNestedManyWithoutAgencyInput = {
    create?: XOR<UnitCreateWithoutAgencyInput, UnitUncheckedCreateWithoutAgencyInput> | UnitCreateWithoutAgencyInput[] | UnitUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutAgencyInput | UnitCreateOrConnectWithoutAgencyInput[]
    createMany?: UnitCreateManyAgencyInputEnvelope
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
  }

  export type EMSUserCreateNestedManyWithoutAgencyInput = {
    create?: XOR<EMSUserCreateWithoutAgencyInput, EMSUserUncheckedCreateWithoutAgencyInput> | EMSUserCreateWithoutAgencyInput[] | EMSUserUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: EMSUserCreateOrConnectWithoutAgencyInput | EMSUserCreateOrConnectWithoutAgencyInput[]
    createMany?: EMSUserCreateManyAgencyInputEnvelope
    connect?: EMSUserWhereUniqueInput | EMSUserWhereUniqueInput[]
  }

  export type UnitUncheckedCreateNestedManyWithoutAgencyInput = {
    create?: XOR<UnitCreateWithoutAgencyInput, UnitUncheckedCreateWithoutAgencyInput> | UnitCreateWithoutAgencyInput[] | UnitUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutAgencyInput | UnitCreateOrConnectWithoutAgencyInput[]
    createMany?: UnitCreateManyAgencyInputEnvelope
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
  }

  export type EMSUserUncheckedCreateNestedManyWithoutAgencyInput = {
    create?: XOR<EMSUserCreateWithoutAgencyInput, EMSUserUncheckedCreateWithoutAgencyInput> | EMSUserCreateWithoutAgencyInput[] | EMSUserUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: EMSUserCreateOrConnectWithoutAgencyInput | EMSUserCreateOrConnectWithoutAgencyInput[]
    createMany?: EMSUserCreateManyAgencyInputEnvelope
    connect?: EMSUserWhereUniqueInput | EMSUserWhereUniqueInput[]
  }

  export type EMSAgencyUpdateserviceAreaInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EMSAgencyUpdatecapabilitiesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EMSAgencyUpdatenotificationMethodsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UnitUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<UnitCreateWithoutAgencyInput, UnitUncheckedCreateWithoutAgencyInput> | UnitCreateWithoutAgencyInput[] | UnitUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutAgencyInput | UnitCreateOrConnectWithoutAgencyInput[]
    upsert?: UnitUpsertWithWhereUniqueWithoutAgencyInput | UnitUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: UnitCreateManyAgencyInputEnvelope
    set?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    disconnect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    delete?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    update?: UnitUpdateWithWhereUniqueWithoutAgencyInput | UnitUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: UnitUpdateManyWithWhereWithoutAgencyInput | UnitUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: UnitScalarWhereInput | UnitScalarWhereInput[]
  }

  export type EMSUserUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<EMSUserCreateWithoutAgencyInput, EMSUserUncheckedCreateWithoutAgencyInput> | EMSUserCreateWithoutAgencyInput[] | EMSUserUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: EMSUserCreateOrConnectWithoutAgencyInput | EMSUserCreateOrConnectWithoutAgencyInput[]
    upsert?: EMSUserUpsertWithWhereUniqueWithoutAgencyInput | EMSUserUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: EMSUserCreateManyAgencyInputEnvelope
    set?: EMSUserWhereUniqueInput | EMSUserWhereUniqueInput[]
    disconnect?: EMSUserWhereUniqueInput | EMSUserWhereUniqueInput[]
    delete?: EMSUserWhereUniqueInput | EMSUserWhereUniqueInput[]
    connect?: EMSUserWhereUniqueInput | EMSUserWhereUniqueInput[]
    update?: EMSUserUpdateWithWhereUniqueWithoutAgencyInput | EMSUserUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: EMSUserUpdateManyWithWhereWithoutAgencyInput | EMSUserUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: EMSUserScalarWhereInput | EMSUserScalarWhereInput[]
  }

  export type UnitUncheckedUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<UnitCreateWithoutAgencyInput, UnitUncheckedCreateWithoutAgencyInput> | UnitCreateWithoutAgencyInput[] | UnitUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutAgencyInput | UnitCreateOrConnectWithoutAgencyInput[]
    upsert?: UnitUpsertWithWhereUniqueWithoutAgencyInput | UnitUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: UnitCreateManyAgencyInputEnvelope
    set?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    disconnect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    delete?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    update?: UnitUpdateWithWhereUniqueWithoutAgencyInput | UnitUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: UnitUpdateManyWithWhereWithoutAgencyInput | UnitUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: UnitScalarWhereInput | UnitScalarWhereInput[]
  }

  export type EMSUserUncheckedUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<EMSUserCreateWithoutAgencyInput, EMSUserUncheckedCreateWithoutAgencyInput> | EMSUserCreateWithoutAgencyInput[] | EMSUserUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: EMSUserCreateOrConnectWithoutAgencyInput | EMSUserCreateOrConnectWithoutAgencyInput[]
    upsert?: EMSUserUpsertWithWhereUniqueWithoutAgencyInput | EMSUserUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: EMSUserCreateManyAgencyInputEnvelope
    set?: EMSUserWhereUniqueInput | EMSUserWhereUniqueInput[]
    disconnect?: EMSUserWhereUniqueInput | EMSUserWhereUniqueInput[]
    delete?: EMSUserWhereUniqueInput | EMSUserWhereUniqueInput[]
    connect?: EMSUserWhereUniqueInput | EMSUserWhereUniqueInput[]
    update?: EMSUserUpdateWithWhereUniqueWithoutAgencyInput | EMSUserUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: EMSUserUpdateManyWithWhereWithoutAgencyInput | EMSUserUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: EMSUserScalarWhereInput | EMSUserScalarWhereInput[]
  }

  export type TripCreateselectedAgenciesInput = {
    set: string[]
  }

  export type AgencyResponseCreateNestedManyWithoutTripInput = {
    create?: XOR<AgencyResponseCreateWithoutTripInput, AgencyResponseUncheckedCreateWithoutTripInput> | AgencyResponseCreateWithoutTripInput[] | AgencyResponseUncheckedCreateWithoutTripInput[]
    connectOrCreate?: AgencyResponseCreateOrConnectWithoutTripInput | AgencyResponseCreateOrConnectWithoutTripInput[]
    createMany?: AgencyResponseCreateManyTripInputEnvelope
    connect?: AgencyResponseWhereUniqueInput | AgencyResponseWhereUniqueInput[]
  }

  export type pickup_locationsCreateNestedOneWithoutLegacyTripsInput = {
    create?: XOR<pickup_locationsCreateWithoutLegacyTripsInput, pickup_locationsUncheckedCreateWithoutLegacyTripsInput>
    connectOrCreate?: pickup_locationsCreateOrConnectWithoutLegacyTripsInput
    connect?: pickup_locationsWhereUniqueInput
  }

  export type AgencyResponseUncheckedCreateNestedManyWithoutTripInput = {
    create?: XOR<AgencyResponseCreateWithoutTripInput, AgencyResponseUncheckedCreateWithoutTripInput> | AgencyResponseCreateWithoutTripInput[] | AgencyResponseUncheckedCreateWithoutTripInput[]
    connectOrCreate?: AgencyResponseCreateOrConnectWithoutTripInput | AgencyResponseCreateOrConnectWithoutTripInput[]
    createMany?: AgencyResponseCreateManyTripInputEnvelope
    connect?: AgencyResponseWhereUniqueInput | AgencyResponseWhereUniqueInput[]
  }

  export type TripUpdateselectedAgenciesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type AgencyResponseUpdateManyWithoutTripNestedInput = {
    create?: XOR<AgencyResponseCreateWithoutTripInput, AgencyResponseUncheckedCreateWithoutTripInput> | AgencyResponseCreateWithoutTripInput[] | AgencyResponseUncheckedCreateWithoutTripInput[]
    connectOrCreate?: AgencyResponseCreateOrConnectWithoutTripInput | AgencyResponseCreateOrConnectWithoutTripInput[]
    upsert?: AgencyResponseUpsertWithWhereUniqueWithoutTripInput | AgencyResponseUpsertWithWhereUniqueWithoutTripInput[]
    createMany?: AgencyResponseCreateManyTripInputEnvelope
    set?: AgencyResponseWhereUniqueInput | AgencyResponseWhereUniqueInput[]
    disconnect?: AgencyResponseWhereUniqueInput | AgencyResponseWhereUniqueInput[]
    delete?: AgencyResponseWhereUniqueInput | AgencyResponseWhereUniqueInput[]
    connect?: AgencyResponseWhereUniqueInput | AgencyResponseWhereUniqueInput[]
    update?: AgencyResponseUpdateWithWhereUniqueWithoutTripInput | AgencyResponseUpdateWithWhereUniqueWithoutTripInput[]
    updateMany?: AgencyResponseUpdateManyWithWhereWithoutTripInput | AgencyResponseUpdateManyWithWhereWithoutTripInput[]
    deleteMany?: AgencyResponseScalarWhereInput | AgencyResponseScalarWhereInput[]
  }

  export type pickup_locationsUpdateOneWithoutLegacyTripsNestedInput = {
    create?: XOR<pickup_locationsCreateWithoutLegacyTripsInput, pickup_locationsUncheckedCreateWithoutLegacyTripsInput>
    connectOrCreate?: pickup_locationsCreateOrConnectWithoutLegacyTripsInput
    upsert?: pickup_locationsUpsertWithoutLegacyTripsInput
    disconnect?: pickup_locationsWhereInput | boolean
    delete?: pickup_locationsWhereInput | boolean
    connect?: pickup_locationsWhereUniqueInput
    update?: XOR<XOR<pickup_locationsUpdateToOneWithWhereWithoutLegacyTripsInput, pickup_locationsUpdateWithoutLegacyTripsInput>, pickup_locationsUncheckedUpdateWithoutLegacyTripsInput>
  }

  export type AgencyResponseUncheckedUpdateManyWithoutTripNestedInput = {
    create?: XOR<AgencyResponseCreateWithoutTripInput, AgencyResponseUncheckedCreateWithoutTripInput> | AgencyResponseCreateWithoutTripInput[] | AgencyResponseUncheckedCreateWithoutTripInput[]
    connectOrCreate?: AgencyResponseCreateOrConnectWithoutTripInput | AgencyResponseCreateOrConnectWithoutTripInput[]
    upsert?: AgencyResponseUpsertWithWhereUniqueWithoutTripInput | AgencyResponseUpsertWithWhereUniqueWithoutTripInput[]
    createMany?: AgencyResponseCreateManyTripInputEnvelope
    set?: AgencyResponseWhereUniqueInput | AgencyResponseWhereUniqueInput[]
    disconnect?: AgencyResponseWhereUniqueInput | AgencyResponseWhereUniqueInput[]
    delete?: AgencyResponseWhereUniqueInput | AgencyResponseWhereUniqueInput[]
    connect?: AgencyResponseWhereUniqueInput | AgencyResponseWhereUniqueInput[]
    update?: AgencyResponseUpdateWithWhereUniqueWithoutTripInput | AgencyResponseUpdateWithWhereUniqueWithoutTripInput[]
    updateMany?: AgencyResponseUpdateManyWithWhereWithoutTripInput | AgencyResponseUpdateManyWithWhereWithoutTripInput[]
    deleteMany?: AgencyResponseScalarWhereInput | AgencyResponseScalarWhereInput[]
  }

  export type TripCreateNestedOneWithoutAgencyResponsesInput = {
    create?: XOR<TripCreateWithoutAgencyResponsesInput, TripUncheckedCreateWithoutAgencyResponsesInput>
    connectOrCreate?: TripCreateOrConnectWithoutAgencyResponsesInput
    connect?: TripWhereUniqueInput
  }

  export type TripUpdateOneRequiredWithoutAgencyResponsesNestedInput = {
    create?: XOR<TripCreateWithoutAgencyResponsesInput, TripUncheckedCreateWithoutAgencyResponsesInput>
    connectOrCreate?: TripCreateOrConnectWithoutAgencyResponsesInput
    upsert?: TripUpsertWithoutAgencyResponsesInput
    connect?: TripWhereUniqueInput
    update?: XOR<XOR<TripUpdateToOneWithWhereWithoutAgencyResponsesInput, TripUpdateWithoutAgencyResponsesInput>, TripUncheckedUpdateWithoutAgencyResponsesInput>
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type TransportRequestCreateNestedManyWithoutPickupLocationInput = {
    create?: XOR<TransportRequestCreateWithoutPickupLocationInput, TransportRequestUncheckedCreateWithoutPickupLocationInput> | TransportRequestCreateWithoutPickupLocationInput[] | TransportRequestUncheckedCreateWithoutPickupLocationInput[]
    connectOrCreate?: TransportRequestCreateOrConnectWithoutPickupLocationInput | TransportRequestCreateOrConnectWithoutPickupLocationInput[]
    createMany?: TransportRequestCreateManyPickupLocationInputEnvelope
    connect?: TransportRequestWhereUniqueInput | TransportRequestWhereUniqueInput[]
  }

  export type TripCreateNestedManyWithoutPickup_locationsInput = {
    create?: XOR<TripCreateWithoutPickup_locationsInput, TripUncheckedCreateWithoutPickup_locationsInput> | TripCreateWithoutPickup_locationsInput[] | TripUncheckedCreateWithoutPickup_locationsInput[]
    connectOrCreate?: TripCreateOrConnectWithoutPickup_locationsInput | TripCreateOrConnectWithoutPickup_locationsInput[]
    createMany?: TripCreateManyPickup_locationsInputEnvelope
    connect?: TripWhereUniqueInput | TripWhereUniqueInput[]
  }

  export type TransportRequestUncheckedCreateNestedManyWithoutPickupLocationInput = {
    create?: XOR<TransportRequestCreateWithoutPickupLocationInput, TransportRequestUncheckedCreateWithoutPickupLocationInput> | TransportRequestCreateWithoutPickupLocationInput[] | TransportRequestUncheckedCreateWithoutPickupLocationInput[]
    connectOrCreate?: TransportRequestCreateOrConnectWithoutPickupLocationInput | TransportRequestCreateOrConnectWithoutPickupLocationInput[]
    createMany?: TransportRequestCreateManyPickupLocationInputEnvelope
    connect?: TransportRequestWhereUniqueInput | TransportRequestWhereUniqueInput[]
  }

  export type TripUncheckedCreateNestedManyWithoutPickup_locationsInput = {
    create?: XOR<TripCreateWithoutPickup_locationsInput, TripUncheckedCreateWithoutPickup_locationsInput> | TripCreateWithoutPickup_locationsInput[] | TripUncheckedCreateWithoutPickup_locationsInput[]
    connectOrCreate?: TripCreateOrConnectWithoutPickup_locationsInput | TripCreateOrConnectWithoutPickup_locationsInput[]
    createMany?: TripCreateManyPickup_locationsInputEnvelope
    connect?: TripWhereUniqueInput | TripWhereUniqueInput[]
  }

  export type TransportRequestUpdateManyWithoutPickupLocationNestedInput = {
    create?: XOR<TransportRequestCreateWithoutPickupLocationInput, TransportRequestUncheckedCreateWithoutPickupLocationInput> | TransportRequestCreateWithoutPickupLocationInput[] | TransportRequestUncheckedCreateWithoutPickupLocationInput[]
    connectOrCreate?: TransportRequestCreateOrConnectWithoutPickupLocationInput | TransportRequestCreateOrConnectWithoutPickupLocationInput[]
    upsert?: TransportRequestUpsertWithWhereUniqueWithoutPickupLocationInput | TransportRequestUpsertWithWhereUniqueWithoutPickupLocationInput[]
    createMany?: TransportRequestCreateManyPickupLocationInputEnvelope
    set?: TransportRequestWhereUniqueInput | TransportRequestWhereUniqueInput[]
    disconnect?: TransportRequestWhereUniqueInput | TransportRequestWhereUniqueInput[]
    delete?: TransportRequestWhereUniqueInput | TransportRequestWhereUniqueInput[]
    connect?: TransportRequestWhereUniqueInput | TransportRequestWhereUniqueInput[]
    update?: TransportRequestUpdateWithWhereUniqueWithoutPickupLocationInput | TransportRequestUpdateWithWhereUniqueWithoutPickupLocationInput[]
    updateMany?: TransportRequestUpdateManyWithWhereWithoutPickupLocationInput | TransportRequestUpdateManyWithWhereWithoutPickupLocationInput[]
    deleteMany?: TransportRequestScalarWhereInput | TransportRequestScalarWhereInput[]
  }

  export type TripUpdateManyWithoutPickup_locationsNestedInput = {
    create?: XOR<TripCreateWithoutPickup_locationsInput, TripUncheckedCreateWithoutPickup_locationsInput> | TripCreateWithoutPickup_locationsInput[] | TripUncheckedCreateWithoutPickup_locationsInput[]
    connectOrCreate?: TripCreateOrConnectWithoutPickup_locationsInput | TripCreateOrConnectWithoutPickup_locationsInput[]
    upsert?: TripUpsertWithWhereUniqueWithoutPickup_locationsInput | TripUpsertWithWhereUniqueWithoutPickup_locationsInput[]
    createMany?: TripCreateManyPickup_locationsInputEnvelope
    set?: TripWhereUniqueInput | TripWhereUniqueInput[]
    disconnect?: TripWhereUniqueInput | TripWhereUniqueInput[]
    delete?: TripWhereUniqueInput | TripWhereUniqueInput[]
    connect?: TripWhereUniqueInput | TripWhereUniqueInput[]
    update?: TripUpdateWithWhereUniqueWithoutPickup_locationsInput | TripUpdateWithWhereUniqueWithoutPickup_locationsInput[]
    updateMany?: TripUpdateManyWithWhereWithoutPickup_locationsInput | TripUpdateManyWithWhereWithoutPickup_locationsInput[]
    deleteMany?: TripScalarWhereInput | TripScalarWhereInput[]
  }

  export type TransportRequestUncheckedUpdateManyWithoutPickupLocationNestedInput = {
    create?: XOR<TransportRequestCreateWithoutPickupLocationInput, TransportRequestUncheckedCreateWithoutPickupLocationInput> | TransportRequestCreateWithoutPickupLocationInput[] | TransportRequestUncheckedCreateWithoutPickupLocationInput[]
    connectOrCreate?: TransportRequestCreateOrConnectWithoutPickupLocationInput | TransportRequestCreateOrConnectWithoutPickupLocationInput[]
    upsert?: TransportRequestUpsertWithWhereUniqueWithoutPickupLocationInput | TransportRequestUpsertWithWhereUniqueWithoutPickupLocationInput[]
    createMany?: TransportRequestCreateManyPickupLocationInputEnvelope
    set?: TransportRequestWhereUniqueInput | TransportRequestWhereUniqueInput[]
    disconnect?: TransportRequestWhereUniqueInput | TransportRequestWhereUniqueInput[]
    delete?: TransportRequestWhereUniqueInput | TransportRequestWhereUniqueInput[]
    connect?: TransportRequestWhereUniqueInput | TransportRequestWhereUniqueInput[]
    update?: TransportRequestUpdateWithWhereUniqueWithoutPickupLocationInput | TransportRequestUpdateWithWhereUniqueWithoutPickupLocationInput[]
    updateMany?: TransportRequestUpdateManyWithWhereWithoutPickupLocationInput | TransportRequestUpdateManyWithWhereWithoutPickupLocationInput[]
    deleteMany?: TransportRequestScalarWhereInput | TransportRequestScalarWhereInput[]
  }

  export type TripUncheckedUpdateManyWithoutPickup_locationsNestedInput = {
    create?: XOR<TripCreateWithoutPickup_locationsInput, TripUncheckedCreateWithoutPickup_locationsInput> | TripCreateWithoutPickup_locationsInput[] | TripUncheckedCreateWithoutPickup_locationsInput[]
    connectOrCreate?: TripCreateOrConnectWithoutPickup_locationsInput | TripCreateOrConnectWithoutPickup_locationsInput[]
    upsert?: TripUpsertWithWhereUniqueWithoutPickup_locationsInput | TripUpsertWithWhereUniqueWithoutPickup_locationsInput[]
    createMany?: TripCreateManyPickup_locationsInputEnvelope
    set?: TripWhereUniqueInput | TripWhereUniqueInput[]
    disconnect?: TripWhereUniqueInput | TripWhereUniqueInput[]
    delete?: TripWhereUniqueInput | TripWhereUniqueInput[]
    connect?: TripWhereUniqueInput | TripWhereUniqueInput[]
    update?: TripUpdateWithWhereUniqueWithoutPickup_locationsInput | TripUpdateWithWhereUniqueWithoutPickup_locationsInput[]
    updateMany?: TripUpdateManyWithWhereWithoutPickup_locationsInput | TripUpdateManyWithWhereWithoutPickup_locationsInput[]
    deleteMany?: TripScalarWhereInput | TripScalarWhereInput[]
  }

  export type UnitCreatecapabilitiesInput = {
    set: string[]
  }

  export type UnitCreateequipmentInput = {
    set: string[]
  }

  export type unit_analyticsCreateNestedOneWithoutUnitInput = {
    create?: XOR<unit_analyticsCreateWithoutUnitInput, unit_analyticsUncheckedCreateWithoutUnitInput>
    connectOrCreate?: unit_analyticsCreateOrConnectWithoutUnitInput
    connect?: unit_analyticsWhereUniqueInput
  }

  export type EMSAgencyCreateNestedOneWithoutUnitsInput = {
    create?: XOR<EMSAgencyCreateWithoutUnitsInput, EMSAgencyUncheckedCreateWithoutUnitsInput>
    connectOrCreate?: EMSAgencyCreateOrConnectWithoutUnitsInput
    connect?: EMSAgencyWhereUniqueInput
  }

  export type TransportRequestCreateNestedManyWithoutAssignedUnitInput = {
    create?: XOR<TransportRequestCreateWithoutAssignedUnitInput, TransportRequestUncheckedCreateWithoutAssignedUnitInput> | TransportRequestCreateWithoutAssignedUnitInput[] | TransportRequestUncheckedCreateWithoutAssignedUnitInput[]
    connectOrCreate?: TransportRequestCreateOrConnectWithoutAssignedUnitInput | TransportRequestCreateOrConnectWithoutAssignedUnitInput[]
    createMany?: TransportRequestCreateManyAssignedUnitInputEnvelope
    connect?: TransportRequestWhereUniqueInput | TransportRequestWhereUniqueInput[]
  }

  export type unit_analyticsUncheckedCreateNestedOneWithoutUnitInput = {
    create?: XOR<unit_analyticsCreateWithoutUnitInput, unit_analyticsUncheckedCreateWithoutUnitInput>
    connectOrCreate?: unit_analyticsCreateOrConnectWithoutUnitInput
    connect?: unit_analyticsWhereUniqueInput
  }

  export type TransportRequestUncheckedCreateNestedManyWithoutAssignedUnitInput = {
    create?: XOR<TransportRequestCreateWithoutAssignedUnitInput, TransportRequestUncheckedCreateWithoutAssignedUnitInput> | TransportRequestCreateWithoutAssignedUnitInput[] | TransportRequestUncheckedCreateWithoutAssignedUnitInput[]
    connectOrCreate?: TransportRequestCreateOrConnectWithoutAssignedUnitInput | TransportRequestCreateOrConnectWithoutAssignedUnitInput[]
    createMany?: TransportRequestCreateManyAssignedUnitInputEnvelope
    connect?: TransportRequestWhereUniqueInput | TransportRequestWhereUniqueInput[]
  }

  export type UnitUpdatecapabilitiesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UnitUpdateequipmentInput = {
    set?: string[]
    push?: string | string[]
  }

  export type unit_analyticsUpdateOneWithoutUnitNestedInput = {
    create?: XOR<unit_analyticsCreateWithoutUnitInput, unit_analyticsUncheckedCreateWithoutUnitInput>
    connectOrCreate?: unit_analyticsCreateOrConnectWithoutUnitInput
    upsert?: unit_analyticsUpsertWithoutUnitInput
    disconnect?: unit_analyticsWhereInput | boolean
    delete?: unit_analyticsWhereInput | boolean
    connect?: unit_analyticsWhereUniqueInput
    update?: XOR<XOR<unit_analyticsUpdateToOneWithWhereWithoutUnitInput, unit_analyticsUpdateWithoutUnitInput>, unit_analyticsUncheckedUpdateWithoutUnitInput>
  }

  export type EMSAgencyUpdateOneRequiredWithoutUnitsNestedInput = {
    create?: XOR<EMSAgencyCreateWithoutUnitsInput, EMSAgencyUncheckedCreateWithoutUnitsInput>
    connectOrCreate?: EMSAgencyCreateOrConnectWithoutUnitsInput
    upsert?: EMSAgencyUpsertWithoutUnitsInput
    connect?: EMSAgencyWhereUniqueInput
    update?: XOR<XOR<EMSAgencyUpdateToOneWithWhereWithoutUnitsInput, EMSAgencyUpdateWithoutUnitsInput>, EMSAgencyUncheckedUpdateWithoutUnitsInput>
  }

  export type TransportRequestUpdateManyWithoutAssignedUnitNestedInput = {
    create?: XOR<TransportRequestCreateWithoutAssignedUnitInput, TransportRequestUncheckedCreateWithoutAssignedUnitInput> | TransportRequestCreateWithoutAssignedUnitInput[] | TransportRequestUncheckedCreateWithoutAssignedUnitInput[]
    connectOrCreate?: TransportRequestCreateOrConnectWithoutAssignedUnitInput | TransportRequestCreateOrConnectWithoutAssignedUnitInput[]
    upsert?: TransportRequestUpsertWithWhereUniqueWithoutAssignedUnitInput | TransportRequestUpsertWithWhereUniqueWithoutAssignedUnitInput[]
    createMany?: TransportRequestCreateManyAssignedUnitInputEnvelope
    set?: TransportRequestWhereUniqueInput | TransportRequestWhereUniqueInput[]
    disconnect?: TransportRequestWhereUniqueInput | TransportRequestWhereUniqueInput[]
    delete?: TransportRequestWhereUniqueInput | TransportRequestWhereUniqueInput[]
    connect?: TransportRequestWhereUniqueInput | TransportRequestWhereUniqueInput[]
    update?: TransportRequestUpdateWithWhereUniqueWithoutAssignedUnitInput | TransportRequestUpdateWithWhereUniqueWithoutAssignedUnitInput[]
    updateMany?: TransportRequestUpdateManyWithWhereWithoutAssignedUnitInput | TransportRequestUpdateManyWithWhereWithoutAssignedUnitInput[]
    deleteMany?: TransportRequestScalarWhereInput | TransportRequestScalarWhereInput[]
  }

  export type unit_analyticsUncheckedUpdateOneWithoutUnitNestedInput = {
    create?: XOR<unit_analyticsCreateWithoutUnitInput, unit_analyticsUncheckedCreateWithoutUnitInput>
    connectOrCreate?: unit_analyticsCreateOrConnectWithoutUnitInput
    upsert?: unit_analyticsUpsertWithoutUnitInput
    disconnect?: unit_analyticsWhereInput | boolean
    delete?: unit_analyticsWhereInput | boolean
    connect?: unit_analyticsWhereUniqueInput
    update?: XOR<XOR<unit_analyticsUpdateToOneWithWhereWithoutUnitInput, unit_analyticsUpdateWithoutUnitInput>, unit_analyticsUncheckedUpdateWithoutUnitInput>
  }

  export type TransportRequestUncheckedUpdateManyWithoutAssignedUnitNestedInput = {
    create?: XOR<TransportRequestCreateWithoutAssignedUnitInput, TransportRequestUncheckedCreateWithoutAssignedUnitInput> | TransportRequestCreateWithoutAssignedUnitInput[] | TransportRequestUncheckedCreateWithoutAssignedUnitInput[]
    connectOrCreate?: TransportRequestCreateOrConnectWithoutAssignedUnitInput | TransportRequestCreateOrConnectWithoutAssignedUnitInput[]
    upsert?: TransportRequestUpsertWithWhereUniqueWithoutAssignedUnitInput | TransportRequestUpsertWithWhereUniqueWithoutAssignedUnitInput[]
    createMany?: TransportRequestCreateManyAssignedUnitInputEnvelope
    set?: TransportRequestWhereUniqueInput | TransportRequestWhereUniqueInput[]
    disconnect?: TransportRequestWhereUniqueInput | TransportRequestWhereUniqueInput[]
    delete?: TransportRequestWhereUniqueInput | TransportRequestWhereUniqueInput[]
    connect?: TransportRequestWhereUniqueInput | TransportRequestWhereUniqueInput[]
    update?: TransportRequestUpdateWithWhereUniqueWithoutAssignedUnitInput | TransportRequestUpdateWithWhereUniqueWithoutAssignedUnitInput[]
    updateMany?: TransportRequestUpdateManyWithWhereWithoutAssignedUnitInput | TransportRequestUpdateManyWithWhereWithoutAssignedUnitInput[]
    deleteMany?: TransportRequestScalarWhereInput | TransportRequestScalarWhereInput[]
  }

  export type UnitCreateNestedOneWithoutAnalyticsInput = {
    create?: XOR<UnitCreateWithoutAnalyticsInput, UnitUncheckedCreateWithoutAnalyticsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutAnalyticsInput
    connect?: UnitWhereUniqueInput
  }

  export type UnitUpdateOneRequiredWithoutAnalyticsNestedInput = {
    create?: XOR<UnitCreateWithoutAnalyticsInput, UnitUncheckedCreateWithoutAnalyticsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutAnalyticsInput
    upsert?: UnitUpsertWithoutAnalyticsInput
    connect?: UnitWhereUniqueInput
    update?: XOR<XOR<UnitUpdateToOneWithWhereWithoutAnalyticsInput, UnitUpdateWithoutAnalyticsInput>, UnitUncheckedUpdateWithoutAnalyticsInput>
  }

  export type CenterUserCreateNestedOneWithoutNotificationPreferencesInput = {
    create?: XOR<CenterUserCreateWithoutNotificationPreferencesInput, CenterUserUncheckedCreateWithoutNotificationPreferencesInput>
    connectOrCreate?: CenterUserCreateOrConnectWithoutNotificationPreferencesInput
    connect?: CenterUserWhereUniqueInput
  }

  export type CenterUserUpdateOneRequiredWithoutNotificationPreferencesNestedInput = {
    create?: XOR<CenterUserCreateWithoutNotificationPreferencesInput, CenterUserUncheckedCreateWithoutNotificationPreferencesInput>
    connectOrCreate?: CenterUserCreateOrConnectWithoutNotificationPreferencesInput
    upsert?: CenterUserUpsertWithoutNotificationPreferencesInput
    connect?: CenterUserWhereUniqueInput
    update?: XOR<XOR<CenterUserUpdateToOneWithWhereWithoutNotificationPreferencesInput, CenterUserUpdateWithoutNotificationPreferencesInput>, CenterUserUncheckedUpdateWithoutNotificationPreferencesInput>
  }

  export type CenterUserCreateNestedOneWithoutNotificationLogsInput = {
    create?: XOR<CenterUserCreateWithoutNotificationLogsInput, CenterUserUncheckedCreateWithoutNotificationLogsInput>
    connectOrCreate?: CenterUserCreateOrConnectWithoutNotificationLogsInput
    connect?: CenterUserWhereUniqueInput
  }

  export type CenterUserUpdateOneRequiredWithoutNotificationLogsNestedInput = {
    create?: XOR<CenterUserCreateWithoutNotificationLogsInput, CenterUserUncheckedCreateWithoutNotificationLogsInput>
    connectOrCreate?: CenterUserCreateOrConnectWithoutNotificationLogsInput
    upsert?: CenterUserUpsertWithoutNotificationLogsInput
    connect?: CenterUserWhereUniqueInput
    update?: XOR<XOR<CenterUserUpdateToOneWithWhereWithoutNotificationLogsInput, CenterUserUpdateWithoutNotificationLogsInput>, CenterUserUncheckedUpdateWithoutNotificationLogsInput>
  }

  export type CategoryDefaultCreateNestedOneWithoutOptionInput = {
    create?: XOR<CategoryDefaultCreateWithoutOptionInput, CategoryDefaultUncheckedCreateWithoutOptionInput>
    connectOrCreate?: CategoryDefaultCreateOrConnectWithoutOptionInput
    connect?: CategoryDefaultWhereUniqueInput
  }

  export type CategoryDefaultUncheckedCreateNestedOneWithoutOptionInput = {
    create?: XOR<CategoryDefaultCreateWithoutOptionInput, CategoryDefaultUncheckedCreateWithoutOptionInput>
    connectOrCreate?: CategoryDefaultCreateOrConnectWithoutOptionInput
    connect?: CategoryDefaultWhereUniqueInput
  }

  export type CategoryDefaultUpdateOneWithoutOptionNestedInput = {
    create?: XOR<CategoryDefaultCreateWithoutOptionInput, CategoryDefaultUncheckedCreateWithoutOptionInput>
    connectOrCreate?: CategoryDefaultCreateOrConnectWithoutOptionInput
    upsert?: CategoryDefaultUpsertWithoutOptionInput
    disconnect?: CategoryDefaultWhereInput | boolean
    delete?: CategoryDefaultWhereInput | boolean
    connect?: CategoryDefaultWhereUniqueInput
    update?: XOR<XOR<CategoryDefaultUpdateToOneWithWhereWithoutOptionInput, CategoryDefaultUpdateWithoutOptionInput>, CategoryDefaultUncheckedUpdateWithoutOptionInput>
  }

  export type CategoryDefaultUncheckedUpdateOneWithoutOptionNestedInput = {
    create?: XOR<CategoryDefaultCreateWithoutOptionInput, CategoryDefaultUncheckedCreateWithoutOptionInput>
    connectOrCreate?: CategoryDefaultCreateOrConnectWithoutOptionInput
    upsert?: CategoryDefaultUpsertWithoutOptionInput
    disconnect?: CategoryDefaultWhereInput | boolean
    delete?: CategoryDefaultWhereInput | boolean
    connect?: CategoryDefaultWhereUniqueInput
    update?: XOR<XOR<CategoryDefaultUpdateToOneWithWhereWithoutOptionInput, CategoryDefaultUpdateWithoutOptionInput>, CategoryDefaultUncheckedUpdateWithoutOptionInput>
  }

  export type DropdownOptionCreateNestedOneWithoutDefaultForInput = {
    create?: XOR<DropdownOptionCreateWithoutDefaultForInput, DropdownOptionUncheckedCreateWithoutDefaultForInput>
    connectOrCreate?: DropdownOptionCreateOrConnectWithoutDefaultForInput
    connect?: DropdownOptionWhereUniqueInput
  }

  export type DropdownOptionUpdateOneRequiredWithoutDefaultForNestedInput = {
    create?: XOR<DropdownOptionCreateWithoutDefaultForInput, DropdownOptionUncheckedCreateWithoutDefaultForInput>
    connectOrCreate?: DropdownOptionCreateOrConnectWithoutDefaultForInput
    upsert?: DropdownOptionUpsertWithoutDefaultForInput
    connect?: DropdownOptionWhereUniqueInput
    update?: XOR<XOR<DropdownOptionUpdateToOneWithWhereWithoutDefaultForInput, DropdownOptionUpdateWithoutDefaultForInput>, DropdownOptionUncheckedUpdateWithoutDefaultForInput>
  }

  export type TransportRequestCreateselectedAgenciesInput = {
    set: string[]
  }

  export type FacilityCreateNestedOneWithoutOriginTripsInput = {
    create?: XOR<FacilityCreateWithoutOriginTripsInput, FacilityUncheckedCreateWithoutOriginTripsInput>
    connectOrCreate?: FacilityCreateOrConnectWithoutOriginTripsInput
    connect?: FacilityWhereUniqueInput
  }

  export type FacilityCreateNestedOneWithoutDestinationTripsInput = {
    create?: XOR<FacilityCreateWithoutDestinationTripsInput, FacilityUncheckedCreateWithoutDestinationTripsInput>
    connectOrCreate?: FacilityCreateOrConnectWithoutDestinationTripsInput
    connect?: FacilityWhereUniqueInput
  }

  export type pickup_locationsCreateNestedOneWithoutTripsInput = {
    create?: XOR<pickup_locationsCreateWithoutTripsInput, pickup_locationsUncheckedCreateWithoutTripsInput>
    connectOrCreate?: pickup_locationsCreateOrConnectWithoutTripsInput
    connect?: pickup_locationsWhereUniqueInput
  }

  export type UnitCreateNestedOneWithoutAssignedTripsInput = {
    create?: XOR<UnitCreateWithoutAssignedTripsInput, UnitUncheckedCreateWithoutAssignedTripsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutAssignedTripsInput
    connect?: UnitWhereUniqueInput
  }

  export type HealthcareLocationCreateNestedOneWithoutTransportRequestsInput = {
    create?: XOR<HealthcareLocationCreateWithoutTransportRequestsInput, HealthcareLocationUncheckedCreateWithoutTransportRequestsInput>
    connectOrCreate?: HealthcareLocationCreateOrConnectWithoutTransportRequestsInput
    connect?: HealthcareLocationWhereUniqueInput
  }

  export type TransportRequestUpdateselectedAgenciesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type FacilityUpdateOneWithoutOriginTripsNestedInput = {
    create?: XOR<FacilityCreateWithoutOriginTripsInput, FacilityUncheckedCreateWithoutOriginTripsInput>
    connectOrCreate?: FacilityCreateOrConnectWithoutOriginTripsInput
    upsert?: FacilityUpsertWithoutOriginTripsInput
    disconnect?: FacilityWhereInput | boolean
    delete?: FacilityWhereInput | boolean
    connect?: FacilityWhereUniqueInput
    update?: XOR<XOR<FacilityUpdateToOneWithWhereWithoutOriginTripsInput, FacilityUpdateWithoutOriginTripsInput>, FacilityUncheckedUpdateWithoutOriginTripsInput>
  }

  export type FacilityUpdateOneWithoutDestinationTripsNestedInput = {
    create?: XOR<FacilityCreateWithoutDestinationTripsInput, FacilityUncheckedCreateWithoutDestinationTripsInput>
    connectOrCreate?: FacilityCreateOrConnectWithoutDestinationTripsInput
    upsert?: FacilityUpsertWithoutDestinationTripsInput
    disconnect?: FacilityWhereInput | boolean
    delete?: FacilityWhereInput | boolean
    connect?: FacilityWhereUniqueInput
    update?: XOR<XOR<FacilityUpdateToOneWithWhereWithoutDestinationTripsInput, FacilityUpdateWithoutDestinationTripsInput>, FacilityUncheckedUpdateWithoutDestinationTripsInput>
  }

  export type pickup_locationsUpdateOneWithoutTripsNestedInput = {
    create?: XOR<pickup_locationsCreateWithoutTripsInput, pickup_locationsUncheckedCreateWithoutTripsInput>
    connectOrCreate?: pickup_locationsCreateOrConnectWithoutTripsInput
    upsert?: pickup_locationsUpsertWithoutTripsInput
    disconnect?: pickup_locationsWhereInput | boolean
    delete?: pickup_locationsWhereInput | boolean
    connect?: pickup_locationsWhereUniqueInput
    update?: XOR<XOR<pickup_locationsUpdateToOneWithWhereWithoutTripsInput, pickup_locationsUpdateWithoutTripsInput>, pickup_locationsUncheckedUpdateWithoutTripsInput>
  }

  export type UnitUpdateOneWithoutAssignedTripsNestedInput = {
    create?: XOR<UnitCreateWithoutAssignedTripsInput, UnitUncheckedCreateWithoutAssignedTripsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutAssignedTripsInput
    upsert?: UnitUpsertWithoutAssignedTripsInput
    disconnect?: UnitWhereInput | boolean
    delete?: UnitWhereInput | boolean
    connect?: UnitWhereUniqueInput
    update?: XOR<XOR<UnitUpdateToOneWithWhereWithoutAssignedTripsInput, UnitUpdateWithoutAssignedTripsInput>, UnitUncheckedUpdateWithoutAssignedTripsInput>
  }

  export type HealthcareLocationUpdateOneWithoutTransportRequestsNestedInput = {
    create?: XOR<HealthcareLocationCreateWithoutTransportRequestsInput, HealthcareLocationUncheckedCreateWithoutTransportRequestsInput>
    connectOrCreate?: HealthcareLocationCreateOrConnectWithoutTransportRequestsInput
    upsert?: HealthcareLocationUpsertWithoutTransportRequestsInput
    disconnect?: HealthcareLocationWhereInput | boolean
    delete?: HealthcareLocationWhereInput | boolean
    connect?: HealthcareLocationWhereUniqueInput
    update?: XOR<XOR<HealthcareLocationUpdateToOneWithWhereWithoutTransportRequestsInput, HealthcareLocationUpdateWithoutTransportRequestsInput>, HealthcareLocationUncheckedUpdateWithoutTransportRequestsInput>
  }

  export type FacilityCreatecapabilitiesInput = {
    set: string[]
  }

  export type TransportRequestCreateNestedManyWithoutOriginFacilityInput = {
    create?: XOR<TransportRequestCreateWithoutOriginFacilityInput, TransportRequestUncheckedCreateWithoutOriginFacilityInput> | TransportRequestCreateWithoutOriginFacilityInput[] | TransportRequestUncheckedCreateWithoutOriginFacilityInput[]
    connectOrCreate?: TransportRequestCreateOrConnectWithoutOriginFacilityInput | TransportRequestCreateOrConnectWithoutOriginFacilityInput[]
    createMany?: TransportRequestCreateManyOriginFacilityInputEnvelope
    connect?: TransportRequestWhereUniqueInput | TransportRequestWhereUniqueInput[]
  }

  export type TransportRequestCreateNestedManyWithoutDestinationFacilityInput = {
    create?: XOR<TransportRequestCreateWithoutDestinationFacilityInput, TransportRequestUncheckedCreateWithoutDestinationFacilityInput> | TransportRequestCreateWithoutDestinationFacilityInput[] | TransportRequestUncheckedCreateWithoutDestinationFacilityInput[]
    connectOrCreate?: TransportRequestCreateOrConnectWithoutDestinationFacilityInput | TransportRequestCreateOrConnectWithoutDestinationFacilityInput[]
    createMany?: TransportRequestCreateManyDestinationFacilityInputEnvelope
    connect?: TransportRequestWhereUniqueInput | TransportRequestWhereUniqueInput[]
  }

  export type TransportRequestUncheckedCreateNestedManyWithoutOriginFacilityInput = {
    create?: XOR<TransportRequestCreateWithoutOriginFacilityInput, TransportRequestUncheckedCreateWithoutOriginFacilityInput> | TransportRequestCreateWithoutOriginFacilityInput[] | TransportRequestUncheckedCreateWithoutOriginFacilityInput[]
    connectOrCreate?: TransportRequestCreateOrConnectWithoutOriginFacilityInput | TransportRequestCreateOrConnectWithoutOriginFacilityInput[]
    createMany?: TransportRequestCreateManyOriginFacilityInputEnvelope
    connect?: TransportRequestWhereUniqueInput | TransportRequestWhereUniqueInput[]
  }

  export type TransportRequestUncheckedCreateNestedManyWithoutDestinationFacilityInput = {
    create?: XOR<TransportRequestCreateWithoutDestinationFacilityInput, TransportRequestUncheckedCreateWithoutDestinationFacilityInput> | TransportRequestCreateWithoutDestinationFacilityInput[] | TransportRequestUncheckedCreateWithoutDestinationFacilityInput[]
    connectOrCreate?: TransportRequestCreateOrConnectWithoutDestinationFacilityInput | TransportRequestCreateOrConnectWithoutDestinationFacilityInput[]
    createMany?: TransportRequestCreateManyDestinationFacilityInputEnvelope
    connect?: TransportRequestWhereUniqueInput | TransportRequestWhereUniqueInput[]
  }

  export type FacilityUpdatecapabilitiesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TransportRequestUpdateManyWithoutOriginFacilityNestedInput = {
    create?: XOR<TransportRequestCreateWithoutOriginFacilityInput, TransportRequestUncheckedCreateWithoutOriginFacilityInput> | TransportRequestCreateWithoutOriginFacilityInput[] | TransportRequestUncheckedCreateWithoutOriginFacilityInput[]
    connectOrCreate?: TransportRequestCreateOrConnectWithoutOriginFacilityInput | TransportRequestCreateOrConnectWithoutOriginFacilityInput[]
    upsert?: TransportRequestUpsertWithWhereUniqueWithoutOriginFacilityInput | TransportRequestUpsertWithWhereUniqueWithoutOriginFacilityInput[]
    createMany?: TransportRequestCreateManyOriginFacilityInputEnvelope
    set?: TransportRequestWhereUniqueInput | TransportRequestWhereUniqueInput[]
    disconnect?: TransportRequestWhereUniqueInput | TransportRequestWhereUniqueInput[]
    delete?: TransportRequestWhereUniqueInput | TransportRequestWhereUniqueInput[]
    connect?: TransportRequestWhereUniqueInput | TransportRequestWhereUniqueInput[]
    update?: TransportRequestUpdateWithWhereUniqueWithoutOriginFacilityInput | TransportRequestUpdateWithWhereUniqueWithoutOriginFacilityInput[]
    updateMany?: TransportRequestUpdateManyWithWhereWithoutOriginFacilityInput | TransportRequestUpdateManyWithWhereWithoutOriginFacilityInput[]
    deleteMany?: TransportRequestScalarWhereInput | TransportRequestScalarWhereInput[]
  }

  export type TransportRequestUpdateManyWithoutDestinationFacilityNestedInput = {
    create?: XOR<TransportRequestCreateWithoutDestinationFacilityInput, TransportRequestUncheckedCreateWithoutDestinationFacilityInput> | TransportRequestCreateWithoutDestinationFacilityInput[] | TransportRequestUncheckedCreateWithoutDestinationFacilityInput[]
    connectOrCreate?: TransportRequestCreateOrConnectWithoutDestinationFacilityInput | TransportRequestCreateOrConnectWithoutDestinationFacilityInput[]
    upsert?: TransportRequestUpsertWithWhereUniqueWithoutDestinationFacilityInput | TransportRequestUpsertWithWhereUniqueWithoutDestinationFacilityInput[]
    createMany?: TransportRequestCreateManyDestinationFacilityInputEnvelope
    set?: TransportRequestWhereUniqueInput | TransportRequestWhereUniqueInput[]
    disconnect?: TransportRequestWhereUniqueInput | TransportRequestWhereUniqueInput[]
    delete?: TransportRequestWhereUniqueInput | TransportRequestWhereUniqueInput[]
    connect?: TransportRequestWhereUniqueInput | TransportRequestWhereUniqueInput[]
    update?: TransportRequestUpdateWithWhereUniqueWithoutDestinationFacilityInput | TransportRequestUpdateWithWhereUniqueWithoutDestinationFacilityInput[]
    updateMany?: TransportRequestUpdateManyWithWhereWithoutDestinationFacilityInput | TransportRequestUpdateManyWithWhereWithoutDestinationFacilityInput[]
    deleteMany?: TransportRequestScalarWhereInput | TransportRequestScalarWhereInput[]
  }

  export type TransportRequestUncheckedUpdateManyWithoutOriginFacilityNestedInput = {
    create?: XOR<TransportRequestCreateWithoutOriginFacilityInput, TransportRequestUncheckedCreateWithoutOriginFacilityInput> | TransportRequestCreateWithoutOriginFacilityInput[] | TransportRequestUncheckedCreateWithoutOriginFacilityInput[]
    connectOrCreate?: TransportRequestCreateOrConnectWithoutOriginFacilityInput | TransportRequestCreateOrConnectWithoutOriginFacilityInput[]
    upsert?: TransportRequestUpsertWithWhereUniqueWithoutOriginFacilityInput | TransportRequestUpsertWithWhereUniqueWithoutOriginFacilityInput[]
    createMany?: TransportRequestCreateManyOriginFacilityInputEnvelope
    set?: TransportRequestWhereUniqueInput | TransportRequestWhereUniqueInput[]
    disconnect?: TransportRequestWhereUniqueInput | TransportRequestWhereUniqueInput[]
    delete?: TransportRequestWhereUniqueInput | TransportRequestWhereUniqueInput[]
    connect?: TransportRequestWhereUniqueInput | TransportRequestWhereUniqueInput[]
    update?: TransportRequestUpdateWithWhereUniqueWithoutOriginFacilityInput | TransportRequestUpdateWithWhereUniqueWithoutOriginFacilityInput[]
    updateMany?: TransportRequestUpdateManyWithWhereWithoutOriginFacilityInput | TransportRequestUpdateManyWithWhereWithoutOriginFacilityInput[]
    deleteMany?: TransportRequestScalarWhereInput | TransportRequestScalarWhereInput[]
  }

  export type TransportRequestUncheckedUpdateManyWithoutDestinationFacilityNestedInput = {
    create?: XOR<TransportRequestCreateWithoutDestinationFacilityInput, TransportRequestUncheckedCreateWithoutDestinationFacilityInput> | TransportRequestCreateWithoutDestinationFacilityInput[] | TransportRequestUncheckedCreateWithoutDestinationFacilityInput[]
    connectOrCreate?: TransportRequestCreateOrConnectWithoutDestinationFacilityInput | TransportRequestCreateOrConnectWithoutDestinationFacilityInput[]
    upsert?: TransportRequestUpsertWithWhereUniqueWithoutDestinationFacilityInput | TransportRequestUpsertWithWhereUniqueWithoutDestinationFacilityInput[]
    createMany?: TransportRequestCreateManyDestinationFacilityInputEnvelope
    set?: TransportRequestWhereUniqueInput | TransportRequestWhereUniqueInput[]
    disconnect?: TransportRequestWhereUniqueInput | TransportRequestWhereUniqueInput[]
    delete?: TransportRequestWhereUniqueInput | TransportRequestWhereUniqueInput[]
    connect?: TransportRequestWhereUniqueInput | TransportRequestWhereUniqueInput[]
    update?: TransportRequestUpdateWithWhereUniqueWithoutDestinationFacilityInput | TransportRequestUpdateWithWhereUniqueWithoutDestinationFacilityInput[]
    updateMany?: TransportRequestUpdateManyWithWhereWithoutDestinationFacilityInput | TransportRequestUpdateManyWithWhereWithoutDestinationFacilityInput[]
    deleteMany?: TransportRequestScalarWhereInput | TransportRequestScalarWhereInput[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NotificationLogCreateWithoutUserInput = {
    id?: string
    notificationType: string
    channel: string
    status: string
    sentAt?: Date | string
    deliveredAt?: Date | string | null
    errorMessage?: string | null
  }

  export type NotificationLogUncheckedCreateWithoutUserInput = {
    id?: string
    notificationType: string
    channel: string
    status: string
    sentAt?: Date | string
    deliveredAt?: Date | string | null
    errorMessage?: string | null
  }

  export type NotificationLogCreateOrConnectWithoutUserInput = {
    where: NotificationLogWhereUniqueInput
    create: XOR<NotificationLogCreateWithoutUserInput, NotificationLogUncheckedCreateWithoutUserInput>
  }

  export type NotificationLogCreateManyUserInputEnvelope = {
    data: NotificationLogCreateManyUserInput | NotificationLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationPreferenceCreateWithoutUserInput = {
    id?: string
    notificationType: string
    emailEnabled?: boolean
    smsEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPreferenceUncheckedCreateWithoutUserInput = {
    id?: string
    notificationType: string
    emailEnabled?: boolean
    smsEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPreferenceCreateOrConnectWithoutUserInput = {
    where: NotificationPreferenceWhereUniqueInput
    create: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
  }

  export type NotificationPreferenceCreateManyUserInputEnvelope = {
    data: NotificationPreferenceCreateManyUserInput | NotificationPreferenceCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationLogUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationLogWhereUniqueInput
    update: XOR<NotificationLogUpdateWithoutUserInput, NotificationLogUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationLogCreateWithoutUserInput, NotificationLogUncheckedCreateWithoutUserInput>
  }

  export type NotificationLogUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationLogWhereUniqueInput
    data: XOR<NotificationLogUpdateWithoutUserInput, NotificationLogUncheckedUpdateWithoutUserInput>
  }

  export type NotificationLogUpdateManyWithWhereWithoutUserInput = {
    where: NotificationLogScalarWhereInput
    data: XOR<NotificationLogUpdateManyMutationInput, NotificationLogUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationLogScalarWhereInput = {
    AND?: NotificationLogScalarWhereInput | NotificationLogScalarWhereInput[]
    OR?: NotificationLogScalarWhereInput[]
    NOT?: NotificationLogScalarWhereInput | NotificationLogScalarWhereInput[]
    id?: StringFilter<"NotificationLog"> | string
    userId?: StringFilter<"NotificationLog"> | string
    notificationType?: StringFilter<"NotificationLog"> | string
    channel?: StringFilter<"NotificationLog"> | string
    status?: StringFilter<"NotificationLog"> | string
    sentAt?: DateTimeFilter<"NotificationLog"> | Date | string
    deliveredAt?: DateTimeNullableFilter<"NotificationLog"> | Date | string | null
    errorMessage?: StringNullableFilter<"NotificationLog"> | string | null
  }

  export type NotificationPreferenceUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationPreferenceWhereUniqueInput
    update: XOR<NotificationPreferenceUpdateWithoutUserInput, NotificationPreferenceUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
  }

  export type NotificationPreferenceUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationPreferenceWhereUniqueInput
    data: XOR<NotificationPreferenceUpdateWithoutUserInput, NotificationPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type NotificationPreferenceUpdateManyWithWhereWithoutUserInput = {
    where: NotificationPreferenceScalarWhereInput
    data: XOR<NotificationPreferenceUpdateManyMutationInput, NotificationPreferenceUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationPreferenceScalarWhereInput = {
    AND?: NotificationPreferenceScalarWhereInput | NotificationPreferenceScalarWhereInput[]
    OR?: NotificationPreferenceScalarWhereInput[]
    NOT?: NotificationPreferenceScalarWhereInput | NotificationPreferenceScalarWhereInput[]
    id?: StringFilter<"NotificationPreference"> | string
    userId?: StringFilter<"NotificationPreference"> | string
    notificationType?: StringFilter<"NotificationPreference"> | string
    emailEnabled?: BoolFilter<"NotificationPreference"> | boolean
    smsEnabled?: BoolFilter<"NotificationPreference"> | boolean
    createdAt?: DateTimeFilter<"NotificationPreference"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationPreference"> | Date | string
  }

  export type HealthcareLocationCreateWithoutHealthcareUserInput = {
    id?: string
    locationName: string
    address: string
    city: string
    state: string
    zipCode: string
    phone?: string | null
    facilityType: string
    isActive?: boolean
    isPrimary?: boolean
    latitude?: number | null
    longitude?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transportRequests?: TransportRequestCreateNestedManyWithoutHealthcareLocationInput
  }

  export type HealthcareLocationUncheckedCreateWithoutHealthcareUserInput = {
    id?: string
    locationName: string
    address: string
    city: string
    state: string
    zipCode: string
    phone?: string | null
    facilityType: string
    isActive?: boolean
    isPrimary?: boolean
    latitude?: number | null
    longitude?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transportRequests?: TransportRequestUncheckedCreateNestedManyWithoutHealthcareLocationInput
  }

  export type HealthcareLocationCreateOrConnectWithoutHealthcareUserInput = {
    where: HealthcareLocationWhereUniqueInput
    create: XOR<HealthcareLocationCreateWithoutHealthcareUserInput, HealthcareLocationUncheckedCreateWithoutHealthcareUserInput>
  }

  export type HealthcareLocationCreateManyHealthcareUserInputEnvelope = {
    data: HealthcareLocationCreateManyHealthcareUserInput | HealthcareLocationCreateManyHealthcareUserInput[]
    skipDuplicates?: boolean
  }

  export type HealthcareLocationUpsertWithWhereUniqueWithoutHealthcareUserInput = {
    where: HealthcareLocationWhereUniqueInput
    update: XOR<HealthcareLocationUpdateWithoutHealthcareUserInput, HealthcareLocationUncheckedUpdateWithoutHealthcareUserInput>
    create: XOR<HealthcareLocationCreateWithoutHealthcareUserInput, HealthcareLocationUncheckedCreateWithoutHealthcareUserInput>
  }

  export type HealthcareLocationUpdateWithWhereUniqueWithoutHealthcareUserInput = {
    where: HealthcareLocationWhereUniqueInput
    data: XOR<HealthcareLocationUpdateWithoutHealthcareUserInput, HealthcareLocationUncheckedUpdateWithoutHealthcareUserInput>
  }

  export type HealthcareLocationUpdateManyWithWhereWithoutHealthcareUserInput = {
    where: HealthcareLocationScalarWhereInput
    data: XOR<HealthcareLocationUpdateManyMutationInput, HealthcareLocationUncheckedUpdateManyWithoutHealthcareUserInput>
  }

  export type HealthcareLocationScalarWhereInput = {
    AND?: HealthcareLocationScalarWhereInput | HealthcareLocationScalarWhereInput[]
    OR?: HealthcareLocationScalarWhereInput[]
    NOT?: HealthcareLocationScalarWhereInput | HealthcareLocationScalarWhereInput[]
    id?: StringFilter<"HealthcareLocation"> | string
    healthcareUserId?: StringFilter<"HealthcareLocation"> | string
    locationName?: StringFilter<"HealthcareLocation"> | string
    address?: StringFilter<"HealthcareLocation"> | string
    city?: StringFilter<"HealthcareLocation"> | string
    state?: StringFilter<"HealthcareLocation"> | string
    zipCode?: StringFilter<"HealthcareLocation"> | string
    phone?: StringNullableFilter<"HealthcareLocation"> | string | null
    facilityType?: StringFilter<"HealthcareLocation"> | string
    isActive?: BoolFilter<"HealthcareLocation"> | boolean
    isPrimary?: BoolFilter<"HealthcareLocation"> | boolean
    latitude?: FloatNullableFilter<"HealthcareLocation"> | number | null
    longitude?: FloatNullableFilter<"HealthcareLocation"> | number | null
    createdAt?: DateTimeFilter<"HealthcareLocation"> | Date | string
    updatedAt?: DateTimeFilter<"HealthcareLocation"> | Date | string
  }

  export type HealthcareUserCreateWithoutLocationsInput = {
    id?: string
    email: string
    password: string
    name: string
    facilityName: string
    facilityType: string
    userType?: string
    isActive?: boolean
    manageMultipleLocations?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HealthcareUserUncheckedCreateWithoutLocationsInput = {
    id?: string
    email: string
    password: string
    name: string
    facilityName: string
    facilityType: string
    userType?: string
    isActive?: boolean
    manageMultipleLocations?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HealthcareUserCreateOrConnectWithoutLocationsInput = {
    where: HealthcareUserWhereUniqueInput
    create: XOR<HealthcareUserCreateWithoutLocationsInput, HealthcareUserUncheckedCreateWithoutLocationsInput>
  }

  export type TransportRequestCreateWithoutHealthcareLocationInput = {
    id?: string
    tripNumber?: string | null
    patientId: string
    patientWeight?: string | null
    specialNeeds?: string | null
    fromLocation?: string | null
    toLocation?: string | null
    isMultiLocationFacility?: boolean
    scheduledTime?: Date | string | null
    transportLevel: string
    urgencyLevel?: string | null
    priority: string
    status?: string
    specialRequirements?: string | null
    diagnosis?: string | null
    mobilityLevel?: string | null
    oxygenRequired?: boolean
    monitoringRequired?: boolean
    generateQRCode?: boolean
    qrCodeData?: string | null
    selectedAgencies?: TransportRequestCreateselectedAgenciesInput | string[]
    notificationRadius?: number | null
    requestTimestamp?: Date | string
    acceptedTimestamp?: Date | string | null
    pickupTimestamp?: Date | string | null
    arrivalTimestamp?: Date | string | null
    departureTimestamp?: Date | string | null
    completionTimestamp?: Date | string | null
    assignedAgencyId?: string | null
    createdById?: string | null
    healthcareCreatedById?: string | null
    isolation?: boolean
    bariatric?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    originFacility?: FacilityCreateNestedOneWithoutOriginTripsInput
    destinationFacility?: FacilityCreateNestedOneWithoutDestinationTripsInput
    pickupLocation?: pickup_locationsCreateNestedOneWithoutTripsInput
    assignedUnit?: UnitCreateNestedOneWithoutAssignedTripsInput
  }

  export type TransportRequestUncheckedCreateWithoutHealthcareLocationInput = {
    id?: string
    tripNumber?: string | null
    patientId: string
    patientWeight?: string | null
    specialNeeds?: string | null
    originFacilityId?: string | null
    destinationFacilityId?: string | null
    fromLocation?: string | null
    toLocation?: string | null
    isMultiLocationFacility?: boolean
    scheduledTime?: Date | string | null
    transportLevel: string
    urgencyLevel?: string | null
    priority: string
    status?: string
    specialRequirements?: string | null
    diagnosis?: string | null
    mobilityLevel?: string | null
    oxygenRequired?: boolean
    monitoringRequired?: boolean
    generateQRCode?: boolean
    qrCodeData?: string | null
    selectedAgencies?: TransportRequestCreateselectedAgenciesInput | string[]
    notificationRadius?: number | null
    requestTimestamp?: Date | string
    acceptedTimestamp?: Date | string | null
    pickupTimestamp?: Date | string | null
    arrivalTimestamp?: Date | string | null
    departureTimestamp?: Date | string | null
    completionTimestamp?: Date | string | null
    pickupLocationId?: string | null
    assignedAgencyId?: string | null
    assignedUnitId?: string | null
    createdById?: string | null
    healthcareCreatedById?: string | null
    isolation?: boolean
    bariatric?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransportRequestCreateOrConnectWithoutHealthcareLocationInput = {
    where: TransportRequestWhereUniqueInput
    create: XOR<TransportRequestCreateWithoutHealthcareLocationInput, TransportRequestUncheckedCreateWithoutHealthcareLocationInput>
  }

  export type TransportRequestCreateManyHealthcareLocationInputEnvelope = {
    data: TransportRequestCreateManyHealthcareLocationInput | TransportRequestCreateManyHealthcareLocationInput[]
    skipDuplicates?: boolean
  }

  export type HealthcareUserUpsertWithoutLocationsInput = {
    update: XOR<HealthcareUserUpdateWithoutLocationsInput, HealthcareUserUncheckedUpdateWithoutLocationsInput>
    create: XOR<HealthcareUserCreateWithoutLocationsInput, HealthcareUserUncheckedCreateWithoutLocationsInput>
    where?: HealthcareUserWhereInput
  }

  export type HealthcareUserUpdateToOneWithWhereWithoutLocationsInput = {
    where?: HealthcareUserWhereInput
    data: XOR<HealthcareUserUpdateWithoutLocationsInput, HealthcareUserUncheckedUpdateWithoutLocationsInput>
  }

  export type HealthcareUserUpdateWithoutLocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    facilityName?: StringFieldUpdateOperationsInput | string
    facilityType?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    manageMultipleLocations?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HealthcareUserUncheckedUpdateWithoutLocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    facilityName?: StringFieldUpdateOperationsInput | string
    facilityType?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    manageMultipleLocations?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransportRequestUpsertWithWhereUniqueWithoutHealthcareLocationInput = {
    where: TransportRequestWhereUniqueInput
    update: XOR<TransportRequestUpdateWithoutHealthcareLocationInput, TransportRequestUncheckedUpdateWithoutHealthcareLocationInput>
    create: XOR<TransportRequestCreateWithoutHealthcareLocationInput, TransportRequestUncheckedCreateWithoutHealthcareLocationInput>
  }

  export type TransportRequestUpdateWithWhereUniqueWithoutHealthcareLocationInput = {
    where: TransportRequestWhereUniqueInput
    data: XOR<TransportRequestUpdateWithoutHealthcareLocationInput, TransportRequestUncheckedUpdateWithoutHealthcareLocationInput>
  }

  export type TransportRequestUpdateManyWithWhereWithoutHealthcareLocationInput = {
    where: TransportRequestScalarWhereInput
    data: XOR<TransportRequestUpdateManyMutationInput, TransportRequestUncheckedUpdateManyWithoutHealthcareLocationInput>
  }

  export type TransportRequestScalarWhereInput = {
    AND?: TransportRequestScalarWhereInput | TransportRequestScalarWhereInput[]
    OR?: TransportRequestScalarWhereInput[]
    NOT?: TransportRequestScalarWhereInput | TransportRequestScalarWhereInput[]
    id?: StringFilter<"TransportRequest"> | string
    tripNumber?: StringNullableFilter<"TransportRequest"> | string | null
    patientId?: StringFilter<"TransportRequest"> | string
    patientWeight?: StringNullableFilter<"TransportRequest"> | string | null
    specialNeeds?: StringNullableFilter<"TransportRequest"> | string | null
    originFacilityId?: StringNullableFilter<"TransportRequest"> | string | null
    destinationFacilityId?: StringNullableFilter<"TransportRequest"> | string | null
    fromLocation?: StringNullableFilter<"TransportRequest"> | string | null
    toLocation?: StringNullableFilter<"TransportRequest"> | string | null
    fromLocationId?: StringNullableFilter<"TransportRequest"> | string | null
    isMultiLocationFacility?: BoolFilter<"TransportRequest"> | boolean
    scheduledTime?: DateTimeNullableFilter<"TransportRequest"> | Date | string | null
    transportLevel?: StringFilter<"TransportRequest"> | string
    urgencyLevel?: StringNullableFilter<"TransportRequest"> | string | null
    priority?: StringFilter<"TransportRequest"> | string
    status?: StringFilter<"TransportRequest"> | string
    specialRequirements?: StringNullableFilter<"TransportRequest"> | string | null
    diagnosis?: StringNullableFilter<"TransportRequest"> | string | null
    mobilityLevel?: StringNullableFilter<"TransportRequest"> | string | null
    oxygenRequired?: BoolFilter<"TransportRequest"> | boolean
    monitoringRequired?: BoolFilter<"TransportRequest"> | boolean
    generateQRCode?: BoolFilter<"TransportRequest"> | boolean
    qrCodeData?: StringNullableFilter<"TransportRequest"> | string | null
    selectedAgencies?: StringNullableListFilter<"TransportRequest">
    notificationRadius?: IntNullableFilter<"TransportRequest"> | number | null
    requestTimestamp?: DateTimeFilter<"TransportRequest"> | Date | string
    acceptedTimestamp?: DateTimeNullableFilter<"TransportRequest"> | Date | string | null
    pickupTimestamp?: DateTimeNullableFilter<"TransportRequest"> | Date | string | null
    arrivalTimestamp?: DateTimeNullableFilter<"TransportRequest"> | Date | string | null
    departureTimestamp?: DateTimeNullableFilter<"TransportRequest"> | Date | string | null
    completionTimestamp?: DateTimeNullableFilter<"TransportRequest"> | Date | string | null
    pickupLocationId?: StringNullableFilter<"TransportRequest"> | string | null
    assignedAgencyId?: StringNullableFilter<"TransportRequest"> | string | null
    assignedUnitId?: StringNullableFilter<"TransportRequest"> | string | null
    createdById?: StringNullableFilter<"TransportRequest"> | string | null
    healthcareCreatedById?: StringNullableFilter<"TransportRequest"> | string | null
    isolation?: BoolFilter<"TransportRequest"> | boolean
    bariatric?: BoolFilter<"TransportRequest"> | boolean
    notes?: StringNullableFilter<"TransportRequest"> | string | null
    createdAt?: DateTimeFilter<"TransportRequest"> | Date | string
    updatedAt?: DateTimeFilter<"TransportRequest"> | Date | string
  }

  export type EMSAgencyCreateWithoutUsersInput = {
    id?: string
    name: string
    contactName: string
    phone: string
    email: string
    address: string
    city: string
    state: string
    zipCode: string
    serviceArea?: EMSAgencyCreateserviceAreaInput | string[]
    operatingHours?: NullableJsonNullValueInput | InputJsonValue
    capabilities?: EMSAgencyCreatecapabilitiesInput | string[]
    pricingStructure?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    status?: string
    addedBy?: string | null
    addedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    acceptsNotifications?: boolean
    approvedAt?: Date | string | null
    approvedBy?: string | null
    availableUnits?: number
    lastUpdated?: Date | string
    latitude?: number | null
    longitude?: number | null
    notificationMethods?: EMSAgencyCreatenotificationMethodsInput | string[]
    requiresReview?: boolean
    serviceRadius?: number | null
    totalUnits?: number
    units?: UnitCreateNestedManyWithoutAgencyInput
  }

  export type EMSAgencyUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    contactName: string
    phone: string
    email: string
    address: string
    city: string
    state: string
    zipCode: string
    serviceArea?: EMSAgencyCreateserviceAreaInput | string[]
    operatingHours?: NullableJsonNullValueInput | InputJsonValue
    capabilities?: EMSAgencyCreatecapabilitiesInput | string[]
    pricingStructure?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    status?: string
    addedBy?: string | null
    addedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    acceptsNotifications?: boolean
    approvedAt?: Date | string | null
    approvedBy?: string | null
    availableUnits?: number
    lastUpdated?: Date | string
    latitude?: number | null
    longitude?: number | null
    notificationMethods?: EMSAgencyCreatenotificationMethodsInput | string[]
    requiresReview?: boolean
    serviceRadius?: number | null
    totalUnits?: number
    units?: UnitUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type EMSAgencyCreateOrConnectWithoutUsersInput = {
    where: EMSAgencyWhereUniqueInput
    create: XOR<EMSAgencyCreateWithoutUsersInput, EMSAgencyUncheckedCreateWithoutUsersInput>
  }

  export type EMSAgencyUpsertWithoutUsersInput = {
    update: XOR<EMSAgencyUpdateWithoutUsersInput, EMSAgencyUncheckedUpdateWithoutUsersInput>
    create: XOR<EMSAgencyCreateWithoutUsersInput, EMSAgencyUncheckedCreateWithoutUsersInput>
    where?: EMSAgencyWhereInput
  }

  export type EMSAgencyUpdateToOneWithWhereWithoutUsersInput = {
    where?: EMSAgencyWhereInput
    data: XOR<EMSAgencyUpdateWithoutUsersInput, EMSAgencyUncheckedUpdateWithoutUsersInput>
  }

  export type EMSAgencyUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    serviceArea?: EMSAgencyUpdateserviceAreaInput | string[]
    operatingHours?: NullableJsonNullValueInput | InputJsonValue
    capabilities?: EMSAgencyUpdatecapabilitiesInput | string[]
    pricingStructure?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    addedBy?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptsNotifications?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    availableUnits?: IntFieldUpdateOperationsInput | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    notificationMethods?: EMSAgencyUpdatenotificationMethodsInput | string[]
    requiresReview?: BoolFieldUpdateOperationsInput | boolean
    serviceRadius?: NullableIntFieldUpdateOperationsInput | number | null
    totalUnits?: IntFieldUpdateOperationsInput | number
    units?: UnitUpdateManyWithoutAgencyNestedInput
  }

  export type EMSAgencyUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    serviceArea?: EMSAgencyUpdateserviceAreaInput | string[]
    operatingHours?: NullableJsonNullValueInput | InputJsonValue
    capabilities?: EMSAgencyUpdatecapabilitiesInput | string[]
    pricingStructure?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    addedBy?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptsNotifications?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    availableUnits?: IntFieldUpdateOperationsInput | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    notificationMethods?: EMSAgencyUpdatenotificationMethodsInput | string[]
    requiresReview?: BoolFieldUpdateOperationsInput | boolean
    serviceRadius?: NullableIntFieldUpdateOperationsInput | number | null
    totalUnits?: IntFieldUpdateOperationsInput | number
    units?: UnitUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type UnitCreateWithoutAgencyInput = {
    id?: string
    unitNumber: string
    type: string
    status?: string
    currentStatus?: string
    currentLocation?: string | null
    capabilities?: UnitCreatecapabilitiesInput | string[]
    crewSize?: number
    equipment?: UnitCreateequipmentInput | string[]
    location?: NullableJsonNullValueInput | InputJsonValue
    latitude?: number | null
    longitude?: number | null
    lastMaintenance?: Date | string | null
    nextMaintenance?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    analytics?: unit_analyticsCreateNestedOneWithoutUnitInput
    assignedTrips?: TransportRequestCreateNestedManyWithoutAssignedUnitInput
  }

  export type UnitUncheckedCreateWithoutAgencyInput = {
    id?: string
    unitNumber: string
    type: string
    status?: string
    currentStatus?: string
    currentLocation?: string | null
    capabilities?: UnitCreatecapabilitiesInput | string[]
    crewSize?: number
    equipment?: UnitCreateequipmentInput | string[]
    location?: NullableJsonNullValueInput | InputJsonValue
    latitude?: number | null
    longitude?: number | null
    lastMaintenance?: Date | string | null
    nextMaintenance?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    analytics?: unit_analyticsUncheckedCreateNestedOneWithoutUnitInput
    assignedTrips?: TransportRequestUncheckedCreateNestedManyWithoutAssignedUnitInput
  }

  export type UnitCreateOrConnectWithoutAgencyInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutAgencyInput, UnitUncheckedCreateWithoutAgencyInput>
  }

  export type UnitCreateManyAgencyInputEnvelope = {
    data: UnitCreateManyAgencyInput | UnitCreateManyAgencyInput[]
    skipDuplicates?: boolean
  }

  export type EMSUserCreateWithoutAgencyInput = {
    id?: string
    email: string
    password: string
    name: string
    agencyName: string
    isActive?: boolean
    userType?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EMSUserUncheckedCreateWithoutAgencyInput = {
    id?: string
    email: string
    password: string
    name: string
    agencyName: string
    isActive?: boolean
    userType?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EMSUserCreateOrConnectWithoutAgencyInput = {
    where: EMSUserWhereUniqueInput
    create: XOR<EMSUserCreateWithoutAgencyInput, EMSUserUncheckedCreateWithoutAgencyInput>
  }

  export type EMSUserCreateManyAgencyInputEnvelope = {
    data: EMSUserCreateManyAgencyInput | EMSUserCreateManyAgencyInput[]
    skipDuplicates?: boolean
  }

  export type UnitUpsertWithWhereUniqueWithoutAgencyInput = {
    where: UnitWhereUniqueInput
    update: XOR<UnitUpdateWithoutAgencyInput, UnitUncheckedUpdateWithoutAgencyInput>
    create: XOR<UnitCreateWithoutAgencyInput, UnitUncheckedCreateWithoutAgencyInput>
  }

  export type UnitUpdateWithWhereUniqueWithoutAgencyInput = {
    where: UnitWhereUniqueInput
    data: XOR<UnitUpdateWithoutAgencyInput, UnitUncheckedUpdateWithoutAgencyInput>
  }

  export type UnitUpdateManyWithWhereWithoutAgencyInput = {
    where: UnitScalarWhereInput
    data: XOR<UnitUpdateManyMutationInput, UnitUncheckedUpdateManyWithoutAgencyInput>
  }

  export type UnitScalarWhereInput = {
    AND?: UnitScalarWhereInput | UnitScalarWhereInput[]
    OR?: UnitScalarWhereInput[]
    NOT?: UnitScalarWhereInput | UnitScalarWhereInput[]
    id?: StringFilter<"Unit"> | string
    agencyId?: StringFilter<"Unit"> | string
    unitNumber?: StringFilter<"Unit"> | string
    type?: StringFilter<"Unit"> | string
    status?: StringFilter<"Unit"> | string
    currentStatus?: StringFilter<"Unit"> | string
    currentLocation?: StringNullableFilter<"Unit"> | string | null
    capabilities?: StringNullableListFilter<"Unit">
    crewSize?: IntFilter<"Unit"> | number
    equipment?: StringNullableListFilter<"Unit">
    location?: JsonNullableFilter<"Unit">
    latitude?: FloatNullableFilter<"Unit"> | number | null
    longitude?: FloatNullableFilter<"Unit"> | number | null
    lastMaintenance?: DateTimeNullableFilter<"Unit"> | Date | string | null
    nextMaintenance?: DateTimeNullableFilter<"Unit"> | Date | string | null
    isActive?: BoolFilter<"Unit"> | boolean
    createdAt?: DateTimeFilter<"Unit"> | Date | string
    updatedAt?: DateTimeFilter<"Unit"> | Date | string
  }

  export type EMSUserUpsertWithWhereUniqueWithoutAgencyInput = {
    where: EMSUserWhereUniqueInput
    update: XOR<EMSUserUpdateWithoutAgencyInput, EMSUserUncheckedUpdateWithoutAgencyInput>
    create: XOR<EMSUserCreateWithoutAgencyInput, EMSUserUncheckedCreateWithoutAgencyInput>
  }

  export type EMSUserUpdateWithWhereUniqueWithoutAgencyInput = {
    where: EMSUserWhereUniqueInput
    data: XOR<EMSUserUpdateWithoutAgencyInput, EMSUserUncheckedUpdateWithoutAgencyInput>
  }

  export type EMSUserUpdateManyWithWhereWithoutAgencyInput = {
    where: EMSUserScalarWhereInput
    data: XOR<EMSUserUpdateManyMutationInput, EMSUserUncheckedUpdateManyWithoutAgencyInput>
  }

  export type EMSUserScalarWhereInput = {
    AND?: EMSUserScalarWhereInput | EMSUserScalarWhereInput[]
    OR?: EMSUserScalarWhereInput[]
    NOT?: EMSUserScalarWhereInput | EMSUserScalarWhereInput[]
    id?: StringFilter<"EMSUser"> | string
    email?: StringFilter<"EMSUser"> | string
    password?: StringFilter<"EMSUser"> | string
    name?: StringFilter<"EMSUser"> | string
    agencyName?: StringFilter<"EMSUser"> | string
    agencyId?: StringNullableFilter<"EMSUser"> | string | null
    isActive?: BoolFilter<"EMSUser"> | boolean
    userType?: StringFilter<"EMSUser"> | string
    createdAt?: DateTimeFilter<"EMSUser"> | Date | string
    updatedAt?: DateTimeFilter<"EMSUser"> | Date | string
  }

  export type AgencyResponseCreateWithoutTripInput = {
    id?: string
    agencyId: string
    response: string
    responseTimestamp?: Date | string
    responseNotes?: string | null
    estimatedArrival?: Date | string | null
    isSelected?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgencyResponseUncheckedCreateWithoutTripInput = {
    id?: string
    agencyId: string
    response: string
    responseTimestamp?: Date | string
    responseNotes?: string | null
    estimatedArrival?: Date | string | null
    isSelected?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgencyResponseCreateOrConnectWithoutTripInput = {
    where: AgencyResponseWhereUniqueInput
    create: XOR<AgencyResponseCreateWithoutTripInput, AgencyResponseUncheckedCreateWithoutTripInput>
  }

  export type AgencyResponseCreateManyTripInputEnvelope = {
    data: AgencyResponseCreateManyTripInput | AgencyResponseCreateManyTripInput[]
    skipDuplicates?: boolean
  }

  export type pickup_locationsCreateWithoutLegacyTripsInput = {
    id: string
    hospitalId: string
    name: string
    description?: string | null
    contactPhone?: string | null
    contactEmail?: string | null
    floor?: string | null
    room?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    trips?: TransportRequestCreateNestedManyWithoutPickupLocationInput
  }

  export type pickup_locationsUncheckedCreateWithoutLegacyTripsInput = {
    id: string
    hospitalId: string
    name: string
    description?: string | null
    contactPhone?: string | null
    contactEmail?: string | null
    floor?: string | null
    room?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    trips?: TransportRequestUncheckedCreateNestedManyWithoutPickupLocationInput
  }

  export type pickup_locationsCreateOrConnectWithoutLegacyTripsInput = {
    where: pickup_locationsWhereUniqueInput
    create: XOR<pickup_locationsCreateWithoutLegacyTripsInput, pickup_locationsUncheckedCreateWithoutLegacyTripsInput>
  }

  export type AgencyResponseUpsertWithWhereUniqueWithoutTripInput = {
    where: AgencyResponseWhereUniqueInput
    update: XOR<AgencyResponseUpdateWithoutTripInput, AgencyResponseUncheckedUpdateWithoutTripInput>
    create: XOR<AgencyResponseCreateWithoutTripInput, AgencyResponseUncheckedCreateWithoutTripInput>
  }

  export type AgencyResponseUpdateWithWhereUniqueWithoutTripInput = {
    where: AgencyResponseWhereUniqueInput
    data: XOR<AgencyResponseUpdateWithoutTripInput, AgencyResponseUncheckedUpdateWithoutTripInput>
  }

  export type AgencyResponseUpdateManyWithWhereWithoutTripInput = {
    where: AgencyResponseScalarWhereInput
    data: XOR<AgencyResponseUpdateManyMutationInput, AgencyResponseUncheckedUpdateManyWithoutTripInput>
  }

  export type AgencyResponseScalarWhereInput = {
    AND?: AgencyResponseScalarWhereInput | AgencyResponseScalarWhereInput[]
    OR?: AgencyResponseScalarWhereInput[]
    NOT?: AgencyResponseScalarWhereInput | AgencyResponseScalarWhereInput[]
    id?: StringFilter<"AgencyResponse"> | string
    tripId?: StringFilter<"AgencyResponse"> | string
    agencyId?: StringFilter<"AgencyResponse"> | string
    response?: StringFilter<"AgencyResponse"> | string
    responseTimestamp?: DateTimeFilter<"AgencyResponse"> | Date | string
    responseNotes?: StringNullableFilter<"AgencyResponse"> | string | null
    estimatedArrival?: DateTimeNullableFilter<"AgencyResponse"> | Date | string | null
    isSelected?: BoolFilter<"AgencyResponse"> | boolean
    createdAt?: DateTimeFilter<"AgencyResponse"> | Date | string
    updatedAt?: DateTimeFilter<"AgencyResponse"> | Date | string
  }

  export type pickup_locationsUpsertWithoutLegacyTripsInput = {
    update: XOR<pickup_locationsUpdateWithoutLegacyTripsInput, pickup_locationsUncheckedUpdateWithoutLegacyTripsInput>
    create: XOR<pickup_locationsCreateWithoutLegacyTripsInput, pickup_locationsUncheckedCreateWithoutLegacyTripsInput>
    where?: pickup_locationsWhereInput
  }

  export type pickup_locationsUpdateToOneWithWhereWithoutLegacyTripsInput = {
    where?: pickup_locationsWhereInput
    data: XOR<pickup_locationsUpdateWithoutLegacyTripsInput, pickup_locationsUncheckedUpdateWithoutLegacyTripsInput>
  }

  export type pickup_locationsUpdateWithoutLegacyTripsInput = {
    id?: StringFieldUpdateOperationsInput | string
    hospitalId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trips?: TransportRequestUpdateManyWithoutPickupLocationNestedInput
  }

  export type pickup_locationsUncheckedUpdateWithoutLegacyTripsInput = {
    id?: StringFieldUpdateOperationsInput | string
    hospitalId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trips?: TransportRequestUncheckedUpdateManyWithoutPickupLocationNestedInput
  }

  export type TripCreateWithoutAgencyResponsesInput = {
    id?: string
    tripNumber: string
    patientId: string
    patientWeight?: string | null
    specialNeeds?: string | null
    fromLocation: string
    toLocation: string
    scheduledTime: Date | string
    transportLevel: string
    urgencyLevel: string
    diagnosis?: string | null
    mobilityLevel?: string | null
    oxygenRequired?: boolean
    monitoringRequired?: boolean
    generateQRCode?: boolean
    qrCodeData?: string | null
    selectedAgencies?: TripCreateselectedAgenciesInput | string[]
    notificationRadius?: number | null
    transferRequestTime?: Date | string | null
    transferAcceptedTime?: Date | string | null
    emsArrivalTime?: Date | string | null
    emsDepartureTime?: Date | string | null
    actualStartTime?: Date | string | null
    actualEndTime?: Date | string | null
    status: string
    priority: string
    notes?: string | null
    assignedTo?: string | null
    assignedAgencyId?: string | null
    assignedUnitId?: string | null
    acceptedTimestamp?: Date | string | null
    pickupTimestamp?: Date | string | null
    completionTimestamp?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    actualTripTimeMinutes?: number | null
    backhaulOpportunity?: boolean
    completionTimeMinutes?: number | null
    customerSatisfaction?: number | null
    deadheadMiles?: number | null
    destinationLatitude?: number | null
    destinationLongitude?: number | null
    distanceMiles?: number | null
    efficiency?: Decimal | DecimalJsLike | number | string | null
    estimatedTripTimeMinutes?: number | null
    insuranceCompany?: string | null
    insurancePayRate?: Decimal | DecimalJsLike | number | string | null
    loadedMiles?: Decimal | DecimalJsLike | number | string | null
    originLatitude?: number | null
    originLongitude?: number | null
    perMileRate?: Decimal | DecimalJsLike | number | string | null
    performanceScore?: Decimal | DecimalJsLike | number | string | null
    requestTimestamp?: Date | string | null
    responseTimeMinutes?: number | null
    revenuePerHour?: Decimal | DecimalJsLike | number | string | null
    tripCost?: Decimal | DecimalJsLike | number | string | null
    maxResponses?: number
    responseDeadline?: Date | string | null
    responseStatus?: string
    selectionMode?: string
    pickup_locations?: pickup_locationsCreateNestedOneWithoutLegacyTripsInput
  }

  export type TripUncheckedCreateWithoutAgencyResponsesInput = {
    id?: string
    tripNumber: string
    patientId: string
    patientWeight?: string | null
    specialNeeds?: string | null
    fromLocation: string
    toLocation: string
    scheduledTime: Date | string
    transportLevel: string
    urgencyLevel: string
    diagnosis?: string | null
    mobilityLevel?: string | null
    oxygenRequired?: boolean
    monitoringRequired?: boolean
    generateQRCode?: boolean
    qrCodeData?: string | null
    selectedAgencies?: TripCreateselectedAgenciesInput | string[]
    notificationRadius?: number | null
    transferRequestTime?: Date | string | null
    transferAcceptedTime?: Date | string | null
    emsArrivalTime?: Date | string | null
    emsDepartureTime?: Date | string | null
    actualStartTime?: Date | string | null
    actualEndTime?: Date | string | null
    status: string
    priority: string
    notes?: string | null
    assignedTo?: string | null
    assignedAgencyId?: string | null
    assignedUnitId?: string | null
    acceptedTimestamp?: Date | string | null
    pickupTimestamp?: Date | string | null
    completionTimestamp?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    actualTripTimeMinutes?: number | null
    backhaulOpportunity?: boolean
    completionTimeMinutes?: number | null
    customerSatisfaction?: number | null
    deadheadMiles?: number | null
    destinationLatitude?: number | null
    destinationLongitude?: number | null
    distanceMiles?: number | null
    efficiency?: Decimal | DecimalJsLike | number | string | null
    estimatedTripTimeMinutes?: number | null
    insuranceCompany?: string | null
    insurancePayRate?: Decimal | DecimalJsLike | number | string | null
    loadedMiles?: Decimal | DecimalJsLike | number | string | null
    originLatitude?: number | null
    originLongitude?: number | null
    perMileRate?: Decimal | DecimalJsLike | number | string | null
    performanceScore?: Decimal | DecimalJsLike | number | string | null
    requestTimestamp?: Date | string | null
    responseTimeMinutes?: number | null
    revenuePerHour?: Decimal | DecimalJsLike | number | string | null
    tripCost?: Decimal | DecimalJsLike | number | string | null
    pickupLocationId?: string | null
    maxResponses?: number
    responseDeadline?: Date | string | null
    responseStatus?: string
    selectionMode?: string
  }

  export type TripCreateOrConnectWithoutAgencyResponsesInput = {
    where: TripWhereUniqueInput
    create: XOR<TripCreateWithoutAgencyResponsesInput, TripUncheckedCreateWithoutAgencyResponsesInput>
  }

  export type TripUpsertWithoutAgencyResponsesInput = {
    update: XOR<TripUpdateWithoutAgencyResponsesInput, TripUncheckedUpdateWithoutAgencyResponsesInput>
    create: XOR<TripCreateWithoutAgencyResponsesInput, TripUncheckedCreateWithoutAgencyResponsesInput>
    where?: TripWhereInput
  }

  export type TripUpdateToOneWithWhereWithoutAgencyResponsesInput = {
    where?: TripWhereInput
    data: XOR<TripUpdateWithoutAgencyResponsesInput, TripUncheckedUpdateWithoutAgencyResponsesInput>
  }

  export type TripUpdateWithoutAgencyResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripNumber?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    patientWeight?: NullableStringFieldUpdateOperationsInput | string | null
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocation?: StringFieldUpdateOperationsInput | string
    toLocation?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    transportLevel?: StringFieldUpdateOperationsInput | string
    urgencyLevel?: StringFieldUpdateOperationsInput | string
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    mobilityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    oxygenRequired?: BoolFieldUpdateOperationsInput | boolean
    monitoringRequired?: BoolFieldUpdateOperationsInput | boolean
    generateQRCode?: BoolFieldUpdateOperationsInput | boolean
    qrCodeData?: NullableStringFieldUpdateOperationsInput | string | null
    selectedAgencies?: TripUpdateselectedAgenciesInput | string[]
    notificationRadius?: NullableIntFieldUpdateOperationsInput | number | null
    transferRequestTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferAcceptedTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emsArrivalTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emsDepartureTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAgencyId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actualTripTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    backhaulOpportunity?: BoolFieldUpdateOperationsInput | boolean
    completionTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    customerSatisfaction?: NullableIntFieldUpdateOperationsInput | number | null
    deadheadMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    distanceMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    efficiency?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    estimatedTripTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    insuranceCompany?: NullableStringFieldUpdateOperationsInput | string | null
    insurancePayRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loadedMiles?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    originLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    perMileRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    performanceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    requestTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    revenuePerHour?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tripCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxResponses?: IntFieldUpdateOperationsInput | number
    responseDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseStatus?: StringFieldUpdateOperationsInput | string
    selectionMode?: StringFieldUpdateOperationsInput | string
    pickup_locations?: pickup_locationsUpdateOneWithoutLegacyTripsNestedInput
  }

  export type TripUncheckedUpdateWithoutAgencyResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripNumber?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    patientWeight?: NullableStringFieldUpdateOperationsInput | string | null
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocation?: StringFieldUpdateOperationsInput | string
    toLocation?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    transportLevel?: StringFieldUpdateOperationsInput | string
    urgencyLevel?: StringFieldUpdateOperationsInput | string
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    mobilityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    oxygenRequired?: BoolFieldUpdateOperationsInput | boolean
    monitoringRequired?: BoolFieldUpdateOperationsInput | boolean
    generateQRCode?: BoolFieldUpdateOperationsInput | boolean
    qrCodeData?: NullableStringFieldUpdateOperationsInput | string | null
    selectedAgencies?: TripUpdateselectedAgenciesInput | string[]
    notificationRadius?: NullableIntFieldUpdateOperationsInput | number | null
    transferRequestTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferAcceptedTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emsArrivalTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emsDepartureTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAgencyId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actualTripTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    backhaulOpportunity?: BoolFieldUpdateOperationsInput | boolean
    completionTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    customerSatisfaction?: NullableIntFieldUpdateOperationsInput | number | null
    deadheadMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    distanceMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    efficiency?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    estimatedTripTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    insuranceCompany?: NullableStringFieldUpdateOperationsInput | string | null
    insurancePayRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loadedMiles?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    originLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    perMileRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    performanceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    requestTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    revenuePerHour?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tripCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pickupLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    maxResponses?: IntFieldUpdateOperationsInput | number
    responseDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseStatus?: StringFieldUpdateOperationsInput | string
    selectionMode?: StringFieldUpdateOperationsInput | string
  }

  export type TransportRequestCreateWithoutPickupLocationInput = {
    id?: string
    tripNumber?: string | null
    patientId: string
    patientWeight?: string | null
    specialNeeds?: string | null
    fromLocation?: string | null
    toLocation?: string | null
    isMultiLocationFacility?: boolean
    scheduledTime?: Date | string | null
    transportLevel: string
    urgencyLevel?: string | null
    priority: string
    status?: string
    specialRequirements?: string | null
    diagnosis?: string | null
    mobilityLevel?: string | null
    oxygenRequired?: boolean
    monitoringRequired?: boolean
    generateQRCode?: boolean
    qrCodeData?: string | null
    selectedAgencies?: TransportRequestCreateselectedAgenciesInput | string[]
    notificationRadius?: number | null
    requestTimestamp?: Date | string
    acceptedTimestamp?: Date | string | null
    pickupTimestamp?: Date | string | null
    arrivalTimestamp?: Date | string | null
    departureTimestamp?: Date | string | null
    completionTimestamp?: Date | string | null
    assignedAgencyId?: string | null
    createdById?: string | null
    healthcareCreatedById?: string | null
    isolation?: boolean
    bariatric?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    originFacility?: FacilityCreateNestedOneWithoutOriginTripsInput
    destinationFacility?: FacilityCreateNestedOneWithoutDestinationTripsInput
    assignedUnit?: UnitCreateNestedOneWithoutAssignedTripsInput
    healthcareLocation?: HealthcareLocationCreateNestedOneWithoutTransportRequestsInput
  }

  export type TransportRequestUncheckedCreateWithoutPickupLocationInput = {
    id?: string
    tripNumber?: string | null
    patientId: string
    patientWeight?: string | null
    specialNeeds?: string | null
    originFacilityId?: string | null
    destinationFacilityId?: string | null
    fromLocation?: string | null
    toLocation?: string | null
    fromLocationId?: string | null
    isMultiLocationFacility?: boolean
    scheduledTime?: Date | string | null
    transportLevel: string
    urgencyLevel?: string | null
    priority: string
    status?: string
    specialRequirements?: string | null
    diagnosis?: string | null
    mobilityLevel?: string | null
    oxygenRequired?: boolean
    monitoringRequired?: boolean
    generateQRCode?: boolean
    qrCodeData?: string | null
    selectedAgencies?: TransportRequestCreateselectedAgenciesInput | string[]
    notificationRadius?: number | null
    requestTimestamp?: Date | string
    acceptedTimestamp?: Date | string | null
    pickupTimestamp?: Date | string | null
    arrivalTimestamp?: Date | string | null
    departureTimestamp?: Date | string | null
    completionTimestamp?: Date | string | null
    assignedAgencyId?: string | null
    assignedUnitId?: string | null
    createdById?: string | null
    healthcareCreatedById?: string | null
    isolation?: boolean
    bariatric?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransportRequestCreateOrConnectWithoutPickupLocationInput = {
    where: TransportRequestWhereUniqueInput
    create: XOR<TransportRequestCreateWithoutPickupLocationInput, TransportRequestUncheckedCreateWithoutPickupLocationInput>
  }

  export type TransportRequestCreateManyPickupLocationInputEnvelope = {
    data: TransportRequestCreateManyPickupLocationInput | TransportRequestCreateManyPickupLocationInput[]
    skipDuplicates?: boolean
  }

  export type TripCreateWithoutPickup_locationsInput = {
    id?: string
    tripNumber: string
    patientId: string
    patientWeight?: string | null
    specialNeeds?: string | null
    fromLocation: string
    toLocation: string
    scheduledTime: Date | string
    transportLevel: string
    urgencyLevel: string
    diagnosis?: string | null
    mobilityLevel?: string | null
    oxygenRequired?: boolean
    monitoringRequired?: boolean
    generateQRCode?: boolean
    qrCodeData?: string | null
    selectedAgencies?: TripCreateselectedAgenciesInput | string[]
    notificationRadius?: number | null
    transferRequestTime?: Date | string | null
    transferAcceptedTime?: Date | string | null
    emsArrivalTime?: Date | string | null
    emsDepartureTime?: Date | string | null
    actualStartTime?: Date | string | null
    actualEndTime?: Date | string | null
    status: string
    priority: string
    notes?: string | null
    assignedTo?: string | null
    assignedAgencyId?: string | null
    assignedUnitId?: string | null
    acceptedTimestamp?: Date | string | null
    pickupTimestamp?: Date | string | null
    completionTimestamp?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    actualTripTimeMinutes?: number | null
    backhaulOpportunity?: boolean
    completionTimeMinutes?: number | null
    customerSatisfaction?: number | null
    deadheadMiles?: number | null
    destinationLatitude?: number | null
    destinationLongitude?: number | null
    distanceMiles?: number | null
    efficiency?: Decimal | DecimalJsLike | number | string | null
    estimatedTripTimeMinutes?: number | null
    insuranceCompany?: string | null
    insurancePayRate?: Decimal | DecimalJsLike | number | string | null
    loadedMiles?: Decimal | DecimalJsLike | number | string | null
    originLatitude?: number | null
    originLongitude?: number | null
    perMileRate?: Decimal | DecimalJsLike | number | string | null
    performanceScore?: Decimal | DecimalJsLike | number | string | null
    requestTimestamp?: Date | string | null
    responseTimeMinutes?: number | null
    revenuePerHour?: Decimal | DecimalJsLike | number | string | null
    tripCost?: Decimal | DecimalJsLike | number | string | null
    maxResponses?: number
    responseDeadline?: Date | string | null
    responseStatus?: string
    selectionMode?: string
    agencyResponses?: AgencyResponseCreateNestedManyWithoutTripInput
  }

  export type TripUncheckedCreateWithoutPickup_locationsInput = {
    id?: string
    tripNumber: string
    patientId: string
    patientWeight?: string | null
    specialNeeds?: string | null
    fromLocation: string
    toLocation: string
    scheduledTime: Date | string
    transportLevel: string
    urgencyLevel: string
    diagnosis?: string | null
    mobilityLevel?: string | null
    oxygenRequired?: boolean
    monitoringRequired?: boolean
    generateQRCode?: boolean
    qrCodeData?: string | null
    selectedAgencies?: TripCreateselectedAgenciesInput | string[]
    notificationRadius?: number | null
    transferRequestTime?: Date | string | null
    transferAcceptedTime?: Date | string | null
    emsArrivalTime?: Date | string | null
    emsDepartureTime?: Date | string | null
    actualStartTime?: Date | string | null
    actualEndTime?: Date | string | null
    status: string
    priority: string
    notes?: string | null
    assignedTo?: string | null
    assignedAgencyId?: string | null
    assignedUnitId?: string | null
    acceptedTimestamp?: Date | string | null
    pickupTimestamp?: Date | string | null
    completionTimestamp?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    actualTripTimeMinutes?: number | null
    backhaulOpportunity?: boolean
    completionTimeMinutes?: number | null
    customerSatisfaction?: number | null
    deadheadMiles?: number | null
    destinationLatitude?: number | null
    destinationLongitude?: number | null
    distanceMiles?: number | null
    efficiency?: Decimal | DecimalJsLike | number | string | null
    estimatedTripTimeMinutes?: number | null
    insuranceCompany?: string | null
    insurancePayRate?: Decimal | DecimalJsLike | number | string | null
    loadedMiles?: Decimal | DecimalJsLike | number | string | null
    originLatitude?: number | null
    originLongitude?: number | null
    perMileRate?: Decimal | DecimalJsLike | number | string | null
    performanceScore?: Decimal | DecimalJsLike | number | string | null
    requestTimestamp?: Date | string | null
    responseTimeMinutes?: number | null
    revenuePerHour?: Decimal | DecimalJsLike | number | string | null
    tripCost?: Decimal | DecimalJsLike | number | string | null
    maxResponses?: number
    responseDeadline?: Date | string | null
    responseStatus?: string
    selectionMode?: string
    agencyResponses?: AgencyResponseUncheckedCreateNestedManyWithoutTripInput
  }

  export type TripCreateOrConnectWithoutPickup_locationsInput = {
    where: TripWhereUniqueInput
    create: XOR<TripCreateWithoutPickup_locationsInput, TripUncheckedCreateWithoutPickup_locationsInput>
  }

  export type TripCreateManyPickup_locationsInputEnvelope = {
    data: TripCreateManyPickup_locationsInput | TripCreateManyPickup_locationsInput[]
    skipDuplicates?: boolean
  }

  export type TransportRequestUpsertWithWhereUniqueWithoutPickupLocationInput = {
    where: TransportRequestWhereUniqueInput
    update: XOR<TransportRequestUpdateWithoutPickupLocationInput, TransportRequestUncheckedUpdateWithoutPickupLocationInput>
    create: XOR<TransportRequestCreateWithoutPickupLocationInput, TransportRequestUncheckedCreateWithoutPickupLocationInput>
  }

  export type TransportRequestUpdateWithWhereUniqueWithoutPickupLocationInput = {
    where: TransportRequestWhereUniqueInput
    data: XOR<TransportRequestUpdateWithoutPickupLocationInput, TransportRequestUncheckedUpdateWithoutPickupLocationInput>
  }

  export type TransportRequestUpdateManyWithWhereWithoutPickupLocationInput = {
    where: TransportRequestScalarWhereInput
    data: XOR<TransportRequestUpdateManyMutationInput, TransportRequestUncheckedUpdateManyWithoutPickupLocationInput>
  }

  export type TripUpsertWithWhereUniqueWithoutPickup_locationsInput = {
    where: TripWhereUniqueInput
    update: XOR<TripUpdateWithoutPickup_locationsInput, TripUncheckedUpdateWithoutPickup_locationsInput>
    create: XOR<TripCreateWithoutPickup_locationsInput, TripUncheckedCreateWithoutPickup_locationsInput>
  }

  export type TripUpdateWithWhereUniqueWithoutPickup_locationsInput = {
    where: TripWhereUniqueInput
    data: XOR<TripUpdateWithoutPickup_locationsInput, TripUncheckedUpdateWithoutPickup_locationsInput>
  }

  export type TripUpdateManyWithWhereWithoutPickup_locationsInput = {
    where: TripScalarWhereInput
    data: XOR<TripUpdateManyMutationInput, TripUncheckedUpdateManyWithoutPickup_locationsInput>
  }

  export type TripScalarWhereInput = {
    AND?: TripScalarWhereInput | TripScalarWhereInput[]
    OR?: TripScalarWhereInput[]
    NOT?: TripScalarWhereInput | TripScalarWhereInput[]
    id?: StringFilter<"Trip"> | string
    tripNumber?: StringFilter<"Trip"> | string
    patientId?: StringFilter<"Trip"> | string
    patientWeight?: StringNullableFilter<"Trip"> | string | null
    specialNeeds?: StringNullableFilter<"Trip"> | string | null
    fromLocation?: StringFilter<"Trip"> | string
    toLocation?: StringFilter<"Trip"> | string
    scheduledTime?: DateTimeFilter<"Trip"> | Date | string
    transportLevel?: StringFilter<"Trip"> | string
    urgencyLevel?: StringFilter<"Trip"> | string
    diagnosis?: StringNullableFilter<"Trip"> | string | null
    mobilityLevel?: StringNullableFilter<"Trip"> | string | null
    oxygenRequired?: BoolFilter<"Trip"> | boolean
    monitoringRequired?: BoolFilter<"Trip"> | boolean
    generateQRCode?: BoolFilter<"Trip"> | boolean
    qrCodeData?: StringNullableFilter<"Trip"> | string | null
    selectedAgencies?: StringNullableListFilter<"Trip">
    notificationRadius?: IntNullableFilter<"Trip"> | number | null
    transferRequestTime?: DateTimeNullableFilter<"Trip"> | Date | string | null
    transferAcceptedTime?: DateTimeNullableFilter<"Trip"> | Date | string | null
    emsArrivalTime?: DateTimeNullableFilter<"Trip"> | Date | string | null
    emsDepartureTime?: DateTimeNullableFilter<"Trip"> | Date | string | null
    actualStartTime?: DateTimeNullableFilter<"Trip"> | Date | string | null
    actualEndTime?: DateTimeNullableFilter<"Trip"> | Date | string | null
    status?: StringFilter<"Trip"> | string
    priority?: StringFilter<"Trip"> | string
    notes?: StringNullableFilter<"Trip"> | string | null
    assignedTo?: StringNullableFilter<"Trip"> | string | null
    assignedAgencyId?: StringNullableFilter<"Trip"> | string | null
    assignedUnitId?: StringNullableFilter<"Trip"> | string | null
    acceptedTimestamp?: DateTimeNullableFilter<"Trip"> | Date | string | null
    pickupTimestamp?: DateTimeNullableFilter<"Trip"> | Date | string | null
    completionTimestamp?: DateTimeNullableFilter<"Trip"> | Date | string | null
    createdAt?: DateTimeFilter<"Trip"> | Date | string
    updatedAt?: DateTimeFilter<"Trip"> | Date | string
    actualTripTimeMinutes?: IntNullableFilter<"Trip"> | number | null
    backhaulOpportunity?: BoolFilter<"Trip"> | boolean
    completionTimeMinutes?: IntNullableFilter<"Trip"> | number | null
    customerSatisfaction?: IntNullableFilter<"Trip"> | number | null
    deadheadMiles?: FloatNullableFilter<"Trip"> | number | null
    destinationLatitude?: FloatNullableFilter<"Trip"> | number | null
    destinationLongitude?: FloatNullableFilter<"Trip"> | number | null
    distanceMiles?: FloatNullableFilter<"Trip"> | number | null
    efficiency?: DecimalNullableFilter<"Trip"> | Decimal | DecimalJsLike | number | string | null
    estimatedTripTimeMinutes?: IntNullableFilter<"Trip"> | number | null
    insuranceCompany?: StringNullableFilter<"Trip"> | string | null
    insurancePayRate?: DecimalNullableFilter<"Trip"> | Decimal | DecimalJsLike | number | string | null
    loadedMiles?: DecimalNullableFilter<"Trip"> | Decimal | DecimalJsLike | number | string | null
    originLatitude?: FloatNullableFilter<"Trip"> | number | null
    originLongitude?: FloatNullableFilter<"Trip"> | number | null
    perMileRate?: DecimalNullableFilter<"Trip"> | Decimal | DecimalJsLike | number | string | null
    performanceScore?: DecimalNullableFilter<"Trip"> | Decimal | DecimalJsLike | number | string | null
    requestTimestamp?: DateTimeNullableFilter<"Trip"> | Date | string | null
    responseTimeMinutes?: IntNullableFilter<"Trip"> | number | null
    revenuePerHour?: DecimalNullableFilter<"Trip"> | Decimal | DecimalJsLike | number | string | null
    tripCost?: DecimalNullableFilter<"Trip"> | Decimal | DecimalJsLike | number | string | null
    pickupLocationId?: StringNullableFilter<"Trip"> | string | null
    maxResponses?: IntFilter<"Trip"> | number
    responseDeadline?: DateTimeNullableFilter<"Trip"> | Date | string | null
    responseStatus?: StringFilter<"Trip"> | string
    selectionMode?: StringFilter<"Trip"> | string
  }

  export type unit_analyticsCreateWithoutUnitInput = {
    id: string
    performanceScore?: Decimal | DecimalJsLike | number | string | null
    efficiency?: Decimal | DecimalJsLike | number | string | null
    totalTrips?: number
    totalTripsCompleted?: number
    averageResponseTime?: Decimal | DecimalJsLike | number | string | null
    lastUpdated?: Date | string
  }

  export type unit_analyticsUncheckedCreateWithoutUnitInput = {
    id: string
    performanceScore?: Decimal | DecimalJsLike | number | string | null
    efficiency?: Decimal | DecimalJsLike | number | string | null
    totalTrips?: number
    totalTripsCompleted?: number
    averageResponseTime?: Decimal | DecimalJsLike | number | string | null
    lastUpdated?: Date | string
  }

  export type unit_analyticsCreateOrConnectWithoutUnitInput = {
    where: unit_analyticsWhereUniqueInput
    create: XOR<unit_analyticsCreateWithoutUnitInput, unit_analyticsUncheckedCreateWithoutUnitInput>
  }

  export type EMSAgencyCreateWithoutUnitsInput = {
    id?: string
    name: string
    contactName: string
    phone: string
    email: string
    address: string
    city: string
    state: string
    zipCode: string
    serviceArea?: EMSAgencyCreateserviceAreaInput | string[]
    operatingHours?: NullableJsonNullValueInput | InputJsonValue
    capabilities?: EMSAgencyCreatecapabilitiesInput | string[]
    pricingStructure?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    status?: string
    addedBy?: string | null
    addedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    acceptsNotifications?: boolean
    approvedAt?: Date | string | null
    approvedBy?: string | null
    availableUnits?: number
    lastUpdated?: Date | string
    latitude?: number | null
    longitude?: number | null
    notificationMethods?: EMSAgencyCreatenotificationMethodsInput | string[]
    requiresReview?: boolean
    serviceRadius?: number | null
    totalUnits?: number
    users?: EMSUserCreateNestedManyWithoutAgencyInput
  }

  export type EMSAgencyUncheckedCreateWithoutUnitsInput = {
    id?: string
    name: string
    contactName: string
    phone: string
    email: string
    address: string
    city: string
    state: string
    zipCode: string
    serviceArea?: EMSAgencyCreateserviceAreaInput | string[]
    operatingHours?: NullableJsonNullValueInput | InputJsonValue
    capabilities?: EMSAgencyCreatecapabilitiesInput | string[]
    pricingStructure?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    status?: string
    addedBy?: string | null
    addedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    acceptsNotifications?: boolean
    approvedAt?: Date | string | null
    approvedBy?: string | null
    availableUnits?: number
    lastUpdated?: Date | string
    latitude?: number | null
    longitude?: number | null
    notificationMethods?: EMSAgencyCreatenotificationMethodsInput | string[]
    requiresReview?: boolean
    serviceRadius?: number | null
    totalUnits?: number
    users?: EMSUserUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type EMSAgencyCreateOrConnectWithoutUnitsInput = {
    where: EMSAgencyWhereUniqueInput
    create: XOR<EMSAgencyCreateWithoutUnitsInput, EMSAgencyUncheckedCreateWithoutUnitsInput>
  }

  export type TransportRequestCreateWithoutAssignedUnitInput = {
    id?: string
    tripNumber?: string | null
    patientId: string
    patientWeight?: string | null
    specialNeeds?: string | null
    fromLocation?: string | null
    toLocation?: string | null
    isMultiLocationFacility?: boolean
    scheduledTime?: Date | string | null
    transportLevel: string
    urgencyLevel?: string | null
    priority: string
    status?: string
    specialRequirements?: string | null
    diagnosis?: string | null
    mobilityLevel?: string | null
    oxygenRequired?: boolean
    monitoringRequired?: boolean
    generateQRCode?: boolean
    qrCodeData?: string | null
    selectedAgencies?: TransportRequestCreateselectedAgenciesInput | string[]
    notificationRadius?: number | null
    requestTimestamp?: Date | string
    acceptedTimestamp?: Date | string | null
    pickupTimestamp?: Date | string | null
    arrivalTimestamp?: Date | string | null
    departureTimestamp?: Date | string | null
    completionTimestamp?: Date | string | null
    assignedAgencyId?: string | null
    createdById?: string | null
    healthcareCreatedById?: string | null
    isolation?: boolean
    bariatric?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    originFacility?: FacilityCreateNestedOneWithoutOriginTripsInput
    destinationFacility?: FacilityCreateNestedOneWithoutDestinationTripsInput
    pickupLocation?: pickup_locationsCreateNestedOneWithoutTripsInput
    healthcareLocation?: HealthcareLocationCreateNestedOneWithoutTransportRequestsInput
  }

  export type TransportRequestUncheckedCreateWithoutAssignedUnitInput = {
    id?: string
    tripNumber?: string | null
    patientId: string
    patientWeight?: string | null
    specialNeeds?: string | null
    originFacilityId?: string | null
    destinationFacilityId?: string | null
    fromLocation?: string | null
    toLocation?: string | null
    fromLocationId?: string | null
    isMultiLocationFacility?: boolean
    scheduledTime?: Date | string | null
    transportLevel: string
    urgencyLevel?: string | null
    priority: string
    status?: string
    specialRequirements?: string | null
    diagnosis?: string | null
    mobilityLevel?: string | null
    oxygenRequired?: boolean
    monitoringRequired?: boolean
    generateQRCode?: boolean
    qrCodeData?: string | null
    selectedAgencies?: TransportRequestCreateselectedAgenciesInput | string[]
    notificationRadius?: number | null
    requestTimestamp?: Date | string
    acceptedTimestamp?: Date | string | null
    pickupTimestamp?: Date | string | null
    arrivalTimestamp?: Date | string | null
    departureTimestamp?: Date | string | null
    completionTimestamp?: Date | string | null
    pickupLocationId?: string | null
    assignedAgencyId?: string | null
    createdById?: string | null
    healthcareCreatedById?: string | null
    isolation?: boolean
    bariatric?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransportRequestCreateOrConnectWithoutAssignedUnitInput = {
    where: TransportRequestWhereUniqueInput
    create: XOR<TransportRequestCreateWithoutAssignedUnitInput, TransportRequestUncheckedCreateWithoutAssignedUnitInput>
  }

  export type TransportRequestCreateManyAssignedUnitInputEnvelope = {
    data: TransportRequestCreateManyAssignedUnitInput | TransportRequestCreateManyAssignedUnitInput[]
    skipDuplicates?: boolean
  }

  export type unit_analyticsUpsertWithoutUnitInput = {
    update: XOR<unit_analyticsUpdateWithoutUnitInput, unit_analyticsUncheckedUpdateWithoutUnitInput>
    create: XOR<unit_analyticsCreateWithoutUnitInput, unit_analyticsUncheckedCreateWithoutUnitInput>
    where?: unit_analyticsWhereInput
  }

  export type unit_analyticsUpdateToOneWithWhereWithoutUnitInput = {
    where?: unit_analyticsWhereInput
    data: XOR<unit_analyticsUpdateWithoutUnitInput, unit_analyticsUncheckedUpdateWithoutUnitInput>
  }

  export type unit_analyticsUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    performanceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    efficiency?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalTrips?: IntFieldUpdateOperationsInput | number
    totalTripsCompleted?: IntFieldUpdateOperationsInput | number
    averageResponseTime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type unit_analyticsUncheckedUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    performanceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    efficiency?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalTrips?: IntFieldUpdateOperationsInput | number
    totalTripsCompleted?: IntFieldUpdateOperationsInput | number
    averageResponseTime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EMSAgencyUpsertWithoutUnitsInput = {
    update: XOR<EMSAgencyUpdateWithoutUnitsInput, EMSAgencyUncheckedUpdateWithoutUnitsInput>
    create: XOR<EMSAgencyCreateWithoutUnitsInput, EMSAgencyUncheckedCreateWithoutUnitsInput>
    where?: EMSAgencyWhereInput
  }

  export type EMSAgencyUpdateToOneWithWhereWithoutUnitsInput = {
    where?: EMSAgencyWhereInput
    data: XOR<EMSAgencyUpdateWithoutUnitsInput, EMSAgencyUncheckedUpdateWithoutUnitsInput>
  }

  export type EMSAgencyUpdateWithoutUnitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    serviceArea?: EMSAgencyUpdateserviceAreaInput | string[]
    operatingHours?: NullableJsonNullValueInput | InputJsonValue
    capabilities?: EMSAgencyUpdatecapabilitiesInput | string[]
    pricingStructure?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    addedBy?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptsNotifications?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    availableUnits?: IntFieldUpdateOperationsInput | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    notificationMethods?: EMSAgencyUpdatenotificationMethodsInput | string[]
    requiresReview?: BoolFieldUpdateOperationsInput | boolean
    serviceRadius?: NullableIntFieldUpdateOperationsInput | number | null
    totalUnits?: IntFieldUpdateOperationsInput | number
    users?: EMSUserUpdateManyWithoutAgencyNestedInput
  }

  export type EMSAgencyUncheckedUpdateWithoutUnitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    serviceArea?: EMSAgencyUpdateserviceAreaInput | string[]
    operatingHours?: NullableJsonNullValueInput | InputJsonValue
    capabilities?: EMSAgencyUpdatecapabilitiesInput | string[]
    pricingStructure?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    addedBy?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptsNotifications?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    availableUnits?: IntFieldUpdateOperationsInput | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    notificationMethods?: EMSAgencyUpdatenotificationMethodsInput | string[]
    requiresReview?: BoolFieldUpdateOperationsInput | boolean
    serviceRadius?: NullableIntFieldUpdateOperationsInput | number | null
    totalUnits?: IntFieldUpdateOperationsInput | number
    users?: EMSUserUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type TransportRequestUpsertWithWhereUniqueWithoutAssignedUnitInput = {
    where: TransportRequestWhereUniqueInput
    update: XOR<TransportRequestUpdateWithoutAssignedUnitInput, TransportRequestUncheckedUpdateWithoutAssignedUnitInput>
    create: XOR<TransportRequestCreateWithoutAssignedUnitInput, TransportRequestUncheckedCreateWithoutAssignedUnitInput>
  }

  export type TransportRequestUpdateWithWhereUniqueWithoutAssignedUnitInput = {
    where: TransportRequestWhereUniqueInput
    data: XOR<TransportRequestUpdateWithoutAssignedUnitInput, TransportRequestUncheckedUpdateWithoutAssignedUnitInput>
  }

  export type TransportRequestUpdateManyWithWhereWithoutAssignedUnitInput = {
    where: TransportRequestScalarWhereInput
    data: XOR<TransportRequestUpdateManyMutationInput, TransportRequestUncheckedUpdateManyWithoutAssignedUnitInput>
  }

  export type UnitCreateWithoutAnalyticsInput = {
    id?: string
    unitNumber: string
    type: string
    status?: string
    currentStatus?: string
    currentLocation?: string | null
    capabilities?: UnitCreatecapabilitiesInput | string[]
    crewSize?: number
    equipment?: UnitCreateequipmentInput | string[]
    location?: NullableJsonNullValueInput | InputJsonValue
    latitude?: number | null
    longitude?: number | null
    lastMaintenance?: Date | string | null
    nextMaintenance?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    agency: EMSAgencyCreateNestedOneWithoutUnitsInput
    assignedTrips?: TransportRequestCreateNestedManyWithoutAssignedUnitInput
  }

  export type UnitUncheckedCreateWithoutAnalyticsInput = {
    id?: string
    agencyId: string
    unitNumber: string
    type: string
    status?: string
    currentStatus?: string
    currentLocation?: string | null
    capabilities?: UnitCreatecapabilitiesInput | string[]
    crewSize?: number
    equipment?: UnitCreateequipmentInput | string[]
    location?: NullableJsonNullValueInput | InputJsonValue
    latitude?: number | null
    longitude?: number | null
    lastMaintenance?: Date | string | null
    nextMaintenance?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedTrips?: TransportRequestUncheckedCreateNestedManyWithoutAssignedUnitInput
  }

  export type UnitCreateOrConnectWithoutAnalyticsInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutAnalyticsInput, UnitUncheckedCreateWithoutAnalyticsInput>
  }

  export type UnitUpsertWithoutAnalyticsInput = {
    update: XOR<UnitUpdateWithoutAnalyticsInput, UnitUncheckedUpdateWithoutAnalyticsInput>
    create: XOR<UnitCreateWithoutAnalyticsInput, UnitUncheckedCreateWithoutAnalyticsInput>
    where?: UnitWhereInput
  }

  export type UnitUpdateToOneWithWhereWithoutAnalyticsInput = {
    where?: UnitWhereInput
    data: XOR<UnitUpdateWithoutAnalyticsInput, UnitUncheckedUpdateWithoutAnalyticsInput>
  }

  export type UnitUpdateWithoutAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitNumber?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentStatus?: StringFieldUpdateOperationsInput | string
    currentLocation?: NullableStringFieldUpdateOperationsInput | string | null
    capabilities?: UnitUpdatecapabilitiesInput | string[]
    crewSize?: IntFieldUpdateOperationsInput | number
    equipment?: UnitUpdateequipmentInput | string[]
    location?: NullableJsonNullValueInput | InputJsonValue
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agency?: EMSAgencyUpdateOneRequiredWithoutUnitsNestedInput
    assignedTrips?: TransportRequestUpdateManyWithoutAssignedUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    unitNumber?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentStatus?: StringFieldUpdateOperationsInput | string
    currentLocation?: NullableStringFieldUpdateOperationsInput | string | null
    capabilities?: UnitUpdatecapabilitiesInput | string[]
    crewSize?: IntFieldUpdateOperationsInput | number
    equipment?: UnitUpdateequipmentInput | string[]
    location?: NullableJsonNullValueInput | InputJsonValue
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTrips?: TransportRequestUncheckedUpdateManyWithoutAssignedUnitNestedInput
  }

  export type CenterUserCreateWithoutNotificationPreferencesInput = {
    id?: string
    email: string
    password: string
    name: string
    userType: string
    phone?: string | null
    emailNotifications?: boolean
    smsNotifications?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    notificationLogs?: NotificationLogCreateNestedManyWithoutUserInput
  }

  export type CenterUserUncheckedCreateWithoutNotificationPreferencesInput = {
    id?: string
    email: string
    password: string
    name: string
    userType: string
    phone?: string | null
    emailNotifications?: boolean
    smsNotifications?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    notificationLogs?: NotificationLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type CenterUserCreateOrConnectWithoutNotificationPreferencesInput = {
    where: CenterUserWhereUniqueInput
    create: XOR<CenterUserCreateWithoutNotificationPreferencesInput, CenterUserUncheckedCreateWithoutNotificationPreferencesInput>
  }

  export type CenterUserUpsertWithoutNotificationPreferencesInput = {
    update: XOR<CenterUserUpdateWithoutNotificationPreferencesInput, CenterUserUncheckedUpdateWithoutNotificationPreferencesInput>
    create: XOR<CenterUserCreateWithoutNotificationPreferencesInput, CenterUserUncheckedCreateWithoutNotificationPreferencesInput>
    where?: CenterUserWhereInput
  }

  export type CenterUserUpdateToOneWithWhereWithoutNotificationPreferencesInput = {
    where?: CenterUserWhereInput
    data: XOR<CenterUserUpdateWithoutNotificationPreferencesInput, CenterUserUncheckedUpdateWithoutNotificationPreferencesInput>
  }

  export type CenterUserUpdateWithoutNotificationPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    smsNotifications?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notificationLogs?: NotificationLogUpdateManyWithoutUserNestedInput
  }

  export type CenterUserUncheckedUpdateWithoutNotificationPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    smsNotifications?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notificationLogs?: NotificationLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CenterUserCreateWithoutNotificationLogsInput = {
    id?: string
    email: string
    password: string
    name: string
    userType: string
    phone?: string | null
    emailNotifications?: boolean
    smsNotifications?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    notificationPreferences?: NotificationPreferenceCreateNestedManyWithoutUserInput
  }

  export type CenterUserUncheckedCreateWithoutNotificationLogsInput = {
    id?: string
    email: string
    password: string
    name: string
    userType: string
    phone?: string | null
    emailNotifications?: boolean
    smsNotifications?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
  }

  export type CenterUserCreateOrConnectWithoutNotificationLogsInput = {
    where: CenterUserWhereUniqueInput
    create: XOR<CenterUserCreateWithoutNotificationLogsInput, CenterUserUncheckedCreateWithoutNotificationLogsInput>
  }

  export type CenterUserUpsertWithoutNotificationLogsInput = {
    update: XOR<CenterUserUpdateWithoutNotificationLogsInput, CenterUserUncheckedUpdateWithoutNotificationLogsInput>
    create: XOR<CenterUserCreateWithoutNotificationLogsInput, CenterUserUncheckedCreateWithoutNotificationLogsInput>
    where?: CenterUserWhereInput
  }

  export type CenterUserUpdateToOneWithWhereWithoutNotificationLogsInput = {
    where?: CenterUserWhereInput
    data: XOR<CenterUserUpdateWithoutNotificationLogsInput, CenterUserUncheckedUpdateWithoutNotificationLogsInput>
  }

  export type CenterUserUpdateWithoutNotificationLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    smsNotifications?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notificationPreferences?: NotificationPreferenceUpdateManyWithoutUserNestedInput
  }

  export type CenterUserUncheckedUpdateWithoutNotificationLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    smsNotifications?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notificationPreferences?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CategoryDefaultCreateWithoutOptionInput = {
    id?: string
    category: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryDefaultUncheckedCreateWithoutOptionInput = {
    id?: string
    category: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryDefaultCreateOrConnectWithoutOptionInput = {
    where: CategoryDefaultWhereUniqueInput
    create: XOR<CategoryDefaultCreateWithoutOptionInput, CategoryDefaultUncheckedCreateWithoutOptionInput>
  }

  export type CategoryDefaultUpsertWithoutOptionInput = {
    update: XOR<CategoryDefaultUpdateWithoutOptionInput, CategoryDefaultUncheckedUpdateWithoutOptionInput>
    create: XOR<CategoryDefaultCreateWithoutOptionInput, CategoryDefaultUncheckedCreateWithoutOptionInput>
    where?: CategoryDefaultWhereInput
  }

  export type CategoryDefaultUpdateToOneWithWhereWithoutOptionInput = {
    where?: CategoryDefaultWhereInput
    data: XOR<CategoryDefaultUpdateWithoutOptionInput, CategoryDefaultUncheckedUpdateWithoutOptionInput>
  }

  export type CategoryDefaultUpdateWithoutOptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryDefaultUncheckedUpdateWithoutOptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DropdownOptionCreateWithoutDefaultForInput = {
    id?: string
    category: string
    value: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DropdownOptionUncheckedCreateWithoutDefaultForInput = {
    id?: string
    category: string
    value: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DropdownOptionCreateOrConnectWithoutDefaultForInput = {
    where: DropdownOptionWhereUniqueInput
    create: XOR<DropdownOptionCreateWithoutDefaultForInput, DropdownOptionUncheckedCreateWithoutDefaultForInput>
  }

  export type DropdownOptionUpsertWithoutDefaultForInput = {
    update: XOR<DropdownOptionUpdateWithoutDefaultForInput, DropdownOptionUncheckedUpdateWithoutDefaultForInput>
    create: XOR<DropdownOptionCreateWithoutDefaultForInput, DropdownOptionUncheckedCreateWithoutDefaultForInput>
    where?: DropdownOptionWhereInput
  }

  export type DropdownOptionUpdateToOneWithWhereWithoutDefaultForInput = {
    where?: DropdownOptionWhereInput
    data: XOR<DropdownOptionUpdateWithoutDefaultForInput, DropdownOptionUncheckedUpdateWithoutDefaultForInput>
  }

  export type DropdownOptionUpdateWithoutDefaultForInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DropdownOptionUncheckedUpdateWithoutDefaultForInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacilityCreateWithoutOriginTripsInput = {
    id?: string
    name: string
    address: string
    city: string
    state: string
    zipCode: string
    phone?: string | null
    email?: string | null
    type: string
    capabilities?: FacilityCreatecapabilitiesInput | string[]
    region: string
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    latitude?: number | null
    longitude?: number | null
    operatingHours?: string | null
    isActive?: boolean
    requiresReview?: boolean
    approvedAt?: Date | string | null
    approvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    destinationTrips?: TransportRequestCreateNestedManyWithoutDestinationFacilityInput
  }

  export type FacilityUncheckedCreateWithoutOriginTripsInput = {
    id?: string
    name: string
    address: string
    city: string
    state: string
    zipCode: string
    phone?: string | null
    email?: string | null
    type: string
    capabilities?: FacilityCreatecapabilitiesInput | string[]
    region: string
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    latitude?: number | null
    longitude?: number | null
    operatingHours?: string | null
    isActive?: boolean
    requiresReview?: boolean
    approvedAt?: Date | string | null
    approvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    destinationTrips?: TransportRequestUncheckedCreateNestedManyWithoutDestinationFacilityInput
  }

  export type FacilityCreateOrConnectWithoutOriginTripsInput = {
    where: FacilityWhereUniqueInput
    create: XOR<FacilityCreateWithoutOriginTripsInput, FacilityUncheckedCreateWithoutOriginTripsInput>
  }

  export type FacilityCreateWithoutDestinationTripsInput = {
    id?: string
    name: string
    address: string
    city: string
    state: string
    zipCode: string
    phone?: string | null
    email?: string | null
    type: string
    capabilities?: FacilityCreatecapabilitiesInput | string[]
    region: string
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    latitude?: number | null
    longitude?: number | null
    operatingHours?: string | null
    isActive?: boolean
    requiresReview?: boolean
    approvedAt?: Date | string | null
    approvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    originTrips?: TransportRequestCreateNestedManyWithoutOriginFacilityInput
  }

  export type FacilityUncheckedCreateWithoutDestinationTripsInput = {
    id?: string
    name: string
    address: string
    city: string
    state: string
    zipCode: string
    phone?: string | null
    email?: string | null
    type: string
    capabilities?: FacilityCreatecapabilitiesInput | string[]
    region: string
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    latitude?: number | null
    longitude?: number | null
    operatingHours?: string | null
    isActive?: boolean
    requiresReview?: boolean
    approvedAt?: Date | string | null
    approvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    originTrips?: TransportRequestUncheckedCreateNestedManyWithoutOriginFacilityInput
  }

  export type FacilityCreateOrConnectWithoutDestinationTripsInput = {
    where: FacilityWhereUniqueInput
    create: XOR<FacilityCreateWithoutDestinationTripsInput, FacilityUncheckedCreateWithoutDestinationTripsInput>
  }

  export type pickup_locationsCreateWithoutTripsInput = {
    id: string
    hospitalId: string
    name: string
    description?: string | null
    contactPhone?: string | null
    contactEmail?: string | null
    floor?: string | null
    room?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    legacyTrips?: TripCreateNestedManyWithoutPickup_locationsInput
  }

  export type pickup_locationsUncheckedCreateWithoutTripsInput = {
    id: string
    hospitalId: string
    name: string
    description?: string | null
    contactPhone?: string | null
    contactEmail?: string | null
    floor?: string | null
    room?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    legacyTrips?: TripUncheckedCreateNestedManyWithoutPickup_locationsInput
  }

  export type pickup_locationsCreateOrConnectWithoutTripsInput = {
    where: pickup_locationsWhereUniqueInput
    create: XOR<pickup_locationsCreateWithoutTripsInput, pickup_locationsUncheckedCreateWithoutTripsInput>
  }

  export type UnitCreateWithoutAssignedTripsInput = {
    id?: string
    unitNumber: string
    type: string
    status?: string
    currentStatus?: string
    currentLocation?: string | null
    capabilities?: UnitCreatecapabilitiesInput | string[]
    crewSize?: number
    equipment?: UnitCreateequipmentInput | string[]
    location?: NullableJsonNullValueInput | InputJsonValue
    latitude?: number | null
    longitude?: number | null
    lastMaintenance?: Date | string | null
    nextMaintenance?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    analytics?: unit_analyticsCreateNestedOneWithoutUnitInput
    agency: EMSAgencyCreateNestedOneWithoutUnitsInput
  }

  export type UnitUncheckedCreateWithoutAssignedTripsInput = {
    id?: string
    agencyId: string
    unitNumber: string
    type: string
    status?: string
    currentStatus?: string
    currentLocation?: string | null
    capabilities?: UnitCreatecapabilitiesInput | string[]
    crewSize?: number
    equipment?: UnitCreateequipmentInput | string[]
    location?: NullableJsonNullValueInput | InputJsonValue
    latitude?: number | null
    longitude?: number | null
    lastMaintenance?: Date | string | null
    nextMaintenance?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    analytics?: unit_analyticsUncheckedCreateNestedOneWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutAssignedTripsInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutAssignedTripsInput, UnitUncheckedCreateWithoutAssignedTripsInput>
  }

  export type HealthcareLocationCreateWithoutTransportRequestsInput = {
    id?: string
    locationName: string
    address: string
    city: string
    state: string
    zipCode: string
    phone?: string | null
    facilityType: string
    isActive?: boolean
    isPrimary?: boolean
    latitude?: number | null
    longitude?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    healthcareUser: HealthcareUserCreateNestedOneWithoutLocationsInput
  }

  export type HealthcareLocationUncheckedCreateWithoutTransportRequestsInput = {
    id?: string
    healthcareUserId: string
    locationName: string
    address: string
    city: string
    state: string
    zipCode: string
    phone?: string | null
    facilityType: string
    isActive?: boolean
    isPrimary?: boolean
    latitude?: number | null
    longitude?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HealthcareLocationCreateOrConnectWithoutTransportRequestsInput = {
    where: HealthcareLocationWhereUniqueInput
    create: XOR<HealthcareLocationCreateWithoutTransportRequestsInput, HealthcareLocationUncheckedCreateWithoutTransportRequestsInput>
  }

  export type FacilityUpsertWithoutOriginTripsInput = {
    update: XOR<FacilityUpdateWithoutOriginTripsInput, FacilityUncheckedUpdateWithoutOriginTripsInput>
    create: XOR<FacilityCreateWithoutOriginTripsInput, FacilityUncheckedCreateWithoutOriginTripsInput>
    where?: FacilityWhereInput
  }

  export type FacilityUpdateToOneWithWhereWithoutOriginTripsInput = {
    where?: FacilityWhereInput
    data: XOR<FacilityUpdateWithoutOriginTripsInput, FacilityUncheckedUpdateWithoutOriginTripsInput>
  }

  export type FacilityUpdateWithoutOriginTripsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    capabilities?: FacilityUpdatecapabilitiesInput | string[]
    region?: StringFieldUpdateOperationsInput | string
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    operatingHours?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requiresReview?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    destinationTrips?: TransportRequestUpdateManyWithoutDestinationFacilityNestedInput
  }

  export type FacilityUncheckedUpdateWithoutOriginTripsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    capabilities?: FacilityUpdatecapabilitiesInput | string[]
    region?: StringFieldUpdateOperationsInput | string
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    operatingHours?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requiresReview?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    destinationTrips?: TransportRequestUncheckedUpdateManyWithoutDestinationFacilityNestedInput
  }

  export type FacilityUpsertWithoutDestinationTripsInput = {
    update: XOR<FacilityUpdateWithoutDestinationTripsInput, FacilityUncheckedUpdateWithoutDestinationTripsInput>
    create: XOR<FacilityCreateWithoutDestinationTripsInput, FacilityUncheckedCreateWithoutDestinationTripsInput>
    where?: FacilityWhereInput
  }

  export type FacilityUpdateToOneWithWhereWithoutDestinationTripsInput = {
    where?: FacilityWhereInput
    data: XOR<FacilityUpdateWithoutDestinationTripsInput, FacilityUncheckedUpdateWithoutDestinationTripsInput>
  }

  export type FacilityUpdateWithoutDestinationTripsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    capabilities?: FacilityUpdatecapabilitiesInput | string[]
    region?: StringFieldUpdateOperationsInput | string
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    operatingHours?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requiresReview?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    originTrips?: TransportRequestUpdateManyWithoutOriginFacilityNestedInput
  }

  export type FacilityUncheckedUpdateWithoutDestinationTripsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    capabilities?: FacilityUpdatecapabilitiesInput | string[]
    region?: StringFieldUpdateOperationsInput | string
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    operatingHours?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requiresReview?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    originTrips?: TransportRequestUncheckedUpdateManyWithoutOriginFacilityNestedInput
  }

  export type pickup_locationsUpsertWithoutTripsInput = {
    update: XOR<pickup_locationsUpdateWithoutTripsInput, pickup_locationsUncheckedUpdateWithoutTripsInput>
    create: XOR<pickup_locationsCreateWithoutTripsInput, pickup_locationsUncheckedCreateWithoutTripsInput>
    where?: pickup_locationsWhereInput
  }

  export type pickup_locationsUpdateToOneWithWhereWithoutTripsInput = {
    where?: pickup_locationsWhereInput
    data: XOR<pickup_locationsUpdateWithoutTripsInput, pickup_locationsUncheckedUpdateWithoutTripsInput>
  }

  export type pickup_locationsUpdateWithoutTripsInput = {
    id?: StringFieldUpdateOperationsInput | string
    hospitalId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    legacyTrips?: TripUpdateManyWithoutPickup_locationsNestedInput
  }

  export type pickup_locationsUncheckedUpdateWithoutTripsInput = {
    id?: StringFieldUpdateOperationsInput | string
    hospitalId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    legacyTrips?: TripUncheckedUpdateManyWithoutPickup_locationsNestedInput
  }

  export type UnitUpsertWithoutAssignedTripsInput = {
    update: XOR<UnitUpdateWithoutAssignedTripsInput, UnitUncheckedUpdateWithoutAssignedTripsInput>
    create: XOR<UnitCreateWithoutAssignedTripsInput, UnitUncheckedCreateWithoutAssignedTripsInput>
    where?: UnitWhereInput
  }

  export type UnitUpdateToOneWithWhereWithoutAssignedTripsInput = {
    where?: UnitWhereInput
    data: XOR<UnitUpdateWithoutAssignedTripsInput, UnitUncheckedUpdateWithoutAssignedTripsInput>
  }

  export type UnitUpdateWithoutAssignedTripsInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitNumber?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentStatus?: StringFieldUpdateOperationsInput | string
    currentLocation?: NullableStringFieldUpdateOperationsInput | string | null
    capabilities?: UnitUpdatecapabilitiesInput | string[]
    crewSize?: IntFieldUpdateOperationsInput | number
    equipment?: UnitUpdateequipmentInput | string[]
    location?: NullableJsonNullValueInput | InputJsonValue
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analytics?: unit_analyticsUpdateOneWithoutUnitNestedInput
    agency?: EMSAgencyUpdateOneRequiredWithoutUnitsNestedInput
  }

  export type UnitUncheckedUpdateWithoutAssignedTripsInput = {
    id?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    unitNumber?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentStatus?: StringFieldUpdateOperationsInput | string
    currentLocation?: NullableStringFieldUpdateOperationsInput | string | null
    capabilities?: UnitUpdatecapabilitiesInput | string[]
    crewSize?: IntFieldUpdateOperationsInput | number
    equipment?: UnitUpdateequipmentInput | string[]
    location?: NullableJsonNullValueInput | InputJsonValue
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analytics?: unit_analyticsUncheckedUpdateOneWithoutUnitNestedInput
  }

  export type HealthcareLocationUpsertWithoutTransportRequestsInput = {
    update: XOR<HealthcareLocationUpdateWithoutTransportRequestsInput, HealthcareLocationUncheckedUpdateWithoutTransportRequestsInput>
    create: XOR<HealthcareLocationCreateWithoutTransportRequestsInput, HealthcareLocationUncheckedCreateWithoutTransportRequestsInput>
    where?: HealthcareLocationWhereInput
  }

  export type HealthcareLocationUpdateToOneWithWhereWithoutTransportRequestsInput = {
    where?: HealthcareLocationWhereInput
    data: XOR<HealthcareLocationUpdateWithoutTransportRequestsInput, HealthcareLocationUncheckedUpdateWithoutTransportRequestsInput>
  }

  export type HealthcareLocationUpdateWithoutTransportRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    facilityType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    healthcareUser?: HealthcareUserUpdateOneRequiredWithoutLocationsNestedInput
  }

  export type HealthcareLocationUncheckedUpdateWithoutTransportRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    healthcareUserId?: StringFieldUpdateOperationsInput | string
    locationName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    facilityType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransportRequestCreateWithoutOriginFacilityInput = {
    id?: string
    tripNumber?: string | null
    patientId: string
    patientWeight?: string | null
    specialNeeds?: string | null
    fromLocation?: string | null
    toLocation?: string | null
    isMultiLocationFacility?: boolean
    scheduledTime?: Date | string | null
    transportLevel: string
    urgencyLevel?: string | null
    priority: string
    status?: string
    specialRequirements?: string | null
    diagnosis?: string | null
    mobilityLevel?: string | null
    oxygenRequired?: boolean
    monitoringRequired?: boolean
    generateQRCode?: boolean
    qrCodeData?: string | null
    selectedAgencies?: TransportRequestCreateselectedAgenciesInput | string[]
    notificationRadius?: number | null
    requestTimestamp?: Date | string
    acceptedTimestamp?: Date | string | null
    pickupTimestamp?: Date | string | null
    arrivalTimestamp?: Date | string | null
    departureTimestamp?: Date | string | null
    completionTimestamp?: Date | string | null
    assignedAgencyId?: string | null
    createdById?: string | null
    healthcareCreatedById?: string | null
    isolation?: boolean
    bariatric?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    destinationFacility?: FacilityCreateNestedOneWithoutDestinationTripsInput
    pickupLocation?: pickup_locationsCreateNestedOneWithoutTripsInput
    assignedUnit?: UnitCreateNestedOneWithoutAssignedTripsInput
    healthcareLocation?: HealthcareLocationCreateNestedOneWithoutTransportRequestsInput
  }

  export type TransportRequestUncheckedCreateWithoutOriginFacilityInput = {
    id?: string
    tripNumber?: string | null
    patientId: string
    patientWeight?: string | null
    specialNeeds?: string | null
    destinationFacilityId?: string | null
    fromLocation?: string | null
    toLocation?: string | null
    fromLocationId?: string | null
    isMultiLocationFacility?: boolean
    scheduledTime?: Date | string | null
    transportLevel: string
    urgencyLevel?: string | null
    priority: string
    status?: string
    specialRequirements?: string | null
    diagnosis?: string | null
    mobilityLevel?: string | null
    oxygenRequired?: boolean
    monitoringRequired?: boolean
    generateQRCode?: boolean
    qrCodeData?: string | null
    selectedAgencies?: TransportRequestCreateselectedAgenciesInput | string[]
    notificationRadius?: number | null
    requestTimestamp?: Date | string
    acceptedTimestamp?: Date | string | null
    pickupTimestamp?: Date | string | null
    arrivalTimestamp?: Date | string | null
    departureTimestamp?: Date | string | null
    completionTimestamp?: Date | string | null
    pickupLocationId?: string | null
    assignedAgencyId?: string | null
    assignedUnitId?: string | null
    createdById?: string | null
    healthcareCreatedById?: string | null
    isolation?: boolean
    bariatric?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransportRequestCreateOrConnectWithoutOriginFacilityInput = {
    where: TransportRequestWhereUniqueInput
    create: XOR<TransportRequestCreateWithoutOriginFacilityInput, TransportRequestUncheckedCreateWithoutOriginFacilityInput>
  }

  export type TransportRequestCreateManyOriginFacilityInputEnvelope = {
    data: TransportRequestCreateManyOriginFacilityInput | TransportRequestCreateManyOriginFacilityInput[]
    skipDuplicates?: boolean
  }

  export type TransportRequestCreateWithoutDestinationFacilityInput = {
    id?: string
    tripNumber?: string | null
    patientId: string
    patientWeight?: string | null
    specialNeeds?: string | null
    fromLocation?: string | null
    toLocation?: string | null
    isMultiLocationFacility?: boolean
    scheduledTime?: Date | string | null
    transportLevel: string
    urgencyLevel?: string | null
    priority: string
    status?: string
    specialRequirements?: string | null
    diagnosis?: string | null
    mobilityLevel?: string | null
    oxygenRequired?: boolean
    monitoringRequired?: boolean
    generateQRCode?: boolean
    qrCodeData?: string | null
    selectedAgencies?: TransportRequestCreateselectedAgenciesInput | string[]
    notificationRadius?: number | null
    requestTimestamp?: Date | string
    acceptedTimestamp?: Date | string | null
    pickupTimestamp?: Date | string | null
    arrivalTimestamp?: Date | string | null
    departureTimestamp?: Date | string | null
    completionTimestamp?: Date | string | null
    assignedAgencyId?: string | null
    createdById?: string | null
    healthcareCreatedById?: string | null
    isolation?: boolean
    bariatric?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    originFacility?: FacilityCreateNestedOneWithoutOriginTripsInput
    pickupLocation?: pickup_locationsCreateNestedOneWithoutTripsInput
    assignedUnit?: UnitCreateNestedOneWithoutAssignedTripsInput
    healthcareLocation?: HealthcareLocationCreateNestedOneWithoutTransportRequestsInput
  }

  export type TransportRequestUncheckedCreateWithoutDestinationFacilityInput = {
    id?: string
    tripNumber?: string | null
    patientId: string
    patientWeight?: string | null
    specialNeeds?: string | null
    originFacilityId?: string | null
    fromLocation?: string | null
    toLocation?: string | null
    fromLocationId?: string | null
    isMultiLocationFacility?: boolean
    scheduledTime?: Date | string | null
    transportLevel: string
    urgencyLevel?: string | null
    priority: string
    status?: string
    specialRequirements?: string | null
    diagnosis?: string | null
    mobilityLevel?: string | null
    oxygenRequired?: boolean
    monitoringRequired?: boolean
    generateQRCode?: boolean
    qrCodeData?: string | null
    selectedAgencies?: TransportRequestCreateselectedAgenciesInput | string[]
    notificationRadius?: number | null
    requestTimestamp?: Date | string
    acceptedTimestamp?: Date | string | null
    pickupTimestamp?: Date | string | null
    arrivalTimestamp?: Date | string | null
    departureTimestamp?: Date | string | null
    completionTimestamp?: Date | string | null
    pickupLocationId?: string | null
    assignedAgencyId?: string | null
    assignedUnitId?: string | null
    createdById?: string | null
    healthcareCreatedById?: string | null
    isolation?: boolean
    bariatric?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransportRequestCreateOrConnectWithoutDestinationFacilityInput = {
    where: TransportRequestWhereUniqueInput
    create: XOR<TransportRequestCreateWithoutDestinationFacilityInput, TransportRequestUncheckedCreateWithoutDestinationFacilityInput>
  }

  export type TransportRequestCreateManyDestinationFacilityInputEnvelope = {
    data: TransportRequestCreateManyDestinationFacilityInput | TransportRequestCreateManyDestinationFacilityInput[]
    skipDuplicates?: boolean
  }

  export type TransportRequestUpsertWithWhereUniqueWithoutOriginFacilityInput = {
    where: TransportRequestWhereUniqueInput
    update: XOR<TransportRequestUpdateWithoutOriginFacilityInput, TransportRequestUncheckedUpdateWithoutOriginFacilityInput>
    create: XOR<TransportRequestCreateWithoutOriginFacilityInput, TransportRequestUncheckedCreateWithoutOriginFacilityInput>
  }

  export type TransportRequestUpdateWithWhereUniqueWithoutOriginFacilityInput = {
    where: TransportRequestWhereUniqueInput
    data: XOR<TransportRequestUpdateWithoutOriginFacilityInput, TransportRequestUncheckedUpdateWithoutOriginFacilityInput>
  }

  export type TransportRequestUpdateManyWithWhereWithoutOriginFacilityInput = {
    where: TransportRequestScalarWhereInput
    data: XOR<TransportRequestUpdateManyMutationInput, TransportRequestUncheckedUpdateManyWithoutOriginFacilityInput>
  }

  export type TransportRequestUpsertWithWhereUniqueWithoutDestinationFacilityInput = {
    where: TransportRequestWhereUniqueInput
    update: XOR<TransportRequestUpdateWithoutDestinationFacilityInput, TransportRequestUncheckedUpdateWithoutDestinationFacilityInput>
    create: XOR<TransportRequestCreateWithoutDestinationFacilityInput, TransportRequestUncheckedCreateWithoutDestinationFacilityInput>
  }

  export type TransportRequestUpdateWithWhereUniqueWithoutDestinationFacilityInput = {
    where: TransportRequestWhereUniqueInput
    data: XOR<TransportRequestUpdateWithoutDestinationFacilityInput, TransportRequestUncheckedUpdateWithoutDestinationFacilityInput>
  }

  export type TransportRequestUpdateManyWithWhereWithoutDestinationFacilityInput = {
    where: TransportRequestScalarWhereInput
    data: XOR<TransportRequestUpdateManyMutationInput, TransportRequestUncheckedUpdateManyWithoutDestinationFacilityInput>
  }

  export type NotificationLogCreateManyUserInput = {
    id?: string
    notificationType: string
    channel: string
    status: string
    sentAt?: Date | string
    deliveredAt?: Date | string | null
    errorMessage?: string | null
  }

  export type NotificationPreferenceCreateManyUserInput = {
    id?: string
    notificationType: string
    emailEnabled?: boolean
    smsEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    notificationType?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    notificationType?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    notificationType?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationPreferenceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    notificationType?: StringFieldUpdateOperationsInput | string
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
    smsEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    notificationType?: StringFieldUpdateOperationsInput | string
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
    smsEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    notificationType?: StringFieldUpdateOperationsInput | string
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
    smsEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HealthcareLocationCreateManyHealthcareUserInput = {
    id?: string
    locationName: string
    address: string
    city: string
    state: string
    zipCode: string
    phone?: string | null
    facilityType: string
    isActive?: boolean
    isPrimary?: boolean
    latitude?: number | null
    longitude?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HealthcareLocationUpdateWithoutHealthcareUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    facilityType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transportRequests?: TransportRequestUpdateManyWithoutHealthcareLocationNestedInput
  }

  export type HealthcareLocationUncheckedUpdateWithoutHealthcareUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    facilityType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transportRequests?: TransportRequestUncheckedUpdateManyWithoutHealthcareLocationNestedInput
  }

  export type HealthcareLocationUncheckedUpdateManyWithoutHealthcareUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    facilityType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransportRequestCreateManyHealthcareLocationInput = {
    id?: string
    tripNumber?: string | null
    patientId: string
    patientWeight?: string | null
    specialNeeds?: string | null
    originFacilityId?: string | null
    destinationFacilityId?: string | null
    fromLocation?: string | null
    toLocation?: string | null
    isMultiLocationFacility?: boolean
    scheduledTime?: Date | string | null
    transportLevel: string
    urgencyLevel?: string | null
    priority: string
    status?: string
    specialRequirements?: string | null
    diagnosis?: string | null
    mobilityLevel?: string | null
    oxygenRequired?: boolean
    monitoringRequired?: boolean
    generateQRCode?: boolean
    qrCodeData?: string | null
    selectedAgencies?: TransportRequestCreateselectedAgenciesInput | string[]
    notificationRadius?: number | null
    requestTimestamp?: Date | string
    acceptedTimestamp?: Date | string | null
    pickupTimestamp?: Date | string | null
    arrivalTimestamp?: Date | string | null
    departureTimestamp?: Date | string | null
    completionTimestamp?: Date | string | null
    pickupLocationId?: string | null
    assignedAgencyId?: string | null
    assignedUnitId?: string | null
    createdById?: string | null
    healthcareCreatedById?: string | null
    isolation?: boolean
    bariatric?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransportRequestUpdateWithoutHealthcareLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripNumber?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    patientWeight?: NullableStringFieldUpdateOperationsInput | string | null
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocation?: NullableStringFieldUpdateOperationsInput | string | null
    toLocation?: NullableStringFieldUpdateOperationsInput | string | null
    isMultiLocationFacility?: BoolFieldUpdateOperationsInput | boolean
    scheduledTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transportLevel?: StringFieldUpdateOperationsInput | string
    urgencyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    specialRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    mobilityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    oxygenRequired?: BoolFieldUpdateOperationsInput | boolean
    monitoringRequired?: BoolFieldUpdateOperationsInput | boolean
    generateQRCode?: BoolFieldUpdateOperationsInput | boolean
    qrCodeData?: NullableStringFieldUpdateOperationsInput | string | null
    selectedAgencies?: TransportRequestUpdateselectedAgenciesInput | string[]
    notificationRadius?: NullableIntFieldUpdateOperationsInput | number | null
    requestTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    arrivalTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departureTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedAgencyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    healthcareCreatedById?: NullableStringFieldUpdateOperationsInput | string | null
    isolation?: BoolFieldUpdateOperationsInput | boolean
    bariatric?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    originFacility?: FacilityUpdateOneWithoutOriginTripsNestedInput
    destinationFacility?: FacilityUpdateOneWithoutDestinationTripsNestedInput
    pickupLocation?: pickup_locationsUpdateOneWithoutTripsNestedInput
    assignedUnit?: UnitUpdateOneWithoutAssignedTripsNestedInput
  }

  export type TransportRequestUncheckedUpdateWithoutHealthcareLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripNumber?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    patientWeight?: NullableStringFieldUpdateOperationsInput | string | null
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    originFacilityId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationFacilityId?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocation?: NullableStringFieldUpdateOperationsInput | string | null
    toLocation?: NullableStringFieldUpdateOperationsInput | string | null
    isMultiLocationFacility?: BoolFieldUpdateOperationsInput | boolean
    scheduledTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transportLevel?: StringFieldUpdateOperationsInput | string
    urgencyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    specialRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    mobilityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    oxygenRequired?: BoolFieldUpdateOperationsInput | boolean
    monitoringRequired?: BoolFieldUpdateOperationsInput | boolean
    generateQRCode?: BoolFieldUpdateOperationsInput | boolean
    qrCodeData?: NullableStringFieldUpdateOperationsInput | string | null
    selectedAgencies?: TransportRequestUpdateselectedAgenciesInput | string[]
    notificationRadius?: NullableIntFieldUpdateOperationsInput | number | null
    requestTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    arrivalTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departureTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAgencyId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    healthcareCreatedById?: NullableStringFieldUpdateOperationsInput | string | null
    isolation?: BoolFieldUpdateOperationsInput | boolean
    bariatric?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransportRequestUncheckedUpdateManyWithoutHealthcareLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripNumber?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    patientWeight?: NullableStringFieldUpdateOperationsInput | string | null
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    originFacilityId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationFacilityId?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocation?: NullableStringFieldUpdateOperationsInput | string | null
    toLocation?: NullableStringFieldUpdateOperationsInput | string | null
    isMultiLocationFacility?: BoolFieldUpdateOperationsInput | boolean
    scheduledTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transportLevel?: StringFieldUpdateOperationsInput | string
    urgencyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    specialRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    mobilityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    oxygenRequired?: BoolFieldUpdateOperationsInput | boolean
    monitoringRequired?: BoolFieldUpdateOperationsInput | boolean
    generateQRCode?: BoolFieldUpdateOperationsInput | boolean
    qrCodeData?: NullableStringFieldUpdateOperationsInput | string | null
    selectedAgencies?: TransportRequestUpdateselectedAgenciesInput | string[]
    notificationRadius?: NullableIntFieldUpdateOperationsInput | number | null
    requestTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    arrivalTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departureTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAgencyId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    healthcareCreatedById?: NullableStringFieldUpdateOperationsInput | string | null
    isolation?: BoolFieldUpdateOperationsInput | boolean
    bariatric?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitCreateManyAgencyInput = {
    id?: string
    unitNumber: string
    type: string
    status?: string
    currentStatus?: string
    currentLocation?: string | null
    capabilities?: UnitCreatecapabilitiesInput | string[]
    crewSize?: number
    equipment?: UnitCreateequipmentInput | string[]
    location?: NullableJsonNullValueInput | InputJsonValue
    latitude?: number | null
    longitude?: number | null
    lastMaintenance?: Date | string | null
    nextMaintenance?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EMSUserCreateManyAgencyInput = {
    id?: string
    email: string
    password: string
    name: string
    agencyName: string
    isActive?: boolean
    userType?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitNumber?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentStatus?: StringFieldUpdateOperationsInput | string
    currentLocation?: NullableStringFieldUpdateOperationsInput | string | null
    capabilities?: UnitUpdatecapabilitiesInput | string[]
    crewSize?: IntFieldUpdateOperationsInput | number
    equipment?: UnitUpdateequipmentInput | string[]
    location?: NullableJsonNullValueInput | InputJsonValue
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analytics?: unit_analyticsUpdateOneWithoutUnitNestedInput
    assignedTrips?: TransportRequestUpdateManyWithoutAssignedUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitNumber?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentStatus?: StringFieldUpdateOperationsInput | string
    currentLocation?: NullableStringFieldUpdateOperationsInput | string | null
    capabilities?: UnitUpdatecapabilitiesInput | string[]
    crewSize?: IntFieldUpdateOperationsInput | number
    equipment?: UnitUpdateequipmentInput | string[]
    location?: NullableJsonNullValueInput | InputJsonValue
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analytics?: unit_analyticsUncheckedUpdateOneWithoutUnitNestedInput
    assignedTrips?: TransportRequestUncheckedUpdateManyWithoutAssignedUnitNestedInput
  }

  export type UnitUncheckedUpdateManyWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitNumber?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentStatus?: StringFieldUpdateOperationsInput | string
    currentLocation?: NullableStringFieldUpdateOperationsInput | string | null
    capabilities?: UnitUpdatecapabilitiesInput | string[]
    crewSize?: IntFieldUpdateOperationsInput | number
    equipment?: UnitUpdateequipmentInput | string[]
    location?: NullableJsonNullValueInput | InputJsonValue
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EMSUserUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    agencyName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    userType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EMSUserUncheckedUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    agencyName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    userType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EMSUserUncheckedUpdateManyWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    agencyName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    userType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyResponseCreateManyTripInput = {
    id?: string
    agencyId: string
    response: string
    responseTimestamp?: Date | string
    responseNotes?: string | null
    estimatedArrival?: Date | string | null
    isSelected?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgencyResponseUpdateWithoutTripInput = {
    id?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    responseTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    responseNotes?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedArrival?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyResponseUncheckedUpdateWithoutTripInput = {
    id?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    responseTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    responseNotes?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedArrival?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyResponseUncheckedUpdateManyWithoutTripInput = {
    id?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    responseTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    responseNotes?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedArrival?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransportRequestCreateManyPickupLocationInput = {
    id?: string
    tripNumber?: string | null
    patientId: string
    patientWeight?: string | null
    specialNeeds?: string | null
    originFacilityId?: string | null
    destinationFacilityId?: string | null
    fromLocation?: string | null
    toLocation?: string | null
    fromLocationId?: string | null
    isMultiLocationFacility?: boolean
    scheduledTime?: Date | string | null
    transportLevel: string
    urgencyLevel?: string | null
    priority: string
    status?: string
    specialRequirements?: string | null
    diagnosis?: string | null
    mobilityLevel?: string | null
    oxygenRequired?: boolean
    monitoringRequired?: boolean
    generateQRCode?: boolean
    qrCodeData?: string | null
    selectedAgencies?: TransportRequestCreateselectedAgenciesInput | string[]
    notificationRadius?: number | null
    requestTimestamp?: Date | string
    acceptedTimestamp?: Date | string | null
    pickupTimestamp?: Date | string | null
    arrivalTimestamp?: Date | string | null
    departureTimestamp?: Date | string | null
    completionTimestamp?: Date | string | null
    assignedAgencyId?: string | null
    assignedUnitId?: string | null
    createdById?: string | null
    healthcareCreatedById?: string | null
    isolation?: boolean
    bariatric?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TripCreateManyPickup_locationsInput = {
    id?: string
    tripNumber: string
    patientId: string
    patientWeight?: string | null
    specialNeeds?: string | null
    fromLocation: string
    toLocation: string
    scheduledTime: Date | string
    transportLevel: string
    urgencyLevel: string
    diagnosis?: string | null
    mobilityLevel?: string | null
    oxygenRequired?: boolean
    monitoringRequired?: boolean
    generateQRCode?: boolean
    qrCodeData?: string | null
    selectedAgencies?: TripCreateselectedAgenciesInput | string[]
    notificationRadius?: number | null
    transferRequestTime?: Date | string | null
    transferAcceptedTime?: Date | string | null
    emsArrivalTime?: Date | string | null
    emsDepartureTime?: Date | string | null
    actualStartTime?: Date | string | null
    actualEndTime?: Date | string | null
    status: string
    priority: string
    notes?: string | null
    assignedTo?: string | null
    assignedAgencyId?: string | null
    assignedUnitId?: string | null
    acceptedTimestamp?: Date | string | null
    pickupTimestamp?: Date | string | null
    completionTimestamp?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    actualTripTimeMinutes?: number | null
    backhaulOpportunity?: boolean
    completionTimeMinutes?: number | null
    customerSatisfaction?: number | null
    deadheadMiles?: number | null
    destinationLatitude?: number | null
    destinationLongitude?: number | null
    distanceMiles?: number | null
    efficiency?: Decimal | DecimalJsLike | number | string | null
    estimatedTripTimeMinutes?: number | null
    insuranceCompany?: string | null
    insurancePayRate?: Decimal | DecimalJsLike | number | string | null
    loadedMiles?: Decimal | DecimalJsLike | number | string | null
    originLatitude?: number | null
    originLongitude?: number | null
    perMileRate?: Decimal | DecimalJsLike | number | string | null
    performanceScore?: Decimal | DecimalJsLike | number | string | null
    requestTimestamp?: Date | string | null
    responseTimeMinutes?: number | null
    revenuePerHour?: Decimal | DecimalJsLike | number | string | null
    tripCost?: Decimal | DecimalJsLike | number | string | null
    maxResponses?: number
    responseDeadline?: Date | string | null
    responseStatus?: string
    selectionMode?: string
  }

  export type TransportRequestUpdateWithoutPickupLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripNumber?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    patientWeight?: NullableStringFieldUpdateOperationsInput | string | null
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocation?: NullableStringFieldUpdateOperationsInput | string | null
    toLocation?: NullableStringFieldUpdateOperationsInput | string | null
    isMultiLocationFacility?: BoolFieldUpdateOperationsInput | boolean
    scheduledTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transportLevel?: StringFieldUpdateOperationsInput | string
    urgencyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    specialRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    mobilityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    oxygenRequired?: BoolFieldUpdateOperationsInput | boolean
    monitoringRequired?: BoolFieldUpdateOperationsInput | boolean
    generateQRCode?: BoolFieldUpdateOperationsInput | boolean
    qrCodeData?: NullableStringFieldUpdateOperationsInput | string | null
    selectedAgencies?: TransportRequestUpdateselectedAgenciesInput | string[]
    notificationRadius?: NullableIntFieldUpdateOperationsInput | number | null
    requestTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    arrivalTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departureTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedAgencyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    healthcareCreatedById?: NullableStringFieldUpdateOperationsInput | string | null
    isolation?: BoolFieldUpdateOperationsInput | boolean
    bariatric?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    originFacility?: FacilityUpdateOneWithoutOriginTripsNestedInput
    destinationFacility?: FacilityUpdateOneWithoutDestinationTripsNestedInput
    assignedUnit?: UnitUpdateOneWithoutAssignedTripsNestedInput
    healthcareLocation?: HealthcareLocationUpdateOneWithoutTransportRequestsNestedInput
  }

  export type TransportRequestUncheckedUpdateWithoutPickupLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripNumber?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    patientWeight?: NullableStringFieldUpdateOperationsInput | string | null
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    originFacilityId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationFacilityId?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocation?: NullableStringFieldUpdateOperationsInput | string | null
    toLocation?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    isMultiLocationFacility?: BoolFieldUpdateOperationsInput | boolean
    scheduledTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transportLevel?: StringFieldUpdateOperationsInput | string
    urgencyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    specialRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    mobilityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    oxygenRequired?: BoolFieldUpdateOperationsInput | boolean
    monitoringRequired?: BoolFieldUpdateOperationsInput | boolean
    generateQRCode?: BoolFieldUpdateOperationsInput | boolean
    qrCodeData?: NullableStringFieldUpdateOperationsInput | string | null
    selectedAgencies?: TransportRequestUpdateselectedAgenciesInput | string[]
    notificationRadius?: NullableIntFieldUpdateOperationsInput | number | null
    requestTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    arrivalTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departureTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedAgencyId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    healthcareCreatedById?: NullableStringFieldUpdateOperationsInput | string | null
    isolation?: BoolFieldUpdateOperationsInput | boolean
    bariatric?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransportRequestUncheckedUpdateManyWithoutPickupLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripNumber?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    patientWeight?: NullableStringFieldUpdateOperationsInput | string | null
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    originFacilityId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationFacilityId?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocation?: NullableStringFieldUpdateOperationsInput | string | null
    toLocation?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    isMultiLocationFacility?: BoolFieldUpdateOperationsInput | boolean
    scheduledTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transportLevel?: StringFieldUpdateOperationsInput | string
    urgencyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    specialRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    mobilityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    oxygenRequired?: BoolFieldUpdateOperationsInput | boolean
    monitoringRequired?: BoolFieldUpdateOperationsInput | boolean
    generateQRCode?: BoolFieldUpdateOperationsInput | boolean
    qrCodeData?: NullableStringFieldUpdateOperationsInput | string | null
    selectedAgencies?: TransportRequestUpdateselectedAgenciesInput | string[]
    notificationRadius?: NullableIntFieldUpdateOperationsInput | number | null
    requestTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    arrivalTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departureTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedAgencyId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    healthcareCreatedById?: NullableStringFieldUpdateOperationsInput | string | null
    isolation?: BoolFieldUpdateOperationsInput | boolean
    bariatric?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TripUpdateWithoutPickup_locationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripNumber?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    patientWeight?: NullableStringFieldUpdateOperationsInput | string | null
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocation?: StringFieldUpdateOperationsInput | string
    toLocation?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    transportLevel?: StringFieldUpdateOperationsInput | string
    urgencyLevel?: StringFieldUpdateOperationsInput | string
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    mobilityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    oxygenRequired?: BoolFieldUpdateOperationsInput | boolean
    monitoringRequired?: BoolFieldUpdateOperationsInput | boolean
    generateQRCode?: BoolFieldUpdateOperationsInput | boolean
    qrCodeData?: NullableStringFieldUpdateOperationsInput | string | null
    selectedAgencies?: TripUpdateselectedAgenciesInput | string[]
    notificationRadius?: NullableIntFieldUpdateOperationsInput | number | null
    transferRequestTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferAcceptedTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emsArrivalTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emsDepartureTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAgencyId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actualTripTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    backhaulOpportunity?: BoolFieldUpdateOperationsInput | boolean
    completionTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    customerSatisfaction?: NullableIntFieldUpdateOperationsInput | number | null
    deadheadMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    distanceMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    efficiency?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    estimatedTripTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    insuranceCompany?: NullableStringFieldUpdateOperationsInput | string | null
    insurancePayRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loadedMiles?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    originLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    perMileRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    performanceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    requestTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    revenuePerHour?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tripCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxResponses?: IntFieldUpdateOperationsInput | number
    responseDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseStatus?: StringFieldUpdateOperationsInput | string
    selectionMode?: StringFieldUpdateOperationsInput | string
    agencyResponses?: AgencyResponseUpdateManyWithoutTripNestedInput
  }

  export type TripUncheckedUpdateWithoutPickup_locationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripNumber?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    patientWeight?: NullableStringFieldUpdateOperationsInput | string | null
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocation?: StringFieldUpdateOperationsInput | string
    toLocation?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    transportLevel?: StringFieldUpdateOperationsInput | string
    urgencyLevel?: StringFieldUpdateOperationsInput | string
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    mobilityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    oxygenRequired?: BoolFieldUpdateOperationsInput | boolean
    monitoringRequired?: BoolFieldUpdateOperationsInput | boolean
    generateQRCode?: BoolFieldUpdateOperationsInput | boolean
    qrCodeData?: NullableStringFieldUpdateOperationsInput | string | null
    selectedAgencies?: TripUpdateselectedAgenciesInput | string[]
    notificationRadius?: NullableIntFieldUpdateOperationsInput | number | null
    transferRequestTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferAcceptedTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emsArrivalTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emsDepartureTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAgencyId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actualTripTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    backhaulOpportunity?: BoolFieldUpdateOperationsInput | boolean
    completionTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    customerSatisfaction?: NullableIntFieldUpdateOperationsInput | number | null
    deadheadMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    distanceMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    efficiency?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    estimatedTripTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    insuranceCompany?: NullableStringFieldUpdateOperationsInput | string | null
    insurancePayRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loadedMiles?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    originLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    perMileRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    performanceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    requestTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    revenuePerHour?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tripCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxResponses?: IntFieldUpdateOperationsInput | number
    responseDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseStatus?: StringFieldUpdateOperationsInput | string
    selectionMode?: StringFieldUpdateOperationsInput | string
    agencyResponses?: AgencyResponseUncheckedUpdateManyWithoutTripNestedInput
  }

  export type TripUncheckedUpdateManyWithoutPickup_locationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripNumber?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    patientWeight?: NullableStringFieldUpdateOperationsInput | string | null
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocation?: StringFieldUpdateOperationsInput | string
    toLocation?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    transportLevel?: StringFieldUpdateOperationsInput | string
    urgencyLevel?: StringFieldUpdateOperationsInput | string
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    mobilityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    oxygenRequired?: BoolFieldUpdateOperationsInput | boolean
    monitoringRequired?: BoolFieldUpdateOperationsInput | boolean
    generateQRCode?: BoolFieldUpdateOperationsInput | boolean
    qrCodeData?: NullableStringFieldUpdateOperationsInput | string | null
    selectedAgencies?: TripUpdateselectedAgenciesInput | string[]
    notificationRadius?: NullableIntFieldUpdateOperationsInput | number | null
    transferRequestTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferAcceptedTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emsArrivalTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emsDepartureTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAgencyId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actualTripTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    backhaulOpportunity?: BoolFieldUpdateOperationsInput | boolean
    completionTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    customerSatisfaction?: NullableIntFieldUpdateOperationsInput | number | null
    deadheadMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    distanceMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    efficiency?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    estimatedTripTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    insuranceCompany?: NullableStringFieldUpdateOperationsInput | string | null
    insurancePayRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loadedMiles?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    originLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    perMileRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    performanceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    requestTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    revenuePerHour?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tripCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxResponses?: IntFieldUpdateOperationsInput | number
    responseDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseStatus?: StringFieldUpdateOperationsInput | string
    selectionMode?: StringFieldUpdateOperationsInput | string
  }

  export type TransportRequestCreateManyAssignedUnitInput = {
    id?: string
    tripNumber?: string | null
    patientId: string
    patientWeight?: string | null
    specialNeeds?: string | null
    originFacilityId?: string | null
    destinationFacilityId?: string | null
    fromLocation?: string | null
    toLocation?: string | null
    fromLocationId?: string | null
    isMultiLocationFacility?: boolean
    scheduledTime?: Date | string | null
    transportLevel: string
    urgencyLevel?: string | null
    priority: string
    status?: string
    specialRequirements?: string | null
    diagnosis?: string | null
    mobilityLevel?: string | null
    oxygenRequired?: boolean
    monitoringRequired?: boolean
    generateQRCode?: boolean
    qrCodeData?: string | null
    selectedAgencies?: TransportRequestCreateselectedAgenciesInput | string[]
    notificationRadius?: number | null
    requestTimestamp?: Date | string
    acceptedTimestamp?: Date | string | null
    pickupTimestamp?: Date | string | null
    arrivalTimestamp?: Date | string | null
    departureTimestamp?: Date | string | null
    completionTimestamp?: Date | string | null
    pickupLocationId?: string | null
    assignedAgencyId?: string | null
    createdById?: string | null
    healthcareCreatedById?: string | null
    isolation?: boolean
    bariatric?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransportRequestUpdateWithoutAssignedUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripNumber?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    patientWeight?: NullableStringFieldUpdateOperationsInput | string | null
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocation?: NullableStringFieldUpdateOperationsInput | string | null
    toLocation?: NullableStringFieldUpdateOperationsInput | string | null
    isMultiLocationFacility?: BoolFieldUpdateOperationsInput | boolean
    scheduledTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transportLevel?: StringFieldUpdateOperationsInput | string
    urgencyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    specialRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    mobilityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    oxygenRequired?: BoolFieldUpdateOperationsInput | boolean
    monitoringRequired?: BoolFieldUpdateOperationsInput | boolean
    generateQRCode?: BoolFieldUpdateOperationsInput | boolean
    qrCodeData?: NullableStringFieldUpdateOperationsInput | string | null
    selectedAgencies?: TransportRequestUpdateselectedAgenciesInput | string[]
    notificationRadius?: NullableIntFieldUpdateOperationsInput | number | null
    requestTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    arrivalTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departureTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedAgencyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    healthcareCreatedById?: NullableStringFieldUpdateOperationsInput | string | null
    isolation?: BoolFieldUpdateOperationsInput | boolean
    bariatric?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    originFacility?: FacilityUpdateOneWithoutOriginTripsNestedInput
    destinationFacility?: FacilityUpdateOneWithoutDestinationTripsNestedInput
    pickupLocation?: pickup_locationsUpdateOneWithoutTripsNestedInput
    healthcareLocation?: HealthcareLocationUpdateOneWithoutTransportRequestsNestedInput
  }

  export type TransportRequestUncheckedUpdateWithoutAssignedUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripNumber?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    patientWeight?: NullableStringFieldUpdateOperationsInput | string | null
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    originFacilityId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationFacilityId?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocation?: NullableStringFieldUpdateOperationsInput | string | null
    toLocation?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    isMultiLocationFacility?: BoolFieldUpdateOperationsInput | boolean
    scheduledTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transportLevel?: StringFieldUpdateOperationsInput | string
    urgencyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    specialRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    mobilityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    oxygenRequired?: BoolFieldUpdateOperationsInput | boolean
    monitoringRequired?: BoolFieldUpdateOperationsInput | boolean
    generateQRCode?: BoolFieldUpdateOperationsInput | boolean
    qrCodeData?: NullableStringFieldUpdateOperationsInput | string | null
    selectedAgencies?: TransportRequestUpdateselectedAgenciesInput | string[]
    notificationRadius?: NullableIntFieldUpdateOperationsInput | number | null
    requestTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    arrivalTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departureTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAgencyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    healthcareCreatedById?: NullableStringFieldUpdateOperationsInput | string | null
    isolation?: BoolFieldUpdateOperationsInput | boolean
    bariatric?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransportRequestUncheckedUpdateManyWithoutAssignedUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripNumber?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    patientWeight?: NullableStringFieldUpdateOperationsInput | string | null
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    originFacilityId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationFacilityId?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocation?: NullableStringFieldUpdateOperationsInput | string | null
    toLocation?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    isMultiLocationFacility?: BoolFieldUpdateOperationsInput | boolean
    scheduledTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transportLevel?: StringFieldUpdateOperationsInput | string
    urgencyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    specialRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    mobilityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    oxygenRequired?: BoolFieldUpdateOperationsInput | boolean
    monitoringRequired?: BoolFieldUpdateOperationsInput | boolean
    generateQRCode?: BoolFieldUpdateOperationsInput | boolean
    qrCodeData?: NullableStringFieldUpdateOperationsInput | string | null
    selectedAgencies?: TransportRequestUpdateselectedAgenciesInput | string[]
    notificationRadius?: NullableIntFieldUpdateOperationsInput | number | null
    requestTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    arrivalTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departureTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAgencyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    healthcareCreatedById?: NullableStringFieldUpdateOperationsInput | string | null
    isolation?: BoolFieldUpdateOperationsInput | boolean
    bariatric?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransportRequestCreateManyOriginFacilityInput = {
    id?: string
    tripNumber?: string | null
    patientId: string
    patientWeight?: string | null
    specialNeeds?: string | null
    destinationFacilityId?: string | null
    fromLocation?: string | null
    toLocation?: string | null
    fromLocationId?: string | null
    isMultiLocationFacility?: boolean
    scheduledTime?: Date | string | null
    transportLevel: string
    urgencyLevel?: string | null
    priority: string
    status?: string
    specialRequirements?: string | null
    diagnosis?: string | null
    mobilityLevel?: string | null
    oxygenRequired?: boolean
    monitoringRequired?: boolean
    generateQRCode?: boolean
    qrCodeData?: string | null
    selectedAgencies?: TransportRequestCreateselectedAgenciesInput | string[]
    notificationRadius?: number | null
    requestTimestamp?: Date | string
    acceptedTimestamp?: Date | string | null
    pickupTimestamp?: Date | string | null
    arrivalTimestamp?: Date | string | null
    departureTimestamp?: Date | string | null
    completionTimestamp?: Date | string | null
    pickupLocationId?: string | null
    assignedAgencyId?: string | null
    assignedUnitId?: string | null
    createdById?: string | null
    healthcareCreatedById?: string | null
    isolation?: boolean
    bariatric?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransportRequestCreateManyDestinationFacilityInput = {
    id?: string
    tripNumber?: string | null
    patientId: string
    patientWeight?: string | null
    specialNeeds?: string | null
    originFacilityId?: string | null
    fromLocation?: string | null
    toLocation?: string | null
    fromLocationId?: string | null
    isMultiLocationFacility?: boolean
    scheduledTime?: Date | string | null
    transportLevel: string
    urgencyLevel?: string | null
    priority: string
    status?: string
    specialRequirements?: string | null
    diagnosis?: string | null
    mobilityLevel?: string | null
    oxygenRequired?: boolean
    monitoringRequired?: boolean
    generateQRCode?: boolean
    qrCodeData?: string | null
    selectedAgencies?: TransportRequestCreateselectedAgenciesInput | string[]
    notificationRadius?: number | null
    requestTimestamp?: Date | string
    acceptedTimestamp?: Date | string | null
    pickupTimestamp?: Date | string | null
    arrivalTimestamp?: Date | string | null
    departureTimestamp?: Date | string | null
    completionTimestamp?: Date | string | null
    pickupLocationId?: string | null
    assignedAgencyId?: string | null
    assignedUnitId?: string | null
    createdById?: string | null
    healthcareCreatedById?: string | null
    isolation?: boolean
    bariatric?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransportRequestUpdateWithoutOriginFacilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripNumber?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    patientWeight?: NullableStringFieldUpdateOperationsInput | string | null
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocation?: NullableStringFieldUpdateOperationsInput | string | null
    toLocation?: NullableStringFieldUpdateOperationsInput | string | null
    isMultiLocationFacility?: BoolFieldUpdateOperationsInput | boolean
    scheduledTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transportLevel?: StringFieldUpdateOperationsInput | string
    urgencyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    specialRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    mobilityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    oxygenRequired?: BoolFieldUpdateOperationsInput | boolean
    monitoringRequired?: BoolFieldUpdateOperationsInput | boolean
    generateQRCode?: BoolFieldUpdateOperationsInput | boolean
    qrCodeData?: NullableStringFieldUpdateOperationsInput | string | null
    selectedAgencies?: TransportRequestUpdateselectedAgenciesInput | string[]
    notificationRadius?: NullableIntFieldUpdateOperationsInput | number | null
    requestTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    arrivalTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departureTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedAgencyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    healthcareCreatedById?: NullableStringFieldUpdateOperationsInput | string | null
    isolation?: BoolFieldUpdateOperationsInput | boolean
    bariatric?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    destinationFacility?: FacilityUpdateOneWithoutDestinationTripsNestedInput
    pickupLocation?: pickup_locationsUpdateOneWithoutTripsNestedInput
    assignedUnit?: UnitUpdateOneWithoutAssignedTripsNestedInput
    healthcareLocation?: HealthcareLocationUpdateOneWithoutTransportRequestsNestedInput
  }

  export type TransportRequestUncheckedUpdateWithoutOriginFacilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripNumber?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    patientWeight?: NullableStringFieldUpdateOperationsInput | string | null
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    destinationFacilityId?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocation?: NullableStringFieldUpdateOperationsInput | string | null
    toLocation?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    isMultiLocationFacility?: BoolFieldUpdateOperationsInput | boolean
    scheduledTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transportLevel?: StringFieldUpdateOperationsInput | string
    urgencyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    specialRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    mobilityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    oxygenRequired?: BoolFieldUpdateOperationsInput | boolean
    monitoringRequired?: BoolFieldUpdateOperationsInput | boolean
    generateQRCode?: BoolFieldUpdateOperationsInput | boolean
    qrCodeData?: NullableStringFieldUpdateOperationsInput | string | null
    selectedAgencies?: TransportRequestUpdateselectedAgenciesInput | string[]
    notificationRadius?: NullableIntFieldUpdateOperationsInput | number | null
    requestTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    arrivalTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departureTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAgencyId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    healthcareCreatedById?: NullableStringFieldUpdateOperationsInput | string | null
    isolation?: BoolFieldUpdateOperationsInput | boolean
    bariatric?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransportRequestUncheckedUpdateManyWithoutOriginFacilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripNumber?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    patientWeight?: NullableStringFieldUpdateOperationsInput | string | null
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    destinationFacilityId?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocation?: NullableStringFieldUpdateOperationsInput | string | null
    toLocation?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    isMultiLocationFacility?: BoolFieldUpdateOperationsInput | boolean
    scheduledTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transportLevel?: StringFieldUpdateOperationsInput | string
    urgencyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    specialRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    mobilityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    oxygenRequired?: BoolFieldUpdateOperationsInput | boolean
    monitoringRequired?: BoolFieldUpdateOperationsInput | boolean
    generateQRCode?: BoolFieldUpdateOperationsInput | boolean
    qrCodeData?: NullableStringFieldUpdateOperationsInput | string | null
    selectedAgencies?: TransportRequestUpdateselectedAgenciesInput | string[]
    notificationRadius?: NullableIntFieldUpdateOperationsInput | number | null
    requestTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    arrivalTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departureTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAgencyId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    healthcareCreatedById?: NullableStringFieldUpdateOperationsInput | string | null
    isolation?: BoolFieldUpdateOperationsInput | boolean
    bariatric?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransportRequestUpdateWithoutDestinationFacilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripNumber?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    patientWeight?: NullableStringFieldUpdateOperationsInput | string | null
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocation?: NullableStringFieldUpdateOperationsInput | string | null
    toLocation?: NullableStringFieldUpdateOperationsInput | string | null
    isMultiLocationFacility?: BoolFieldUpdateOperationsInput | boolean
    scheduledTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transportLevel?: StringFieldUpdateOperationsInput | string
    urgencyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    specialRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    mobilityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    oxygenRequired?: BoolFieldUpdateOperationsInput | boolean
    monitoringRequired?: BoolFieldUpdateOperationsInput | boolean
    generateQRCode?: BoolFieldUpdateOperationsInput | boolean
    qrCodeData?: NullableStringFieldUpdateOperationsInput | string | null
    selectedAgencies?: TransportRequestUpdateselectedAgenciesInput | string[]
    notificationRadius?: NullableIntFieldUpdateOperationsInput | number | null
    requestTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    arrivalTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departureTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedAgencyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    healthcareCreatedById?: NullableStringFieldUpdateOperationsInput | string | null
    isolation?: BoolFieldUpdateOperationsInput | boolean
    bariatric?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    originFacility?: FacilityUpdateOneWithoutOriginTripsNestedInput
    pickupLocation?: pickup_locationsUpdateOneWithoutTripsNestedInput
    assignedUnit?: UnitUpdateOneWithoutAssignedTripsNestedInput
    healthcareLocation?: HealthcareLocationUpdateOneWithoutTransportRequestsNestedInput
  }

  export type TransportRequestUncheckedUpdateWithoutDestinationFacilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripNumber?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    patientWeight?: NullableStringFieldUpdateOperationsInput | string | null
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    originFacilityId?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocation?: NullableStringFieldUpdateOperationsInput | string | null
    toLocation?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    isMultiLocationFacility?: BoolFieldUpdateOperationsInput | boolean
    scheduledTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transportLevel?: StringFieldUpdateOperationsInput | string
    urgencyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    specialRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    mobilityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    oxygenRequired?: BoolFieldUpdateOperationsInput | boolean
    monitoringRequired?: BoolFieldUpdateOperationsInput | boolean
    generateQRCode?: BoolFieldUpdateOperationsInput | boolean
    qrCodeData?: NullableStringFieldUpdateOperationsInput | string | null
    selectedAgencies?: TransportRequestUpdateselectedAgenciesInput | string[]
    notificationRadius?: NullableIntFieldUpdateOperationsInput | number | null
    requestTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    arrivalTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departureTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAgencyId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    healthcareCreatedById?: NullableStringFieldUpdateOperationsInput | string | null
    isolation?: BoolFieldUpdateOperationsInput | boolean
    bariatric?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransportRequestUncheckedUpdateManyWithoutDestinationFacilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripNumber?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    patientWeight?: NullableStringFieldUpdateOperationsInput | string | null
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    originFacilityId?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocation?: NullableStringFieldUpdateOperationsInput | string | null
    toLocation?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    isMultiLocationFacility?: BoolFieldUpdateOperationsInput | boolean
    scheduledTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transportLevel?: StringFieldUpdateOperationsInput | string
    urgencyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    specialRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    mobilityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    oxygenRequired?: BoolFieldUpdateOperationsInput | boolean
    monitoringRequired?: BoolFieldUpdateOperationsInput | boolean
    generateQRCode?: BoolFieldUpdateOperationsInput | boolean
    qrCodeData?: NullableStringFieldUpdateOperationsInput | string | null
    selectedAgencies?: TransportRequestUpdateselectedAgenciesInput | string[]
    notificationRadius?: NullableIntFieldUpdateOperationsInput | number | null
    requestTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    arrivalTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departureTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAgencyId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    healthcareCreatedById?: NullableStringFieldUpdateOperationsInput | string | null
    isolation?: BoolFieldUpdateOperationsInput | boolean
    bariatric?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use CenterUserCountOutputTypeDefaultArgs instead
     */
    export type CenterUserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CenterUserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HealthcareUserCountOutputTypeDefaultArgs instead
     */
    export type HealthcareUserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HealthcareUserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HealthcareLocationCountOutputTypeDefaultArgs instead
     */
    export type HealthcareLocationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HealthcareLocationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EMSAgencyCountOutputTypeDefaultArgs instead
     */
    export type EMSAgencyCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EMSAgencyCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TripCountOutputTypeDefaultArgs instead
     */
    export type TripCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TripCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Pickup_locationsCountOutputTypeDefaultArgs instead
     */
    export type Pickup_locationsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Pickup_locationsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UnitCountOutputTypeDefaultArgs instead
     */
    export type UnitCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UnitCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FacilityCountOutputTypeDefaultArgs instead
     */
    export type FacilityCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FacilityCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CenterUserDefaultArgs instead
     */
    export type CenterUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CenterUserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HealthcareUserDefaultArgs instead
     */
    export type HealthcareUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HealthcareUserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HealthcareLocationDefaultArgs instead
     */
    export type HealthcareLocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HealthcareLocationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HospitalDefaultArgs instead
     */
    export type HospitalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HospitalDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EMSUserDefaultArgs instead
     */
    export type EMSUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EMSUserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EMSAgencyDefaultArgs instead
     */
    export type EMSAgencyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EMSAgencyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TripDefaultArgs instead
     */
    export type TripArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TripDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AgencyResponseDefaultArgs instead
     */
    export type AgencyResponseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AgencyResponseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SystemAnalyticsDefaultArgs instead
     */
    export type SystemAnalyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SystemAnalyticsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TripCostBreakdownDefaultArgs instead
     */
    export type TripCostBreakdownArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TripCostBreakdownDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CostCenterDefaultArgs instead
     */
    export type CostCenterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CostCenterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use backhaul_opportunitiesDefaultArgs instead
     */
    export type backhaul_opportunitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = backhaul_opportunitiesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use pickup_locationsDefaultArgs instead
     */
    export type pickup_locationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = pickup_locationsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use pricing_modelsDefaultArgs instead
     */
    export type pricing_modelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = pricing_modelsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use route_optimization_settingsDefaultArgs instead
     */
    export type route_optimization_settingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = route_optimization_settingsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UnitDefaultArgs instead
     */
    export type UnitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UnitDefaultArgs<ExtArgs>
    /**
     * @deprecated Use unit_analyticsDefaultArgs instead
     */
    export type unit_analyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = unit_analyticsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationPreferenceDefaultArgs instead
     */
    export type NotificationPreferenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationPreferenceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationLogDefaultArgs instead
     */
    export type NotificationLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DropdownOptionDefaultArgs instead
     */
    export type DropdownOptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DropdownOptionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoryDefaultDefaultArgs instead
     */
    export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoryDefaultDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TransportRequestDefaultArgs instead
     */
    export type TransportRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TransportRequestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FacilityDefaultArgs instead
     */
    export type FacilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FacilityDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}