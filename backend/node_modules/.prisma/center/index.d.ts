
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model CenterUser
 * 
 */
export type CenterUser = $Result.DefaultSelection<Prisma.$CenterUserPayload>
/**
 * Model Hospital
 * 
 */
export type Hospital = $Result.DefaultSelection<Prisma.$HospitalPayload>
/**
 * Model PickupLocation
 * 
 */
export type PickupLocation = $Result.DefaultSelection<Prisma.$PickupLocationPayload>
/**
 * Model EMSAgency
 * 
 */
export type EMSAgency = $Result.DefaultSelection<Prisma.$EMSAgencyPayload>
/**
 * Model Trip
 * 
 */
export type Trip = $Result.DefaultSelection<Prisma.$TripPayload>
/**
 * Model SystemAnalytics
 * 
 */
export type SystemAnalytics = $Result.DefaultSelection<Prisma.$SystemAnalyticsPayload>
/**
 * Model pricingModel
 * 
 */
export type pricingModel = $Result.DefaultSelection<Prisma.$pricingModelPayload>
/**
 * Model BackhaulOpportunities
 * 
 */
export type BackhaulOpportunities = $Result.DefaultSelection<Prisma.$BackhaulOpportunitiesPayload>
/**
 * Model UnitAnalytics
 * 
 */
export type UnitAnalytics = $Result.DefaultSelection<Prisma.$UnitAnalyticsPayload>
/**
 * Model RouteOptimizationSettings
 * 
 */
export type RouteOptimizationSettings = $Result.DefaultSelection<Prisma.$RouteOptimizationSettingsPayload>
/**
 * Model TripCostBreakdown
 * 
 */
export type TripCostBreakdown = $Result.DefaultSelection<Prisma.$TripCostBreakdownPayload>
/**
 * Model CostCenter
 * 
 */
export type CostCenter = $Result.DefaultSelection<Prisma.$CostCenterPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more CenterUsers
 * const centerUsers = await prisma.centerUser.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more CenterUsers
   * const centerUsers = await prisma.centerUser.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.centerUser`: Exposes CRUD operations for the **CenterUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CenterUsers
    * const centerUsers = await prisma.centerUser.findMany()
    * ```
    */
  get centerUser(): Prisma.CenterUserDelegate<ExtArgs>;

  /**
   * `prisma.hospital`: Exposes CRUD operations for the **Hospital** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Hospitals
    * const hospitals = await prisma.hospital.findMany()
    * ```
    */
  get hospital(): Prisma.HospitalDelegate<ExtArgs>;

  /**
   * `prisma.pickupLocation`: Exposes CRUD operations for the **PickupLocation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PickupLocations
    * const pickupLocations = await prisma.pickupLocation.findMany()
    * ```
    */
  get pickupLocation(): Prisma.PickupLocationDelegate<ExtArgs>;

  /**
   * `prisma.eMSAgency`: Exposes CRUD operations for the **EMSAgency** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EMSAgencies
    * const eMSAgencies = await prisma.eMSAgency.findMany()
    * ```
    */
  get eMSAgency(): Prisma.EMSAgencyDelegate<ExtArgs>;

  /**
   * `prisma.trip`: Exposes CRUD operations for the **Trip** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Trips
    * const trips = await prisma.trip.findMany()
    * ```
    */
  get trip(): Prisma.TripDelegate<ExtArgs>;

  /**
   * `prisma.systemAnalytics`: Exposes CRUD operations for the **SystemAnalytics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemAnalytics
    * const systemAnalytics = await prisma.systemAnalytics.findMany()
    * ```
    */
  get systemAnalytics(): Prisma.SystemAnalyticsDelegate<ExtArgs>;

  /**
   * `prisma.pricingModel`: Exposes CRUD operations for the **pricingModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PricingModels
    * const pricingModels = await prisma.pricingModel.findMany()
    * ```
    */
  get pricingModel(): Prisma.pricingModelDelegate<ExtArgs>;

  /**
   * `prisma.backhaulOpportunities`: Exposes CRUD operations for the **BackhaulOpportunities** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BackhaulOpportunities
    * const backhaulOpportunities = await prisma.backhaulOpportunities.findMany()
    * ```
    */
  get backhaulOpportunities(): Prisma.BackhaulOpportunitiesDelegate<ExtArgs>;

  /**
   * `prisma.unitAnalytics`: Exposes CRUD operations for the **UnitAnalytics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UnitAnalytics
    * const unitAnalytics = await prisma.unitAnalytics.findMany()
    * ```
    */
  get unitAnalytics(): Prisma.UnitAnalyticsDelegate<ExtArgs>;

  /**
   * `prisma.routeOptimizationSettings`: Exposes CRUD operations for the **RouteOptimizationSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RouteOptimizationSettings
    * const routeOptimizationSettings = await prisma.routeOptimizationSettings.findMany()
    * ```
    */
  get routeOptimizationSettings(): Prisma.RouteOptimizationSettingsDelegate<ExtArgs>;

  /**
   * `prisma.tripCostBreakdown`: Exposes CRUD operations for the **TripCostBreakdown** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TripCostBreakdowns
    * const tripCostBreakdowns = await prisma.tripCostBreakdown.findMany()
    * ```
    */
  get tripCostBreakdown(): Prisma.TripCostBreakdownDelegate<ExtArgs>;

  /**
   * `prisma.costCenter`: Exposes CRUD operations for the **CostCenter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CostCenters
    * const costCenters = await prisma.costCenter.findMany()
    * ```
    */
  get costCenter(): Prisma.CostCenterDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    CenterUser: 'CenterUser',
    Hospital: 'Hospital',
    PickupLocation: 'PickupLocation',
    EMSAgency: 'EMSAgency',
    Trip: 'Trip',
    SystemAnalytics: 'SystemAnalytics',
    pricingModel: 'pricingModel',
    BackhaulOpportunities: 'BackhaulOpportunities',
    UnitAnalytics: 'UnitAnalytics',
    RouteOptimizationSettings: 'RouteOptimizationSettings',
    TripCostBreakdown: 'TripCostBreakdown',
    CostCenter: 'CostCenter'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "centerUser" | "hospital" | "pickupLocation" | "eMSAgency" | "trip" | "systemAnalytics" | "pricingModel" | "backhaulOpportunities" | "unitAnalytics" | "routeOptimizationSettings" | "tripCostBreakdown" | "costCenter"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      CenterUser: {
        payload: Prisma.$CenterUserPayload<ExtArgs>
        fields: Prisma.CenterUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CenterUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CenterUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CenterUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CenterUserPayload>
          }
          findFirst: {
            args: Prisma.CenterUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CenterUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CenterUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CenterUserPayload>
          }
          findMany: {
            args: Prisma.CenterUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CenterUserPayload>[]
          }
          create: {
            args: Prisma.CenterUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CenterUserPayload>
          }
          createMany: {
            args: Prisma.CenterUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CenterUserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CenterUserPayload>[]
          }
          delete: {
            args: Prisma.CenterUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CenterUserPayload>
          }
          update: {
            args: Prisma.CenterUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CenterUserPayload>
          }
          deleteMany: {
            args: Prisma.CenterUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CenterUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CenterUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CenterUserPayload>
          }
          aggregate: {
            args: Prisma.CenterUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCenterUser>
          }
          groupBy: {
            args: Prisma.CenterUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<CenterUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.CenterUserCountArgs<ExtArgs>
            result: $Utils.Optional<CenterUserCountAggregateOutputType> | number
          }
        }
      }
      Hospital: {
        payload: Prisma.$HospitalPayload<ExtArgs>
        fields: Prisma.HospitalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HospitalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HospitalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalPayload>
          }
          findFirst: {
            args: Prisma.HospitalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HospitalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalPayload>
          }
          findMany: {
            args: Prisma.HospitalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalPayload>[]
          }
          create: {
            args: Prisma.HospitalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalPayload>
          }
          createMany: {
            args: Prisma.HospitalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HospitalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalPayload>[]
          }
          delete: {
            args: Prisma.HospitalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalPayload>
          }
          update: {
            args: Prisma.HospitalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalPayload>
          }
          deleteMany: {
            args: Prisma.HospitalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HospitalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HospitalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalPayload>
          }
          aggregate: {
            args: Prisma.HospitalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHospital>
          }
          groupBy: {
            args: Prisma.HospitalGroupByArgs<ExtArgs>
            result: $Utils.Optional<HospitalGroupByOutputType>[]
          }
          count: {
            args: Prisma.HospitalCountArgs<ExtArgs>
            result: $Utils.Optional<HospitalCountAggregateOutputType> | number
          }
        }
      }
      PickupLocation: {
        payload: Prisma.$PickupLocationPayload<ExtArgs>
        fields: Prisma.PickupLocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PickupLocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PickupLocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PickupLocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PickupLocationPayload>
          }
          findFirst: {
            args: Prisma.PickupLocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PickupLocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PickupLocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PickupLocationPayload>
          }
          findMany: {
            args: Prisma.PickupLocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PickupLocationPayload>[]
          }
          create: {
            args: Prisma.PickupLocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PickupLocationPayload>
          }
          createMany: {
            args: Prisma.PickupLocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PickupLocationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PickupLocationPayload>[]
          }
          delete: {
            args: Prisma.PickupLocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PickupLocationPayload>
          }
          update: {
            args: Prisma.PickupLocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PickupLocationPayload>
          }
          deleteMany: {
            args: Prisma.PickupLocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PickupLocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PickupLocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PickupLocationPayload>
          }
          aggregate: {
            args: Prisma.PickupLocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePickupLocation>
          }
          groupBy: {
            args: Prisma.PickupLocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<PickupLocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.PickupLocationCountArgs<ExtArgs>
            result: $Utils.Optional<PickupLocationCountAggregateOutputType> | number
          }
        }
      }
      EMSAgency: {
        payload: Prisma.$EMSAgencyPayload<ExtArgs>
        fields: Prisma.EMSAgencyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EMSAgencyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EMSAgencyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EMSAgencyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EMSAgencyPayload>
          }
          findFirst: {
            args: Prisma.EMSAgencyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EMSAgencyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EMSAgencyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EMSAgencyPayload>
          }
          findMany: {
            args: Prisma.EMSAgencyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EMSAgencyPayload>[]
          }
          create: {
            args: Prisma.EMSAgencyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EMSAgencyPayload>
          }
          createMany: {
            args: Prisma.EMSAgencyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EMSAgencyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EMSAgencyPayload>[]
          }
          delete: {
            args: Prisma.EMSAgencyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EMSAgencyPayload>
          }
          update: {
            args: Prisma.EMSAgencyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EMSAgencyPayload>
          }
          deleteMany: {
            args: Prisma.EMSAgencyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EMSAgencyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EMSAgencyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EMSAgencyPayload>
          }
          aggregate: {
            args: Prisma.EMSAgencyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEMSAgency>
          }
          groupBy: {
            args: Prisma.EMSAgencyGroupByArgs<ExtArgs>
            result: $Utils.Optional<EMSAgencyGroupByOutputType>[]
          }
          count: {
            args: Prisma.EMSAgencyCountArgs<ExtArgs>
            result: $Utils.Optional<EMSAgencyCountAggregateOutputType> | number
          }
        }
      }
      Trip: {
        payload: Prisma.$TripPayload<ExtArgs>
        fields: Prisma.TripFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TripFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TripFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>
          }
          findFirst: {
            args: Prisma.TripFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TripFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>
          }
          findMany: {
            args: Prisma.TripFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>[]
          }
          create: {
            args: Prisma.TripCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>
          }
          createMany: {
            args: Prisma.TripCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TripCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>[]
          }
          delete: {
            args: Prisma.TripDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>
          }
          update: {
            args: Prisma.TripUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>
          }
          deleteMany: {
            args: Prisma.TripDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TripUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TripUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>
          }
          aggregate: {
            args: Prisma.TripAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrip>
          }
          groupBy: {
            args: Prisma.TripGroupByArgs<ExtArgs>
            result: $Utils.Optional<TripGroupByOutputType>[]
          }
          count: {
            args: Prisma.TripCountArgs<ExtArgs>
            result: $Utils.Optional<TripCountAggregateOutputType> | number
          }
        }
      }
      SystemAnalytics: {
        payload: Prisma.$SystemAnalyticsPayload<ExtArgs>
        fields: Prisma.SystemAnalyticsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemAnalyticsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemAnalyticsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemAnalyticsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemAnalyticsPayload>
          }
          findFirst: {
            args: Prisma.SystemAnalyticsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemAnalyticsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemAnalyticsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemAnalyticsPayload>
          }
          findMany: {
            args: Prisma.SystemAnalyticsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemAnalyticsPayload>[]
          }
          create: {
            args: Prisma.SystemAnalyticsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemAnalyticsPayload>
          }
          createMany: {
            args: Prisma.SystemAnalyticsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemAnalyticsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemAnalyticsPayload>[]
          }
          delete: {
            args: Prisma.SystemAnalyticsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemAnalyticsPayload>
          }
          update: {
            args: Prisma.SystemAnalyticsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemAnalyticsPayload>
          }
          deleteMany: {
            args: Prisma.SystemAnalyticsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemAnalyticsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SystemAnalyticsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemAnalyticsPayload>
          }
          aggregate: {
            args: Prisma.SystemAnalyticsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemAnalytics>
          }
          groupBy: {
            args: Prisma.SystemAnalyticsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemAnalyticsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemAnalyticsCountArgs<ExtArgs>
            result: $Utils.Optional<SystemAnalyticsCountAggregateOutputType> | number
          }
        }
      }
      pricingModel: {
        payload: Prisma.$pricingModelPayload<ExtArgs>
        fields: Prisma.pricingModelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.pricingModelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pricingModelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.pricingModelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pricingModelPayload>
          }
          findFirst: {
            args: Prisma.pricingModelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pricingModelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.pricingModelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pricingModelPayload>
          }
          findMany: {
            args: Prisma.pricingModelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pricingModelPayload>[]
          }
          create: {
            args: Prisma.pricingModelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pricingModelPayload>
          }
          createMany: {
            args: Prisma.pricingModelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.pricingModelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pricingModelPayload>[]
          }
          delete: {
            args: Prisma.pricingModelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pricingModelPayload>
          }
          update: {
            args: Prisma.pricingModelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pricingModelPayload>
          }
          deleteMany: {
            args: Prisma.pricingModelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.pricingModelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.pricingModelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pricingModelPayload>
          }
          aggregate: {
            args: Prisma.PricingModelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePricingModel>
          }
          groupBy: {
            args: Prisma.pricingModelGroupByArgs<ExtArgs>
            result: $Utils.Optional<PricingModelGroupByOutputType>[]
          }
          count: {
            args: Prisma.pricingModelCountArgs<ExtArgs>
            result: $Utils.Optional<PricingModelCountAggregateOutputType> | number
          }
        }
      }
      BackhaulOpportunities: {
        payload: Prisma.$BackhaulOpportunitiesPayload<ExtArgs>
        fields: Prisma.BackhaulOpportunitiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BackhaulOpportunitiesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackhaulOpportunitiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BackhaulOpportunitiesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackhaulOpportunitiesPayload>
          }
          findFirst: {
            args: Prisma.BackhaulOpportunitiesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackhaulOpportunitiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BackhaulOpportunitiesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackhaulOpportunitiesPayload>
          }
          findMany: {
            args: Prisma.BackhaulOpportunitiesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackhaulOpportunitiesPayload>[]
          }
          create: {
            args: Prisma.BackhaulOpportunitiesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackhaulOpportunitiesPayload>
          }
          createMany: {
            args: Prisma.BackhaulOpportunitiesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BackhaulOpportunitiesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackhaulOpportunitiesPayload>[]
          }
          delete: {
            args: Prisma.BackhaulOpportunitiesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackhaulOpportunitiesPayload>
          }
          update: {
            args: Prisma.BackhaulOpportunitiesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackhaulOpportunitiesPayload>
          }
          deleteMany: {
            args: Prisma.BackhaulOpportunitiesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BackhaulOpportunitiesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BackhaulOpportunitiesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackhaulOpportunitiesPayload>
          }
          aggregate: {
            args: Prisma.BackhaulOpportunitiesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBackhaulOpportunities>
          }
          groupBy: {
            args: Prisma.BackhaulOpportunitiesGroupByArgs<ExtArgs>
            result: $Utils.Optional<BackhaulOpportunitiesGroupByOutputType>[]
          }
          count: {
            args: Prisma.BackhaulOpportunitiesCountArgs<ExtArgs>
            result: $Utils.Optional<BackhaulOpportunitiesCountAggregateOutputType> | number
          }
        }
      }
      UnitAnalytics: {
        payload: Prisma.$UnitAnalyticsPayload<ExtArgs>
        fields: Prisma.UnitAnalyticsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnitAnalyticsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitAnalyticsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnitAnalyticsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitAnalyticsPayload>
          }
          findFirst: {
            args: Prisma.UnitAnalyticsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitAnalyticsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnitAnalyticsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitAnalyticsPayload>
          }
          findMany: {
            args: Prisma.UnitAnalyticsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitAnalyticsPayload>[]
          }
          create: {
            args: Prisma.UnitAnalyticsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitAnalyticsPayload>
          }
          createMany: {
            args: Prisma.UnitAnalyticsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UnitAnalyticsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitAnalyticsPayload>[]
          }
          delete: {
            args: Prisma.UnitAnalyticsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitAnalyticsPayload>
          }
          update: {
            args: Prisma.UnitAnalyticsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitAnalyticsPayload>
          }
          deleteMany: {
            args: Prisma.UnitAnalyticsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnitAnalyticsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UnitAnalyticsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitAnalyticsPayload>
          }
          aggregate: {
            args: Prisma.UnitAnalyticsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnitAnalytics>
          }
          groupBy: {
            args: Prisma.UnitAnalyticsGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnitAnalyticsGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnitAnalyticsCountArgs<ExtArgs>
            result: $Utils.Optional<UnitAnalyticsCountAggregateOutputType> | number
          }
        }
      }
      RouteOptimizationSettings: {
        payload: Prisma.$RouteOptimizationSettingsPayload<ExtArgs>
        fields: Prisma.RouteOptimizationSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RouteOptimizationSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteOptimizationSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RouteOptimizationSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteOptimizationSettingsPayload>
          }
          findFirst: {
            args: Prisma.RouteOptimizationSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteOptimizationSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RouteOptimizationSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteOptimizationSettingsPayload>
          }
          findMany: {
            args: Prisma.RouteOptimizationSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteOptimizationSettingsPayload>[]
          }
          create: {
            args: Prisma.RouteOptimizationSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteOptimizationSettingsPayload>
          }
          createMany: {
            args: Prisma.RouteOptimizationSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RouteOptimizationSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteOptimizationSettingsPayload>[]
          }
          delete: {
            args: Prisma.RouteOptimizationSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteOptimizationSettingsPayload>
          }
          update: {
            args: Prisma.RouteOptimizationSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteOptimizationSettingsPayload>
          }
          deleteMany: {
            args: Prisma.RouteOptimizationSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RouteOptimizationSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RouteOptimizationSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteOptimizationSettingsPayload>
          }
          aggregate: {
            args: Prisma.RouteOptimizationSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRouteOptimizationSettings>
          }
          groupBy: {
            args: Prisma.RouteOptimizationSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<RouteOptimizationSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.RouteOptimizationSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<RouteOptimizationSettingsCountAggregateOutputType> | number
          }
        }
      }
      TripCostBreakdown: {
        payload: Prisma.$TripCostBreakdownPayload<ExtArgs>
        fields: Prisma.TripCostBreakdownFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TripCostBreakdownFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripCostBreakdownPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TripCostBreakdownFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripCostBreakdownPayload>
          }
          findFirst: {
            args: Prisma.TripCostBreakdownFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripCostBreakdownPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TripCostBreakdownFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripCostBreakdownPayload>
          }
          findMany: {
            args: Prisma.TripCostBreakdownFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripCostBreakdownPayload>[]
          }
          create: {
            args: Prisma.TripCostBreakdownCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripCostBreakdownPayload>
          }
          createMany: {
            args: Prisma.TripCostBreakdownCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TripCostBreakdownCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripCostBreakdownPayload>[]
          }
          delete: {
            args: Prisma.TripCostBreakdownDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripCostBreakdownPayload>
          }
          update: {
            args: Prisma.TripCostBreakdownUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripCostBreakdownPayload>
          }
          deleteMany: {
            args: Prisma.TripCostBreakdownDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TripCostBreakdownUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TripCostBreakdownUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripCostBreakdownPayload>
          }
          aggregate: {
            args: Prisma.TripCostBreakdownAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTripCostBreakdown>
          }
          groupBy: {
            args: Prisma.TripCostBreakdownGroupByArgs<ExtArgs>
            result: $Utils.Optional<TripCostBreakdownGroupByOutputType>[]
          }
          count: {
            args: Prisma.TripCostBreakdownCountArgs<ExtArgs>
            result: $Utils.Optional<TripCostBreakdownCountAggregateOutputType> | number
          }
        }
      }
      CostCenter: {
        payload: Prisma.$CostCenterPayload<ExtArgs>
        fields: Prisma.CostCenterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CostCenterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostCenterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CostCenterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostCenterPayload>
          }
          findFirst: {
            args: Prisma.CostCenterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostCenterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CostCenterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostCenterPayload>
          }
          findMany: {
            args: Prisma.CostCenterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostCenterPayload>[]
          }
          create: {
            args: Prisma.CostCenterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostCenterPayload>
          }
          createMany: {
            args: Prisma.CostCenterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CostCenterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostCenterPayload>[]
          }
          delete: {
            args: Prisma.CostCenterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostCenterPayload>
          }
          update: {
            args: Prisma.CostCenterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostCenterPayload>
          }
          deleteMany: {
            args: Prisma.CostCenterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CostCenterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CostCenterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostCenterPayload>
          }
          aggregate: {
            args: Prisma.CostCenterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCostCenter>
          }
          groupBy: {
            args: Prisma.CostCenterGroupByArgs<ExtArgs>
            result: $Utils.Optional<CostCenterGroupByOutputType>[]
          }
          count: {
            args: Prisma.CostCenterCountArgs<ExtArgs>
            result: $Utils.Optional<CostCenterCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type HospitalCountOutputType
   */

  export type HospitalCountOutputType = {
    pickupLocations: number
  }

  export type HospitalCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pickupLocations?: boolean | HospitalCountOutputTypeCountPickupLocationsArgs
  }

  // Custom InputTypes
  /**
   * HospitalCountOutputType without action
   */
  export type HospitalCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HospitalCountOutputType
     */
    select?: HospitalCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HospitalCountOutputType without action
   */
  export type HospitalCountOutputTypeCountPickupLocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PickupLocationWhereInput
  }


  /**
   * Count Type PickupLocationCountOutputType
   */

  export type PickupLocationCountOutputType = {
    trips: number
  }

  export type PickupLocationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trips?: boolean | PickupLocationCountOutputTypeCountTripsArgs
  }

  // Custom InputTypes
  /**
   * PickupLocationCountOutputType without action
   */
  export type PickupLocationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PickupLocationCountOutputType
     */
    select?: PickupLocationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PickupLocationCountOutputType without action
   */
  export type PickupLocationCountOutputTypeCountTripsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TripWhereInput
  }


  /**
   * Models
   */

  /**
   * Model CenterUser
   */

  export type AggregateCenterUser = {
    _count: CenterUserCountAggregateOutputType | null
    _min: CenterUserMinAggregateOutputType | null
    _max: CenterUserMaxAggregateOutputType | null
  }

  export type CenterUserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    userType: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CenterUserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    userType: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CenterUserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    name: number
    userType: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CenterUserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    userType?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CenterUserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    userType?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CenterUserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    userType?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CenterUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CenterUser to aggregate.
     */
    where?: CenterUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CenterUsers to fetch.
     */
    orderBy?: CenterUserOrderByWithRelationInput | CenterUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CenterUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CenterUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CenterUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CenterUsers
    **/
    _count?: true | CenterUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CenterUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CenterUserMaxAggregateInputType
  }

  export type GetCenterUserAggregateType<T extends CenterUserAggregateArgs> = {
        [P in keyof T & keyof AggregateCenterUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCenterUser[P]>
      : GetScalarType<T[P], AggregateCenterUser[P]>
  }




  export type CenterUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CenterUserWhereInput
    orderBy?: CenterUserOrderByWithAggregationInput | CenterUserOrderByWithAggregationInput[]
    by: CenterUserScalarFieldEnum[] | CenterUserScalarFieldEnum
    having?: CenterUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CenterUserCountAggregateInputType | true
    _min?: CenterUserMinAggregateInputType
    _max?: CenterUserMaxAggregateInputType
  }

  export type CenterUserGroupByOutputType = {
    id: string
    email: string
    password: string
    name: string
    userType: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: CenterUserCountAggregateOutputType | null
    _min: CenterUserMinAggregateOutputType | null
    _max: CenterUserMaxAggregateOutputType | null
  }

  type GetCenterUserGroupByPayload<T extends CenterUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CenterUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CenterUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CenterUserGroupByOutputType[P]>
            : GetScalarType<T[P], CenterUserGroupByOutputType[P]>
        }
      >
    >


  export type CenterUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    userType?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["centerUser"]>

  export type CenterUserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    userType?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["centerUser"]>

  export type CenterUserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    userType?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $CenterUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CenterUser"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string
      name: string
      userType: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["centerUser"]>
    composites: {}
  }

  type CenterUserGetPayload<S extends boolean | null | undefined | CenterUserDefaultArgs> = $Result.GetResult<Prisma.$CenterUserPayload, S>

  type CenterUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CenterUserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CenterUserCountAggregateInputType | true
    }

  export interface CenterUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CenterUser'], meta: { name: 'CenterUser' } }
    /**
     * Find zero or one CenterUser that matches the filter.
     * @param {CenterUserFindUniqueArgs} args - Arguments to find a CenterUser
     * @example
     * // Get one CenterUser
     * const centerUser = await prisma.centerUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CenterUserFindUniqueArgs>(args: SelectSubset<T, CenterUserFindUniqueArgs<ExtArgs>>): Prisma__CenterUserClient<$Result.GetResult<Prisma.$CenterUserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CenterUser that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CenterUserFindUniqueOrThrowArgs} args - Arguments to find a CenterUser
     * @example
     * // Get one CenterUser
     * const centerUser = await prisma.centerUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CenterUserFindUniqueOrThrowArgs>(args: SelectSubset<T, CenterUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CenterUserClient<$Result.GetResult<Prisma.$CenterUserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CenterUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CenterUserFindFirstArgs} args - Arguments to find a CenterUser
     * @example
     * // Get one CenterUser
     * const centerUser = await prisma.centerUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CenterUserFindFirstArgs>(args?: SelectSubset<T, CenterUserFindFirstArgs<ExtArgs>>): Prisma__CenterUserClient<$Result.GetResult<Prisma.$CenterUserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CenterUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CenterUserFindFirstOrThrowArgs} args - Arguments to find a CenterUser
     * @example
     * // Get one CenterUser
     * const centerUser = await prisma.centerUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CenterUserFindFirstOrThrowArgs>(args?: SelectSubset<T, CenterUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__CenterUserClient<$Result.GetResult<Prisma.$CenterUserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CenterUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CenterUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CenterUsers
     * const centerUsers = await prisma.centerUser.findMany()
     * 
     * // Get first 10 CenterUsers
     * const centerUsers = await prisma.centerUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const centerUserWithIdOnly = await prisma.centerUser.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CenterUserFindManyArgs>(args?: SelectSubset<T, CenterUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CenterUserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CenterUser.
     * @param {CenterUserCreateArgs} args - Arguments to create a CenterUser.
     * @example
     * // Create one CenterUser
     * const CenterUser = await prisma.centerUser.create({
     *   data: {
     *     // ... data to create a CenterUser
     *   }
     * })
     * 
     */
    create<T extends CenterUserCreateArgs>(args: SelectSubset<T, CenterUserCreateArgs<ExtArgs>>): Prisma__CenterUserClient<$Result.GetResult<Prisma.$CenterUserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CenterUsers.
     * @param {CenterUserCreateManyArgs} args - Arguments to create many CenterUsers.
     * @example
     * // Create many CenterUsers
     * const centerUser = await prisma.centerUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CenterUserCreateManyArgs>(args?: SelectSubset<T, CenterUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CenterUsers and returns the data saved in the database.
     * @param {CenterUserCreateManyAndReturnArgs} args - Arguments to create many CenterUsers.
     * @example
     * // Create many CenterUsers
     * const centerUser = await prisma.centerUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CenterUsers and only return the `id`
     * const centerUserWithIdOnly = await prisma.centerUser.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CenterUserCreateManyAndReturnArgs>(args?: SelectSubset<T, CenterUserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CenterUserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CenterUser.
     * @param {CenterUserDeleteArgs} args - Arguments to delete one CenterUser.
     * @example
     * // Delete one CenterUser
     * const CenterUser = await prisma.centerUser.delete({
     *   where: {
     *     // ... filter to delete one CenterUser
     *   }
     * })
     * 
     */
    delete<T extends CenterUserDeleteArgs>(args: SelectSubset<T, CenterUserDeleteArgs<ExtArgs>>): Prisma__CenterUserClient<$Result.GetResult<Prisma.$CenterUserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CenterUser.
     * @param {CenterUserUpdateArgs} args - Arguments to update one CenterUser.
     * @example
     * // Update one CenterUser
     * const centerUser = await prisma.centerUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CenterUserUpdateArgs>(args: SelectSubset<T, CenterUserUpdateArgs<ExtArgs>>): Prisma__CenterUserClient<$Result.GetResult<Prisma.$CenterUserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CenterUsers.
     * @param {CenterUserDeleteManyArgs} args - Arguments to filter CenterUsers to delete.
     * @example
     * // Delete a few CenterUsers
     * const { count } = await prisma.centerUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CenterUserDeleteManyArgs>(args?: SelectSubset<T, CenterUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CenterUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CenterUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CenterUsers
     * const centerUser = await prisma.centerUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CenterUserUpdateManyArgs>(args: SelectSubset<T, CenterUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CenterUser.
     * @param {CenterUserUpsertArgs} args - Arguments to update or create a CenterUser.
     * @example
     * // Update or create a CenterUser
     * const centerUser = await prisma.centerUser.upsert({
     *   create: {
     *     // ... data to create a CenterUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CenterUser we want to update
     *   }
     * })
     */
    upsert<T extends CenterUserUpsertArgs>(args: SelectSubset<T, CenterUserUpsertArgs<ExtArgs>>): Prisma__CenterUserClient<$Result.GetResult<Prisma.$CenterUserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CenterUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CenterUserCountArgs} args - Arguments to filter CenterUsers to count.
     * @example
     * // Count the number of CenterUsers
     * const count = await prisma.centerUser.count({
     *   where: {
     *     // ... the filter for the CenterUsers we want to count
     *   }
     * })
    **/
    count<T extends CenterUserCountArgs>(
      args?: Subset<T, CenterUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CenterUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CenterUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CenterUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CenterUserAggregateArgs>(args: Subset<T, CenterUserAggregateArgs>): Prisma.PrismaPromise<GetCenterUserAggregateType<T>>

    /**
     * Group by CenterUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CenterUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CenterUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CenterUserGroupByArgs['orderBy'] }
        : { orderBy?: CenterUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CenterUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCenterUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CenterUser model
   */
  readonly fields: CenterUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CenterUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CenterUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CenterUser model
   */ 
  interface CenterUserFieldRefs {
    readonly id: FieldRef<"CenterUser", 'String'>
    readonly email: FieldRef<"CenterUser", 'String'>
    readonly password: FieldRef<"CenterUser", 'String'>
    readonly name: FieldRef<"CenterUser", 'String'>
    readonly userType: FieldRef<"CenterUser", 'String'>
    readonly isActive: FieldRef<"CenterUser", 'Boolean'>
    readonly createdAt: FieldRef<"CenterUser", 'DateTime'>
    readonly updatedAt: FieldRef<"CenterUser", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CenterUser findUnique
   */
  export type CenterUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CenterUser
     */
    select?: CenterUserSelect<ExtArgs> | null
    /**
     * Filter, which CenterUser to fetch.
     */
    where: CenterUserWhereUniqueInput
  }

  /**
   * CenterUser findUniqueOrThrow
   */
  export type CenterUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CenterUser
     */
    select?: CenterUserSelect<ExtArgs> | null
    /**
     * Filter, which CenterUser to fetch.
     */
    where: CenterUserWhereUniqueInput
  }

  /**
   * CenterUser findFirst
   */
  export type CenterUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CenterUser
     */
    select?: CenterUserSelect<ExtArgs> | null
    /**
     * Filter, which CenterUser to fetch.
     */
    where?: CenterUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CenterUsers to fetch.
     */
    orderBy?: CenterUserOrderByWithRelationInput | CenterUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CenterUsers.
     */
    cursor?: CenterUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CenterUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CenterUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CenterUsers.
     */
    distinct?: CenterUserScalarFieldEnum | CenterUserScalarFieldEnum[]
  }

  /**
   * CenterUser findFirstOrThrow
   */
  export type CenterUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CenterUser
     */
    select?: CenterUserSelect<ExtArgs> | null
    /**
     * Filter, which CenterUser to fetch.
     */
    where?: CenterUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CenterUsers to fetch.
     */
    orderBy?: CenterUserOrderByWithRelationInput | CenterUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CenterUsers.
     */
    cursor?: CenterUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CenterUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CenterUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CenterUsers.
     */
    distinct?: CenterUserScalarFieldEnum | CenterUserScalarFieldEnum[]
  }

  /**
   * CenterUser findMany
   */
  export type CenterUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CenterUser
     */
    select?: CenterUserSelect<ExtArgs> | null
    /**
     * Filter, which CenterUsers to fetch.
     */
    where?: CenterUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CenterUsers to fetch.
     */
    orderBy?: CenterUserOrderByWithRelationInput | CenterUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CenterUsers.
     */
    cursor?: CenterUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CenterUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CenterUsers.
     */
    skip?: number
    distinct?: CenterUserScalarFieldEnum | CenterUserScalarFieldEnum[]
  }

  /**
   * CenterUser create
   */
  export type CenterUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CenterUser
     */
    select?: CenterUserSelect<ExtArgs> | null
    /**
     * The data needed to create a CenterUser.
     */
    data: XOR<CenterUserCreateInput, CenterUserUncheckedCreateInput>
  }

  /**
   * CenterUser createMany
   */
  export type CenterUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CenterUsers.
     */
    data: CenterUserCreateManyInput | CenterUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CenterUser createManyAndReturn
   */
  export type CenterUserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CenterUser
     */
    select?: CenterUserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CenterUsers.
     */
    data: CenterUserCreateManyInput | CenterUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CenterUser update
   */
  export type CenterUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CenterUser
     */
    select?: CenterUserSelect<ExtArgs> | null
    /**
     * The data needed to update a CenterUser.
     */
    data: XOR<CenterUserUpdateInput, CenterUserUncheckedUpdateInput>
    /**
     * Choose, which CenterUser to update.
     */
    where: CenterUserWhereUniqueInput
  }

  /**
   * CenterUser updateMany
   */
  export type CenterUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CenterUsers.
     */
    data: XOR<CenterUserUpdateManyMutationInput, CenterUserUncheckedUpdateManyInput>
    /**
     * Filter which CenterUsers to update
     */
    where?: CenterUserWhereInput
  }

  /**
   * CenterUser upsert
   */
  export type CenterUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CenterUser
     */
    select?: CenterUserSelect<ExtArgs> | null
    /**
     * The filter to search for the CenterUser to update in case it exists.
     */
    where: CenterUserWhereUniqueInput
    /**
     * In case the CenterUser found by the `where` argument doesn't exist, create a new CenterUser with this data.
     */
    create: XOR<CenterUserCreateInput, CenterUserUncheckedCreateInput>
    /**
     * In case the CenterUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CenterUserUpdateInput, CenterUserUncheckedUpdateInput>
  }

  /**
   * CenterUser delete
   */
  export type CenterUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CenterUser
     */
    select?: CenterUserSelect<ExtArgs> | null
    /**
     * Filter which CenterUser to delete.
     */
    where: CenterUserWhereUniqueInput
  }

  /**
   * CenterUser deleteMany
   */
  export type CenterUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CenterUsers to delete
     */
    where?: CenterUserWhereInput
  }

  /**
   * CenterUser without action
   */
  export type CenterUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CenterUser
     */
    select?: CenterUserSelect<ExtArgs> | null
  }


  /**
   * Model Hospital
   */

  export type AggregateHospital = {
    _count: HospitalCountAggregateOutputType | null
    _avg: HospitalAvgAggregateOutputType | null
    _sum: HospitalSumAggregateOutputType | null
    _min: HospitalMinAggregateOutputType | null
    _max: HospitalMaxAggregateOutputType | null
  }

  export type HospitalAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type HospitalSumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type HospitalMinAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    phone: string | null
    email: string | null
    type: string | null
    region: string | null
    latitude: number | null
    longitude: number | null
    operatingHours: string | null
    isActive: boolean | null
    requiresReview: boolean | null
    approvedAt: Date | null
    approvedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HospitalMaxAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    phone: string | null
    email: string | null
    type: string | null
    region: string | null
    latitude: number | null
    longitude: number | null
    operatingHours: string | null
    isActive: boolean | null
    requiresReview: boolean | null
    approvedAt: Date | null
    approvedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HospitalCountAggregateOutputType = {
    id: number
    name: number
    address: number
    city: number
    state: number
    zipCode: number
    phone: number
    email: number
    type: number
    capabilities: number
    region: number
    coordinates: number
    latitude: number
    longitude: number
    operatingHours: number
    isActive: number
    requiresReview: number
    approvedAt: number
    approvedBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HospitalAvgAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type HospitalSumAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type HospitalMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    city?: true
    state?: true
    zipCode?: true
    phone?: true
    email?: true
    type?: true
    region?: true
    latitude?: true
    longitude?: true
    operatingHours?: true
    isActive?: true
    requiresReview?: true
    approvedAt?: true
    approvedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HospitalMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    city?: true
    state?: true
    zipCode?: true
    phone?: true
    email?: true
    type?: true
    region?: true
    latitude?: true
    longitude?: true
    operatingHours?: true
    isActive?: true
    requiresReview?: true
    approvedAt?: true
    approvedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HospitalCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    city?: true
    state?: true
    zipCode?: true
    phone?: true
    email?: true
    type?: true
    capabilities?: true
    region?: true
    coordinates?: true
    latitude?: true
    longitude?: true
    operatingHours?: true
    isActive?: true
    requiresReview?: true
    approvedAt?: true
    approvedBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HospitalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Hospital to aggregate.
     */
    where?: HospitalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hospitals to fetch.
     */
    orderBy?: HospitalOrderByWithRelationInput | HospitalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HospitalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hospitals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hospitals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Hospitals
    **/
    _count?: true | HospitalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HospitalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HospitalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HospitalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HospitalMaxAggregateInputType
  }

  export type GetHospitalAggregateType<T extends HospitalAggregateArgs> = {
        [P in keyof T & keyof AggregateHospital]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHospital[P]>
      : GetScalarType<T[P], AggregateHospital[P]>
  }




  export type HospitalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HospitalWhereInput
    orderBy?: HospitalOrderByWithAggregationInput | HospitalOrderByWithAggregationInput[]
    by: HospitalScalarFieldEnum[] | HospitalScalarFieldEnum
    having?: HospitalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HospitalCountAggregateInputType | true
    _avg?: HospitalAvgAggregateInputType
    _sum?: HospitalSumAggregateInputType
    _min?: HospitalMinAggregateInputType
    _max?: HospitalMaxAggregateInputType
  }

  export type HospitalGroupByOutputType = {
    id: string
    name: string
    address: string
    city: string
    state: string
    zipCode: string
    phone: string | null
    email: string | null
    type: string
    capabilities: string[]
    region: string
    coordinates: JsonValue | null
    latitude: number | null
    longitude: number | null
    operatingHours: string | null
    isActive: boolean
    requiresReview: boolean
    approvedAt: Date | null
    approvedBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: HospitalCountAggregateOutputType | null
    _avg: HospitalAvgAggregateOutputType | null
    _sum: HospitalSumAggregateOutputType | null
    _min: HospitalMinAggregateOutputType | null
    _max: HospitalMaxAggregateOutputType | null
  }

  type GetHospitalGroupByPayload<T extends HospitalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HospitalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HospitalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HospitalGroupByOutputType[P]>
            : GetScalarType<T[P], HospitalGroupByOutputType[P]>
        }
      >
    >


  export type HospitalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    phone?: boolean
    email?: boolean
    type?: boolean
    capabilities?: boolean
    region?: boolean
    coordinates?: boolean
    latitude?: boolean
    longitude?: boolean
    operatingHours?: boolean
    isActive?: boolean
    requiresReview?: boolean
    approvedAt?: boolean
    approvedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pickupLocations?: boolean | Hospital$pickupLocationsArgs<ExtArgs>
    _count?: boolean | HospitalCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hospital"]>

  export type HospitalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    phone?: boolean
    email?: boolean
    type?: boolean
    capabilities?: boolean
    region?: boolean
    coordinates?: boolean
    latitude?: boolean
    longitude?: boolean
    operatingHours?: boolean
    isActive?: boolean
    requiresReview?: boolean
    approvedAt?: boolean
    approvedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["hospital"]>

  export type HospitalSelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    phone?: boolean
    email?: boolean
    type?: boolean
    capabilities?: boolean
    region?: boolean
    coordinates?: boolean
    latitude?: boolean
    longitude?: boolean
    operatingHours?: boolean
    isActive?: boolean
    requiresReview?: boolean
    approvedAt?: boolean
    approvedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HospitalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pickupLocations?: boolean | Hospital$pickupLocationsArgs<ExtArgs>
    _count?: boolean | HospitalCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type HospitalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $HospitalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Hospital"
    objects: {
      pickupLocations: Prisma.$PickupLocationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      address: string
      city: string
      state: string
      zipCode: string
      phone: string | null
      email: string | null
      type: string
      capabilities: string[]
      region: string
      coordinates: Prisma.JsonValue | null
      latitude: number | null
      longitude: number | null
      operatingHours: string | null
      isActive: boolean
      requiresReview: boolean
      approvedAt: Date | null
      approvedBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["hospital"]>
    composites: {}
  }

  type HospitalGetPayload<S extends boolean | null | undefined | HospitalDefaultArgs> = $Result.GetResult<Prisma.$HospitalPayload, S>

  type HospitalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HospitalFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HospitalCountAggregateInputType | true
    }

  export interface HospitalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Hospital'], meta: { name: 'Hospital' } }
    /**
     * Find zero or one Hospital that matches the filter.
     * @param {HospitalFindUniqueArgs} args - Arguments to find a Hospital
     * @example
     * // Get one Hospital
     * const hospital = await prisma.hospital.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HospitalFindUniqueArgs>(args: SelectSubset<T, HospitalFindUniqueArgs<ExtArgs>>): Prisma__HospitalClient<$Result.GetResult<Prisma.$HospitalPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Hospital that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HospitalFindUniqueOrThrowArgs} args - Arguments to find a Hospital
     * @example
     * // Get one Hospital
     * const hospital = await prisma.hospital.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HospitalFindUniqueOrThrowArgs>(args: SelectSubset<T, HospitalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HospitalClient<$Result.GetResult<Prisma.$HospitalPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Hospital that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalFindFirstArgs} args - Arguments to find a Hospital
     * @example
     * // Get one Hospital
     * const hospital = await prisma.hospital.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HospitalFindFirstArgs>(args?: SelectSubset<T, HospitalFindFirstArgs<ExtArgs>>): Prisma__HospitalClient<$Result.GetResult<Prisma.$HospitalPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Hospital that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalFindFirstOrThrowArgs} args - Arguments to find a Hospital
     * @example
     * // Get one Hospital
     * const hospital = await prisma.hospital.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HospitalFindFirstOrThrowArgs>(args?: SelectSubset<T, HospitalFindFirstOrThrowArgs<ExtArgs>>): Prisma__HospitalClient<$Result.GetResult<Prisma.$HospitalPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Hospitals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Hospitals
     * const hospitals = await prisma.hospital.findMany()
     * 
     * // Get first 10 Hospitals
     * const hospitals = await prisma.hospital.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hospitalWithIdOnly = await prisma.hospital.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HospitalFindManyArgs>(args?: SelectSubset<T, HospitalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HospitalPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Hospital.
     * @param {HospitalCreateArgs} args - Arguments to create a Hospital.
     * @example
     * // Create one Hospital
     * const Hospital = await prisma.hospital.create({
     *   data: {
     *     // ... data to create a Hospital
     *   }
     * })
     * 
     */
    create<T extends HospitalCreateArgs>(args: SelectSubset<T, HospitalCreateArgs<ExtArgs>>): Prisma__HospitalClient<$Result.GetResult<Prisma.$HospitalPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Hospitals.
     * @param {HospitalCreateManyArgs} args - Arguments to create many Hospitals.
     * @example
     * // Create many Hospitals
     * const hospital = await prisma.hospital.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HospitalCreateManyArgs>(args?: SelectSubset<T, HospitalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Hospitals and returns the data saved in the database.
     * @param {HospitalCreateManyAndReturnArgs} args - Arguments to create many Hospitals.
     * @example
     * // Create many Hospitals
     * const hospital = await prisma.hospital.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Hospitals and only return the `id`
     * const hospitalWithIdOnly = await prisma.hospital.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HospitalCreateManyAndReturnArgs>(args?: SelectSubset<T, HospitalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HospitalPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Hospital.
     * @param {HospitalDeleteArgs} args - Arguments to delete one Hospital.
     * @example
     * // Delete one Hospital
     * const Hospital = await prisma.hospital.delete({
     *   where: {
     *     // ... filter to delete one Hospital
     *   }
     * })
     * 
     */
    delete<T extends HospitalDeleteArgs>(args: SelectSubset<T, HospitalDeleteArgs<ExtArgs>>): Prisma__HospitalClient<$Result.GetResult<Prisma.$HospitalPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Hospital.
     * @param {HospitalUpdateArgs} args - Arguments to update one Hospital.
     * @example
     * // Update one Hospital
     * const hospital = await prisma.hospital.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HospitalUpdateArgs>(args: SelectSubset<T, HospitalUpdateArgs<ExtArgs>>): Prisma__HospitalClient<$Result.GetResult<Prisma.$HospitalPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Hospitals.
     * @param {HospitalDeleteManyArgs} args - Arguments to filter Hospitals to delete.
     * @example
     * // Delete a few Hospitals
     * const { count } = await prisma.hospital.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HospitalDeleteManyArgs>(args?: SelectSubset<T, HospitalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Hospitals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Hospitals
     * const hospital = await prisma.hospital.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HospitalUpdateManyArgs>(args: SelectSubset<T, HospitalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Hospital.
     * @param {HospitalUpsertArgs} args - Arguments to update or create a Hospital.
     * @example
     * // Update or create a Hospital
     * const hospital = await prisma.hospital.upsert({
     *   create: {
     *     // ... data to create a Hospital
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Hospital we want to update
     *   }
     * })
     */
    upsert<T extends HospitalUpsertArgs>(args: SelectSubset<T, HospitalUpsertArgs<ExtArgs>>): Prisma__HospitalClient<$Result.GetResult<Prisma.$HospitalPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Hospitals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalCountArgs} args - Arguments to filter Hospitals to count.
     * @example
     * // Count the number of Hospitals
     * const count = await prisma.hospital.count({
     *   where: {
     *     // ... the filter for the Hospitals we want to count
     *   }
     * })
    **/
    count<T extends HospitalCountArgs>(
      args?: Subset<T, HospitalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HospitalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Hospital.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HospitalAggregateArgs>(args: Subset<T, HospitalAggregateArgs>): Prisma.PrismaPromise<GetHospitalAggregateType<T>>

    /**
     * Group by Hospital.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HospitalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HospitalGroupByArgs['orderBy'] }
        : { orderBy?: HospitalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HospitalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHospitalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Hospital model
   */
  readonly fields: HospitalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Hospital.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HospitalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pickupLocations<T extends Hospital$pickupLocationsArgs<ExtArgs> = {}>(args?: Subset<T, Hospital$pickupLocationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PickupLocationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Hospital model
   */ 
  interface HospitalFieldRefs {
    readonly id: FieldRef<"Hospital", 'String'>
    readonly name: FieldRef<"Hospital", 'String'>
    readonly address: FieldRef<"Hospital", 'String'>
    readonly city: FieldRef<"Hospital", 'String'>
    readonly state: FieldRef<"Hospital", 'String'>
    readonly zipCode: FieldRef<"Hospital", 'String'>
    readonly phone: FieldRef<"Hospital", 'String'>
    readonly email: FieldRef<"Hospital", 'String'>
    readonly type: FieldRef<"Hospital", 'String'>
    readonly capabilities: FieldRef<"Hospital", 'String[]'>
    readonly region: FieldRef<"Hospital", 'String'>
    readonly coordinates: FieldRef<"Hospital", 'Json'>
    readonly latitude: FieldRef<"Hospital", 'Float'>
    readonly longitude: FieldRef<"Hospital", 'Float'>
    readonly operatingHours: FieldRef<"Hospital", 'String'>
    readonly isActive: FieldRef<"Hospital", 'Boolean'>
    readonly requiresReview: FieldRef<"Hospital", 'Boolean'>
    readonly approvedAt: FieldRef<"Hospital", 'DateTime'>
    readonly approvedBy: FieldRef<"Hospital", 'String'>
    readonly createdAt: FieldRef<"Hospital", 'DateTime'>
    readonly updatedAt: FieldRef<"Hospital", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Hospital findUnique
   */
  export type HospitalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalInclude<ExtArgs> | null
    /**
     * Filter, which Hospital to fetch.
     */
    where: HospitalWhereUniqueInput
  }

  /**
   * Hospital findUniqueOrThrow
   */
  export type HospitalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalInclude<ExtArgs> | null
    /**
     * Filter, which Hospital to fetch.
     */
    where: HospitalWhereUniqueInput
  }

  /**
   * Hospital findFirst
   */
  export type HospitalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalInclude<ExtArgs> | null
    /**
     * Filter, which Hospital to fetch.
     */
    where?: HospitalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hospitals to fetch.
     */
    orderBy?: HospitalOrderByWithRelationInput | HospitalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Hospitals.
     */
    cursor?: HospitalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hospitals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hospitals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Hospitals.
     */
    distinct?: HospitalScalarFieldEnum | HospitalScalarFieldEnum[]
  }

  /**
   * Hospital findFirstOrThrow
   */
  export type HospitalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalInclude<ExtArgs> | null
    /**
     * Filter, which Hospital to fetch.
     */
    where?: HospitalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hospitals to fetch.
     */
    orderBy?: HospitalOrderByWithRelationInput | HospitalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Hospitals.
     */
    cursor?: HospitalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hospitals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hospitals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Hospitals.
     */
    distinct?: HospitalScalarFieldEnum | HospitalScalarFieldEnum[]
  }

  /**
   * Hospital findMany
   */
  export type HospitalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalInclude<ExtArgs> | null
    /**
     * Filter, which Hospitals to fetch.
     */
    where?: HospitalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hospitals to fetch.
     */
    orderBy?: HospitalOrderByWithRelationInput | HospitalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Hospitals.
     */
    cursor?: HospitalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hospitals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hospitals.
     */
    skip?: number
    distinct?: HospitalScalarFieldEnum | HospitalScalarFieldEnum[]
  }

  /**
   * Hospital create
   */
  export type HospitalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalInclude<ExtArgs> | null
    /**
     * The data needed to create a Hospital.
     */
    data: XOR<HospitalCreateInput, HospitalUncheckedCreateInput>
  }

  /**
   * Hospital createMany
   */
  export type HospitalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Hospitals.
     */
    data: HospitalCreateManyInput | HospitalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Hospital createManyAndReturn
   */
  export type HospitalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Hospitals.
     */
    data: HospitalCreateManyInput | HospitalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Hospital update
   */
  export type HospitalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalInclude<ExtArgs> | null
    /**
     * The data needed to update a Hospital.
     */
    data: XOR<HospitalUpdateInput, HospitalUncheckedUpdateInput>
    /**
     * Choose, which Hospital to update.
     */
    where: HospitalWhereUniqueInput
  }

  /**
   * Hospital updateMany
   */
  export type HospitalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Hospitals.
     */
    data: XOR<HospitalUpdateManyMutationInput, HospitalUncheckedUpdateManyInput>
    /**
     * Filter which Hospitals to update
     */
    where?: HospitalWhereInput
  }

  /**
   * Hospital upsert
   */
  export type HospitalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalInclude<ExtArgs> | null
    /**
     * The filter to search for the Hospital to update in case it exists.
     */
    where: HospitalWhereUniqueInput
    /**
     * In case the Hospital found by the `where` argument doesn't exist, create a new Hospital with this data.
     */
    create: XOR<HospitalCreateInput, HospitalUncheckedCreateInput>
    /**
     * In case the Hospital was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HospitalUpdateInput, HospitalUncheckedUpdateInput>
  }

  /**
   * Hospital delete
   */
  export type HospitalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalInclude<ExtArgs> | null
    /**
     * Filter which Hospital to delete.
     */
    where: HospitalWhereUniqueInput
  }

  /**
   * Hospital deleteMany
   */
  export type HospitalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Hospitals to delete
     */
    where?: HospitalWhereInput
  }

  /**
   * Hospital.pickupLocations
   */
  export type Hospital$pickupLocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PickupLocation
     */
    select?: PickupLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PickupLocationInclude<ExtArgs> | null
    where?: PickupLocationWhereInput
    orderBy?: PickupLocationOrderByWithRelationInput | PickupLocationOrderByWithRelationInput[]
    cursor?: PickupLocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PickupLocationScalarFieldEnum | PickupLocationScalarFieldEnum[]
  }

  /**
   * Hospital without action
   */
  export type HospitalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalInclude<ExtArgs> | null
  }


  /**
   * Model PickupLocation
   */

  export type AggregatePickupLocation = {
    _count: PickupLocationCountAggregateOutputType | null
    _min: PickupLocationMinAggregateOutputType | null
    _max: PickupLocationMaxAggregateOutputType | null
  }

  export type PickupLocationMinAggregateOutputType = {
    id: string | null
    hospitalId: string | null
    name: string | null
    description: string | null
    contactPhone: string | null
    contactEmail: string | null
    floor: string | null
    room: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PickupLocationMaxAggregateOutputType = {
    id: string | null
    hospitalId: string | null
    name: string | null
    description: string | null
    contactPhone: string | null
    contactEmail: string | null
    floor: string | null
    room: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PickupLocationCountAggregateOutputType = {
    id: number
    hospitalId: number
    name: number
    description: number
    contactPhone: number
    contactEmail: number
    floor: number
    room: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PickupLocationMinAggregateInputType = {
    id?: true
    hospitalId?: true
    name?: true
    description?: true
    contactPhone?: true
    contactEmail?: true
    floor?: true
    room?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PickupLocationMaxAggregateInputType = {
    id?: true
    hospitalId?: true
    name?: true
    description?: true
    contactPhone?: true
    contactEmail?: true
    floor?: true
    room?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PickupLocationCountAggregateInputType = {
    id?: true
    hospitalId?: true
    name?: true
    description?: true
    contactPhone?: true
    contactEmail?: true
    floor?: true
    room?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PickupLocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PickupLocation to aggregate.
     */
    where?: PickupLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PickupLocations to fetch.
     */
    orderBy?: PickupLocationOrderByWithRelationInput | PickupLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PickupLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PickupLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PickupLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PickupLocations
    **/
    _count?: true | PickupLocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PickupLocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PickupLocationMaxAggregateInputType
  }

  export type GetPickupLocationAggregateType<T extends PickupLocationAggregateArgs> = {
        [P in keyof T & keyof AggregatePickupLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePickupLocation[P]>
      : GetScalarType<T[P], AggregatePickupLocation[P]>
  }




  export type PickupLocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PickupLocationWhereInput
    orderBy?: PickupLocationOrderByWithAggregationInput | PickupLocationOrderByWithAggregationInput[]
    by: PickupLocationScalarFieldEnum[] | PickupLocationScalarFieldEnum
    having?: PickupLocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PickupLocationCountAggregateInputType | true
    _min?: PickupLocationMinAggregateInputType
    _max?: PickupLocationMaxAggregateInputType
  }

  export type PickupLocationGroupByOutputType = {
    id: string
    hospitalId: string
    name: string
    description: string | null
    contactPhone: string | null
    contactEmail: string | null
    floor: string | null
    room: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: PickupLocationCountAggregateOutputType | null
    _min: PickupLocationMinAggregateOutputType | null
    _max: PickupLocationMaxAggregateOutputType | null
  }

  type GetPickupLocationGroupByPayload<T extends PickupLocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PickupLocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PickupLocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PickupLocationGroupByOutputType[P]>
            : GetScalarType<T[P], PickupLocationGroupByOutputType[P]>
        }
      >
    >


  export type PickupLocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hospitalId?: boolean
    name?: boolean
    description?: boolean
    contactPhone?: boolean
    contactEmail?: boolean
    floor?: boolean
    room?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hospital?: boolean | HospitalDefaultArgs<ExtArgs>
    trips?: boolean | PickupLocation$tripsArgs<ExtArgs>
    _count?: boolean | PickupLocationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pickupLocation"]>

  export type PickupLocationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hospitalId?: boolean
    name?: boolean
    description?: boolean
    contactPhone?: boolean
    contactEmail?: boolean
    floor?: boolean
    room?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hospital?: boolean | HospitalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pickupLocation"]>

  export type PickupLocationSelectScalar = {
    id?: boolean
    hospitalId?: boolean
    name?: boolean
    description?: boolean
    contactPhone?: boolean
    contactEmail?: boolean
    floor?: boolean
    room?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PickupLocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hospital?: boolean | HospitalDefaultArgs<ExtArgs>
    trips?: boolean | PickupLocation$tripsArgs<ExtArgs>
    _count?: boolean | PickupLocationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PickupLocationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hospital?: boolean | HospitalDefaultArgs<ExtArgs>
  }

  export type $PickupLocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PickupLocation"
    objects: {
      hospital: Prisma.$HospitalPayload<ExtArgs>
      trips: Prisma.$TripPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      hospitalId: string
      name: string
      description: string | null
      contactPhone: string | null
      contactEmail: string | null
      floor: string | null
      room: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pickupLocation"]>
    composites: {}
  }

  type PickupLocationGetPayload<S extends boolean | null | undefined | PickupLocationDefaultArgs> = $Result.GetResult<Prisma.$PickupLocationPayload, S>

  type PickupLocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PickupLocationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PickupLocationCountAggregateInputType | true
    }

  export interface PickupLocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PickupLocation'], meta: { name: 'PickupLocation' } }
    /**
     * Find zero or one PickupLocation that matches the filter.
     * @param {PickupLocationFindUniqueArgs} args - Arguments to find a PickupLocation
     * @example
     * // Get one PickupLocation
     * const pickupLocation = await prisma.pickupLocation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PickupLocationFindUniqueArgs>(args: SelectSubset<T, PickupLocationFindUniqueArgs<ExtArgs>>): Prisma__PickupLocationClient<$Result.GetResult<Prisma.$PickupLocationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PickupLocation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PickupLocationFindUniqueOrThrowArgs} args - Arguments to find a PickupLocation
     * @example
     * // Get one PickupLocation
     * const pickupLocation = await prisma.pickupLocation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PickupLocationFindUniqueOrThrowArgs>(args: SelectSubset<T, PickupLocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PickupLocationClient<$Result.GetResult<Prisma.$PickupLocationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PickupLocation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PickupLocationFindFirstArgs} args - Arguments to find a PickupLocation
     * @example
     * // Get one PickupLocation
     * const pickupLocation = await prisma.pickupLocation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PickupLocationFindFirstArgs>(args?: SelectSubset<T, PickupLocationFindFirstArgs<ExtArgs>>): Prisma__PickupLocationClient<$Result.GetResult<Prisma.$PickupLocationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PickupLocation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PickupLocationFindFirstOrThrowArgs} args - Arguments to find a PickupLocation
     * @example
     * // Get one PickupLocation
     * const pickupLocation = await prisma.pickupLocation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PickupLocationFindFirstOrThrowArgs>(args?: SelectSubset<T, PickupLocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__PickupLocationClient<$Result.GetResult<Prisma.$PickupLocationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PickupLocations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PickupLocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PickupLocations
     * const pickupLocations = await prisma.pickupLocation.findMany()
     * 
     * // Get first 10 PickupLocations
     * const pickupLocations = await prisma.pickupLocation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pickupLocationWithIdOnly = await prisma.pickupLocation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PickupLocationFindManyArgs>(args?: SelectSubset<T, PickupLocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PickupLocationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PickupLocation.
     * @param {PickupLocationCreateArgs} args - Arguments to create a PickupLocation.
     * @example
     * // Create one PickupLocation
     * const PickupLocation = await prisma.pickupLocation.create({
     *   data: {
     *     // ... data to create a PickupLocation
     *   }
     * })
     * 
     */
    create<T extends PickupLocationCreateArgs>(args: SelectSubset<T, PickupLocationCreateArgs<ExtArgs>>): Prisma__PickupLocationClient<$Result.GetResult<Prisma.$PickupLocationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PickupLocations.
     * @param {PickupLocationCreateManyArgs} args - Arguments to create many PickupLocations.
     * @example
     * // Create many PickupLocations
     * const pickupLocation = await prisma.pickupLocation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PickupLocationCreateManyArgs>(args?: SelectSubset<T, PickupLocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PickupLocations and returns the data saved in the database.
     * @param {PickupLocationCreateManyAndReturnArgs} args - Arguments to create many PickupLocations.
     * @example
     * // Create many PickupLocations
     * const pickupLocation = await prisma.pickupLocation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PickupLocations and only return the `id`
     * const pickupLocationWithIdOnly = await prisma.pickupLocation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PickupLocationCreateManyAndReturnArgs>(args?: SelectSubset<T, PickupLocationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PickupLocationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PickupLocation.
     * @param {PickupLocationDeleteArgs} args - Arguments to delete one PickupLocation.
     * @example
     * // Delete one PickupLocation
     * const PickupLocation = await prisma.pickupLocation.delete({
     *   where: {
     *     // ... filter to delete one PickupLocation
     *   }
     * })
     * 
     */
    delete<T extends PickupLocationDeleteArgs>(args: SelectSubset<T, PickupLocationDeleteArgs<ExtArgs>>): Prisma__PickupLocationClient<$Result.GetResult<Prisma.$PickupLocationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PickupLocation.
     * @param {PickupLocationUpdateArgs} args - Arguments to update one PickupLocation.
     * @example
     * // Update one PickupLocation
     * const pickupLocation = await prisma.pickupLocation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PickupLocationUpdateArgs>(args: SelectSubset<T, PickupLocationUpdateArgs<ExtArgs>>): Prisma__PickupLocationClient<$Result.GetResult<Prisma.$PickupLocationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PickupLocations.
     * @param {PickupLocationDeleteManyArgs} args - Arguments to filter PickupLocations to delete.
     * @example
     * // Delete a few PickupLocations
     * const { count } = await prisma.pickupLocation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PickupLocationDeleteManyArgs>(args?: SelectSubset<T, PickupLocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PickupLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PickupLocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PickupLocations
     * const pickupLocation = await prisma.pickupLocation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PickupLocationUpdateManyArgs>(args: SelectSubset<T, PickupLocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PickupLocation.
     * @param {PickupLocationUpsertArgs} args - Arguments to update or create a PickupLocation.
     * @example
     * // Update or create a PickupLocation
     * const pickupLocation = await prisma.pickupLocation.upsert({
     *   create: {
     *     // ... data to create a PickupLocation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PickupLocation we want to update
     *   }
     * })
     */
    upsert<T extends PickupLocationUpsertArgs>(args: SelectSubset<T, PickupLocationUpsertArgs<ExtArgs>>): Prisma__PickupLocationClient<$Result.GetResult<Prisma.$PickupLocationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PickupLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PickupLocationCountArgs} args - Arguments to filter PickupLocations to count.
     * @example
     * // Count the number of PickupLocations
     * const count = await prisma.pickupLocation.count({
     *   where: {
     *     // ... the filter for the PickupLocations we want to count
     *   }
     * })
    **/
    count<T extends PickupLocationCountArgs>(
      args?: Subset<T, PickupLocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PickupLocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PickupLocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PickupLocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PickupLocationAggregateArgs>(args: Subset<T, PickupLocationAggregateArgs>): Prisma.PrismaPromise<GetPickupLocationAggregateType<T>>

    /**
     * Group by PickupLocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PickupLocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PickupLocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PickupLocationGroupByArgs['orderBy'] }
        : { orderBy?: PickupLocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PickupLocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPickupLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PickupLocation model
   */
  readonly fields: PickupLocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PickupLocation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PickupLocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    hospital<T extends HospitalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HospitalDefaultArgs<ExtArgs>>): Prisma__HospitalClient<$Result.GetResult<Prisma.$HospitalPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    trips<T extends PickupLocation$tripsArgs<ExtArgs> = {}>(args?: Subset<T, PickupLocation$tripsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PickupLocation model
   */ 
  interface PickupLocationFieldRefs {
    readonly id: FieldRef<"PickupLocation", 'String'>
    readonly hospitalId: FieldRef<"PickupLocation", 'String'>
    readonly name: FieldRef<"PickupLocation", 'String'>
    readonly description: FieldRef<"PickupLocation", 'String'>
    readonly contactPhone: FieldRef<"PickupLocation", 'String'>
    readonly contactEmail: FieldRef<"PickupLocation", 'String'>
    readonly floor: FieldRef<"PickupLocation", 'String'>
    readonly room: FieldRef<"PickupLocation", 'String'>
    readonly isActive: FieldRef<"PickupLocation", 'Boolean'>
    readonly createdAt: FieldRef<"PickupLocation", 'DateTime'>
    readonly updatedAt: FieldRef<"PickupLocation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PickupLocation findUnique
   */
  export type PickupLocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PickupLocation
     */
    select?: PickupLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PickupLocationInclude<ExtArgs> | null
    /**
     * Filter, which PickupLocation to fetch.
     */
    where: PickupLocationWhereUniqueInput
  }

  /**
   * PickupLocation findUniqueOrThrow
   */
  export type PickupLocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PickupLocation
     */
    select?: PickupLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PickupLocationInclude<ExtArgs> | null
    /**
     * Filter, which PickupLocation to fetch.
     */
    where: PickupLocationWhereUniqueInput
  }

  /**
   * PickupLocation findFirst
   */
  export type PickupLocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PickupLocation
     */
    select?: PickupLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PickupLocationInclude<ExtArgs> | null
    /**
     * Filter, which PickupLocation to fetch.
     */
    where?: PickupLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PickupLocations to fetch.
     */
    orderBy?: PickupLocationOrderByWithRelationInput | PickupLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PickupLocations.
     */
    cursor?: PickupLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PickupLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PickupLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PickupLocations.
     */
    distinct?: PickupLocationScalarFieldEnum | PickupLocationScalarFieldEnum[]
  }

  /**
   * PickupLocation findFirstOrThrow
   */
  export type PickupLocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PickupLocation
     */
    select?: PickupLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PickupLocationInclude<ExtArgs> | null
    /**
     * Filter, which PickupLocation to fetch.
     */
    where?: PickupLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PickupLocations to fetch.
     */
    orderBy?: PickupLocationOrderByWithRelationInput | PickupLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PickupLocations.
     */
    cursor?: PickupLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PickupLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PickupLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PickupLocations.
     */
    distinct?: PickupLocationScalarFieldEnum | PickupLocationScalarFieldEnum[]
  }

  /**
   * PickupLocation findMany
   */
  export type PickupLocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PickupLocation
     */
    select?: PickupLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PickupLocationInclude<ExtArgs> | null
    /**
     * Filter, which PickupLocations to fetch.
     */
    where?: PickupLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PickupLocations to fetch.
     */
    orderBy?: PickupLocationOrderByWithRelationInput | PickupLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PickupLocations.
     */
    cursor?: PickupLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PickupLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PickupLocations.
     */
    skip?: number
    distinct?: PickupLocationScalarFieldEnum | PickupLocationScalarFieldEnum[]
  }

  /**
   * PickupLocation create
   */
  export type PickupLocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PickupLocation
     */
    select?: PickupLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PickupLocationInclude<ExtArgs> | null
    /**
     * The data needed to create a PickupLocation.
     */
    data: XOR<PickupLocationCreateInput, PickupLocationUncheckedCreateInput>
  }

  /**
   * PickupLocation createMany
   */
  export type PickupLocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PickupLocations.
     */
    data: PickupLocationCreateManyInput | PickupLocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PickupLocation createManyAndReturn
   */
  export type PickupLocationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PickupLocation
     */
    select?: PickupLocationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PickupLocations.
     */
    data: PickupLocationCreateManyInput | PickupLocationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PickupLocationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PickupLocation update
   */
  export type PickupLocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PickupLocation
     */
    select?: PickupLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PickupLocationInclude<ExtArgs> | null
    /**
     * The data needed to update a PickupLocation.
     */
    data: XOR<PickupLocationUpdateInput, PickupLocationUncheckedUpdateInput>
    /**
     * Choose, which PickupLocation to update.
     */
    where: PickupLocationWhereUniqueInput
  }

  /**
   * PickupLocation updateMany
   */
  export type PickupLocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PickupLocations.
     */
    data: XOR<PickupLocationUpdateManyMutationInput, PickupLocationUncheckedUpdateManyInput>
    /**
     * Filter which PickupLocations to update
     */
    where?: PickupLocationWhereInput
  }

  /**
   * PickupLocation upsert
   */
  export type PickupLocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PickupLocation
     */
    select?: PickupLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PickupLocationInclude<ExtArgs> | null
    /**
     * The filter to search for the PickupLocation to update in case it exists.
     */
    where: PickupLocationWhereUniqueInput
    /**
     * In case the PickupLocation found by the `where` argument doesn't exist, create a new PickupLocation with this data.
     */
    create: XOR<PickupLocationCreateInput, PickupLocationUncheckedCreateInput>
    /**
     * In case the PickupLocation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PickupLocationUpdateInput, PickupLocationUncheckedUpdateInput>
  }

  /**
   * PickupLocation delete
   */
  export type PickupLocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PickupLocation
     */
    select?: PickupLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PickupLocationInclude<ExtArgs> | null
    /**
     * Filter which PickupLocation to delete.
     */
    where: PickupLocationWhereUniqueInput
  }

  /**
   * PickupLocation deleteMany
   */
  export type PickupLocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PickupLocations to delete
     */
    where?: PickupLocationWhereInput
  }

  /**
   * PickupLocation.trips
   */
  export type PickupLocation$tripsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    where?: TripWhereInput
    orderBy?: TripOrderByWithRelationInput | TripOrderByWithRelationInput[]
    cursor?: TripWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TripScalarFieldEnum | TripScalarFieldEnum[]
  }

  /**
   * PickupLocation without action
   */
  export type PickupLocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PickupLocation
     */
    select?: PickupLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PickupLocationInclude<ExtArgs> | null
  }


  /**
   * Model EMSAgency
   */

  export type AggregateEMSAgency = {
    _count: EMSAgencyCountAggregateOutputType | null
    _avg: EMSAgencyAvgAggregateOutputType | null
    _sum: EMSAgencySumAggregateOutputType | null
    _min: EMSAgencyMinAggregateOutputType | null
    _max: EMSAgencyMaxAggregateOutputType | null
  }

  export type EMSAgencyAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
    serviceRadius: number | null
    totalUnits: number | null
    availableUnits: number | null
  }

  export type EMSAgencySumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
    serviceRadius: number | null
    totalUnits: number | null
    availableUnits: number | null
  }

  export type EMSAgencyMinAggregateOutputType = {
    id: string | null
    name: string | null
    contactName: string | null
    phone: string | null
    email: string | null
    address: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    latitude: number | null
    longitude: number | null
    serviceRadius: number | null
    totalUnits: number | null
    availableUnits: number | null
    lastUpdated: Date | null
    acceptsNotifications: boolean | null
    isActive: boolean | null
    status: string | null
    requiresReview: boolean | null
    approvedAt: Date | null
    approvedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EMSAgencyMaxAggregateOutputType = {
    id: string | null
    name: string | null
    contactName: string | null
    phone: string | null
    email: string | null
    address: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    latitude: number | null
    longitude: number | null
    serviceRadius: number | null
    totalUnits: number | null
    availableUnits: number | null
    lastUpdated: Date | null
    acceptsNotifications: boolean | null
    isActive: boolean | null
    status: string | null
    requiresReview: boolean | null
    approvedAt: Date | null
    approvedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EMSAgencyCountAggregateOutputType = {
    id: number
    name: number
    contactName: number
    phone: number
    email: number
    address: number
    city: number
    state: number
    zipCode: number
    serviceArea: number
    operatingHours: number
    capabilities: number
    pricingStructure: number
    latitude: number
    longitude: number
    serviceRadius: number
    totalUnits: number
    availableUnits: number
    lastUpdated: number
    acceptsNotifications: number
    notificationMethods: number
    isActive: number
    status: number
    requiresReview: number
    approvedAt: number
    approvedBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EMSAgencyAvgAggregateInputType = {
    latitude?: true
    longitude?: true
    serviceRadius?: true
    totalUnits?: true
    availableUnits?: true
  }

  export type EMSAgencySumAggregateInputType = {
    latitude?: true
    longitude?: true
    serviceRadius?: true
    totalUnits?: true
    availableUnits?: true
  }

  export type EMSAgencyMinAggregateInputType = {
    id?: true
    name?: true
    contactName?: true
    phone?: true
    email?: true
    address?: true
    city?: true
    state?: true
    zipCode?: true
    latitude?: true
    longitude?: true
    serviceRadius?: true
    totalUnits?: true
    availableUnits?: true
    lastUpdated?: true
    acceptsNotifications?: true
    isActive?: true
    status?: true
    requiresReview?: true
    approvedAt?: true
    approvedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EMSAgencyMaxAggregateInputType = {
    id?: true
    name?: true
    contactName?: true
    phone?: true
    email?: true
    address?: true
    city?: true
    state?: true
    zipCode?: true
    latitude?: true
    longitude?: true
    serviceRadius?: true
    totalUnits?: true
    availableUnits?: true
    lastUpdated?: true
    acceptsNotifications?: true
    isActive?: true
    status?: true
    requiresReview?: true
    approvedAt?: true
    approvedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EMSAgencyCountAggregateInputType = {
    id?: true
    name?: true
    contactName?: true
    phone?: true
    email?: true
    address?: true
    city?: true
    state?: true
    zipCode?: true
    serviceArea?: true
    operatingHours?: true
    capabilities?: true
    pricingStructure?: true
    latitude?: true
    longitude?: true
    serviceRadius?: true
    totalUnits?: true
    availableUnits?: true
    lastUpdated?: true
    acceptsNotifications?: true
    notificationMethods?: true
    isActive?: true
    status?: true
    requiresReview?: true
    approvedAt?: true
    approvedBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EMSAgencyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EMSAgency to aggregate.
     */
    where?: EMSAgencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EMSAgencies to fetch.
     */
    orderBy?: EMSAgencyOrderByWithRelationInput | EMSAgencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EMSAgencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EMSAgencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EMSAgencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EMSAgencies
    **/
    _count?: true | EMSAgencyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EMSAgencyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EMSAgencySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EMSAgencyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EMSAgencyMaxAggregateInputType
  }

  export type GetEMSAgencyAggregateType<T extends EMSAgencyAggregateArgs> = {
        [P in keyof T & keyof AggregateEMSAgency]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEMSAgency[P]>
      : GetScalarType<T[P], AggregateEMSAgency[P]>
  }




  export type EMSAgencyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EMSAgencyWhereInput
    orderBy?: EMSAgencyOrderByWithAggregationInput | EMSAgencyOrderByWithAggregationInput[]
    by: EMSAgencyScalarFieldEnum[] | EMSAgencyScalarFieldEnum
    having?: EMSAgencyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EMSAgencyCountAggregateInputType | true
    _avg?: EMSAgencyAvgAggregateInputType
    _sum?: EMSAgencySumAggregateInputType
    _min?: EMSAgencyMinAggregateInputType
    _max?: EMSAgencyMaxAggregateInputType
  }

  export type EMSAgencyGroupByOutputType = {
    id: string
    name: string
    contactName: string
    phone: string
    email: string
    address: string
    city: string
    state: string
    zipCode: string
    serviceArea: string[]
    operatingHours: JsonValue | null
    capabilities: string[]
    pricingStructure: JsonValue | null
    latitude: number | null
    longitude: number | null
    serviceRadius: number | null
    totalUnits: number
    availableUnits: number
    lastUpdated: Date
    acceptsNotifications: boolean
    notificationMethods: string[]
    isActive: boolean
    status: string
    requiresReview: boolean
    approvedAt: Date | null
    approvedBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: EMSAgencyCountAggregateOutputType | null
    _avg: EMSAgencyAvgAggregateOutputType | null
    _sum: EMSAgencySumAggregateOutputType | null
    _min: EMSAgencyMinAggregateOutputType | null
    _max: EMSAgencyMaxAggregateOutputType | null
  }

  type GetEMSAgencyGroupByPayload<T extends EMSAgencyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EMSAgencyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EMSAgencyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EMSAgencyGroupByOutputType[P]>
            : GetScalarType<T[P], EMSAgencyGroupByOutputType[P]>
        }
      >
    >


  export type EMSAgencySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    contactName?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    serviceArea?: boolean
    operatingHours?: boolean
    capabilities?: boolean
    pricingStructure?: boolean
    latitude?: boolean
    longitude?: boolean
    serviceRadius?: boolean
    totalUnits?: boolean
    availableUnits?: boolean
    lastUpdated?: boolean
    acceptsNotifications?: boolean
    notificationMethods?: boolean
    isActive?: boolean
    status?: boolean
    requiresReview?: boolean
    approvedAt?: boolean
    approvedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["eMSAgency"]>

  export type EMSAgencySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    contactName?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    serviceArea?: boolean
    operatingHours?: boolean
    capabilities?: boolean
    pricingStructure?: boolean
    latitude?: boolean
    longitude?: boolean
    serviceRadius?: boolean
    totalUnits?: boolean
    availableUnits?: boolean
    lastUpdated?: boolean
    acceptsNotifications?: boolean
    notificationMethods?: boolean
    isActive?: boolean
    status?: boolean
    requiresReview?: boolean
    approvedAt?: boolean
    approvedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["eMSAgency"]>

  export type EMSAgencySelectScalar = {
    id?: boolean
    name?: boolean
    contactName?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    serviceArea?: boolean
    operatingHours?: boolean
    capabilities?: boolean
    pricingStructure?: boolean
    latitude?: boolean
    longitude?: boolean
    serviceRadius?: boolean
    totalUnits?: boolean
    availableUnits?: boolean
    lastUpdated?: boolean
    acceptsNotifications?: boolean
    notificationMethods?: boolean
    isActive?: boolean
    status?: boolean
    requiresReview?: boolean
    approvedAt?: boolean
    approvedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $EMSAgencyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EMSAgency"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      contactName: string
      phone: string
      email: string
      address: string
      city: string
      state: string
      zipCode: string
      serviceArea: string[]
      operatingHours: Prisma.JsonValue | null
      capabilities: string[]
      pricingStructure: Prisma.JsonValue | null
      latitude: number | null
      longitude: number | null
      serviceRadius: number | null
      totalUnits: number
      availableUnits: number
      lastUpdated: Date
      acceptsNotifications: boolean
      notificationMethods: string[]
      isActive: boolean
      status: string
      requiresReview: boolean
      approvedAt: Date | null
      approvedBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["eMSAgency"]>
    composites: {}
  }

  type EMSAgencyGetPayload<S extends boolean | null | undefined | EMSAgencyDefaultArgs> = $Result.GetResult<Prisma.$EMSAgencyPayload, S>

  type EMSAgencyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EMSAgencyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EMSAgencyCountAggregateInputType | true
    }

  export interface EMSAgencyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EMSAgency'], meta: { name: 'EMSAgency' } }
    /**
     * Find zero or one EMSAgency that matches the filter.
     * @param {EMSAgencyFindUniqueArgs} args - Arguments to find a EMSAgency
     * @example
     * // Get one EMSAgency
     * const eMSAgency = await prisma.eMSAgency.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EMSAgencyFindUniqueArgs>(args: SelectSubset<T, EMSAgencyFindUniqueArgs<ExtArgs>>): Prisma__EMSAgencyClient<$Result.GetResult<Prisma.$EMSAgencyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EMSAgency that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EMSAgencyFindUniqueOrThrowArgs} args - Arguments to find a EMSAgency
     * @example
     * // Get one EMSAgency
     * const eMSAgency = await prisma.eMSAgency.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EMSAgencyFindUniqueOrThrowArgs>(args: SelectSubset<T, EMSAgencyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EMSAgencyClient<$Result.GetResult<Prisma.$EMSAgencyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EMSAgency that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EMSAgencyFindFirstArgs} args - Arguments to find a EMSAgency
     * @example
     * // Get one EMSAgency
     * const eMSAgency = await prisma.eMSAgency.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EMSAgencyFindFirstArgs>(args?: SelectSubset<T, EMSAgencyFindFirstArgs<ExtArgs>>): Prisma__EMSAgencyClient<$Result.GetResult<Prisma.$EMSAgencyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EMSAgency that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EMSAgencyFindFirstOrThrowArgs} args - Arguments to find a EMSAgency
     * @example
     * // Get one EMSAgency
     * const eMSAgency = await prisma.eMSAgency.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EMSAgencyFindFirstOrThrowArgs>(args?: SelectSubset<T, EMSAgencyFindFirstOrThrowArgs<ExtArgs>>): Prisma__EMSAgencyClient<$Result.GetResult<Prisma.$EMSAgencyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EMSAgencies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EMSAgencyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EMSAgencies
     * const eMSAgencies = await prisma.eMSAgency.findMany()
     * 
     * // Get first 10 EMSAgencies
     * const eMSAgencies = await prisma.eMSAgency.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eMSAgencyWithIdOnly = await prisma.eMSAgency.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EMSAgencyFindManyArgs>(args?: SelectSubset<T, EMSAgencyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EMSAgencyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EMSAgency.
     * @param {EMSAgencyCreateArgs} args - Arguments to create a EMSAgency.
     * @example
     * // Create one EMSAgency
     * const EMSAgency = await prisma.eMSAgency.create({
     *   data: {
     *     // ... data to create a EMSAgency
     *   }
     * })
     * 
     */
    create<T extends EMSAgencyCreateArgs>(args: SelectSubset<T, EMSAgencyCreateArgs<ExtArgs>>): Prisma__EMSAgencyClient<$Result.GetResult<Prisma.$EMSAgencyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EMSAgencies.
     * @param {EMSAgencyCreateManyArgs} args - Arguments to create many EMSAgencies.
     * @example
     * // Create many EMSAgencies
     * const eMSAgency = await prisma.eMSAgency.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EMSAgencyCreateManyArgs>(args?: SelectSubset<T, EMSAgencyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EMSAgencies and returns the data saved in the database.
     * @param {EMSAgencyCreateManyAndReturnArgs} args - Arguments to create many EMSAgencies.
     * @example
     * // Create many EMSAgencies
     * const eMSAgency = await prisma.eMSAgency.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EMSAgencies and only return the `id`
     * const eMSAgencyWithIdOnly = await prisma.eMSAgency.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EMSAgencyCreateManyAndReturnArgs>(args?: SelectSubset<T, EMSAgencyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EMSAgencyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EMSAgency.
     * @param {EMSAgencyDeleteArgs} args - Arguments to delete one EMSAgency.
     * @example
     * // Delete one EMSAgency
     * const EMSAgency = await prisma.eMSAgency.delete({
     *   where: {
     *     // ... filter to delete one EMSAgency
     *   }
     * })
     * 
     */
    delete<T extends EMSAgencyDeleteArgs>(args: SelectSubset<T, EMSAgencyDeleteArgs<ExtArgs>>): Prisma__EMSAgencyClient<$Result.GetResult<Prisma.$EMSAgencyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EMSAgency.
     * @param {EMSAgencyUpdateArgs} args - Arguments to update one EMSAgency.
     * @example
     * // Update one EMSAgency
     * const eMSAgency = await prisma.eMSAgency.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EMSAgencyUpdateArgs>(args: SelectSubset<T, EMSAgencyUpdateArgs<ExtArgs>>): Prisma__EMSAgencyClient<$Result.GetResult<Prisma.$EMSAgencyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EMSAgencies.
     * @param {EMSAgencyDeleteManyArgs} args - Arguments to filter EMSAgencies to delete.
     * @example
     * // Delete a few EMSAgencies
     * const { count } = await prisma.eMSAgency.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EMSAgencyDeleteManyArgs>(args?: SelectSubset<T, EMSAgencyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EMSAgencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EMSAgencyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EMSAgencies
     * const eMSAgency = await prisma.eMSAgency.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EMSAgencyUpdateManyArgs>(args: SelectSubset<T, EMSAgencyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EMSAgency.
     * @param {EMSAgencyUpsertArgs} args - Arguments to update or create a EMSAgency.
     * @example
     * // Update or create a EMSAgency
     * const eMSAgency = await prisma.eMSAgency.upsert({
     *   create: {
     *     // ... data to create a EMSAgency
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EMSAgency we want to update
     *   }
     * })
     */
    upsert<T extends EMSAgencyUpsertArgs>(args: SelectSubset<T, EMSAgencyUpsertArgs<ExtArgs>>): Prisma__EMSAgencyClient<$Result.GetResult<Prisma.$EMSAgencyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EMSAgencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EMSAgencyCountArgs} args - Arguments to filter EMSAgencies to count.
     * @example
     * // Count the number of EMSAgencies
     * const count = await prisma.eMSAgency.count({
     *   where: {
     *     // ... the filter for the EMSAgencies we want to count
     *   }
     * })
    **/
    count<T extends EMSAgencyCountArgs>(
      args?: Subset<T, EMSAgencyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EMSAgencyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EMSAgency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EMSAgencyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EMSAgencyAggregateArgs>(args: Subset<T, EMSAgencyAggregateArgs>): Prisma.PrismaPromise<GetEMSAgencyAggregateType<T>>

    /**
     * Group by EMSAgency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EMSAgencyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EMSAgencyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EMSAgencyGroupByArgs['orderBy'] }
        : { orderBy?: EMSAgencyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EMSAgencyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEMSAgencyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EMSAgency model
   */
  readonly fields: EMSAgencyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EMSAgency.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EMSAgencyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EMSAgency model
   */ 
  interface EMSAgencyFieldRefs {
    readonly id: FieldRef<"EMSAgency", 'String'>
    readonly name: FieldRef<"EMSAgency", 'String'>
    readonly contactName: FieldRef<"EMSAgency", 'String'>
    readonly phone: FieldRef<"EMSAgency", 'String'>
    readonly email: FieldRef<"EMSAgency", 'String'>
    readonly address: FieldRef<"EMSAgency", 'String'>
    readonly city: FieldRef<"EMSAgency", 'String'>
    readonly state: FieldRef<"EMSAgency", 'String'>
    readonly zipCode: FieldRef<"EMSAgency", 'String'>
    readonly serviceArea: FieldRef<"EMSAgency", 'String[]'>
    readonly operatingHours: FieldRef<"EMSAgency", 'Json'>
    readonly capabilities: FieldRef<"EMSAgency", 'String[]'>
    readonly pricingStructure: FieldRef<"EMSAgency", 'Json'>
    readonly latitude: FieldRef<"EMSAgency", 'Float'>
    readonly longitude: FieldRef<"EMSAgency", 'Float'>
    readonly serviceRadius: FieldRef<"EMSAgency", 'Int'>
    readonly totalUnits: FieldRef<"EMSAgency", 'Int'>
    readonly availableUnits: FieldRef<"EMSAgency", 'Int'>
    readonly lastUpdated: FieldRef<"EMSAgency", 'DateTime'>
    readonly acceptsNotifications: FieldRef<"EMSAgency", 'Boolean'>
    readonly notificationMethods: FieldRef<"EMSAgency", 'String[]'>
    readonly isActive: FieldRef<"EMSAgency", 'Boolean'>
    readonly status: FieldRef<"EMSAgency", 'String'>
    readonly requiresReview: FieldRef<"EMSAgency", 'Boolean'>
    readonly approvedAt: FieldRef<"EMSAgency", 'DateTime'>
    readonly approvedBy: FieldRef<"EMSAgency", 'String'>
    readonly createdAt: FieldRef<"EMSAgency", 'DateTime'>
    readonly updatedAt: FieldRef<"EMSAgency", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EMSAgency findUnique
   */
  export type EMSAgencyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EMSAgency
     */
    select?: EMSAgencySelect<ExtArgs> | null
    /**
     * Filter, which EMSAgency to fetch.
     */
    where: EMSAgencyWhereUniqueInput
  }

  /**
   * EMSAgency findUniqueOrThrow
   */
  export type EMSAgencyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EMSAgency
     */
    select?: EMSAgencySelect<ExtArgs> | null
    /**
     * Filter, which EMSAgency to fetch.
     */
    where: EMSAgencyWhereUniqueInput
  }

  /**
   * EMSAgency findFirst
   */
  export type EMSAgencyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EMSAgency
     */
    select?: EMSAgencySelect<ExtArgs> | null
    /**
     * Filter, which EMSAgency to fetch.
     */
    where?: EMSAgencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EMSAgencies to fetch.
     */
    orderBy?: EMSAgencyOrderByWithRelationInput | EMSAgencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EMSAgencies.
     */
    cursor?: EMSAgencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EMSAgencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EMSAgencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EMSAgencies.
     */
    distinct?: EMSAgencyScalarFieldEnum | EMSAgencyScalarFieldEnum[]
  }

  /**
   * EMSAgency findFirstOrThrow
   */
  export type EMSAgencyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EMSAgency
     */
    select?: EMSAgencySelect<ExtArgs> | null
    /**
     * Filter, which EMSAgency to fetch.
     */
    where?: EMSAgencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EMSAgencies to fetch.
     */
    orderBy?: EMSAgencyOrderByWithRelationInput | EMSAgencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EMSAgencies.
     */
    cursor?: EMSAgencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EMSAgencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EMSAgencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EMSAgencies.
     */
    distinct?: EMSAgencyScalarFieldEnum | EMSAgencyScalarFieldEnum[]
  }

  /**
   * EMSAgency findMany
   */
  export type EMSAgencyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EMSAgency
     */
    select?: EMSAgencySelect<ExtArgs> | null
    /**
     * Filter, which EMSAgencies to fetch.
     */
    where?: EMSAgencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EMSAgencies to fetch.
     */
    orderBy?: EMSAgencyOrderByWithRelationInput | EMSAgencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EMSAgencies.
     */
    cursor?: EMSAgencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EMSAgencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EMSAgencies.
     */
    skip?: number
    distinct?: EMSAgencyScalarFieldEnum | EMSAgencyScalarFieldEnum[]
  }

  /**
   * EMSAgency create
   */
  export type EMSAgencyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EMSAgency
     */
    select?: EMSAgencySelect<ExtArgs> | null
    /**
     * The data needed to create a EMSAgency.
     */
    data: XOR<EMSAgencyCreateInput, EMSAgencyUncheckedCreateInput>
  }

  /**
   * EMSAgency createMany
   */
  export type EMSAgencyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EMSAgencies.
     */
    data: EMSAgencyCreateManyInput | EMSAgencyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EMSAgency createManyAndReturn
   */
  export type EMSAgencyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EMSAgency
     */
    select?: EMSAgencySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EMSAgencies.
     */
    data: EMSAgencyCreateManyInput | EMSAgencyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EMSAgency update
   */
  export type EMSAgencyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EMSAgency
     */
    select?: EMSAgencySelect<ExtArgs> | null
    /**
     * The data needed to update a EMSAgency.
     */
    data: XOR<EMSAgencyUpdateInput, EMSAgencyUncheckedUpdateInput>
    /**
     * Choose, which EMSAgency to update.
     */
    where: EMSAgencyWhereUniqueInput
  }

  /**
   * EMSAgency updateMany
   */
  export type EMSAgencyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EMSAgencies.
     */
    data: XOR<EMSAgencyUpdateManyMutationInput, EMSAgencyUncheckedUpdateManyInput>
    /**
     * Filter which EMSAgencies to update
     */
    where?: EMSAgencyWhereInput
  }

  /**
   * EMSAgency upsert
   */
  export type EMSAgencyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EMSAgency
     */
    select?: EMSAgencySelect<ExtArgs> | null
    /**
     * The filter to search for the EMSAgency to update in case it exists.
     */
    where: EMSAgencyWhereUniqueInput
    /**
     * In case the EMSAgency found by the `where` argument doesn't exist, create a new EMSAgency with this data.
     */
    create: XOR<EMSAgencyCreateInput, EMSAgencyUncheckedCreateInput>
    /**
     * In case the EMSAgency was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EMSAgencyUpdateInput, EMSAgencyUncheckedUpdateInput>
  }

  /**
   * EMSAgency delete
   */
  export type EMSAgencyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EMSAgency
     */
    select?: EMSAgencySelect<ExtArgs> | null
    /**
     * Filter which EMSAgency to delete.
     */
    where: EMSAgencyWhereUniqueInput
  }

  /**
   * EMSAgency deleteMany
   */
  export type EMSAgencyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EMSAgencies to delete
     */
    where?: EMSAgencyWhereInput
  }

  /**
   * EMSAgency without action
   */
  export type EMSAgencyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EMSAgency
     */
    select?: EMSAgencySelect<ExtArgs> | null
  }


  /**
   * Model Trip
   */

  export type AggregateTrip = {
    _count: TripCountAggregateOutputType | null
    _avg: TripAvgAggregateOutputType | null
    _sum: TripSumAggregateOutputType | null
    _min: TripMinAggregateOutputType | null
    _max: TripMaxAggregateOutputType | null
  }

  export type TripAvgAggregateOutputType = {
    originLatitude: number | null
    originLongitude: number | null
    destinationLatitude: number | null
    destinationLongitude: number | null
    notificationRadius: number | null
    tripCost: Decimal | null
    distanceMiles: number | null
    responseTimeMinutes: number | null
    deadheadMiles: number | null
    insurancePayRate: Decimal | null
    perMileRate: Decimal | null
    estimatedTripTimeMinutes: number | null
    actualTripTimeMinutes: number | null
    completionTimeMinutes: number | null
    loadedMiles: Decimal | null
    customerSatisfaction: number | null
    efficiency: Decimal | null
    performanceScore: Decimal | null
    revenuePerHour: Decimal | null
  }

  export type TripSumAggregateOutputType = {
    originLatitude: number | null
    originLongitude: number | null
    destinationLatitude: number | null
    destinationLongitude: number | null
    notificationRadius: number | null
    tripCost: Decimal | null
    distanceMiles: number | null
    responseTimeMinutes: number | null
    deadheadMiles: number | null
    insurancePayRate: Decimal | null
    perMileRate: Decimal | null
    estimatedTripTimeMinutes: number | null
    actualTripTimeMinutes: number | null
    completionTimeMinutes: number | null
    loadedMiles: Decimal | null
    customerSatisfaction: number | null
    efficiency: Decimal | null
    performanceScore: Decimal | null
    revenuePerHour: Decimal | null
  }

  export type TripMinAggregateOutputType = {
    id: string | null
    tripNumber: string | null
    patientId: string | null
    patientWeight: string | null
    specialNeeds: string | null
    insuranceCompany: string | null
    fromLocation: string | null
    pickupLocationId: string | null
    toLocation: string | null
    scheduledTime: Date | null
    transportLevel: string | null
    urgencyLevel: string | null
    originLatitude: number | null
    originLongitude: number | null
    destinationLatitude: number | null
    destinationLongitude: number | null
    diagnosis: string | null
    mobilityLevel: string | null
    oxygenRequired: boolean | null
    monitoringRequired: boolean | null
    generateQRCode: boolean | null
    qrCodeData: string | null
    notificationRadius: number | null
    transferRequestTime: Date | null
    transferAcceptedTime: Date | null
    emsArrivalTime: Date | null
    emsDepartureTime: Date | null
    tripCost: Decimal | null
    distanceMiles: number | null
    responseTimeMinutes: number | null
    deadheadMiles: number | null
    insurancePayRate: Decimal | null
    perMileRate: Decimal | null
    requestTimestamp: Date | null
    estimatedTripTimeMinutes: number | null
    actualTripTimeMinutes: number | null
    completionTimeMinutes: number | null
    loadedMiles: Decimal | null
    customerSatisfaction: number | null
    efficiency: Decimal | null
    performanceScore: Decimal | null
    revenuePerHour: Decimal | null
    backhaulOpportunity: boolean | null
    actualStartTime: Date | null
    actualEndTime: Date | null
    status: string | null
    priority: string | null
    notes: string | null
    assignedTo: string | null
    assignedAgencyId: string | null
    assignedUnitId: string | null
    acceptedTimestamp: Date | null
    pickupTimestamp: Date | null
    completionTimestamp: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TripMaxAggregateOutputType = {
    id: string | null
    tripNumber: string | null
    patientId: string | null
    patientWeight: string | null
    specialNeeds: string | null
    insuranceCompany: string | null
    fromLocation: string | null
    pickupLocationId: string | null
    toLocation: string | null
    scheduledTime: Date | null
    transportLevel: string | null
    urgencyLevel: string | null
    originLatitude: number | null
    originLongitude: number | null
    destinationLatitude: number | null
    destinationLongitude: number | null
    diagnosis: string | null
    mobilityLevel: string | null
    oxygenRequired: boolean | null
    monitoringRequired: boolean | null
    generateQRCode: boolean | null
    qrCodeData: string | null
    notificationRadius: number | null
    transferRequestTime: Date | null
    transferAcceptedTime: Date | null
    emsArrivalTime: Date | null
    emsDepartureTime: Date | null
    tripCost: Decimal | null
    distanceMiles: number | null
    responseTimeMinutes: number | null
    deadheadMiles: number | null
    insurancePayRate: Decimal | null
    perMileRate: Decimal | null
    requestTimestamp: Date | null
    estimatedTripTimeMinutes: number | null
    actualTripTimeMinutes: number | null
    completionTimeMinutes: number | null
    loadedMiles: Decimal | null
    customerSatisfaction: number | null
    efficiency: Decimal | null
    performanceScore: Decimal | null
    revenuePerHour: Decimal | null
    backhaulOpportunity: boolean | null
    actualStartTime: Date | null
    actualEndTime: Date | null
    status: string | null
    priority: string | null
    notes: string | null
    assignedTo: string | null
    assignedAgencyId: string | null
    assignedUnitId: string | null
    acceptedTimestamp: Date | null
    pickupTimestamp: Date | null
    completionTimestamp: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TripCountAggregateOutputType = {
    id: number
    tripNumber: number
    patientId: number
    patientWeight: number
    specialNeeds: number
    insuranceCompany: number
    fromLocation: number
    pickupLocationId: number
    toLocation: number
    scheduledTime: number
    transportLevel: number
    urgencyLevel: number
    originLatitude: number
    originLongitude: number
    destinationLatitude: number
    destinationLongitude: number
    diagnosis: number
    mobilityLevel: number
    oxygenRequired: number
    monitoringRequired: number
    generateQRCode: number
    qrCodeData: number
    selectedAgencies: number
    notificationRadius: number
    transferRequestTime: number
    transferAcceptedTime: number
    emsArrivalTime: number
    emsDepartureTime: number
    tripCost: number
    distanceMiles: number
    responseTimeMinutes: number
    deadheadMiles: number
    insurancePayRate: number
    perMileRate: number
    requestTimestamp: number
    estimatedTripTimeMinutes: number
    actualTripTimeMinutes: number
    completionTimeMinutes: number
    loadedMiles: number
    customerSatisfaction: number
    efficiency: number
    performanceScore: number
    revenuePerHour: number
    backhaulOpportunity: number
    actualStartTime: number
    actualEndTime: number
    status: number
    priority: number
    notes: number
    assignedTo: number
    assignedAgencyId: number
    assignedUnitId: number
    acceptedTimestamp: number
    pickupTimestamp: number
    completionTimestamp: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TripAvgAggregateInputType = {
    originLatitude?: true
    originLongitude?: true
    destinationLatitude?: true
    destinationLongitude?: true
    notificationRadius?: true
    tripCost?: true
    distanceMiles?: true
    responseTimeMinutes?: true
    deadheadMiles?: true
    insurancePayRate?: true
    perMileRate?: true
    estimatedTripTimeMinutes?: true
    actualTripTimeMinutes?: true
    completionTimeMinutes?: true
    loadedMiles?: true
    customerSatisfaction?: true
    efficiency?: true
    performanceScore?: true
    revenuePerHour?: true
  }

  export type TripSumAggregateInputType = {
    originLatitude?: true
    originLongitude?: true
    destinationLatitude?: true
    destinationLongitude?: true
    notificationRadius?: true
    tripCost?: true
    distanceMiles?: true
    responseTimeMinutes?: true
    deadheadMiles?: true
    insurancePayRate?: true
    perMileRate?: true
    estimatedTripTimeMinutes?: true
    actualTripTimeMinutes?: true
    completionTimeMinutes?: true
    loadedMiles?: true
    customerSatisfaction?: true
    efficiency?: true
    performanceScore?: true
    revenuePerHour?: true
  }

  export type TripMinAggregateInputType = {
    id?: true
    tripNumber?: true
    patientId?: true
    patientWeight?: true
    specialNeeds?: true
    insuranceCompany?: true
    fromLocation?: true
    pickupLocationId?: true
    toLocation?: true
    scheduledTime?: true
    transportLevel?: true
    urgencyLevel?: true
    originLatitude?: true
    originLongitude?: true
    destinationLatitude?: true
    destinationLongitude?: true
    diagnosis?: true
    mobilityLevel?: true
    oxygenRequired?: true
    monitoringRequired?: true
    generateQRCode?: true
    qrCodeData?: true
    notificationRadius?: true
    transferRequestTime?: true
    transferAcceptedTime?: true
    emsArrivalTime?: true
    emsDepartureTime?: true
    tripCost?: true
    distanceMiles?: true
    responseTimeMinutes?: true
    deadheadMiles?: true
    insurancePayRate?: true
    perMileRate?: true
    requestTimestamp?: true
    estimatedTripTimeMinutes?: true
    actualTripTimeMinutes?: true
    completionTimeMinutes?: true
    loadedMiles?: true
    customerSatisfaction?: true
    efficiency?: true
    performanceScore?: true
    revenuePerHour?: true
    backhaulOpportunity?: true
    actualStartTime?: true
    actualEndTime?: true
    status?: true
    priority?: true
    notes?: true
    assignedTo?: true
    assignedAgencyId?: true
    assignedUnitId?: true
    acceptedTimestamp?: true
    pickupTimestamp?: true
    completionTimestamp?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TripMaxAggregateInputType = {
    id?: true
    tripNumber?: true
    patientId?: true
    patientWeight?: true
    specialNeeds?: true
    insuranceCompany?: true
    fromLocation?: true
    pickupLocationId?: true
    toLocation?: true
    scheduledTime?: true
    transportLevel?: true
    urgencyLevel?: true
    originLatitude?: true
    originLongitude?: true
    destinationLatitude?: true
    destinationLongitude?: true
    diagnosis?: true
    mobilityLevel?: true
    oxygenRequired?: true
    monitoringRequired?: true
    generateQRCode?: true
    qrCodeData?: true
    notificationRadius?: true
    transferRequestTime?: true
    transferAcceptedTime?: true
    emsArrivalTime?: true
    emsDepartureTime?: true
    tripCost?: true
    distanceMiles?: true
    responseTimeMinutes?: true
    deadheadMiles?: true
    insurancePayRate?: true
    perMileRate?: true
    requestTimestamp?: true
    estimatedTripTimeMinutes?: true
    actualTripTimeMinutes?: true
    completionTimeMinutes?: true
    loadedMiles?: true
    customerSatisfaction?: true
    efficiency?: true
    performanceScore?: true
    revenuePerHour?: true
    backhaulOpportunity?: true
    actualStartTime?: true
    actualEndTime?: true
    status?: true
    priority?: true
    notes?: true
    assignedTo?: true
    assignedAgencyId?: true
    assignedUnitId?: true
    acceptedTimestamp?: true
    pickupTimestamp?: true
    completionTimestamp?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TripCountAggregateInputType = {
    id?: true
    tripNumber?: true
    patientId?: true
    patientWeight?: true
    specialNeeds?: true
    insuranceCompany?: true
    fromLocation?: true
    pickupLocationId?: true
    toLocation?: true
    scheduledTime?: true
    transportLevel?: true
    urgencyLevel?: true
    originLatitude?: true
    originLongitude?: true
    destinationLatitude?: true
    destinationLongitude?: true
    diagnosis?: true
    mobilityLevel?: true
    oxygenRequired?: true
    monitoringRequired?: true
    generateQRCode?: true
    qrCodeData?: true
    selectedAgencies?: true
    notificationRadius?: true
    transferRequestTime?: true
    transferAcceptedTime?: true
    emsArrivalTime?: true
    emsDepartureTime?: true
    tripCost?: true
    distanceMiles?: true
    responseTimeMinutes?: true
    deadheadMiles?: true
    insurancePayRate?: true
    perMileRate?: true
    requestTimestamp?: true
    estimatedTripTimeMinutes?: true
    actualTripTimeMinutes?: true
    completionTimeMinutes?: true
    loadedMiles?: true
    customerSatisfaction?: true
    efficiency?: true
    performanceScore?: true
    revenuePerHour?: true
    backhaulOpportunity?: true
    actualStartTime?: true
    actualEndTime?: true
    status?: true
    priority?: true
    notes?: true
    assignedTo?: true
    assignedAgencyId?: true
    assignedUnitId?: true
    acceptedTimestamp?: true
    pickupTimestamp?: true
    completionTimestamp?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TripAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Trip to aggregate.
     */
    where?: TripWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trips to fetch.
     */
    orderBy?: TripOrderByWithRelationInput | TripOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TripWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Trips
    **/
    _count?: true | TripCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TripAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TripSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TripMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TripMaxAggregateInputType
  }

  export type GetTripAggregateType<T extends TripAggregateArgs> = {
        [P in keyof T & keyof AggregateTrip]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrip[P]>
      : GetScalarType<T[P], AggregateTrip[P]>
  }




  export type TripGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TripWhereInput
    orderBy?: TripOrderByWithAggregationInput | TripOrderByWithAggregationInput[]
    by: TripScalarFieldEnum[] | TripScalarFieldEnum
    having?: TripScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TripCountAggregateInputType | true
    _avg?: TripAvgAggregateInputType
    _sum?: TripSumAggregateInputType
    _min?: TripMinAggregateInputType
    _max?: TripMaxAggregateInputType
  }

  export type TripGroupByOutputType = {
    id: string
    tripNumber: string
    patientId: string
    patientWeight: string | null
    specialNeeds: string | null
    insuranceCompany: string | null
    fromLocation: string
    pickupLocationId: string | null
    toLocation: string
    scheduledTime: Date
    transportLevel: string
    urgencyLevel: string
    originLatitude: number | null
    originLongitude: number | null
    destinationLatitude: number | null
    destinationLongitude: number | null
    diagnosis: string | null
    mobilityLevel: string | null
    oxygenRequired: boolean
    monitoringRequired: boolean
    generateQRCode: boolean
    qrCodeData: string | null
    selectedAgencies: string[]
    notificationRadius: number | null
    transferRequestTime: Date | null
    transferAcceptedTime: Date | null
    emsArrivalTime: Date | null
    emsDepartureTime: Date | null
    tripCost: Decimal | null
    distanceMiles: number | null
    responseTimeMinutes: number | null
    deadheadMiles: number | null
    insurancePayRate: Decimal | null
    perMileRate: Decimal | null
    requestTimestamp: Date | null
    estimatedTripTimeMinutes: number | null
    actualTripTimeMinutes: number | null
    completionTimeMinutes: number | null
    loadedMiles: Decimal | null
    customerSatisfaction: number | null
    efficiency: Decimal | null
    performanceScore: Decimal | null
    revenuePerHour: Decimal | null
    backhaulOpportunity: boolean
    actualStartTime: Date | null
    actualEndTime: Date | null
    status: string
    priority: string
    notes: string | null
    assignedTo: string | null
    assignedAgencyId: string | null
    assignedUnitId: string | null
    acceptedTimestamp: Date | null
    pickupTimestamp: Date | null
    completionTimestamp: Date | null
    createdAt: Date
    updatedAt: Date
    _count: TripCountAggregateOutputType | null
    _avg: TripAvgAggregateOutputType | null
    _sum: TripSumAggregateOutputType | null
    _min: TripMinAggregateOutputType | null
    _max: TripMaxAggregateOutputType | null
  }

  type GetTripGroupByPayload<T extends TripGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TripGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TripGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TripGroupByOutputType[P]>
            : GetScalarType<T[P], TripGroupByOutputType[P]>
        }
      >
    >


  export type TripSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tripNumber?: boolean
    patientId?: boolean
    patientWeight?: boolean
    specialNeeds?: boolean
    insuranceCompany?: boolean
    fromLocation?: boolean
    pickupLocationId?: boolean
    toLocation?: boolean
    scheduledTime?: boolean
    transportLevel?: boolean
    urgencyLevel?: boolean
    originLatitude?: boolean
    originLongitude?: boolean
    destinationLatitude?: boolean
    destinationLongitude?: boolean
    diagnosis?: boolean
    mobilityLevel?: boolean
    oxygenRequired?: boolean
    monitoringRequired?: boolean
    generateQRCode?: boolean
    qrCodeData?: boolean
    selectedAgencies?: boolean
    notificationRadius?: boolean
    transferRequestTime?: boolean
    transferAcceptedTime?: boolean
    emsArrivalTime?: boolean
    emsDepartureTime?: boolean
    tripCost?: boolean
    distanceMiles?: boolean
    responseTimeMinutes?: boolean
    deadheadMiles?: boolean
    insurancePayRate?: boolean
    perMileRate?: boolean
    requestTimestamp?: boolean
    estimatedTripTimeMinutes?: boolean
    actualTripTimeMinutes?: boolean
    completionTimeMinutes?: boolean
    loadedMiles?: boolean
    customerSatisfaction?: boolean
    efficiency?: boolean
    performanceScore?: boolean
    revenuePerHour?: boolean
    backhaulOpportunity?: boolean
    actualStartTime?: boolean
    actualEndTime?: boolean
    status?: boolean
    priority?: boolean
    notes?: boolean
    assignedTo?: boolean
    assignedAgencyId?: boolean
    assignedUnitId?: boolean
    acceptedTimestamp?: boolean
    pickupTimestamp?: boolean
    completionTimestamp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pickupLocation?: boolean | Trip$pickupLocationArgs<ExtArgs>
  }, ExtArgs["result"]["trip"]>

  export type TripSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tripNumber?: boolean
    patientId?: boolean
    patientWeight?: boolean
    specialNeeds?: boolean
    insuranceCompany?: boolean
    fromLocation?: boolean
    pickupLocationId?: boolean
    toLocation?: boolean
    scheduledTime?: boolean
    transportLevel?: boolean
    urgencyLevel?: boolean
    originLatitude?: boolean
    originLongitude?: boolean
    destinationLatitude?: boolean
    destinationLongitude?: boolean
    diagnosis?: boolean
    mobilityLevel?: boolean
    oxygenRequired?: boolean
    monitoringRequired?: boolean
    generateQRCode?: boolean
    qrCodeData?: boolean
    selectedAgencies?: boolean
    notificationRadius?: boolean
    transferRequestTime?: boolean
    transferAcceptedTime?: boolean
    emsArrivalTime?: boolean
    emsDepartureTime?: boolean
    tripCost?: boolean
    distanceMiles?: boolean
    responseTimeMinutes?: boolean
    deadheadMiles?: boolean
    insurancePayRate?: boolean
    perMileRate?: boolean
    requestTimestamp?: boolean
    estimatedTripTimeMinutes?: boolean
    actualTripTimeMinutes?: boolean
    completionTimeMinutes?: boolean
    loadedMiles?: boolean
    customerSatisfaction?: boolean
    efficiency?: boolean
    performanceScore?: boolean
    revenuePerHour?: boolean
    backhaulOpportunity?: boolean
    actualStartTime?: boolean
    actualEndTime?: boolean
    status?: boolean
    priority?: boolean
    notes?: boolean
    assignedTo?: boolean
    assignedAgencyId?: boolean
    assignedUnitId?: boolean
    acceptedTimestamp?: boolean
    pickupTimestamp?: boolean
    completionTimestamp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pickupLocation?: boolean | Trip$pickupLocationArgs<ExtArgs>
  }, ExtArgs["result"]["trip"]>

  export type TripSelectScalar = {
    id?: boolean
    tripNumber?: boolean
    patientId?: boolean
    patientWeight?: boolean
    specialNeeds?: boolean
    insuranceCompany?: boolean
    fromLocation?: boolean
    pickupLocationId?: boolean
    toLocation?: boolean
    scheduledTime?: boolean
    transportLevel?: boolean
    urgencyLevel?: boolean
    originLatitude?: boolean
    originLongitude?: boolean
    destinationLatitude?: boolean
    destinationLongitude?: boolean
    diagnosis?: boolean
    mobilityLevel?: boolean
    oxygenRequired?: boolean
    monitoringRequired?: boolean
    generateQRCode?: boolean
    qrCodeData?: boolean
    selectedAgencies?: boolean
    notificationRadius?: boolean
    transferRequestTime?: boolean
    transferAcceptedTime?: boolean
    emsArrivalTime?: boolean
    emsDepartureTime?: boolean
    tripCost?: boolean
    distanceMiles?: boolean
    responseTimeMinutes?: boolean
    deadheadMiles?: boolean
    insurancePayRate?: boolean
    perMileRate?: boolean
    requestTimestamp?: boolean
    estimatedTripTimeMinutes?: boolean
    actualTripTimeMinutes?: boolean
    completionTimeMinutes?: boolean
    loadedMiles?: boolean
    customerSatisfaction?: boolean
    efficiency?: boolean
    performanceScore?: boolean
    revenuePerHour?: boolean
    backhaulOpportunity?: boolean
    actualStartTime?: boolean
    actualEndTime?: boolean
    status?: boolean
    priority?: boolean
    notes?: boolean
    assignedTo?: boolean
    assignedAgencyId?: boolean
    assignedUnitId?: boolean
    acceptedTimestamp?: boolean
    pickupTimestamp?: boolean
    completionTimestamp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TripInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pickupLocation?: boolean | Trip$pickupLocationArgs<ExtArgs>
  }
  export type TripIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pickupLocation?: boolean | Trip$pickupLocationArgs<ExtArgs>
  }

  export type $TripPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Trip"
    objects: {
      pickupLocation: Prisma.$PickupLocationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tripNumber: string
      patientId: string
      patientWeight: string | null
      specialNeeds: string | null
      insuranceCompany: string | null
      fromLocation: string
      pickupLocationId: string | null
      toLocation: string
      scheduledTime: Date
      transportLevel: string
      urgencyLevel: string
      originLatitude: number | null
      originLongitude: number | null
      destinationLatitude: number | null
      destinationLongitude: number | null
      diagnosis: string | null
      mobilityLevel: string | null
      oxygenRequired: boolean
      monitoringRequired: boolean
      generateQRCode: boolean
      qrCodeData: string | null
      selectedAgencies: string[]
      notificationRadius: number | null
      transferRequestTime: Date | null
      transferAcceptedTime: Date | null
      emsArrivalTime: Date | null
      emsDepartureTime: Date | null
      tripCost: Prisma.Decimal | null
      distanceMiles: number | null
      responseTimeMinutes: number | null
      deadheadMiles: number | null
      insurancePayRate: Prisma.Decimal | null
      perMileRate: Prisma.Decimal | null
      requestTimestamp: Date | null
      estimatedTripTimeMinutes: number | null
      actualTripTimeMinutes: number | null
      completionTimeMinutes: number | null
      loadedMiles: Prisma.Decimal | null
      customerSatisfaction: number | null
      efficiency: Prisma.Decimal | null
      performanceScore: Prisma.Decimal | null
      revenuePerHour: Prisma.Decimal | null
      backhaulOpportunity: boolean
      actualStartTime: Date | null
      actualEndTime: Date | null
      status: string
      priority: string
      notes: string | null
      assignedTo: string | null
      assignedAgencyId: string | null
      assignedUnitId: string | null
      acceptedTimestamp: Date | null
      pickupTimestamp: Date | null
      completionTimestamp: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["trip"]>
    composites: {}
  }

  type TripGetPayload<S extends boolean | null | undefined | TripDefaultArgs> = $Result.GetResult<Prisma.$TripPayload, S>

  type TripCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TripFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TripCountAggregateInputType | true
    }

  export interface TripDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Trip'], meta: { name: 'Trip' } }
    /**
     * Find zero or one Trip that matches the filter.
     * @param {TripFindUniqueArgs} args - Arguments to find a Trip
     * @example
     * // Get one Trip
     * const trip = await prisma.trip.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TripFindUniqueArgs>(args: SelectSubset<T, TripFindUniqueArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Trip that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TripFindUniqueOrThrowArgs} args - Arguments to find a Trip
     * @example
     * // Get one Trip
     * const trip = await prisma.trip.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TripFindUniqueOrThrowArgs>(args: SelectSubset<T, TripFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Trip that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripFindFirstArgs} args - Arguments to find a Trip
     * @example
     * // Get one Trip
     * const trip = await prisma.trip.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TripFindFirstArgs>(args?: SelectSubset<T, TripFindFirstArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Trip that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripFindFirstOrThrowArgs} args - Arguments to find a Trip
     * @example
     * // Get one Trip
     * const trip = await prisma.trip.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TripFindFirstOrThrowArgs>(args?: SelectSubset<T, TripFindFirstOrThrowArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Trips that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Trips
     * const trips = await prisma.trip.findMany()
     * 
     * // Get first 10 Trips
     * const trips = await prisma.trip.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tripWithIdOnly = await prisma.trip.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TripFindManyArgs>(args?: SelectSubset<T, TripFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Trip.
     * @param {TripCreateArgs} args - Arguments to create a Trip.
     * @example
     * // Create one Trip
     * const Trip = await prisma.trip.create({
     *   data: {
     *     // ... data to create a Trip
     *   }
     * })
     * 
     */
    create<T extends TripCreateArgs>(args: SelectSubset<T, TripCreateArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Trips.
     * @param {TripCreateManyArgs} args - Arguments to create many Trips.
     * @example
     * // Create many Trips
     * const trip = await prisma.trip.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TripCreateManyArgs>(args?: SelectSubset<T, TripCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Trips and returns the data saved in the database.
     * @param {TripCreateManyAndReturnArgs} args - Arguments to create many Trips.
     * @example
     * // Create many Trips
     * const trip = await prisma.trip.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Trips and only return the `id`
     * const tripWithIdOnly = await prisma.trip.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TripCreateManyAndReturnArgs>(args?: SelectSubset<T, TripCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Trip.
     * @param {TripDeleteArgs} args - Arguments to delete one Trip.
     * @example
     * // Delete one Trip
     * const Trip = await prisma.trip.delete({
     *   where: {
     *     // ... filter to delete one Trip
     *   }
     * })
     * 
     */
    delete<T extends TripDeleteArgs>(args: SelectSubset<T, TripDeleteArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Trip.
     * @param {TripUpdateArgs} args - Arguments to update one Trip.
     * @example
     * // Update one Trip
     * const trip = await prisma.trip.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TripUpdateArgs>(args: SelectSubset<T, TripUpdateArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Trips.
     * @param {TripDeleteManyArgs} args - Arguments to filter Trips to delete.
     * @example
     * // Delete a few Trips
     * const { count } = await prisma.trip.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TripDeleteManyArgs>(args?: SelectSubset<T, TripDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Trips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Trips
     * const trip = await prisma.trip.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TripUpdateManyArgs>(args: SelectSubset<T, TripUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Trip.
     * @param {TripUpsertArgs} args - Arguments to update or create a Trip.
     * @example
     * // Update or create a Trip
     * const trip = await prisma.trip.upsert({
     *   create: {
     *     // ... data to create a Trip
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Trip we want to update
     *   }
     * })
     */
    upsert<T extends TripUpsertArgs>(args: SelectSubset<T, TripUpsertArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Trips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripCountArgs} args - Arguments to filter Trips to count.
     * @example
     * // Count the number of Trips
     * const count = await prisma.trip.count({
     *   where: {
     *     // ... the filter for the Trips we want to count
     *   }
     * })
    **/
    count<T extends TripCountArgs>(
      args?: Subset<T, TripCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TripCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Trip.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TripAggregateArgs>(args: Subset<T, TripAggregateArgs>): Prisma.PrismaPromise<GetTripAggregateType<T>>

    /**
     * Group by Trip.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TripGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TripGroupByArgs['orderBy'] }
        : { orderBy?: TripGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TripGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTripGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Trip model
   */
  readonly fields: TripFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Trip.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TripClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pickupLocation<T extends Trip$pickupLocationArgs<ExtArgs> = {}>(args?: Subset<T, Trip$pickupLocationArgs<ExtArgs>>): Prisma__PickupLocationClient<$Result.GetResult<Prisma.$PickupLocationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Trip model
   */ 
  interface TripFieldRefs {
    readonly id: FieldRef<"Trip", 'String'>
    readonly tripNumber: FieldRef<"Trip", 'String'>
    readonly patientId: FieldRef<"Trip", 'String'>
    readonly patientWeight: FieldRef<"Trip", 'String'>
    readonly specialNeeds: FieldRef<"Trip", 'String'>
    readonly insuranceCompany: FieldRef<"Trip", 'String'>
    readonly fromLocation: FieldRef<"Trip", 'String'>
    readonly pickupLocationId: FieldRef<"Trip", 'String'>
    readonly toLocation: FieldRef<"Trip", 'String'>
    readonly scheduledTime: FieldRef<"Trip", 'DateTime'>
    readonly transportLevel: FieldRef<"Trip", 'String'>
    readonly urgencyLevel: FieldRef<"Trip", 'String'>
    readonly originLatitude: FieldRef<"Trip", 'Float'>
    readonly originLongitude: FieldRef<"Trip", 'Float'>
    readonly destinationLatitude: FieldRef<"Trip", 'Float'>
    readonly destinationLongitude: FieldRef<"Trip", 'Float'>
    readonly diagnosis: FieldRef<"Trip", 'String'>
    readonly mobilityLevel: FieldRef<"Trip", 'String'>
    readonly oxygenRequired: FieldRef<"Trip", 'Boolean'>
    readonly monitoringRequired: FieldRef<"Trip", 'Boolean'>
    readonly generateQRCode: FieldRef<"Trip", 'Boolean'>
    readonly qrCodeData: FieldRef<"Trip", 'String'>
    readonly selectedAgencies: FieldRef<"Trip", 'String[]'>
    readonly notificationRadius: FieldRef<"Trip", 'Int'>
    readonly transferRequestTime: FieldRef<"Trip", 'DateTime'>
    readonly transferAcceptedTime: FieldRef<"Trip", 'DateTime'>
    readonly emsArrivalTime: FieldRef<"Trip", 'DateTime'>
    readonly emsDepartureTime: FieldRef<"Trip", 'DateTime'>
    readonly tripCost: FieldRef<"Trip", 'Decimal'>
    readonly distanceMiles: FieldRef<"Trip", 'Float'>
    readonly responseTimeMinutes: FieldRef<"Trip", 'Int'>
    readonly deadheadMiles: FieldRef<"Trip", 'Float'>
    readonly insurancePayRate: FieldRef<"Trip", 'Decimal'>
    readonly perMileRate: FieldRef<"Trip", 'Decimal'>
    readonly requestTimestamp: FieldRef<"Trip", 'DateTime'>
    readonly estimatedTripTimeMinutes: FieldRef<"Trip", 'Int'>
    readonly actualTripTimeMinutes: FieldRef<"Trip", 'Int'>
    readonly completionTimeMinutes: FieldRef<"Trip", 'Int'>
    readonly loadedMiles: FieldRef<"Trip", 'Decimal'>
    readonly customerSatisfaction: FieldRef<"Trip", 'Int'>
    readonly efficiency: FieldRef<"Trip", 'Decimal'>
    readonly performanceScore: FieldRef<"Trip", 'Decimal'>
    readonly revenuePerHour: FieldRef<"Trip", 'Decimal'>
    readonly backhaulOpportunity: FieldRef<"Trip", 'Boolean'>
    readonly actualStartTime: FieldRef<"Trip", 'DateTime'>
    readonly actualEndTime: FieldRef<"Trip", 'DateTime'>
    readonly status: FieldRef<"Trip", 'String'>
    readonly priority: FieldRef<"Trip", 'String'>
    readonly notes: FieldRef<"Trip", 'String'>
    readonly assignedTo: FieldRef<"Trip", 'String'>
    readonly assignedAgencyId: FieldRef<"Trip", 'String'>
    readonly assignedUnitId: FieldRef<"Trip", 'String'>
    readonly acceptedTimestamp: FieldRef<"Trip", 'DateTime'>
    readonly pickupTimestamp: FieldRef<"Trip", 'DateTime'>
    readonly completionTimestamp: FieldRef<"Trip", 'DateTime'>
    readonly createdAt: FieldRef<"Trip", 'DateTime'>
    readonly updatedAt: FieldRef<"Trip", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Trip findUnique
   */
  export type TripFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * Filter, which Trip to fetch.
     */
    where: TripWhereUniqueInput
  }

  /**
   * Trip findUniqueOrThrow
   */
  export type TripFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * Filter, which Trip to fetch.
     */
    where: TripWhereUniqueInput
  }

  /**
   * Trip findFirst
   */
  export type TripFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * Filter, which Trip to fetch.
     */
    where?: TripWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trips to fetch.
     */
    orderBy?: TripOrderByWithRelationInput | TripOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Trips.
     */
    cursor?: TripWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Trips.
     */
    distinct?: TripScalarFieldEnum | TripScalarFieldEnum[]
  }

  /**
   * Trip findFirstOrThrow
   */
  export type TripFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * Filter, which Trip to fetch.
     */
    where?: TripWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trips to fetch.
     */
    orderBy?: TripOrderByWithRelationInput | TripOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Trips.
     */
    cursor?: TripWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Trips.
     */
    distinct?: TripScalarFieldEnum | TripScalarFieldEnum[]
  }

  /**
   * Trip findMany
   */
  export type TripFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * Filter, which Trips to fetch.
     */
    where?: TripWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trips to fetch.
     */
    orderBy?: TripOrderByWithRelationInput | TripOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Trips.
     */
    cursor?: TripWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trips.
     */
    skip?: number
    distinct?: TripScalarFieldEnum | TripScalarFieldEnum[]
  }

  /**
   * Trip create
   */
  export type TripCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * The data needed to create a Trip.
     */
    data: XOR<TripCreateInput, TripUncheckedCreateInput>
  }

  /**
   * Trip createMany
   */
  export type TripCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Trips.
     */
    data: TripCreateManyInput | TripCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Trip createManyAndReturn
   */
  export type TripCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Trips.
     */
    data: TripCreateManyInput | TripCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Trip update
   */
  export type TripUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * The data needed to update a Trip.
     */
    data: XOR<TripUpdateInput, TripUncheckedUpdateInput>
    /**
     * Choose, which Trip to update.
     */
    where: TripWhereUniqueInput
  }

  /**
   * Trip updateMany
   */
  export type TripUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Trips.
     */
    data: XOR<TripUpdateManyMutationInput, TripUncheckedUpdateManyInput>
    /**
     * Filter which Trips to update
     */
    where?: TripWhereInput
  }

  /**
   * Trip upsert
   */
  export type TripUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * The filter to search for the Trip to update in case it exists.
     */
    where: TripWhereUniqueInput
    /**
     * In case the Trip found by the `where` argument doesn't exist, create a new Trip with this data.
     */
    create: XOR<TripCreateInput, TripUncheckedCreateInput>
    /**
     * In case the Trip was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TripUpdateInput, TripUncheckedUpdateInput>
  }

  /**
   * Trip delete
   */
  export type TripDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * Filter which Trip to delete.
     */
    where: TripWhereUniqueInput
  }

  /**
   * Trip deleteMany
   */
  export type TripDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Trips to delete
     */
    where?: TripWhereInput
  }

  /**
   * Trip.pickupLocation
   */
  export type Trip$pickupLocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PickupLocation
     */
    select?: PickupLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PickupLocationInclude<ExtArgs> | null
    where?: PickupLocationWhereInput
  }

  /**
   * Trip without action
   */
  export type TripDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
  }


  /**
   * Model SystemAnalytics
   */

  export type AggregateSystemAnalytics = {
    _count: SystemAnalyticsCountAggregateOutputType | null
    _min: SystemAnalyticsMinAggregateOutputType | null
    _max: SystemAnalyticsMaxAggregateOutputType | null
  }

  export type SystemAnalyticsMinAggregateOutputType = {
    id: string | null
    metricName: string | null
    timestamp: Date | null
    createdAt: Date | null
    userId: string | null
  }

  export type SystemAnalyticsMaxAggregateOutputType = {
    id: string | null
    metricName: string | null
    timestamp: Date | null
    createdAt: Date | null
    userId: string | null
  }

  export type SystemAnalyticsCountAggregateOutputType = {
    id: number
    metricName: number
    metricValue: number
    timestamp: number
    createdAt: number
    userId: number
    _all: number
  }


  export type SystemAnalyticsMinAggregateInputType = {
    id?: true
    metricName?: true
    timestamp?: true
    createdAt?: true
    userId?: true
  }

  export type SystemAnalyticsMaxAggregateInputType = {
    id?: true
    metricName?: true
    timestamp?: true
    createdAt?: true
    userId?: true
  }

  export type SystemAnalyticsCountAggregateInputType = {
    id?: true
    metricName?: true
    metricValue?: true
    timestamp?: true
    createdAt?: true
    userId?: true
    _all?: true
  }

  export type SystemAnalyticsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemAnalytics to aggregate.
     */
    where?: SystemAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemAnalytics to fetch.
     */
    orderBy?: SystemAnalyticsOrderByWithRelationInput | SystemAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemAnalytics
    **/
    _count?: true | SystemAnalyticsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemAnalyticsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemAnalyticsMaxAggregateInputType
  }

  export type GetSystemAnalyticsAggregateType<T extends SystemAnalyticsAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemAnalytics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemAnalytics[P]>
      : GetScalarType<T[P], AggregateSystemAnalytics[P]>
  }




  export type SystemAnalyticsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemAnalyticsWhereInput
    orderBy?: SystemAnalyticsOrderByWithAggregationInput | SystemAnalyticsOrderByWithAggregationInput[]
    by: SystemAnalyticsScalarFieldEnum[] | SystemAnalyticsScalarFieldEnum
    having?: SystemAnalyticsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemAnalyticsCountAggregateInputType | true
    _min?: SystemAnalyticsMinAggregateInputType
    _max?: SystemAnalyticsMaxAggregateInputType
  }

  export type SystemAnalyticsGroupByOutputType = {
    id: string
    metricName: string
    metricValue: JsonValue
    timestamp: Date
    createdAt: Date
    userId: string | null
    _count: SystemAnalyticsCountAggregateOutputType | null
    _min: SystemAnalyticsMinAggregateOutputType | null
    _max: SystemAnalyticsMaxAggregateOutputType | null
  }

  type GetSystemAnalyticsGroupByPayload<T extends SystemAnalyticsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemAnalyticsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemAnalyticsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemAnalyticsGroupByOutputType[P]>
            : GetScalarType<T[P], SystemAnalyticsGroupByOutputType[P]>
        }
      >
    >


  export type SystemAnalyticsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    metricName?: boolean
    metricValue?: boolean
    timestamp?: boolean
    createdAt?: boolean
    userId?: boolean
  }, ExtArgs["result"]["systemAnalytics"]>

  export type SystemAnalyticsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    metricName?: boolean
    metricValue?: boolean
    timestamp?: boolean
    createdAt?: boolean
    userId?: boolean
  }, ExtArgs["result"]["systemAnalytics"]>

  export type SystemAnalyticsSelectScalar = {
    id?: boolean
    metricName?: boolean
    metricValue?: boolean
    timestamp?: boolean
    createdAt?: boolean
    userId?: boolean
  }


  export type $SystemAnalyticsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemAnalytics"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      metricName: string
      metricValue: Prisma.JsonValue
      timestamp: Date
      createdAt: Date
      userId: string | null
    }, ExtArgs["result"]["systemAnalytics"]>
    composites: {}
  }

  type SystemAnalyticsGetPayload<S extends boolean | null | undefined | SystemAnalyticsDefaultArgs> = $Result.GetResult<Prisma.$SystemAnalyticsPayload, S>

  type SystemAnalyticsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SystemAnalyticsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SystemAnalyticsCountAggregateInputType | true
    }

  export interface SystemAnalyticsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemAnalytics'], meta: { name: 'SystemAnalytics' } }
    /**
     * Find zero or one SystemAnalytics that matches the filter.
     * @param {SystemAnalyticsFindUniqueArgs} args - Arguments to find a SystemAnalytics
     * @example
     * // Get one SystemAnalytics
     * const systemAnalytics = await prisma.systemAnalytics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemAnalyticsFindUniqueArgs>(args: SelectSubset<T, SystemAnalyticsFindUniqueArgs<ExtArgs>>): Prisma__SystemAnalyticsClient<$Result.GetResult<Prisma.$SystemAnalyticsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SystemAnalytics that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SystemAnalyticsFindUniqueOrThrowArgs} args - Arguments to find a SystemAnalytics
     * @example
     * // Get one SystemAnalytics
     * const systemAnalytics = await prisma.systemAnalytics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemAnalyticsFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemAnalyticsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemAnalyticsClient<$Result.GetResult<Prisma.$SystemAnalyticsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SystemAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemAnalyticsFindFirstArgs} args - Arguments to find a SystemAnalytics
     * @example
     * // Get one SystemAnalytics
     * const systemAnalytics = await prisma.systemAnalytics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemAnalyticsFindFirstArgs>(args?: SelectSubset<T, SystemAnalyticsFindFirstArgs<ExtArgs>>): Prisma__SystemAnalyticsClient<$Result.GetResult<Prisma.$SystemAnalyticsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SystemAnalytics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemAnalyticsFindFirstOrThrowArgs} args - Arguments to find a SystemAnalytics
     * @example
     * // Get one SystemAnalytics
     * const systemAnalytics = await prisma.systemAnalytics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemAnalyticsFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemAnalyticsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemAnalyticsClient<$Result.GetResult<Prisma.$SystemAnalyticsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SystemAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemAnalyticsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemAnalytics
     * const systemAnalytics = await prisma.systemAnalytics.findMany()
     * 
     * // Get first 10 SystemAnalytics
     * const systemAnalytics = await prisma.systemAnalytics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemAnalyticsWithIdOnly = await prisma.systemAnalytics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemAnalyticsFindManyArgs>(args?: SelectSubset<T, SystemAnalyticsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemAnalyticsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SystemAnalytics.
     * @param {SystemAnalyticsCreateArgs} args - Arguments to create a SystemAnalytics.
     * @example
     * // Create one SystemAnalytics
     * const SystemAnalytics = await prisma.systemAnalytics.create({
     *   data: {
     *     // ... data to create a SystemAnalytics
     *   }
     * })
     * 
     */
    create<T extends SystemAnalyticsCreateArgs>(args: SelectSubset<T, SystemAnalyticsCreateArgs<ExtArgs>>): Prisma__SystemAnalyticsClient<$Result.GetResult<Prisma.$SystemAnalyticsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SystemAnalytics.
     * @param {SystemAnalyticsCreateManyArgs} args - Arguments to create many SystemAnalytics.
     * @example
     * // Create many SystemAnalytics
     * const systemAnalytics = await prisma.systemAnalytics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemAnalyticsCreateManyArgs>(args?: SelectSubset<T, SystemAnalyticsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemAnalytics and returns the data saved in the database.
     * @param {SystemAnalyticsCreateManyAndReturnArgs} args - Arguments to create many SystemAnalytics.
     * @example
     * // Create many SystemAnalytics
     * const systemAnalytics = await prisma.systemAnalytics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemAnalytics and only return the `id`
     * const systemAnalyticsWithIdOnly = await prisma.systemAnalytics.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemAnalyticsCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemAnalyticsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemAnalyticsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SystemAnalytics.
     * @param {SystemAnalyticsDeleteArgs} args - Arguments to delete one SystemAnalytics.
     * @example
     * // Delete one SystemAnalytics
     * const SystemAnalytics = await prisma.systemAnalytics.delete({
     *   where: {
     *     // ... filter to delete one SystemAnalytics
     *   }
     * })
     * 
     */
    delete<T extends SystemAnalyticsDeleteArgs>(args: SelectSubset<T, SystemAnalyticsDeleteArgs<ExtArgs>>): Prisma__SystemAnalyticsClient<$Result.GetResult<Prisma.$SystemAnalyticsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SystemAnalytics.
     * @param {SystemAnalyticsUpdateArgs} args - Arguments to update one SystemAnalytics.
     * @example
     * // Update one SystemAnalytics
     * const systemAnalytics = await prisma.systemAnalytics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemAnalyticsUpdateArgs>(args: SelectSubset<T, SystemAnalyticsUpdateArgs<ExtArgs>>): Prisma__SystemAnalyticsClient<$Result.GetResult<Prisma.$SystemAnalyticsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SystemAnalytics.
     * @param {SystemAnalyticsDeleteManyArgs} args - Arguments to filter SystemAnalytics to delete.
     * @example
     * // Delete a few SystemAnalytics
     * const { count } = await prisma.systemAnalytics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemAnalyticsDeleteManyArgs>(args?: SelectSubset<T, SystemAnalyticsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemAnalyticsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemAnalytics
     * const systemAnalytics = await prisma.systemAnalytics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemAnalyticsUpdateManyArgs>(args: SelectSubset<T, SystemAnalyticsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SystemAnalytics.
     * @param {SystemAnalyticsUpsertArgs} args - Arguments to update or create a SystemAnalytics.
     * @example
     * // Update or create a SystemAnalytics
     * const systemAnalytics = await prisma.systemAnalytics.upsert({
     *   create: {
     *     // ... data to create a SystemAnalytics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemAnalytics we want to update
     *   }
     * })
     */
    upsert<T extends SystemAnalyticsUpsertArgs>(args: SelectSubset<T, SystemAnalyticsUpsertArgs<ExtArgs>>): Prisma__SystemAnalyticsClient<$Result.GetResult<Prisma.$SystemAnalyticsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SystemAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemAnalyticsCountArgs} args - Arguments to filter SystemAnalytics to count.
     * @example
     * // Count the number of SystemAnalytics
     * const count = await prisma.systemAnalytics.count({
     *   where: {
     *     // ... the filter for the SystemAnalytics we want to count
     *   }
     * })
    **/
    count<T extends SystemAnalyticsCountArgs>(
      args?: Subset<T, SystemAnalyticsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemAnalyticsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemAnalyticsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemAnalyticsAggregateArgs>(args: Subset<T, SystemAnalyticsAggregateArgs>): Prisma.PrismaPromise<GetSystemAnalyticsAggregateType<T>>

    /**
     * Group by SystemAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemAnalyticsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemAnalyticsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemAnalyticsGroupByArgs['orderBy'] }
        : { orderBy?: SystemAnalyticsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemAnalyticsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemAnalyticsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemAnalytics model
   */
  readonly fields: SystemAnalyticsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemAnalytics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemAnalyticsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemAnalytics model
   */ 
  interface SystemAnalyticsFieldRefs {
    readonly id: FieldRef<"SystemAnalytics", 'String'>
    readonly metricName: FieldRef<"SystemAnalytics", 'String'>
    readonly metricValue: FieldRef<"SystemAnalytics", 'Json'>
    readonly timestamp: FieldRef<"SystemAnalytics", 'DateTime'>
    readonly createdAt: FieldRef<"SystemAnalytics", 'DateTime'>
    readonly userId: FieldRef<"SystemAnalytics", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SystemAnalytics findUnique
   */
  export type SystemAnalyticsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemAnalytics
     */
    select?: SystemAnalyticsSelect<ExtArgs> | null
    /**
     * Filter, which SystemAnalytics to fetch.
     */
    where: SystemAnalyticsWhereUniqueInput
  }

  /**
   * SystemAnalytics findUniqueOrThrow
   */
  export type SystemAnalyticsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemAnalytics
     */
    select?: SystemAnalyticsSelect<ExtArgs> | null
    /**
     * Filter, which SystemAnalytics to fetch.
     */
    where: SystemAnalyticsWhereUniqueInput
  }

  /**
   * SystemAnalytics findFirst
   */
  export type SystemAnalyticsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemAnalytics
     */
    select?: SystemAnalyticsSelect<ExtArgs> | null
    /**
     * Filter, which SystemAnalytics to fetch.
     */
    where?: SystemAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemAnalytics to fetch.
     */
    orderBy?: SystemAnalyticsOrderByWithRelationInput | SystemAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemAnalytics.
     */
    cursor?: SystemAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemAnalytics.
     */
    distinct?: SystemAnalyticsScalarFieldEnum | SystemAnalyticsScalarFieldEnum[]
  }

  /**
   * SystemAnalytics findFirstOrThrow
   */
  export type SystemAnalyticsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemAnalytics
     */
    select?: SystemAnalyticsSelect<ExtArgs> | null
    /**
     * Filter, which SystemAnalytics to fetch.
     */
    where?: SystemAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemAnalytics to fetch.
     */
    orderBy?: SystemAnalyticsOrderByWithRelationInput | SystemAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemAnalytics.
     */
    cursor?: SystemAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemAnalytics.
     */
    distinct?: SystemAnalyticsScalarFieldEnum | SystemAnalyticsScalarFieldEnum[]
  }

  /**
   * SystemAnalytics findMany
   */
  export type SystemAnalyticsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemAnalytics
     */
    select?: SystemAnalyticsSelect<ExtArgs> | null
    /**
     * Filter, which SystemAnalytics to fetch.
     */
    where?: SystemAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemAnalytics to fetch.
     */
    orderBy?: SystemAnalyticsOrderByWithRelationInput | SystemAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemAnalytics.
     */
    cursor?: SystemAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemAnalytics.
     */
    skip?: number
    distinct?: SystemAnalyticsScalarFieldEnum | SystemAnalyticsScalarFieldEnum[]
  }

  /**
   * SystemAnalytics create
   */
  export type SystemAnalyticsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemAnalytics
     */
    select?: SystemAnalyticsSelect<ExtArgs> | null
    /**
     * The data needed to create a SystemAnalytics.
     */
    data: XOR<SystemAnalyticsCreateInput, SystemAnalyticsUncheckedCreateInput>
  }

  /**
   * SystemAnalytics createMany
   */
  export type SystemAnalyticsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemAnalytics.
     */
    data: SystemAnalyticsCreateManyInput | SystemAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemAnalytics createManyAndReturn
   */
  export type SystemAnalyticsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemAnalytics
     */
    select?: SystemAnalyticsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SystemAnalytics.
     */
    data: SystemAnalyticsCreateManyInput | SystemAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemAnalytics update
   */
  export type SystemAnalyticsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemAnalytics
     */
    select?: SystemAnalyticsSelect<ExtArgs> | null
    /**
     * The data needed to update a SystemAnalytics.
     */
    data: XOR<SystemAnalyticsUpdateInput, SystemAnalyticsUncheckedUpdateInput>
    /**
     * Choose, which SystemAnalytics to update.
     */
    where: SystemAnalyticsWhereUniqueInput
  }

  /**
   * SystemAnalytics updateMany
   */
  export type SystemAnalyticsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemAnalytics.
     */
    data: XOR<SystemAnalyticsUpdateManyMutationInput, SystemAnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which SystemAnalytics to update
     */
    where?: SystemAnalyticsWhereInput
  }

  /**
   * SystemAnalytics upsert
   */
  export type SystemAnalyticsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemAnalytics
     */
    select?: SystemAnalyticsSelect<ExtArgs> | null
    /**
     * The filter to search for the SystemAnalytics to update in case it exists.
     */
    where: SystemAnalyticsWhereUniqueInput
    /**
     * In case the SystemAnalytics found by the `where` argument doesn't exist, create a new SystemAnalytics with this data.
     */
    create: XOR<SystemAnalyticsCreateInput, SystemAnalyticsUncheckedCreateInput>
    /**
     * In case the SystemAnalytics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemAnalyticsUpdateInput, SystemAnalyticsUncheckedUpdateInput>
  }

  /**
   * SystemAnalytics delete
   */
  export type SystemAnalyticsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemAnalytics
     */
    select?: SystemAnalyticsSelect<ExtArgs> | null
    /**
     * Filter which SystemAnalytics to delete.
     */
    where: SystemAnalyticsWhereUniqueInput
  }

  /**
   * SystemAnalytics deleteMany
   */
  export type SystemAnalyticsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemAnalytics to delete
     */
    where?: SystemAnalyticsWhereInput
  }

  /**
   * SystemAnalytics without action
   */
  export type SystemAnalyticsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemAnalytics
     */
    select?: SystemAnalyticsSelect<ExtArgs> | null
  }


  /**
   * Model pricingModel
   */

  export type AggregatePricingModel = {
    _count: PricingModelCountAggregateOutputType | null
    _avg: PricingModelAvgAggregateOutputType | null
    _sum: PricingModelSumAggregateOutputType | null
    _min: PricingModelMinAggregateOutputType | null
    _max: PricingModelMaxAggregateOutputType | null
  }

  export type PricingModelAvgAggregateOutputType = {
    isolationPricing: Decimal | null
    bariatricPricing: Decimal | null
    oxygenPricing: Decimal | null
    monitoringPricing: Decimal | null
  }

  export type PricingModelSumAggregateOutputType = {
    isolationPricing: Decimal | null
    bariatricPricing: Decimal | null
    oxygenPricing: Decimal | null
    monitoringPricing: Decimal | null
  }

  export type PricingModelMinAggregateOutputType = {
    id: string | null
    agencyId: string | null
    name: string | null
    isActive: boolean | null
    isolationPricing: Decimal | null
    bariatricPricing: Decimal | null
    oxygenPricing: Decimal | null
    monitoringPricing: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PricingModelMaxAggregateOutputType = {
    id: string | null
    agencyId: string | null
    name: string | null
    isActive: boolean | null
    isolationPricing: Decimal | null
    bariatricPricing: Decimal | null
    oxygenPricing: Decimal | null
    monitoringPricing: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PricingModelCountAggregateOutputType = {
    id: number
    agencyId: number
    name: number
    isActive: number
    baseRates: number
    perMileRates: number
    priorityMultipliers: number
    peakHourMultipliers: number
    weekendMultipliers: number
    seasonalMultipliers: number
    zoneMultipliers: number
    distanceTiers: number
    specialRequirements: number
    isolationPricing: number
    bariatricPricing: number
    oxygenPricing: number
    monitoringPricing: number
    insuranceRates: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PricingModelAvgAggregateInputType = {
    isolationPricing?: true
    bariatricPricing?: true
    oxygenPricing?: true
    monitoringPricing?: true
  }

  export type PricingModelSumAggregateInputType = {
    isolationPricing?: true
    bariatricPricing?: true
    oxygenPricing?: true
    monitoringPricing?: true
  }

  export type PricingModelMinAggregateInputType = {
    id?: true
    agencyId?: true
    name?: true
    isActive?: true
    isolationPricing?: true
    bariatricPricing?: true
    oxygenPricing?: true
    monitoringPricing?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PricingModelMaxAggregateInputType = {
    id?: true
    agencyId?: true
    name?: true
    isActive?: true
    isolationPricing?: true
    bariatricPricing?: true
    oxygenPricing?: true
    monitoringPricing?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PricingModelCountAggregateInputType = {
    id?: true
    agencyId?: true
    name?: true
    isActive?: true
    baseRates?: true
    perMileRates?: true
    priorityMultipliers?: true
    peakHourMultipliers?: true
    weekendMultipliers?: true
    seasonalMultipliers?: true
    zoneMultipliers?: true
    distanceTiers?: true
    specialRequirements?: true
    isolationPricing?: true
    bariatricPricing?: true
    oxygenPricing?: true
    monitoringPricing?: true
    insuranceRates?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PricingModelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pricingModel to aggregate.
     */
    where?: pricingModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pricingModels to fetch.
     */
    orderBy?: pricingModelOrderByWithRelationInput | pricingModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: pricingModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pricingModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pricingModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pricingModels
    **/
    _count?: true | PricingModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PricingModelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PricingModelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PricingModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PricingModelMaxAggregateInputType
  }

  export type GetPricingModelAggregateType<T extends PricingModelAggregateArgs> = {
        [P in keyof T & keyof AggregatePricingModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePricingModel[P]>
      : GetScalarType<T[P], AggregatePricingModel[P]>
  }




  export type pricingModelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pricingModelWhereInput
    orderBy?: pricingModelOrderByWithAggregationInput | pricingModelOrderByWithAggregationInput[]
    by: PricingModelScalarFieldEnum[] | PricingModelScalarFieldEnum
    having?: pricingModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PricingModelCountAggregateInputType | true
    _avg?: PricingModelAvgAggregateInputType
    _sum?: PricingModelSumAggregateInputType
    _min?: PricingModelMinAggregateInputType
    _max?: PricingModelMaxAggregateInputType
  }

  export type PricingModelGroupByOutputType = {
    id: string
    agencyId: string | null
    name: string
    isActive: boolean
    baseRates: JsonValue
    perMileRates: JsonValue
    priorityMultipliers: JsonValue
    peakHourMultipliers: JsonValue
    weekendMultipliers: JsonValue
    seasonalMultipliers: JsonValue
    zoneMultipliers: JsonValue
    distanceTiers: JsonValue
    specialRequirements: JsonValue
    isolationPricing: Decimal | null
    bariatricPricing: Decimal | null
    oxygenPricing: Decimal | null
    monitoringPricing: Decimal | null
    insuranceRates: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: PricingModelCountAggregateOutputType | null
    _avg: PricingModelAvgAggregateOutputType | null
    _sum: PricingModelSumAggregateOutputType | null
    _min: PricingModelMinAggregateOutputType | null
    _max: PricingModelMaxAggregateOutputType | null
  }

  type GetPricingModelGroupByPayload<T extends pricingModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PricingModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PricingModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PricingModelGroupByOutputType[P]>
            : GetScalarType<T[P], PricingModelGroupByOutputType[P]>
        }
      >
    >


  export type pricingModelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agencyId?: boolean
    name?: boolean
    isActive?: boolean
    baseRates?: boolean
    perMileRates?: boolean
    priorityMultipliers?: boolean
    peakHourMultipliers?: boolean
    weekendMultipliers?: boolean
    seasonalMultipliers?: boolean
    zoneMultipliers?: boolean
    distanceTiers?: boolean
    specialRequirements?: boolean
    isolationPricing?: boolean
    bariatricPricing?: boolean
    oxygenPricing?: boolean
    monitoringPricing?: boolean
    insuranceRates?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["pricingModel"]>

  export type pricingModelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agencyId?: boolean
    name?: boolean
    isActive?: boolean
    baseRates?: boolean
    perMileRates?: boolean
    priorityMultipliers?: boolean
    peakHourMultipliers?: boolean
    weekendMultipliers?: boolean
    seasonalMultipliers?: boolean
    zoneMultipliers?: boolean
    distanceTiers?: boolean
    specialRequirements?: boolean
    isolationPricing?: boolean
    bariatricPricing?: boolean
    oxygenPricing?: boolean
    monitoringPricing?: boolean
    insuranceRates?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["pricingModel"]>

  export type pricingModelSelectScalar = {
    id?: boolean
    agencyId?: boolean
    name?: boolean
    isActive?: boolean
    baseRates?: boolean
    perMileRates?: boolean
    priorityMultipliers?: boolean
    peakHourMultipliers?: boolean
    weekendMultipliers?: boolean
    seasonalMultipliers?: boolean
    zoneMultipliers?: boolean
    distanceTiers?: boolean
    specialRequirements?: boolean
    isolationPricing?: boolean
    bariatricPricing?: boolean
    oxygenPricing?: boolean
    monitoringPricing?: boolean
    insuranceRates?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $pricingModelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "pricingModel"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      agencyId: string | null
      name: string
      isActive: boolean
      baseRates: Prisma.JsonValue
      perMileRates: Prisma.JsonValue
      priorityMultipliers: Prisma.JsonValue
      peakHourMultipliers: Prisma.JsonValue
      weekendMultipliers: Prisma.JsonValue
      seasonalMultipliers: Prisma.JsonValue
      zoneMultipliers: Prisma.JsonValue
      distanceTiers: Prisma.JsonValue
      specialRequirements: Prisma.JsonValue
      isolationPricing: Prisma.Decimal | null
      bariatricPricing: Prisma.Decimal | null
      oxygenPricing: Prisma.Decimal | null
      monitoringPricing: Prisma.Decimal | null
      insuranceRates: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pricingModel"]>
    composites: {}
  }

  type pricingModelGetPayload<S extends boolean | null | undefined | pricingModelDefaultArgs> = $Result.GetResult<Prisma.$pricingModelPayload, S>

  type pricingModelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<pricingModelFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PricingModelCountAggregateInputType | true
    }

  export interface pricingModelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['pricingModel'], meta: { name: 'pricingModel' } }
    /**
     * Find zero or one PricingModel that matches the filter.
     * @param {pricingModelFindUniqueArgs} args - Arguments to find a PricingModel
     * @example
     * // Get one PricingModel
     * const pricingModel = await prisma.pricingModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends pricingModelFindUniqueArgs>(args: SelectSubset<T, pricingModelFindUniqueArgs<ExtArgs>>): Prisma__pricingModelClient<$Result.GetResult<Prisma.$pricingModelPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PricingModel that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {pricingModelFindUniqueOrThrowArgs} args - Arguments to find a PricingModel
     * @example
     * // Get one PricingModel
     * const pricingModel = await prisma.pricingModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends pricingModelFindUniqueOrThrowArgs>(args: SelectSubset<T, pricingModelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__pricingModelClient<$Result.GetResult<Prisma.$pricingModelPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PricingModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pricingModelFindFirstArgs} args - Arguments to find a PricingModel
     * @example
     * // Get one PricingModel
     * const pricingModel = await prisma.pricingModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends pricingModelFindFirstArgs>(args?: SelectSubset<T, pricingModelFindFirstArgs<ExtArgs>>): Prisma__pricingModelClient<$Result.GetResult<Prisma.$pricingModelPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PricingModel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pricingModelFindFirstOrThrowArgs} args - Arguments to find a PricingModel
     * @example
     * // Get one PricingModel
     * const pricingModel = await prisma.pricingModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends pricingModelFindFirstOrThrowArgs>(args?: SelectSubset<T, pricingModelFindFirstOrThrowArgs<ExtArgs>>): Prisma__pricingModelClient<$Result.GetResult<Prisma.$pricingModelPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PricingModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pricingModelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PricingModels
     * const pricingModels = await prisma.pricingModel.findMany()
     * 
     * // Get first 10 PricingModels
     * const pricingModels = await prisma.pricingModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pricingModelWithIdOnly = await prisma.pricingModel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends pricingModelFindManyArgs>(args?: SelectSubset<T, pricingModelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pricingModelPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PricingModel.
     * @param {pricingModelCreateArgs} args - Arguments to create a PricingModel.
     * @example
     * // Create one PricingModel
     * const PricingModel = await prisma.pricingModel.create({
     *   data: {
     *     // ... data to create a PricingModel
     *   }
     * })
     * 
     */
    create<T extends pricingModelCreateArgs>(args: SelectSubset<T, pricingModelCreateArgs<ExtArgs>>): Prisma__pricingModelClient<$Result.GetResult<Prisma.$pricingModelPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PricingModels.
     * @param {pricingModelCreateManyArgs} args - Arguments to create many PricingModels.
     * @example
     * // Create many PricingModels
     * const pricingModel = await prisma.pricingModel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends pricingModelCreateManyArgs>(args?: SelectSubset<T, pricingModelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PricingModels and returns the data saved in the database.
     * @param {pricingModelCreateManyAndReturnArgs} args - Arguments to create many PricingModels.
     * @example
     * // Create many PricingModels
     * const pricingModel = await prisma.pricingModel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PricingModels and only return the `id`
     * const pricingModelWithIdOnly = await prisma.pricingModel.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends pricingModelCreateManyAndReturnArgs>(args?: SelectSubset<T, pricingModelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pricingModelPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PricingModel.
     * @param {pricingModelDeleteArgs} args - Arguments to delete one PricingModel.
     * @example
     * // Delete one PricingModel
     * const PricingModel = await prisma.pricingModel.delete({
     *   where: {
     *     // ... filter to delete one PricingModel
     *   }
     * })
     * 
     */
    delete<T extends pricingModelDeleteArgs>(args: SelectSubset<T, pricingModelDeleteArgs<ExtArgs>>): Prisma__pricingModelClient<$Result.GetResult<Prisma.$pricingModelPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PricingModel.
     * @param {pricingModelUpdateArgs} args - Arguments to update one PricingModel.
     * @example
     * // Update one PricingModel
     * const pricingModel = await prisma.pricingModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends pricingModelUpdateArgs>(args: SelectSubset<T, pricingModelUpdateArgs<ExtArgs>>): Prisma__pricingModelClient<$Result.GetResult<Prisma.$pricingModelPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PricingModels.
     * @param {pricingModelDeleteManyArgs} args - Arguments to filter PricingModels to delete.
     * @example
     * // Delete a few PricingModels
     * const { count } = await prisma.pricingModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends pricingModelDeleteManyArgs>(args?: SelectSubset<T, pricingModelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PricingModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pricingModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PricingModels
     * const pricingModel = await prisma.pricingModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends pricingModelUpdateManyArgs>(args: SelectSubset<T, pricingModelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PricingModel.
     * @param {pricingModelUpsertArgs} args - Arguments to update or create a PricingModel.
     * @example
     * // Update or create a PricingModel
     * const pricingModel = await prisma.pricingModel.upsert({
     *   create: {
     *     // ... data to create a PricingModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PricingModel we want to update
     *   }
     * })
     */
    upsert<T extends pricingModelUpsertArgs>(args: SelectSubset<T, pricingModelUpsertArgs<ExtArgs>>): Prisma__pricingModelClient<$Result.GetResult<Prisma.$pricingModelPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PricingModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pricingModelCountArgs} args - Arguments to filter PricingModels to count.
     * @example
     * // Count the number of PricingModels
     * const count = await prisma.pricingModel.count({
     *   where: {
     *     // ... the filter for the PricingModels we want to count
     *   }
     * })
    **/
    count<T extends pricingModelCountArgs>(
      args?: Subset<T, pricingModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PricingModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PricingModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricingModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PricingModelAggregateArgs>(args: Subset<T, PricingModelAggregateArgs>): Prisma.PrismaPromise<GetPricingModelAggregateType<T>>

    /**
     * Group by PricingModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pricingModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends pricingModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: pricingModelGroupByArgs['orderBy'] }
        : { orderBy?: pricingModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, pricingModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPricingModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the pricingModel model
   */
  readonly fields: pricingModelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for pricingModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__pricingModelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the pricingModel model
   */ 
  interface pricingModelFieldRefs {
    readonly id: FieldRef<"pricingModel", 'String'>
    readonly agencyId: FieldRef<"pricingModel", 'String'>
    readonly name: FieldRef<"pricingModel", 'String'>
    readonly isActive: FieldRef<"pricingModel", 'Boolean'>
    readonly baseRates: FieldRef<"pricingModel", 'Json'>
    readonly perMileRates: FieldRef<"pricingModel", 'Json'>
    readonly priorityMultipliers: FieldRef<"pricingModel", 'Json'>
    readonly peakHourMultipliers: FieldRef<"pricingModel", 'Json'>
    readonly weekendMultipliers: FieldRef<"pricingModel", 'Json'>
    readonly seasonalMultipliers: FieldRef<"pricingModel", 'Json'>
    readonly zoneMultipliers: FieldRef<"pricingModel", 'Json'>
    readonly distanceTiers: FieldRef<"pricingModel", 'Json'>
    readonly specialRequirements: FieldRef<"pricingModel", 'Json'>
    readonly isolationPricing: FieldRef<"pricingModel", 'Decimal'>
    readonly bariatricPricing: FieldRef<"pricingModel", 'Decimal'>
    readonly oxygenPricing: FieldRef<"pricingModel", 'Decimal'>
    readonly monitoringPricing: FieldRef<"pricingModel", 'Decimal'>
    readonly insuranceRates: FieldRef<"pricingModel", 'Json'>
    readonly createdAt: FieldRef<"pricingModel", 'DateTime'>
    readonly updatedAt: FieldRef<"pricingModel", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * pricingModel findUnique
   */
  export type pricingModelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pricingModel
     */
    select?: pricingModelSelect<ExtArgs> | null
    /**
     * Filter, which pricingModel to fetch.
     */
    where: pricingModelWhereUniqueInput
  }

  /**
   * pricingModel findUniqueOrThrow
   */
  export type pricingModelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pricingModel
     */
    select?: pricingModelSelect<ExtArgs> | null
    /**
     * Filter, which pricingModel to fetch.
     */
    where: pricingModelWhereUniqueInput
  }

  /**
   * pricingModel findFirst
   */
  export type pricingModelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pricingModel
     */
    select?: pricingModelSelect<ExtArgs> | null
    /**
     * Filter, which pricingModel to fetch.
     */
    where?: pricingModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pricingModels to fetch.
     */
    orderBy?: pricingModelOrderByWithRelationInput | pricingModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pricingModels.
     */
    cursor?: pricingModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pricingModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pricingModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pricingModels.
     */
    distinct?: PricingModelScalarFieldEnum | PricingModelScalarFieldEnum[]
  }

  /**
   * pricingModel findFirstOrThrow
   */
  export type pricingModelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pricingModel
     */
    select?: pricingModelSelect<ExtArgs> | null
    /**
     * Filter, which pricingModel to fetch.
     */
    where?: pricingModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pricingModels to fetch.
     */
    orderBy?: pricingModelOrderByWithRelationInput | pricingModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pricingModels.
     */
    cursor?: pricingModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pricingModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pricingModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pricingModels.
     */
    distinct?: PricingModelScalarFieldEnum | PricingModelScalarFieldEnum[]
  }

  /**
   * pricingModel findMany
   */
  export type pricingModelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pricingModel
     */
    select?: pricingModelSelect<ExtArgs> | null
    /**
     * Filter, which pricingModels to fetch.
     */
    where?: pricingModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pricingModels to fetch.
     */
    orderBy?: pricingModelOrderByWithRelationInput | pricingModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pricingModels.
     */
    cursor?: pricingModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pricingModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pricingModels.
     */
    skip?: number
    distinct?: PricingModelScalarFieldEnum | PricingModelScalarFieldEnum[]
  }

  /**
   * pricingModel create
   */
  export type pricingModelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pricingModel
     */
    select?: pricingModelSelect<ExtArgs> | null
    /**
     * The data needed to create a pricingModel.
     */
    data: XOR<pricingModelCreateInput, pricingModelUncheckedCreateInput>
  }

  /**
   * pricingModel createMany
   */
  export type pricingModelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many pricingModels.
     */
    data: pricingModelCreateManyInput | pricingModelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pricingModel createManyAndReturn
   */
  export type pricingModelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pricingModel
     */
    select?: pricingModelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many pricingModels.
     */
    data: pricingModelCreateManyInput | pricingModelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pricingModel update
   */
  export type pricingModelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pricingModel
     */
    select?: pricingModelSelect<ExtArgs> | null
    /**
     * The data needed to update a pricingModel.
     */
    data: XOR<pricingModelUpdateInput, pricingModelUncheckedUpdateInput>
    /**
     * Choose, which pricingModel to update.
     */
    where: pricingModelWhereUniqueInput
  }

  /**
   * pricingModel updateMany
   */
  export type pricingModelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update pricingModels.
     */
    data: XOR<pricingModelUpdateManyMutationInput, pricingModelUncheckedUpdateManyInput>
    /**
     * Filter which pricingModels to update
     */
    where?: pricingModelWhereInput
  }

  /**
   * pricingModel upsert
   */
  export type pricingModelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pricingModel
     */
    select?: pricingModelSelect<ExtArgs> | null
    /**
     * The filter to search for the pricingModel to update in case it exists.
     */
    where: pricingModelWhereUniqueInput
    /**
     * In case the pricingModel found by the `where` argument doesn't exist, create a new pricingModel with this data.
     */
    create: XOR<pricingModelCreateInput, pricingModelUncheckedCreateInput>
    /**
     * In case the pricingModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pricingModelUpdateInput, pricingModelUncheckedUpdateInput>
  }

  /**
   * pricingModel delete
   */
  export type pricingModelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pricingModel
     */
    select?: pricingModelSelect<ExtArgs> | null
    /**
     * Filter which pricingModel to delete.
     */
    where: pricingModelWhereUniqueInput
  }

  /**
   * pricingModel deleteMany
   */
  export type pricingModelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pricingModels to delete
     */
    where?: pricingModelWhereInput
  }

  /**
   * pricingModel without action
   */
  export type pricingModelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pricingModel
     */
    select?: pricingModelSelect<ExtArgs> | null
  }


  /**
   * Model BackhaulOpportunities
   */

  export type AggregateBackhaulOpportunities = {
    _count: BackhaulOpportunitiesCountAggregateOutputType | null
    _avg: BackhaulOpportunitiesAvgAggregateOutputType | null
    _sum: BackhaulOpportunitiesSumAggregateOutputType | null
    _min: BackhaulOpportunitiesMinAggregateOutputType | null
    _max: BackhaulOpportunitiesMaxAggregateOutputType | null
  }

  export type BackhaulOpportunitiesAvgAggregateOutputType = {
    revenueBonus: Decimal | null
    efficiency: Decimal | null
  }

  export type BackhaulOpportunitiesSumAggregateOutputType = {
    revenueBonus: Decimal | null
    efficiency: Decimal | null
  }

  export type BackhaulOpportunitiesMinAggregateOutputType = {
    id: string | null
    tripId1: string | null
    tripId2: string | null
    revenueBonus: Decimal | null
    efficiency: Decimal | null
    createdAt: Date | null
    isActive: boolean | null
  }

  export type BackhaulOpportunitiesMaxAggregateOutputType = {
    id: string | null
    tripId1: string | null
    tripId2: string | null
    revenueBonus: Decimal | null
    efficiency: Decimal | null
    createdAt: Date | null
    isActive: boolean | null
  }

  export type BackhaulOpportunitiesCountAggregateOutputType = {
    id: number
    tripId1: number
    tripId2: number
    revenueBonus: number
    efficiency: number
    createdAt: number
    isActive: number
    _all: number
  }


  export type BackhaulOpportunitiesAvgAggregateInputType = {
    revenueBonus?: true
    efficiency?: true
  }

  export type BackhaulOpportunitiesSumAggregateInputType = {
    revenueBonus?: true
    efficiency?: true
  }

  export type BackhaulOpportunitiesMinAggregateInputType = {
    id?: true
    tripId1?: true
    tripId2?: true
    revenueBonus?: true
    efficiency?: true
    createdAt?: true
    isActive?: true
  }

  export type BackhaulOpportunitiesMaxAggregateInputType = {
    id?: true
    tripId1?: true
    tripId2?: true
    revenueBonus?: true
    efficiency?: true
    createdAt?: true
    isActive?: true
  }

  export type BackhaulOpportunitiesCountAggregateInputType = {
    id?: true
    tripId1?: true
    tripId2?: true
    revenueBonus?: true
    efficiency?: true
    createdAt?: true
    isActive?: true
    _all?: true
  }

  export type BackhaulOpportunitiesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BackhaulOpportunities to aggregate.
     */
    where?: BackhaulOpportunitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BackhaulOpportunities to fetch.
     */
    orderBy?: BackhaulOpportunitiesOrderByWithRelationInput | BackhaulOpportunitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BackhaulOpportunitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BackhaulOpportunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BackhaulOpportunities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BackhaulOpportunities
    **/
    _count?: true | BackhaulOpportunitiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BackhaulOpportunitiesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BackhaulOpportunitiesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BackhaulOpportunitiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BackhaulOpportunitiesMaxAggregateInputType
  }

  export type GetBackhaulOpportunitiesAggregateType<T extends BackhaulOpportunitiesAggregateArgs> = {
        [P in keyof T & keyof AggregateBackhaulOpportunities]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBackhaulOpportunities[P]>
      : GetScalarType<T[P], AggregateBackhaulOpportunities[P]>
  }




  export type BackhaulOpportunitiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BackhaulOpportunitiesWhereInput
    orderBy?: BackhaulOpportunitiesOrderByWithAggregationInput | BackhaulOpportunitiesOrderByWithAggregationInput[]
    by: BackhaulOpportunitiesScalarFieldEnum[] | BackhaulOpportunitiesScalarFieldEnum
    having?: BackhaulOpportunitiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BackhaulOpportunitiesCountAggregateInputType | true
    _avg?: BackhaulOpportunitiesAvgAggregateInputType
    _sum?: BackhaulOpportunitiesSumAggregateInputType
    _min?: BackhaulOpportunitiesMinAggregateInputType
    _max?: BackhaulOpportunitiesMaxAggregateInputType
  }

  export type BackhaulOpportunitiesGroupByOutputType = {
    id: string
    tripId1: string
    tripId2: string
    revenueBonus: Decimal | null
    efficiency: Decimal | null
    createdAt: Date
    isActive: boolean
    _count: BackhaulOpportunitiesCountAggregateOutputType | null
    _avg: BackhaulOpportunitiesAvgAggregateOutputType | null
    _sum: BackhaulOpportunitiesSumAggregateOutputType | null
    _min: BackhaulOpportunitiesMinAggregateOutputType | null
    _max: BackhaulOpportunitiesMaxAggregateOutputType | null
  }

  type GetBackhaulOpportunitiesGroupByPayload<T extends BackhaulOpportunitiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BackhaulOpportunitiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BackhaulOpportunitiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BackhaulOpportunitiesGroupByOutputType[P]>
            : GetScalarType<T[P], BackhaulOpportunitiesGroupByOutputType[P]>
        }
      >
    >


  export type BackhaulOpportunitiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tripId1?: boolean
    tripId2?: boolean
    revenueBonus?: boolean
    efficiency?: boolean
    createdAt?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["backhaulOpportunities"]>

  export type BackhaulOpportunitiesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tripId1?: boolean
    tripId2?: boolean
    revenueBonus?: boolean
    efficiency?: boolean
    createdAt?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["backhaulOpportunities"]>

  export type BackhaulOpportunitiesSelectScalar = {
    id?: boolean
    tripId1?: boolean
    tripId2?: boolean
    revenueBonus?: boolean
    efficiency?: boolean
    createdAt?: boolean
    isActive?: boolean
  }


  export type $BackhaulOpportunitiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BackhaulOpportunities"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tripId1: string
      tripId2: string
      revenueBonus: Prisma.Decimal | null
      efficiency: Prisma.Decimal | null
      createdAt: Date
      isActive: boolean
    }, ExtArgs["result"]["backhaulOpportunities"]>
    composites: {}
  }

  type BackhaulOpportunitiesGetPayload<S extends boolean | null | undefined | BackhaulOpportunitiesDefaultArgs> = $Result.GetResult<Prisma.$BackhaulOpportunitiesPayload, S>

  type BackhaulOpportunitiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BackhaulOpportunitiesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BackhaulOpportunitiesCountAggregateInputType | true
    }

  export interface BackhaulOpportunitiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BackhaulOpportunities'], meta: { name: 'BackhaulOpportunities' } }
    /**
     * Find zero or one BackhaulOpportunities that matches the filter.
     * @param {BackhaulOpportunitiesFindUniqueArgs} args - Arguments to find a BackhaulOpportunities
     * @example
     * // Get one BackhaulOpportunities
     * const backhaulOpportunities = await prisma.backhaulOpportunities.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BackhaulOpportunitiesFindUniqueArgs>(args: SelectSubset<T, BackhaulOpportunitiesFindUniqueArgs<ExtArgs>>): Prisma__BackhaulOpportunitiesClient<$Result.GetResult<Prisma.$BackhaulOpportunitiesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BackhaulOpportunities that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BackhaulOpportunitiesFindUniqueOrThrowArgs} args - Arguments to find a BackhaulOpportunities
     * @example
     * // Get one BackhaulOpportunities
     * const backhaulOpportunities = await prisma.backhaulOpportunities.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BackhaulOpportunitiesFindUniqueOrThrowArgs>(args: SelectSubset<T, BackhaulOpportunitiesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BackhaulOpportunitiesClient<$Result.GetResult<Prisma.$BackhaulOpportunitiesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BackhaulOpportunities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackhaulOpportunitiesFindFirstArgs} args - Arguments to find a BackhaulOpportunities
     * @example
     * // Get one BackhaulOpportunities
     * const backhaulOpportunities = await prisma.backhaulOpportunities.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BackhaulOpportunitiesFindFirstArgs>(args?: SelectSubset<T, BackhaulOpportunitiesFindFirstArgs<ExtArgs>>): Prisma__BackhaulOpportunitiesClient<$Result.GetResult<Prisma.$BackhaulOpportunitiesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BackhaulOpportunities that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackhaulOpportunitiesFindFirstOrThrowArgs} args - Arguments to find a BackhaulOpportunities
     * @example
     * // Get one BackhaulOpportunities
     * const backhaulOpportunities = await prisma.backhaulOpportunities.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BackhaulOpportunitiesFindFirstOrThrowArgs>(args?: SelectSubset<T, BackhaulOpportunitiesFindFirstOrThrowArgs<ExtArgs>>): Prisma__BackhaulOpportunitiesClient<$Result.GetResult<Prisma.$BackhaulOpportunitiesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BackhaulOpportunities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackhaulOpportunitiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BackhaulOpportunities
     * const backhaulOpportunities = await prisma.backhaulOpportunities.findMany()
     * 
     * // Get first 10 BackhaulOpportunities
     * const backhaulOpportunities = await prisma.backhaulOpportunities.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const backhaulOpportunitiesWithIdOnly = await prisma.backhaulOpportunities.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BackhaulOpportunitiesFindManyArgs>(args?: SelectSubset<T, BackhaulOpportunitiesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BackhaulOpportunitiesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BackhaulOpportunities.
     * @param {BackhaulOpportunitiesCreateArgs} args - Arguments to create a BackhaulOpportunities.
     * @example
     * // Create one BackhaulOpportunities
     * const BackhaulOpportunities = await prisma.backhaulOpportunities.create({
     *   data: {
     *     // ... data to create a BackhaulOpportunities
     *   }
     * })
     * 
     */
    create<T extends BackhaulOpportunitiesCreateArgs>(args: SelectSubset<T, BackhaulOpportunitiesCreateArgs<ExtArgs>>): Prisma__BackhaulOpportunitiesClient<$Result.GetResult<Prisma.$BackhaulOpportunitiesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BackhaulOpportunities.
     * @param {BackhaulOpportunitiesCreateManyArgs} args - Arguments to create many BackhaulOpportunities.
     * @example
     * // Create many BackhaulOpportunities
     * const backhaulOpportunities = await prisma.backhaulOpportunities.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BackhaulOpportunitiesCreateManyArgs>(args?: SelectSubset<T, BackhaulOpportunitiesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BackhaulOpportunities and returns the data saved in the database.
     * @param {BackhaulOpportunitiesCreateManyAndReturnArgs} args - Arguments to create many BackhaulOpportunities.
     * @example
     * // Create many BackhaulOpportunities
     * const backhaulOpportunities = await prisma.backhaulOpportunities.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BackhaulOpportunities and only return the `id`
     * const backhaulOpportunitiesWithIdOnly = await prisma.backhaulOpportunities.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BackhaulOpportunitiesCreateManyAndReturnArgs>(args?: SelectSubset<T, BackhaulOpportunitiesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BackhaulOpportunitiesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BackhaulOpportunities.
     * @param {BackhaulOpportunitiesDeleteArgs} args - Arguments to delete one BackhaulOpportunities.
     * @example
     * // Delete one BackhaulOpportunities
     * const BackhaulOpportunities = await prisma.backhaulOpportunities.delete({
     *   where: {
     *     // ... filter to delete one BackhaulOpportunities
     *   }
     * })
     * 
     */
    delete<T extends BackhaulOpportunitiesDeleteArgs>(args: SelectSubset<T, BackhaulOpportunitiesDeleteArgs<ExtArgs>>): Prisma__BackhaulOpportunitiesClient<$Result.GetResult<Prisma.$BackhaulOpportunitiesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BackhaulOpportunities.
     * @param {BackhaulOpportunitiesUpdateArgs} args - Arguments to update one BackhaulOpportunities.
     * @example
     * // Update one BackhaulOpportunities
     * const backhaulOpportunities = await prisma.backhaulOpportunities.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BackhaulOpportunitiesUpdateArgs>(args: SelectSubset<T, BackhaulOpportunitiesUpdateArgs<ExtArgs>>): Prisma__BackhaulOpportunitiesClient<$Result.GetResult<Prisma.$BackhaulOpportunitiesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BackhaulOpportunities.
     * @param {BackhaulOpportunitiesDeleteManyArgs} args - Arguments to filter BackhaulOpportunities to delete.
     * @example
     * // Delete a few BackhaulOpportunities
     * const { count } = await prisma.backhaulOpportunities.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BackhaulOpportunitiesDeleteManyArgs>(args?: SelectSubset<T, BackhaulOpportunitiesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BackhaulOpportunities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackhaulOpportunitiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BackhaulOpportunities
     * const backhaulOpportunities = await prisma.backhaulOpportunities.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BackhaulOpportunitiesUpdateManyArgs>(args: SelectSubset<T, BackhaulOpportunitiesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BackhaulOpportunities.
     * @param {BackhaulOpportunitiesUpsertArgs} args - Arguments to update or create a BackhaulOpportunities.
     * @example
     * // Update or create a BackhaulOpportunities
     * const backhaulOpportunities = await prisma.backhaulOpportunities.upsert({
     *   create: {
     *     // ... data to create a BackhaulOpportunities
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BackhaulOpportunities we want to update
     *   }
     * })
     */
    upsert<T extends BackhaulOpportunitiesUpsertArgs>(args: SelectSubset<T, BackhaulOpportunitiesUpsertArgs<ExtArgs>>): Prisma__BackhaulOpportunitiesClient<$Result.GetResult<Prisma.$BackhaulOpportunitiesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BackhaulOpportunities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackhaulOpportunitiesCountArgs} args - Arguments to filter BackhaulOpportunities to count.
     * @example
     * // Count the number of BackhaulOpportunities
     * const count = await prisma.backhaulOpportunities.count({
     *   where: {
     *     // ... the filter for the BackhaulOpportunities we want to count
     *   }
     * })
    **/
    count<T extends BackhaulOpportunitiesCountArgs>(
      args?: Subset<T, BackhaulOpportunitiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BackhaulOpportunitiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BackhaulOpportunities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackhaulOpportunitiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BackhaulOpportunitiesAggregateArgs>(args: Subset<T, BackhaulOpportunitiesAggregateArgs>): Prisma.PrismaPromise<GetBackhaulOpportunitiesAggregateType<T>>

    /**
     * Group by BackhaulOpportunities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackhaulOpportunitiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BackhaulOpportunitiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BackhaulOpportunitiesGroupByArgs['orderBy'] }
        : { orderBy?: BackhaulOpportunitiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BackhaulOpportunitiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBackhaulOpportunitiesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BackhaulOpportunities model
   */
  readonly fields: BackhaulOpportunitiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BackhaulOpportunities.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BackhaulOpportunitiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BackhaulOpportunities model
   */ 
  interface BackhaulOpportunitiesFieldRefs {
    readonly id: FieldRef<"BackhaulOpportunities", 'String'>
    readonly tripId1: FieldRef<"BackhaulOpportunities", 'String'>
    readonly tripId2: FieldRef<"BackhaulOpportunities", 'String'>
    readonly revenueBonus: FieldRef<"BackhaulOpportunities", 'Decimal'>
    readonly efficiency: FieldRef<"BackhaulOpportunities", 'Decimal'>
    readonly createdAt: FieldRef<"BackhaulOpportunities", 'DateTime'>
    readonly isActive: FieldRef<"BackhaulOpportunities", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * BackhaulOpportunities findUnique
   */
  export type BackhaulOpportunitiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackhaulOpportunities
     */
    select?: BackhaulOpportunitiesSelect<ExtArgs> | null
    /**
     * Filter, which BackhaulOpportunities to fetch.
     */
    where: BackhaulOpportunitiesWhereUniqueInput
  }

  /**
   * BackhaulOpportunities findUniqueOrThrow
   */
  export type BackhaulOpportunitiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackhaulOpportunities
     */
    select?: BackhaulOpportunitiesSelect<ExtArgs> | null
    /**
     * Filter, which BackhaulOpportunities to fetch.
     */
    where: BackhaulOpportunitiesWhereUniqueInput
  }

  /**
   * BackhaulOpportunities findFirst
   */
  export type BackhaulOpportunitiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackhaulOpportunities
     */
    select?: BackhaulOpportunitiesSelect<ExtArgs> | null
    /**
     * Filter, which BackhaulOpportunities to fetch.
     */
    where?: BackhaulOpportunitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BackhaulOpportunities to fetch.
     */
    orderBy?: BackhaulOpportunitiesOrderByWithRelationInput | BackhaulOpportunitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BackhaulOpportunities.
     */
    cursor?: BackhaulOpportunitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BackhaulOpportunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BackhaulOpportunities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BackhaulOpportunities.
     */
    distinct?: BackhaulOpportunitiesScalarFieldEnum | BackhaulOpportunitiesScalarFieldEnum[]
  }

  /**
   * BackhaulOpportunities findFirstOrThrow
   */
  export type BackhaulOpportunitiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackhaulOpportunities
     */
    select?: BackhaulOpportunitiesSelect<ExtArgs> | null
    /**
     * Filter, which BackhaulOpportunities to fetch.
     */
    where?: BackhaulOpportunitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BackhaulOpportunities to fetch.
     */
    orderBy?: BackhaulOpportunitiesOrderByWithRelationInput | BackhaulOpportunitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BackhaulOpportunities.
     */
    cursor?: BackhaulOpportunitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BackhaulOpportunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BackhaulOpportunities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BackhaulOpportunities.
     */
    distinct?: BackhaulOpportunitiesScalarFieldEnum | BackhaulOpportunitiesScalarFieldEnum[]
  }

  /**
   * BackhaulOpportunities findMany
   */
  export type BackhaulOpportunitiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackhaulOpportunities
     */
    select?: BackhaulOpportunitiesSelect<ExtArgs> | null
    /**
     * Filter, which BackhaulOpportunities to fetch.
     */
    where?: BackhaulOpportunitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BackhaulOpportunities to fetch.
     */
    orderBy?: BackhaulOpportunitiesOrderByWithRelationInput | BackhaulOpportunitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BackhaulOpportunities.
     */
    cursor?: BackhaulOpportunitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BackhaulOpportunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BackhaulOpportunities.
     */
    skip?: number
    distinct?: BackhaulOpportunitiesScalarFieldEnum | BackhaulOpportunitiesScalarFieldEnum[]
  }

  /**
   * BackhaulOpportunities create
   */
  export type BackhaulOpportunitiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackhaulOpportunities
     */
    select?: BackhaulOpportunitiesSelect<ExtArgs> | null
    /**
     * The data needed to create a BackhaulOpportunities.
     */
    data: XOR<BackhaulOpportunitiesCreateInput, BackhaulOpportunitiesUncheckedCreateInput>
  }

  /**
   * BackhaulOpportunities createMany
   */
  export type BackhaulOpportunitiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BackhaulOpportunities.
     */
    data: BackhaulOpportunitiesCreateManyInput | BackhaulOpportunitiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BackhaulOpportunities createManyAndReturn
   */
  export type BackhaulOpportunitiesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackhaulOpportunities
     */
    select?: BackhaulOpportunitiesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BackhaulOpportunities.
     */
    data: BackhaulOpportunitiesCreateManyInput | BackhaulOpportunitiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BackhaulOpportunities update
   */
  export type BackhaulOpportunitiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackhaulOpportunities
     */
    select?: BackhaulOpportunitiesSelect<ExtArgs> | null
    /**
     * The data needed to update a BackhaulOpportunities.
     */
    data: XOR<BackhaulOpportunitiesUpdateInput, BackhaulOpportunitiesUncheckedUpdateInput>
    /**
     * Choose, which BackhaulOpportunities to update.
     */
    where: BackhaulOpportunitiesWhereUniqueInput
  }

  /**
   * BackhaulOpportunities updateMany
   */
  export type BackhaulOpportunitiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BackhaulOpportunities.
     */
    data: XOR<BackhaulOpportunitiesUpdateManyMutationInput, BackhaulOpportunitiesUncheckedUpdateManyInput>
    /**
     * Filter which BackhaulOpportunities to update
     */
    where?: BackhaulOpportunitiesWhereInput
  }

  /**
   * BackhaulOpportunities upsert
   */
  export type BackhaulOpportunitiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackhaulOpportunities
     */
    select?: BackhaulOpportunitiesSelect<ExtArgs> | null
    /**
     * The filter to search for the BackhaulOpportunities to update in case it exists.
     */
    where: BackhaulOpportunitiesWhereUniqueInput
    /**
     * In case the BackhaulOpportunities found by the `where` argument doesn't exist, create a new BackhaulOpportunities with this data.
     */
    create: XOR<BackhaulOpportunitiesCreateInput, BackhaulOpportunitiesUncheckedCreateInput>
    /**
     * In case the BackhaulOpportunities was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BackhaulOpportunitiesUpdateInput, BackhaulOpportunitiesUncheckedUpdateInput>
  }

  /**
   * BackhaulOpportunities delete
   */
  export type BackhaulOpportunitiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackhaulOpportunities
     */
    select?: BackhaulOpportunitiesSelect<ExtArgs> | null
    /**
     * Filter which BackhaulOpportunities to delete.
     */
    where: BackhaulOpportunitiesWhereUniqueInput
  }

  /**
   * BackhaulOpportunities deleteMany
   */
  export type BackhaulOpportunitiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BackhaulOpportunities to delete
     */
    where?: BackhaulOpportunitiesWhereInput
  }

  /**
   * BackhaulOpportunities without action
   */
  export type BackhaulOpportunitiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackhaulOpportunities
     */
    select?: BackhaulOpportunitiesSelect<ExtArgs> | null
  }


  /**
   * Model UnitAnalytics
   */

  export type AggregateUnitAnalytics = {
    _count: UnitAnalyticsCountAggregateOutputType | null
    _avg: UnitAnalyticsAvgAggregateOutputType | null
    _sum: UnitAnalyticsSumAggregateOutputType | null
    _min: UnitAnalyticsMinAggregateOutputType | null
    _max: UnitAnalyticsMaxAggregateOutputType | null
  }

  export type UnitAnalyticsAvgAggregateOutputType = {
    performanceScore: Decimal | null
    efficiency: Decimal | null
    totalTrips: number | null
    averageResponseTime: Decimal | null
  }

  export type UnitAnalyticsSumAggregateOutputType = {
    performanceScore: Decimal | null
    efficiency: Decimal | null
    totalTrips: number | null
    averageResponseTime: Decimal | null
  }

  export type UnitAnalyticsMinAggregateOutputType = {
    id: string | null
    unitId: string | null
    performanceScore: Decimal | null
    efficiency: Decimal | null
    totalTrips: number | null
    averageResponseTime: Decimal | null
    lastUpdated: Date | null
  }

  export type UnitAnalyticsMaxAggregateOutputType = {
    id: string | null
    unitId: string | null
    performanceScore: Decimal | null
    efficiency: Decimal | null
    totalTrips: number | null
    averageResponseTime: Decimal | null
    lastUpdated: Date | null
  }

  export type UnitAnalyticsCountAggregateOutputType = {
    id: number
    unitId: number
    performanceScore: number
    efficiency: number
    totalTrips: number
    averageResponseTime: number
    lastUpdated: number
    _all: number
  }


  export type UnitAnalyticsAvgAggregateInputType = {
    performanceScore?: true
    efficiency?: true
    totalTrips?: true
    averageResponseTime?: true
  }

  export type UnitAnalyticsSumAggregateInputType = {
    performanceScore?: true
    efficiency?: true
    totalTrips?: true
    averageResponseTime?: true
  }

  export type UnitAnalyticsMinAggregateInputType = {
    id?: true
    unitId?: true
    performanceScore?: true
    efficiency?: true
    totalTrips?: true
    averageResponseTime?: true
    lastUpdated?: true
  }

  export type UnitAnalyticsMaxAggregateInputType = {
    id?: true
    unitId?: true
    performanceScore?: true
    efficiency?: true
    totalTrips?: true
    averageResponseTime?: true
    lastUpdated?: true
  }

  export type UnitAnalyticsCountAggregateInputType = {
    id?: true
    unitId?: true
    performanceScore?: true
    efficiency?: true
    totalTrips?: true
    averageResponseTime?: true
    lastUpdated?: true
    _all?: true
  }

  export type UnitAnalyticsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnitAnalytics to aggregate.
     */
    where?: UnitAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitAnalytics to fetch.
     */
    orderBy?: UnitAnalyticsOrderByWithRelationInput | UnitAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnitAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UnitAnalytics
    **/
    _count?: true | UnitAnalyticsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UnitAnalyticsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UnitAnalyticsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnitAnalyticsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnitAnalyticsMaxAggregateInputType
  }

  export type GetUnitAnalyticsAggregateType<T extends UnitAnalyticsAggregateArgs> = {
        [P in keyof T & keyof AggregateUnitAnalytics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnitAnalytics[P]>
      : GetScalarType<T[P], AggregateUnitAnalytics[P]>
  }




  export type UnitAnalyticsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitAnalyticsWhereInput
    orderBy?: UnitAnalyticsOrderByWithAggregationInput | UnitAnalyticsOrderByWithAggregationInput[]
    by: UnitAnalyticsScalarFieldEnum[] | UnitAnalyticsScalarFieldEnum
    having?: UnitAnalyticsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnitAnalyticsCountAggregateInputType | true
    _avg?: UnitAnalyticsAvgAggregateInputType
    _sum?: UnitAnalyticsSumAggregateInputType
    _min?: UnitAnalyticsMinAggregateInputType
    _max?: UnitAnalyticsMaxAggregateInputType
  }

  export type UnitAnalyticsGroupByOutputType = {
    id: string
    unitId: string
    performanceScore: Decimal | null
    efficiency: Decimal | null
    totalTrips: number
    averageResponseTime: Decimal | null
    lastUpdated: Date
    _count: UnitAnalyticsCountAggregateOutputType | null
    _avg: UnitAnalyticsAvgAggregateOutputType | null
    _sum: UnitAnalyticsSumAggregateOutputType | null
    _min: UnitAnalyticsMinAggregateOutputType | null
    _max: UnitAnalyticsMaxAggregateOutputType | null
  }

  type GetUnitAnalyticsGroupByPayload<T extends UnitAnalyticsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnitAnalyticsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnitAnalyticsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnitAnalyticsGroupByOutputType[P]>
            : GetScalarType<T[P], UnitAnalyticsGroupByOutputType[P]>
        }
      >
    >


  export type UnitAnalyticsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitId?: boolean
    performanceScore?: boolean
    efficiency?: boolean
    totalTrips?: boolean
    averageResponseTime?: boolean
    lastUpdated?: boolean
  }, ExtArgs["result"]["unitAnalytics"]>

  export type UnitAnalyticsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitId?: boolean
    performanceScore?: boolean
    efficiency?: boolean
    totalTrips?: boolean
    averageResponseTime?: boolean
    lastUpdated?: boolean
  }, ExtArgs["result"]["unitAnalytics"]>

  export type UnitAnalyticsSelectScalar = {
    id?: boolean
    unitId?: boolean
    performanceScore?: boolean
    efficiency?: boolean
    totalTrips?: boolean
    averageResponseTime?: boolean
    lastUpdated?: boolean
  }


  export type $UnitAnalyticsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UnitAnalytics"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      unitId: string
      performanceScore: Prisma.Decimal | null
      efficiency: Prisma.Decimal | null
      totalTrips: number
      averageResponseTime: Prisma.Decimal | null
      lastUpdated: Date
    }, ExtArgs["result"]["unitAnalytics"]>
    composites: {}
  }

  type UnitAnalyticsGetPayload<S extends boolean | null | undefined | UnitAnalyticsDefaultArgs> = $Result.GetResult<Prisma.$UnitAnalyticsPayload, S>

  type UnitAnalyticsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UnitAnalyticsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UnitAnalyticsCountAggregateInputType | true
    }

  export interface UnitAnalyticsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UnitAnalytics'], meta: { name: 'UnitAnalytics' } }
    /**
     * Find zero or one UnitAnalytics that matches the filter.
     * @param {UnitAnalyticsFindUniqueArgs} args - Arguments to find a UnitAnalytics
     * @example
     * // Get one UnitAnalytics
     * const unitAnalytics = await prisma.unitAnalytics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnitAnalyticsFindUniqueArgs>(args: SelectSubset<T, UnitAnalyticsFindUniqueArgs<ExtArgs>>): Prisma__UnitAnalyticsClient<$Result.GetResult<Prisma.$UnitAnalyticsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UnitAnalytics that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UnitAnalyticsFindUniqueOrThrowArgs} args - Arguments to find a UnitAnalytics
     * @example
     * // Get one UnitAnalytics
     * const unitAnalytics = await prisma.unitAnalytics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnitAnalyticsFindUniqueOrThrowArgs>(args: SelectSubset<T, UnitAnalyticsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnitAnalyticsClient<$Result.GetResult<Prisma.$UnitAnalyticsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UnitAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitAnalyticsFindFirstArgs} args - Arguments to find a UnitAnalytics
     * @example
     * // Get one UnitAnalytics
     * const unitAnalytics = await prisma.unitAnalytics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnitAnalyticsFindFirstArgs>(args?: SelectSubset<T, UnitAnalyticsFindFirstArgs<ExtArgs>>): Prisma__UnitAnalyticsClient<$Result.GetResult<Prisma.$UnitAnalyticsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UnitAnalytics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitAnalyticsFindFirstOrThrowArgs} args - Arguments to find a UnitAnalytics
     * @example
     * // Get one UnitAnalytics
     * const unitAnalytics = await prisma.unitAnalytics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnitAnalyticsFindFirstOrThrowArgs>(args?: SelectSubset<T, UnitAnalyticsFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnitAnalyticsClient<$Result.GetResult<Prisma.$UnitAnalyticsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UnitAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitAnalyticsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UnitAnalytics
     * const unitAnalytics = await prisma.unitAnalytics.findMany()
     * 
     * // Get first 10 UnitAnalytics
     * const unitAnalytics = await prisma.unitAnalytics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unitAnalyticsWithIdOnly = await prisma.unitAnalytics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UnitAnalyticsFindManyArgs>(args?: SelectSubset<T, UnitAnalyticsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitAnalyticsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UnitAnalytics.
     * @param {UnitAnalyticsCreateArgs} args - Arguments to create a UnitAnalytics.
     * @example
     * // Create one UnitAnalytics
     * const UnitAnalytics = await prisma.unitAnalytics.create({
     *   data: {
     *     // ... data to create a UnitAnalytics
     *   }
     * })
     * 
     */
    create<T extends UnitAnalyticsCreateArgs>(args: SelectSubset<T, UnitAnalyticsCreateArgs<ExtArgs>>): Prisma__UnitAnalyticsClient<$Result.GetResult<Prisma.$UnitAnalyticsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UnitAnalytics.
     * @param {UnitAnalyticsCreateManyArgs} args - Arguments to create many UnitAnalytics.
     * @example
     * // Create many UnitAnalytics
     * const unitAnalytics = await prisma.unitAnalytics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnitAnalyticsCreateManyArgs>(args?: SelectSubset<T, UnitAnalyticsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UnitAnalytics and returns the data saved in the database.
     * @param {UnitAnalyticsCreateManyAndReturnArgs} args - Arguments to create many UnitAnalytics.
     * @example
     * // Create many UnitAnalytics
     * const unitAnalytics = await prisma.unitAnalytics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UnitAnalytics and only return the `id`
     * const unitAnalyticsWithIdOnly = await prisma.unitAnalytics.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UnitAnalyticsCreateManyAndReturnArgs>(args?: SelectSubset<T, UnitAnalyticsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitAnalyticsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UnitAnalytics.
     * @param {UnitAnalyticsDeleteArgs} args - Arguments to delete one UnitAnalytics.
     * @example
     * // Delete one UnitAnalytics
     * const UnitAnalytics = await prisma.unitAnalytics.delete({
     *   where: {
     *     // ... filter to delete one UnitAnalytics
     *   }
     * })
     * 
     */
    delete<T extends UnitAnalyticsDeleteArgs>(args: SelectSubset<T, UnitAnalyticsDeleteArgs<ExtArgs>>): Prisma__UnitAnalyticsClient<$Result.GetResult<Prisma.$UnitAnalyticsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UnitAnalytics.
     * @param {UnitAnalyticsUpdateArgs} args - Arguments to update one UnitAnalytics.
     * @example
     * // Update one UnitAnalytics
     * const unitAnalytics = await prisma.unitAnalytics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnitAnalyticsUpdateArgs>(args: SelectSubset<T, UnitAnalyticsUpdateArgs<ExtArgs>>): Prisma__UnitAnalyticsClient<$Result.GetResult<Prisma.$UnitAnalyticsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UnitAnalytics.
     * @param {UnitAnalyticsDeleteManyArgs} args - Arguments to filter UnitAnalytics to delete.
     * @example
     * // Delete a few UnitAnalytics
     * const { count } = await prisma.unitAnalytics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnitAnalyticsDeleteManyArgs>(args?: SelectSubset<T, UnitAnalyticsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnitAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitAnalyticsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UnitAnalytics
     * const unitAnalytics = await prisma.unitAnalytics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnitAnalyticsUpdateManyArgs>(args: SelectSubset<T, UnitAnalyticsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UnitAnalytics.
     * @param {UnitAnalyticsUpsertArgs} args - Arguments to update or create a UnitAnalytics.
     * @example
     * // Update or create a UnitAnalytics
     * const unitAnalytics = await prisma.unitAnalytics.upsert({
     *   create: {
     *     // ... data to create a UnitAnalytics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UnitAnalytics we want to update
     *   }
     * })
     */
    upsert<T extends UnitAnalyticsUpsertArgs>(args: SelectSubset<T, UnitAnalyticsUpsertArgs<ExtArgs>>): Prisma__UnitAnalyticsClient<$Result.GetResult<Prisma.$UnitAnalyticsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UnitAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitAnalyticsCountArgs} args - Arguments to filter UnitAnalytics to count.
     * @example
     * // Count the number of UnitAnalytics
     * const count = await prisma.unitAnalytics.count({
     *   where: {
     *     // ... the filter for the UnitAnalytics we want to count
     *   }
     * })
    **/
    count<T extends UnitAnalyticsCountArgs>(
      args?: Subset<T, UnitAnalyticsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnitAnalyticsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UnitAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitAnalyticsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnitAnalyticsAggregateArgs>(args: Subset<T, UnitAnalyticsAggregateArgs>): Prisma.PrismaPromise<GetUnitAnalyticsAggregateType<T>>

    /**
     * Group by UnitAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitAnalyticsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnitAnalyticsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnitAnalyticsGroupByArgs['orderBy'] }
        : { orderBy?: UnitAnalyticsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnitAnalyticsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnitAnalyticsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UnitAnalytics model
   */
  readonly fields: UnitAnalyticsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UnitAnalytics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnitAnalyticsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UnitAnalytics model
   */ 
  interface UnitAnalyticsFieldRefs {
    readonly id: FieldRef<"UnitAnalytics", 'String'>
    readonly unitId: FieldRef<"UnitAnalytics", 'String'>
    readonly performanceScore: FieldRef<"UnitAnalytics", 'Decimal'>
    readonly efficiency: FieldRef<"UnitAnalytics", 'Decimal'>
    readonly totalTrips: FieldRef<"UnitAnalytics", 'Int'>
    readonly averageResponseTime: FieldRef<"UnitAnalytics", 'Decimal'>
    readonly lastUpdated: FieldRef<"UnitAnalytics", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UnitAnalytics findUnique
   */
  export type UnitAnalyticsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitAnalytics
     */
    select?: UnitAnalyticsSelect<ExtArgs> | null
    /**
     * Filter, which UnitAnalytics to fetch.
     */
    where: UnitAnalyticsWhereUniqueInput
  }

  /**
   * UnitAnalytics findUniqueOrThrow
   */
  export type UnitAnalyticsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitAnalytics
     */
    select?: UnitAnalyticsSelect<ExtArgs> | null
    /**
     * Filter, which UnitAnalytics to fetch.
     */
    where: UnitAnalyticsWhereUniqueInput
  }

  /**
   * UnitAnalytics findFirst
   */
  export type UnitAnalyticsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitAnalytics
     */
    select?: UnitAnalyticsSelect<ExtArgs> | null
    /**
     * Filter, which UnitAnalytics to fetch.
     */
    where?: UnitAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitAnalytics to fetch.
     */
    orderBy?: UnitAnalyticsOrderByWithRelationInput | UnitAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitAnalytics.
     */
    cursor?: UnitAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitAnalytics.
     */
    distinct?: UnitAnalyticsScalarFieldEnum | UnitAnalyticsScalarFieldEnum[]
  }

  /**
   * UnitAnalytics findFirstOrThrow
   */
  export type UnitAnalyticsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitAnalytics
     */
    select?: UnitAnalyticsSelect<ExtArgs> | null
    /**
     * Filter, which UnitAnalytics to fetch.
     */
    where?: UnitAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitAnalytics to fetch.
     */
    orderBy?: UnitAnalyticsOrderByWithRelationInput | UnitAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitAnalytics.
     */
    cursor?: UnitAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitAnalytics.
     */
    distinct?: UnitAnalyticsScalarFieldEnum | UnitAnalyticsScalarFieldEnum[]
  }

  /**
   * UnitAnalytics findMany
   */
  export type UnitAnalyticsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitAnalytics
     */
    select?: UnitAnalyticsSelect<ExtArgs> | null
    /**
     * Filter, which UnitAnalytics to fetch.
     */
    where?: UnitAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitAnalytics to fetch.
     */
    orderBy?: UnitAnalyticsOrderByWithRelationInput | UnitAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UnitAnalytics.
     */
    cursor?: UnitAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitAnalytics.
     */
    skip?: number
    distinct?: UnitAnalyticsScalarFieldEnum | UnitAnalyticsScalarFieldEnum[]
  }

  /**
   * UnitAnalytics create
   */
  export type UnitAnalyticsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitAnalytics
     */
    select?: UnitAnalyticsSelect<ExtArgs> | null
    /**
     * The data needed to create a UnitAnalytics.
     */
    data: XOR<UnitAnalyticsCreateInput, UnitAnalyticsUncheckedCreateInput>
  }

  /**
   * UnitAnalytics createMany
   */
  export type UnitAnalyticsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UnitAnalytics.
     */
    data: UnitAnalyticsCreateManyInput | UnitAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UnitAnalytics createManyAndReturn
   */
  export type UnitAnalyticsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitAnalytics
     */
    select?: UnitAnalyticsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UnitAnalytics.
     */
    data: UnitAnalyticsCreateManyInput | UnitAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UnitAnalytics update
   */
  export type UnitAnalyticsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitAnalytics
     */
    select?: UnitAnalyticsSelect<ExtArgs> | null
    /**
     * The data needed to update a UnitAnalytics.
     */
    data: XOR<UnitAnalyticsUpdateInput, UnitAnalyticsUncheckedUpdateInput>
    /**
     * Choose, which UnitAnalytics to update.
     */
    where: UnitAnalyticsWhereUniqueInput
  }

  /**
   * UnitAnalytics updateMany
   */
  export type UnitAnalyticsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UnitAnalytics.
     */
    data: XOR<UnitAnalyticsUpdateManyMutationInput, UnitAnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which UnitAnalytics to update
     */
    where?: UnitAnalyticsWhereInput
  }

  /**
   * UnitAnalytics upsert
   */
  export type UnitAnalyticsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitAnalytics
     */
    select?: UnitAnalyticsSelect<ExtArgs> | null
    /**
     * The filter to search for the UnitAnalytics to update in case it exists.
     */
    where: UnitAnalyticsWhereUniqueInput
    /**
     * In case the UnitAnalytics found by the `where` argument doesn't exist, create a new UnitAnalytics with this data.
     */
    create: XOR<UnitAnalyticsCreateInput, UnitAnalyticsUncheckedCreateInput>
    /**
     * In case the UnitAnalytics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnitAnalyticsUpdateInput, UnitAnalyticsUncheckedUpdateInput>
  }

  /**
   * UnitAnalytics delete
   */
  export type UnitAnalyticsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitAnalytics
     */
    select?: UnitAnalyticsSelect<ExtArgs> | null
    /**
     * Filter which UnitAnalytics to delete.
     */
    where: UnitAnalyticsWhereUniqueInput
  }

  /**
   * UnitAnalytics deleteMany
   */
  export type UnitAnalyticsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnitAnalytics to delete
     */
    where?: UnitAnalyticsWhereInput
  }

  /**
   * UnitAnalytics without action
   */
  export type UnitAnalyticsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitAnalytics
     */
    select?: UnitAnalyticsSelect<ExtArgs> | null
  }


  /**
   * Model RouteOptimizationSettings
   */

  export type AggregateRouteOptimizationSettings = {
    _count: RouteOptimizationSettingsCountAggregateOutputType | null
    _avg: RouteOptimizationSettingsAvgAggregateOutputType | null
    _sum: RouteOptimizationSettingsSumAggregateOutputType | null
    _min: RouteOptimizationSettingsMinAggregateOutputType | null
    _max: RouteOptimizationSettingsMaxAggregateOutputType | null
  }

  export type RouteOptimizationSettingsAvgAggregateOutputType = {
    deadheadMileWeight: Decimal | null
    waitTimeWeight: Decimal | null
    backhaulBonusWeight: Decimal | null
    overtimeRiskWeight: Decimal | null
    revenueWeight: Decimal | null
    maxDeadheadMiles: Decimal | null
    maxWaitTimeMinutes: number | null
    maxOvertimeHours: Decimal | null
    maxResponseTimeMinutes: number | null
    maxServiceDistance: Decimal | null
    backhaulTimeWindow: number | null
    backhaulDistanceLimit: Decimal | null
    backhaulRevenueBonus: Decimal | null
    targetLoadedMileRatio: Decimal | null
    targetRevenuePerHour: Decimal | null
    targetResponseTime: number | null
    targetEfficiency: Decimal | null
    maxOptimizationTime: number | null
    crewAvailabilityWeight: Decimal | null
    equipmentCompatibilityWeight: Decimal | null
    patientPriorityWeight: Decimal | null
  }

  export type RouteOptimizationSettingsSumAggregateOutputType = {
    deadheadMileWeight: Decimal | null
    waitTimeWeight: Decimal | null
    backhaulBonusWeight: Decimal | null
    overtimeRiskWeight: Decimal | null
    revenueWeight: Decimal | null
    maxDeadheadMiles: Decimal | null
    maxWaitTimeMinutes: number | null
    maxOvertimeHours: Decimal | null
    maxResponseTimeMinutes: number | null
    maxServiceDistance: Decimal | null
    backhaulTimeWindow: number | null
    backhaulDistanceLimit: Decimal | null
    backhaulRevenueBonus: Decimal | null
    targetLoadedMileRatio: Decimal | null
    targetRevenuePerHour: Decimal | null
    targetResponseTime: number | null
    targetEfficiency: Decimal | null
    maxOptimizationTime: number | null
    crewAvailabilityWeight: Decimal | null
    equipmentCompatibilityWeight: Decimal | null
    patientPriorityWeight: Decimal | null
  }

  export type RouteOptimizationSettingsMinAggregateOutputType = {
    id: string | null
    agencyId: string | null
    deadheadMileWeight: Decimal | null
    waitTimeWeight: Decimal | null
    backhaulBonusWeight: Decimal | null
    overtimeRiskWeight: Decimal | null
    revenueWeight: Decimal | null
    maxDeadheadMiles: Decimal | null
    maxWaitTimeMinutes: number | null
    maxOvertimeHours: Decimal | null
    maxResponseTimeMinutes: number | null
    maxServiceDistance: Decimal | null
    backhaulTimeWindow: number | null
    backhaulDistanceLimit: Decimal | null
    backhaulRevenueBonus: Decimal | null
    enableBackhaulOptimization: boolean | null
    targetLoadedMileRatio: Decimal | null
    targetRevenuePerHour: Decimal | null
    targetResponseTime: number | null
    targetEfficiency: Decimal | null
    optimizationAlgorithm: string | null
    maxOptimizationTime: number | null
    enableRealTimeOptimization: boolean | null
    crewAvailabilityWeight: Decimal | null
    equipmentCompatibilityWeight: Decimal | null
    patientPriorityWeight: Decimal | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RouteOptimizationSettingsMaxAggregateOutputType = {
    id: string | null
    agencyId: string | null
    deadheadMileWeight: Decimal | null
    waitTimeWeight: Decimal | null
    backhaulBonusWeight: Decimal | null
    overtimeRiskWeight: Decimal | null
    revenueWeight: Decimal | null
    maxDeadheadMiles: Decimal | null
    maxWaitTimeMinutes: number | null
    maxOvertimeHours: Decimal | null
    maxResponseTimeMinutes: number | null
    maxServiceDistance: Decimal | null
    backhaulTimeWindow: number | null
    backhaulDistanceLimit: Decimal | null
    backhaulRevenueBonus: Decimal | null
    enableBackhaulOptimization: boolean | null
    targetLoadedMileRatio: Decimal | null
    targetRevenuePerHour: Decimal | null
    targetResponseTime: number | null
    targetEfficiency: Decimal | null
    optimizationAlgorithm: string | null
    maxOptimizationTime: number | null
    enableRealTimeOptimization: boolean | null
    crewAvailabilityWeight: Decimal | null
    equipmentCompatibilityWeight: Decimal | null
    patientPriorityWeight: Decimal | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RouteOptimizationSettingsCountAggregateOutputType = {
    id: number
    agencyId: number
    deadheadMileWeight: number
    waitTimeWeight: number
    backhaulBonusWeight: number
    overtimeRiskWeight: number
    revenueWeight: number
    maxDeadheadMiles: number
    maxWaitTimeMinutes: number
    maxOvertimeHours: number
    maxResponseTimeMinutes: number
    maxServiceDistance: number
    backhaulTimeWindow: number
    backhaulDistanceLimit: number
    backhaulRevenueBonus: number
    enableBackhaulOptimization: number
    targetLoadedMileRatio: number
    targetRevenuePerHour: number
    targetResponseTime: number
    targetEfficiency: number
    optimizationAlgorithm: number
    maxOptimizationTime: number
    enableRealTimeOptimization: number
    crewAvailabilityWeight: number
    equipmentCompatibilityWeight: number
    patientPriorityWeight: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RouteOptimizationSettingsAvgAggregateInputType = {
    deadheadMileWeight?: true
    waitTimeWeight?: true
    backhaulBonusWeight?: true
    overtimeRiskWeight?: true
    revenueWeight?: true
    maxDeadheadMiles?: true
    maxWaitTimeMinutes?: true
    maxOvertimeHours?: true
    maxResponseTimeMinutes?: true
    maxServiceDistance?: true
    backhaulTimeWindow?: true
    backhaulDistanceLimit?: true
    backhaulRevenueBonus?: true
    targetLoadedMileRatio?: true
    targetRevenuePerHour?: true
    targetResponseTime?: true
    targetEfficiency?: true
    maxOptimizationTime?: true
    crewAvailabilityWeight?: true
    equipmentCompatibilityWeight?: true
    patientPriorityWeight?: true
  }

  export type RouteOptimizationSettingsSumAggregateInputType = {
    deadheadMileWeight?: true
    waitTimeWeight?: true
    backhaulBonusWeight?: true
    overtimeRiskWeight?: true
    revenueWeight?: true
    maxDeadheadMiles?: true
    maxWaitTimeMinutes?: true
    maxOvertimeHours?: true
    maxResponseTimeMinutes?: true
    maxServiceDistance?: true
    backhaulTimeWindow?: true
    backhaulDistanceLimit?: true
    backhaulRevenueBonus?: true
    targetLoadedMileRatio?: true
    targetRevenuePerHour?: true
    targetResponseTime?: true
    targetEfficiency?: true
    maxOptimizationTime?: true
    crewAvailabilityWeight?: true
    equipmentCompatibilityWeight?: true
    patientPriorityWeight?: true
  }

  export type RouteOptimizationSettingsMinAggregateInputType = {
    id?: true
    agencyId?: true
    deadheadMileWeight?: true
    waitTimeWeight?: true
    backhaulBonusWeight?: true
    overtimeRiskWeight?: true
    revenueWeight?: true
    maxDeadheadMiles?: true
    maxWaitTimeMinutes?: true
    maxOvertimeHours?: true
    maxResponseTimeMinutes?: true
    maxServiceDistance?: true
    backhaulTimeWindow?: true
    backhaulDistanceLimit?: true
    backhaulRevenueBonus?: true
    enableBackhaulOptimization?: true
    targetLoadedMileRatio?: true
    targetRevenuePerHour?: true
    targetResponseTime?: true
    targetEfficiency?: true
    optimizationAlgorithm?: true
    maxOptimizationTime?: true
    enableRealTimeOptimization?: true
    crewAvailabilityWeight?: true
    equipmentCompatibilityWeight?: true
    patientPriorityWeight?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RouteOptimizationSettingsMaxAggregateInputType = {
    id?: true
    agencyId?: true
    deadheadMileWeight?: true
    waitTimeWeight?: true
    backhaulBonusWeight?: true
    overtimeRiskWeight?: true
    revenueWeight?: true
    maxDeadheadMiles?: true
    maxWaitTimeMinutes?: true
    maxOvertimeHours?: true
    maxResponseTimeMinutes?: true
    maxServiceDistance?: true
    backhaulTimeWindow?: true
    backhaulDistanceLimit?: true
    backhaulRevenueBonus?: true
    enableBackhaulOptimization?: true
    targetLoadedMileRatio?: true
    targetRevenuePerHour?: true
    targetResponseTime?: true
    targetEfficiency?: true
    optimizationAlgorithm?: true
    maxOptimizationTime?: true
    enableRealTimeOptimization?: true
    crewAvailabilityWeight?: true
    equipmentCompatibilityWeight?: true
    patientPriorityWeight?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RouteOptimizationSettingsCountAggregateInputType = {
    id?: true
    agencyId?: true
    deadheadMileWeight?: true
    waitTimeWeight?: true
    backhaulBonusWeight?: true
    overtimeRiskWeight?: true
    revenueWeight?: true
    maxDeadheadMiles?: true
    maxWaitTimeMinutes?: true
    maxOvertimeHours?: true
    maxResponseTimeMinutes?: true
    maxServiceDistance?: true
    backhaulTimeWindow?: true
    backhaulDistanceLimit?: true
    backhaulRevenueBonus?: true
    enableBackhaulOptimization?: true
    targetLoadedMileRatio?: true
    targetRevenuePerHour?: true
    targetResponseTime?: true
    targetEfficiency?: true
    optimizationAlgorithm?: true
    maxOptimizationTime?: true
    enableRealTimeOptimization?: true
    crewAvailabilityWeight?: true
    equipmentCompatibilityWeight?: true
    patientPriorityWeight?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RouteOptimizationSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RouteOptimizationSettings to aggregate.
     */
    where?: RouteOptimizationSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RouteOptimizationSettings to fetch.
     */
    orderBy?: RouteOptimizationSettingsOrderByWithRelationInput | RouteOptimizationSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RouteOptimizationSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RouteOptimizationSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RouteOptimizationSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RouteOptimizationSettings
    **/
    _count?: true | RouteOptimizationSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RouteOptimizationSettingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RouteOptimizationSettingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RouteOptimizationSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RouteOptimizationSettingsMaxAggregateInputType
  }

  export type GetRouteOptimizationSettingsAggregateType<T extends RouteOptimizationSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateRouteOptimizationSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRouteOptimizationSettings[P]>
      : GetScalarType<T[P], AggregateRouteOptimizationSettings[P]>
  }




  export type RouteOptimizationSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RouteOptimizationSettingsWhereInput
    orderBy?: RouteOptimizationSettingsOrderByWithAggregationInput | RouteOptimizationSettingsOrderByWithAggregationInput[]
    by: RouteOptimizationSettingsScalarFieldEnum[] | RouteOptimizationSettingsScalarFieldEnum
    having?: RouteOptimizationSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RouteOptimizationSettingsCountAggregateInputType | true
    _avg?: RouteOptimizationSettingsAvgAggregateInputType
    _sum?: RouteOptimizationSettingsSumAggregateInputType
    _min?: RouteOptimizationSettingsMinAggregateInputType
    _max?: RouteOptimizationSettingsMaxAggregateInputType
  }

  export type RouteOptimizationSettingsGroupByOutputType = {
    id: string
    agencyId: string | null
    deadheadMileWeight: Decimal
    waitTimeWeight: Decimal
    backhaulBonusWeight: Decimal
    overtimeRiskWeight: Decimal
    revenueWeight: Decimal
    maxDeadheadMiles: Decimal
    maxWaitTimeMinutes: number
    maxOvertimeHours: Decimal
    maxResponseTimeMinutes: number
    maxServiceDistance: Decimal
    backhaulTimeWindow: number
    backhaulDistanceLimit: Decimal
    backhaulRevenueBonus: Decimal
    enableBackhaulOptimization: boolean
    targetLoadedMileRatio: Decimal
    targetRevenuePerHour: Decimal
    targetResponseTime: number
    targetEfficiency: Decimal
    optimizationAlgorithm: string
    maxOptimizationTime: number
    enableRealTimeOptimization: boolean
    crewAvailabilityWeight: Decimal
    equipmentCompatibilityWeight: Decimal
    patientPriorityWeight: Decimal
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: RouteOptimizationSettingsCountAggregateOutputType | null
    _avg: RouteOptimizationSettingsAvgAggregateOutputType | null
    _sum: RouteOptimizationSettingsSumAggregateOutputType | null
    _min: RouteOptimizationSettingsMinAggregateOutputType | null
    _max: RouteOptimizationSettingsMaxAggregateOutputType | null
  }

  type GetRouteOptimizationSettingsGroupByPayload<T extends RouteOptimizationSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RouteOptimizationSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RouteOptimizationSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RouteOptimizationSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], RouteOptimizationSettingsGroupByOutputType[P]>
        }
      >
    >


  export type RouteOptimizationSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agencyId?: boolean
    deadheadMileWeight?: boolean
    waitTimeWeight?: boolean
    backhaulBonusWeight?: boolean
    overtimeRiskWeight?: boolean
    revenueWeight?: boolean
    maxDeadheadMiles?: boolean
    maxWaitTimeMinutes?: boolean
    maxOvertimeHours?: boolean
    maxResponseTimeMinutes?: boolean
    maxServiceDistance?: boolean
    backhaulTimeWindow?: boolean
    backhaulDistanceLimit?: boolean
    backhaulRevenueBonus?: boolean
    enableBackhaulOptimization?: boolean
    targetLoadedMileRatio?: boolean
    targetRevenuePerHour?: boolean
    targetResponseTime?: boolean
    targetEfficiency?: boolean
    optimizationAlgorithm?: boolean
    maxOptimizationTime?: boolean
    enableRealTimeOptimization?: boolean
    crewAvailabilityWeight?: boolean
    equipmentCompatibilityWeight?: boolean
    patientPriorityWeight?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["routeOptimizationSettings"]>

  export type RouteOptimizationSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agencyId?: boolean
    deadheadMileWeight?: boolean
    waitTimeWeight?: boolean
    backhaulBonusWeight?: boolean
    overtimeRiskWeight?: boolean
    revenueWeight?: boolean
    maxDeadheadMiles?: boolean
    maxWaitTimeMinutes?: boolean
    maxOvertimeHours?: boolean
    maxResponseTimeMinutes?: boolean
    maxServiceDistance?: boolean
    backhaulTimeWindow?: boolean
    backhaulDistanceLimit?: boolean
    backhaulRevenueBonus?: boolean
    enableBackhaulOptimization?: boolean
    targetLoadedMileRatio?: boolean
    targetRevenuePerHour?: boolean
    targetResponseTime?: boolean
    targetEfficiency?: boolean
    optimizationAlgorithm?: boolean
    maxOptimizationTime?: boolean
    enableRealTimeOptimization?: boolean
    crewAvailabilityWeight?: boolean
    equipmentCompatibilityWeight?: boolean
    patientPriorityWeight?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["routeOptimizationSettings"]>

  export type RouteOptimizationSettingsSelectScalar = {
    id?: boolean
    agencyId?: boolean
    deadheadMileWeight?: boolean
    waitTimeWeight?: boolean
    backhaulBonusWeight?: boolean
    overtimeRiskWeight?: boolean
    revenueWeight?: boolean
    maxDeadheadMiles?: boolean
    maxWaitTimeMinutes?: boolean
    maxOvertimeHours?: boolean
    maxResponseTimeMinutes?: boolean
    maxServiceDistance?: boolean
    backhaulTimeWindow?: boolean
    backhaulDistanceLimit?: boolean
    backhaulRevenueBonus?: boolean
    enableBackhaulOptimization?: boolean
    targetLoadedMileRatio?: boolean
    targetRevenuePerHour?: boolean
    targetResponseTime?: boolean
    targetEfficiency?: boolean
    optimizationAlgorithm?: boolean
    maxOptimizationTime?: boolean
    enableRealTimeOptimization?: boolean
    crewAvailabilityWeight?: boolean
    equipmentCompatibilityWeight?: boolean
    patientPriorityWeight?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $RouteOptimizationSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RouteOptimizationSettings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      agencyId: string | null
      deadheadMileWeight: Prisma.Decimal
      waitTimeWeight: Prisma.Decimal
      backhaulBonusWeight: Prisma.Decimal
      overtimeRiskWeight: Prisma.Decimal
      revenueWeight: Prisma.Decimal
      maxDeadheadMiles: Prisma.Decimal
      maxWaitTimeMinutes: number
      maxOvertimeHours: Prisma.Decimal
      maxResponseTimeMinutes: number
      maxServiceDistance: Prisma.Decimal
      backhaulTimeWindow: number
      backhaulDistanceLimit: Prisma.Decimal
      backhaulRevenueBonus: Prisma.Decimal
      enableBackhaulOptimization: boolean
      targetLoadedMileRatio: Prisma.Decimal
      targetRevenuePerHour: Prisma.Decimal
      targetResponseTime: number
      targetEfficiency: Prisma.Decimal
      optimizationAlgorithm: string
      maxOptimizationTime: number
      enableRealTimeOptimization: boolean
      crewAvailabilityWeight: Prisma.Decimal
      equipmentCompatibilityWeight: Prisma.Decimal
      patientPriorityWeight: Prisma.Decimal
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["routeOptimizationSettings"]>
    composites: {}
  }

  type RouteOptimizationSettingsGetPayload<S extends boolean | null | undefined | RouteOptimizationSettingsDefaultArgs> = $Result.GetResult<Prisma.$RouteOptimizationSettingsPayload, S>

  type RouteOptimizationSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RouteOptimizationSettingsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RouteOptimizationSettingsCountAggregateInputType | true
    }

  export interface RouteOptimizationSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RouteOptimizationSettings'], meta: { name: 'RouteOptimizationSettings' } }
    /**
     * Find zero or one RouteOptimizationSettings that matches the filter.
     * @param {RouteOptimizationSettingsFindUniqueArgs} args - Arguments to find a RouteOptimizationSettings
     * @example
     * // Get one RouteOptimizationSettings
     * const routeOptimizationSettings = await prisma.routeOptimizationSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RouteOptimizationSettingsFindUniqueArgs>(args: SelectSubset<T, RouteOptimizationSettingsFindUniqueArgs<ExtArgs>>): Prisma__RouteOptimizationSettingsClient<$Result.GetResult<Prisma.$RouteOptimizationSettingsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RouteOptimizationSettings that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RouteOptimizationSettingsFindUniqueOrThrowArgs} args - Arguments to find a RouteOptimizationSettings
     * @example
     * // Get one RouteOptimizationSettings
     * const routeOptimizationSettings = await prisma.routeOptimizationSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RouteOptimizationSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, RouteOptimizationSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RouteOptimizationSettingsClient<$Result.GetResult<Prisma.$RouteOptimizationSettingsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RouteOptimizationSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteOptimizationSettingsFindFirstArgs} args - Arguments to find a RouteOptimizationSettings
     * @example
     * // Get one RouteOptimizationSettings
     * const routeOptimizationSettings = await prisma.routeOptimizationSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RouteOptimizationSettingsFindFirstArgs>(args?: SelectSubset<T, RouteOptimizationSettingsFindFirstArgs<ExtArgs>>): Prisma__RouteOptimizationSettingsClient<$Result.GetResult<Prisma.$RouteOptimizationSettingsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RouteOptimizationSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteOptimizationSettingsFindFirstOrThrowArgs} args - Arguments to find a RouteOptimizationSettings
     * @example
     * // Get one RouteOptimizationSettings
     * const routeOptimizationSettings = await prisma.routeOptimizationSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RouteOptimizationSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, RouteOptimizationSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__RouteOptimizationSettingsClient<$Result.GetResult<Prisma.$RouteOptimizationSettingsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RouteOptimizationSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteOptimizationSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RouteOptimizationSettings
     * const routeOptimizationSettings = await prisma.routeOptimizationSettings.findMany()
     * 
     * // Get first 10 RouteOptimizationSettings
     * const routeOptimizationSettings = await prisma.routeOptimizationSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const routeOptimizationSettingsWithIdOnly = await prisma.routeOptimizationSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RouteOptimizationSettingsFindManyArgs>(args?: SelectSubset<T, RouteOptimizationSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RouteOptimizationSettingsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RouteOptimizationSettings.
     * @param {RouteOptimizationSettingsCreateArgs} args - Arguments to create a RouteOptimizationSettings.
     * @example
     * // Create one RouteOptimizationSettings
     * const RouteOptimizationSettings = await prisma.routeOptimizationSettings.create({
     *   data: {
     *     // ... data to create a RouteOptimizationSettings
     *   }
     * })
     * 
     */
    create<T extends RouteOptimizationSettingsCreateArgs>(args: SelectSubset<T, RouteOptimizationSettingsCreateArgs<ExtArgs>>): Prisma__RouteOptimizationSettingsClient<$Result.GetResult<Prisma.$RouteOptimizationSettingsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RouteOptimizationSettings.
     * @param {RouteOptimizationSettingsCreateManyArgs} args - Arguments to create many RouteOptimizationSettings.
     * @example
     * // Create many RouteOptimizationSettings
     * const routeOptimizationSettings = await prisma.routeOptimizationSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RouteOptimizationSettingsCreateManyArgs>(args?: SelectSubset<T, RouteOptimizationSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RouteOptimizationSettings and returns the data saved in the database.
     * @param {RouteOptimizationSettingsCreateManyAndReturnArgs} args - Arguments to create many RouteOptimizationSettings.
     * @example
     * // Create many RouteOptimizationSettings
     * const routeOptimizationSettings = await prisma.routeOptimizationSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RouteOptimizationSettings and only return the `id`
     * const routeOptimizationSettingsWithIdOnly = await prisma.routeOptimizationSettings.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RouteOptimizationSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, RouteOptimizationSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RouteOptimizationSettingsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RouteOptimizationSettings.
     * @param {RouteOptimizationSettingsDeleteArgs} args - Arguments to delete one RouteOptimizationSettings.
     * @example
     * // Delete one RouteOptimizationSettings
     * const RouteOptimizationSettings = await prisma.routeOptimizationSettings.delete({
     *   where: {
     *     // ... filter to delete one RouteOptimizationSettings
     *   }
     * })
     * 
     */
    delete<T extends RouteOptimizationSettingsDeleteArgs>(args: SelectSubset<T, RouteOptimizationSettingsDeleteArgs<ExtArgs>>): Prisma__RouteOptimizationSettingsClient<$Result.GetResult<Prisma.$RouteOptimizationSettingsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RouteOptimizationSettings.
     * @param {RouteOptimizationSettingsUpdateArgs} args - Arguments to update one RouteOptimizationSettings.
     * @example
     * // Update one RouteOptimizationSettings
     * const routeOptimizationSettings = await prisma.routeOptimizationSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RouteOptimizationSettingsUpdateArgs>(args: SelectSubset<T, RouteOptimizationSettingsUpdateArgs<ExtArgs>>): Prisma__RouteOptimizationSettingsClient<$Result.GetResult<Prisma.$RouteOptimizationSettingsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RouteOptimizationSettings.
     * @param {RouteOptimizationSettingsDeleteManyArgs} args - Arguments to filter RouteOptimizationSettings to delete.
     * @example
     * // Delete a few RouteOptimizationSettings
     * const { count } = await prisma.routeOptimizationSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RouteOptimizationSettingsDeleteManyArgs>(args?: SelectSubset<T, RouteOptimizationSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RouteOptimizationSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteOptimizationSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RouteOptimizationSettings
     * const routeOptimizationSettings = await prisma.routeOptimizationSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RouteOptimizationSettingsUpdateManyArgs>(args: SelectSubset<T, RouteOptimizationSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RouteOptimizationSettings.
     * @param {RouteOptimizationSettingsUpsertArgs} args - Arguments to update or create a RouteOptimizationSettings.
     * @example
     * // Update or create a RouteOptimizationSettings
     * const routeOptimizationSettings = await prisma.routeOptimizationSettings.upsert({
     *   create: {
     *     // ... data to create a RouteOptimizationSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RouteOptimizationSettings we want to update
     *   }
     * })
     */
    upsert<T extends RouteOptimizationSettingsUpsertArgs>(args: SelectSubset<T, RouteOptimizationSettingsUpsertArgs<ExtArgs>>): Prisma__RouteOptimizationSettingsClient<$Result.GetResult<Prisma.$RouteOptimizationSettingsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RouteOptimizationSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteOptimizationSettingsCountArgs} args - Arguments to filter RouteOptimizationSettings to count.
     * @example
     * // Count the number of RouteOptimizationSettings
     * const count = await prisma.routeOptimizationSettings.count({
     *   where: {
     *     // ... the filter for the RouteOptimizationSettings we want to count
     *   }
     * })
    **/
    count<T extends RouteOptimizationSettingsCountArgs>(
      args?: Subset<T, RouteOptimizationSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RouteOptimizationSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RouteOptimizationSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteOptimizationSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RouteOptimizationSettingsAggregateArgs>(args: Subset<T, RouteOptimizationSettingsAggregateArgs>): Prisma.PrismaPromise<GetRouteOptimizationSettingsAggregateType<T>>

    /**
     * Group by RouteOptimizationSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteOptimizationSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RouteOptimizationSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RouteOptimizationSettingsGroupByArgs['orderBy'] }
        : { orderBy?: RouteOptimizationSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RouteOptimizationSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRouteOptimizationSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RouteOptimizationSettings model
   */
  readonly fields: RouteOptimizationSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RouteOptimizationSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RouteOptimizationSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RouteOptimizationSettings model
   */ 
  interface RouteOptimizationSettingsFieldRefs {
    readonly id: FieldRef<"RouteOptimizationSettings", 'String'>
    readonly agencyId: FieldRef<"RouteOptimizationSettings", 'String'>
    readonly deadheadMileWeight: FieldRef<"RouteOptimizationSettings", 'Decimal'>
    readonly waitTimeWeight: FieldRef<"RouteOptimizationSettings", 'Decimal'>
    readonly backhaulBonusWeight: FieldRef<"RouteOptimizationSettings", 'Decimal'>
    readonly overtimeRiskWeight: FieldRef<"RouteOptimizationSettings", 'Decimal'>
    readonly revenueWeight: FieldRef<"RouteOptimizationSettings", 'Decimal'>
    readonly maxDeadheadMiles: FieldRef<"RouteOptimizationSettings", 'Decimal'>
    readonly maxWaitTimeMinutes: FieldRef<"RouteOptimizationSettings", 'Int'>
    readonly maxOvertimeHours: FieldRef<"RouteOptimizationSettings", 'Decimal'>
    readonly maxResponseTimeMinutes: FieldRef<"RouteOptimizationSettings", 'Int'>
    readonly maxServiceDistance: FieldRef<"RouteOptimizationSettings", 'Decimal'>
    readonly backhaulTimeWindow: FieldRef<"RouteOptimizationSettings", 'Int'>
    readonly backhaulDistanceLimit: FieldRef<"RouteOptimizationSettings", 'Decimal'>
    readonly backhaulRevenueBonus: FieldRef<"RouteOptimizationSettings", 'Decimal'>
    readonly enableBackhaulOptimization: FieldRef<"RouteOptimizationSettings", 'Boolean'>
    readonly targetLoadedMileRatio: FieldRef<"RouteOptimizationSettings", 'Decimal'>
    readonly targetRevenuePerHour: FieldRef<"RouteOptimizationSettings", 'Decimal'>
    readonly targetResponseTime: FieldRef<"RouteOptimizationSettings", 'Int'>
    readonly targetEfficiency: FieldRef<"RouteOptimizationSettings", 'Decimal'>
    readonly optimizationAlgorithm: FieldRef<"RouteOptimizationSettings", 'String'>
    readonly maxOptimizationTime: FieldRef<"RouteOptimizationSettings", 'Int'>
    readonly enableRealTimeOptimization: FieldRef<"RouteOptimizationSettings", 'Boolean'>
    readonly crewAvailabilityWeight: FieldRef<"RouteOptimizationSettings", 'Decimal'>
    readonly equipmentCompatibilityWeight: FieldRef<"RouteOptimizationSettings", 'Decimal'>
    readonly patientPriorityWeight: FieldRef<"RouteOptimizationSettings", 'Decimal'>
    readonly isActive: FieldRef<"RouteOptimizationSettings", 'Boolean'>
    readonly createdAt: FieldRef<"RouteOptimizationSettings", 'DateTime'>
    readonly updatedAt: FieldRef<"RouteOptimizationSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RouteOptimizationSettings findUnique
   */
  export type RouteOptimizationSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteOptimizationSettings
     */
    select?: RouteOptimizationSettingsSelect<ExtArgs> | null
    /**
     * Filter, which RouteOptimizationSettings to fetch.
     */
    where: RouteOptimizationSettingsWhereUniqueInput
  }

  /**
   * RouteOptimizationSettings findUniqueOrThrow
   */
  export type RouteOptimizationSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteOptimizationSettings
     */
    select?: RouteOptimizationSettingsSelect<ExtArgs> | null
    /**
     * Filter, which RouteOptimizationSettings to fetch.
     */
    where: RouteOptimizationSettingsWhereUniqueInput
  }

  /**
   * RouteOptimizationSettings findFirst
   */
  export type RouteOptimizationSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteOptimizationSettings
     */
    select?: RouteOptimizationSettingsSelect<ExtArgs> | null
    /**
     * Filter, which RouteOptimizationSettings to fetch.
     */
    where?: RouteOptimizationSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RouteOptimizationSettings to fetch.
     */
    orderBy?: RouteOptimizationSettingsOrderByWithRelationInput | RouteOptimizationSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RouteOptimizationSettings.
     */
    cursor?: RouteOptimizationSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RouteOptimizationSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RouteOptimizationSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RouteOptimizationSettings.
     */
    distinct?: RouteOptimizationSettingsScalarFieldEnum | RouteOptimizationSettingsScalarFieldEnum[]
  }

  /**
   * RouteOptimizationSettings findFirstOrThrow
   */
  export type RouteOptimizationSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteOptimizationSettings
     */
    select?: RouteOptimizationSettingsSelect<ExtArgs> | null
    /**
     * Filter, which RouteOptimizationSettings to fetch.
     */
    where?: RouteOptimizationSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RouteOptimizationSettings to fetch.
     */
    orderBy?: RouteOptimizationSettingsOrderByWithRelationInput | RouteOptimizationSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RouteOptimizationSettings.
     */
    cursor?: RouteOptimizationSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RouteOptimizationSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RouteOptimizationSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RouteOptimizationSettings.
     */
    distinct?: RouteOptimizationSettingsScalarFieldEnum | RouteOptimizationSettingsScalarFieldEnum[]
  }

  /**
   * RouteOptimizationSettings findMany
   */
  export type RouteOptimizationSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteOptimizationSettings
     */
    select?: RouteOptimizationSettingsSelect<ExtArgs> | null
    /**
     * Filter, which RouteOptimizationSettings to fetch.
     */
    where?: RouteOptimizationSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RouteOptimizationSettings to fetch.
     */
    orderBy?: RouteOptimizationSettingsOrderByWithRelationInput | RouteOptimizationSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RouteOptimizationSettings.
     */
    cursor?: RouteOptimizationSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RouteOptimizationSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RouteOptimizationSettings.
     */
    skip?: number
    distinct?: RouteOptimizationSettingsScalarFieldEnum | RouteOptimizationSettingsScalarFieldEnum[]
  }

  /**
   * RouteOptimizationSettings create
   */
  export type RouteOptimizationSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteOptimizationSettings
     */
    select?: RouteOptimizationSettingsSelect<ExtArgs> | null
    /**
     * The data needed to create a RouteOptimizationSettings.
     */
    data: XOR<RouteOptimizationSettingsCreateInput, RouteOptimizationSettingsUncheckedCreateInput>
  }

  /**
   * RouteOptimizationSettings createMany
   */
  export type RouteOptimizationSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RouteOptimizationSettings.
     */
    data: RouteOptimizationSettingsCreateManyInput | RouteOptimizationSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RouteOptimizationSettings createManyAndReturn
   */
  export type RouteOptimizationSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteOptimizationSettings
     */
    select?: RouteOptimizationSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RouteOptimizationSettings.
     */
    data: RouteOptimizationSettingsCreateManyInput | RouteOptimizationSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RouteOptimizationSettings update
   */
  export type RouteOptimizationSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteOptimizationSettings
     */
    select?: RouteOptimizationSettingsSelect<ExtArgs> | null
    /**
     * The data needed to update a RouteOptimizationSettings.
     */
    data: XOR<RouteOptimizationSettingsUpdateInput, RouteOptimizationSettingsUncheckedUpdateInput>
    /**
     * Choose, which RouteOptimizationSettings to update.
     */
    where: RouteOptimizationSettingsWhereUniqueInput
  }

  /**
   * RouteOptimizationSettings updateMany
   */
  export type RouteOptimizationSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RouteOptimizationSettings.
     */
    data: XOR<RouteOptimizationSettingsUpdateManyMutationInput, RouteOptimizationSettingsUncheckedUpdateManyInput>
    /**
     * Filter which RouteOptimizationSettings to update
     */
    where?: RouteOptimizationSettingsWhereInput
  }

  /**
   * RouteOptimizationSettings upsert
   */
  export type RouteOptimizationSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteOptimizationSettings
     */
    select?: RouteOptimizationSettingsSelect<ExtArgs> | null
    /**
     * The filter to search for the RouteOptimizationSettings to update in case it exists.
     */
    where: RouteOptimizationSettingsWhereUniqueInput
    /**
     * In case the RouteOptimizationSettings found by the `where` argument doesn't exist, create a new RouteOptimizationSettings with this data.
     */
    create: XOR<RouteOptimizationSettingsCreateInput, RouteOptimizationSettingsUncheckedCreateInput>
    /**
     * In case the RouteOptimizationSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RouteOptimizationSettingsUpdateInput, RouteOptimizationSettingsUncheckedUpdateInput>
  }

  /**
   * RouteOptimizationSettings delete
   */
  export type RouteOptimizationSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteOptimizationSettings
     */
    select?: RouteOptimizationSettingsSelect<ExtArgs> | null
    /**
     * Filter which RouteOptimizationSettings to delete.
     */
    where: RouteOptimizationSettingsWhereUniqueInput
  }

  /**
   * RouteOptimizationSettings deleteMany
   */
  export type RouteOptimizationSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RouteOptimizationSettings to delete
     */
    where?: RouteOptimizationSettingsWhereInput
  }

  /**
   * RouteOptimizationSettings without action
   */
  export type RouteOptimizationSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteOptimizationSettings
     */
    select?: RouteOptimizationSettingsSelect<ExtArgs> | null
  }


  /**
   * Model TripCostBreakdown
   */

  export type AggregateTripCostBreakdown = {
    _count: TripCostBreakdownCountAggregateOutputType | null
    _avg: TripCostBreakdownAvgAggregateOutputType | null
    _sum: TripCostBreakdownSumAggregateOutputType | null
    _min: TripCostBreakdownMinAggregateOutputType | null
    _max: TripCostBreakdownMaxAggregateOutputType | null
  }

  export type TripCostBreakdownAvgAggregateOutputType = {
    baseRevenue: Decimal | null
    mileageRevenue: Decimal | null
    priorityRevenue: Decimal | null
    specialRequirementsRevenue: Decimal | null
    insuranceAdjustment: Decimal | null
    totalRevenue: Decimal | null
    crewLaborCost: Decimal | null
    vehicleCost: Decimal | null
    fuelCost: Decimal | null
    maintenanceCost: Decimal | null
    overheadCost: Decimal | null
    totalCost: Decimal | null
    grossProfit: Decimal | null
    profitMargin: Decimal | null
    revenuePerMile: Decimal | null
    costPerMile: Decimal | null
    loadedMileRatio: Decimal | null
    deadheadMileRatio: Decimal | null
    utilizationRate: Decimal | null
    tripDistance: Decimal | null
    loadedMiles: Decimal | null
    deadheadMiles: Decimal | null
    tripDurationHours: Decimal | null
  }

  export type TripCostBreakdownSumAggregateOutputType = {
    baseRevenue: Decimal | null
    mileageRevenue: Decimal | null
    priorityRevenue: Decimal | null
    specialRequirementsRevenue: Decimal | null
    insuranceAdjustment: Decimal | null
    totalRevenue: Decimal | null
    crewLaborCost: Decimal | null
    vehicleCost: Decimal | null
    fuelCost: Decimal | null
    maintenanceCost: Decimal | null
    overheadCost: Decimal | null
    totalCost: Decimal | null
    grossProfit: Decimal | null
    profitMargin: Decimal | null
    revenuePerMile: Decimal | null
    costPerMile: Decimal | null
    loadedMileRatio: Decimal | null
    deadheadMileRatio: Decimal | null
    utilizationRate: Decimal | null
    tripDistance: Decimal | null
    loadedMiles: Decimal | null
    deadheadMiles: Decimal | null
    tripDurationHours: Decimal | null
  }

  export type TripCostBreakdownMinAggregateOutputType = {
    id: string | null
    tripId: string | null
    baseRevenue: Decimal | null
    mileageRevenue: Decimal | null
    priorityRevenue: Decimal | null
    specialRequirementsRevenue: Decimal | null
    insuranceAdjustment: Decimal | null
    totalRevenue: Decimal | null
    crewLaborCost: Decimal | null
    vehicleCost: Decimal | null
    fuelCost: Decimal | null
    maintenanceCost: Decimal | null
    overheadCost: Decimal | null
    totalCost: Decimal | null
    grossProfit: Decimal | null
    profitMargin: Decimal | null
    revenuePerMile: Decimal | null
    costPerMile: Decimal | null
    loadedMileRatio: Decimal | null
    deadheadMileRatio: Decimal | null
    utilizationRate: Decimal | null
    tripDistance: Decimal | null
    loadedMiles: Decimal | null
    deadheadMiles: Decimal | null
    tripDurationHours: Decimal | null
    transportLevel: string | null
    priorityLevel: string | null
    costCenterId: string | null
    costCenterName: string | null
    calculatedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TripCostBreakdownMaxAggregateOutputType = {
    id: string | null
    tripId: string | null
    baseRevenue: Decimal | null
    mileageRevenue: Decimal | null
    priorityRevenue: Decimal | null
    specialRequirementsRevenue: Decimal | null
    insuranceAdjustment: Decimal | null
    totalRevenue: Decimal | null
    crewLaborCost: Decimal | null
    vehicleCost: Decimal | null
    fuelCost: Decimal | null
    maintenanceCost: Decimal | null
    overheadCost: Decimal | null
    totalCost: Decimal | null
    grossProfit: Decimal | null
    profitMargin: Decimal | null
    revenuePerMile: Decimal | null
    costPerMile: Decimal | null
    loadedMileRatio: Decimal | null
    deadheadMileRatio: Decimal | null
    utilizationRate: Decimal | null
    tripDistance: Decimal | null
    loadedMiles: Decimal | null
    deadheadMiles: Decimal | null
    tripDurationHours: Decimal | null
    transportLevel: string | null
    priorityLevel: string | null
    costCenterId: string | null
    costCenterName: string | null
    calculatedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TripCostBreakdownCountAggregateOutputType = {
    id: number
    tripId: number
    baseRevenue: number
    mileageRevenue: number
    priorityRevenue: number
    specialRequirementsRevenue: number
    insuranceAdjustment: number
    totalRevenue: number
    crewLaborCost: number
    vehicleCost: number
    fuelCost: number
    maintenanceCost: number
    overheadCost: number
    totalCost: number
    grossProfit: number
    profitMargin: number
    revenuePerMile: number
    costPerMile: number
    loadedMileRatio: number
    deadheadMileRatio: number
    utilizationRate: number
    tripDistance: number
    loadedMiles: number
    deadheadMiles: number
    tripDurationHours: number
    transportLevel: number
    priorityLevel: number
    costCenterId: number
    costCenterName: number
    calculatedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TripCostBreakdownAvgAggregateInputType = {
    baseRevenue?: true
    mileageRevenue?: true
    priorityRevenue?: true
    specialRequirementsRevenue?: true
    insuranceAdjustment?: true
    totalRevenue?: true
    crewLaborCost?: true
    vehicleCost?: true
    fuelCost?: true
    maintenanceCost?: true
    overheadCost?: true
    totalCost?: true
    grossProfit?: true
    profitMargin?: true
    revenuePerMile?: true
    costPerMile?: true
    loadedMileRatio?: true
    deadheadMileRatio?: true
    utilizationRate?: true
    tripDistance?: true
    loadedMiles?: true
    deadheadMiles?: true
    tripDurationHours?: true
  }

  export type TripCostBreakdownSumAggregateInputType = {
    baseRevenue?: true
    mileageRevenue?: true
    priorityRevenue?: true
    specialRequirementsRevenue?: true
    insuranceAdjustment?: true
    totalRevenue?: true
    crewLaborCost?: true
    vehicleCost?: true
    fuelCost?: true
    maintenanceCost?: true
    overheadCost?: true
    totalCost?: true
    grossProfit?: true
    profitMargin?: true
    revenuePerMile?: true
    costPerMile?: true
    loadedMileRatio?: true
    deadheadMileRatio?: true
    utilizationRate?: true
    tripDistance?: true
    loadedMiles?: true
    deadheadMiles?: true
    tripDurationHours?: true
  }

  export type TripCostBreakdownMinAggregateInputType = {
    id?: true
    tripId?: true
    baseRevenue?: true
    mileageRevenue?: true
    priorityRevenue?: true
    specialRequirementsRevenue?: true
    insuranceAdjustment?: true
    totalRevenue?: true
    crewLaborCost?: true
    vehicleCost?: true
    fuelCost?: true
    maintenanceCost?: true
    overheadCost?: true
    totalCost?: true
    grossProfit?: true
    profitMargin?: true
    revenuePerMile?: true
    costPerMile?: true
    loadedMileRatio?: true
    deadheadMileRatio?: true
    utilizationRate?: true
    tripDistance?: true
    loadedMiles?: true
    deadheadMiles?: true
    tripDurationHours?: true
    transportLevel?: true
    priorityLevel?: true
    costCenterId?: true
    costCenterName?: true
    calculatedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TripCostBreakdownMaxAggregateInputType = {
    id?: true
    tripId?: true
    baseRevenue?: true
    mileageRevenue?: true
    priorityRevenue?: true
    specialRequirementsRevenue?: true
    insuranceAdjustment?: true
    totalRevenue?: true
    crewLaborCost?: true
    vehicleCost?: true
    fuelCost?: true
    maintenanceCost?: true
    overheadCost?: true
    totalCost?: true
    grossProfit?: true
    profitMargin?: true
    revenuePerMile?: true
    costPerMile?: true
    loadedMileRatio?: true
    deadheadMileRatio?: true
    utilizationRate?: true
    tripDistance?: true
    loadedMiles?: true
    deadheadMiles?: true
    tripDurationHours?: true
    transportLevel?: true
    priorityLevel?: true
    costCenterId?: true
    costCenterName?: true
    calculatedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TripCostBreakdownCountAggregateInputType = {
    id?: true
    tripId?: true
    baseRevenue?: true
    mileageRevenue?: true
    priorityRevenue?: true
    specialRequirementsRevenue?: true
    insuranceAdjustment?: true
    totalRevenue?: true
    crewLaborCost?: true
    vehicleCost?: true
    fuelCost?: true
    maintenanceCost?: true
    overheadCost?: true
    totalCost?: true
    grossProfit?: true
    profitMargin?: true
    revenuePerMile?: true
    costPerMile?: true
    loadedMileRatio?: true
    deadheadMileRatio?: true
    utilizationRate?: true
    tripDistance?: true
    loadedMiles?: true
    deadheadMiles?: true
    tripDurationHours?: true
    transportLevel?: true
    priorityLevel?: true
    costCenterId?: true
    costCenterName?: true
    calculatedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TripCostBreakdownAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TripCostBreakdown to aggregate.
     */
    where?: TripCostBreakdownWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TripCostBreakdowns to fetch.
     */
    orderBy?: TripCostBreakdownOrderByWithRelationInput | TripCostBreakdownOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TripCostBreakdownWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TripCostBreakdowns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TripCostBreakdowns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TripCostBreakdowns
    **/
    _count?: true | TripCostBreakdownCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TripCostBreakdownAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TripCostBreakdownSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TripCostBreakdownMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TripCostBreakdownMaxAggregateInputType
  }

  export type GetTripCostBreakdownAggregateType<T extends TripCostBreakdownAggregateArgs> = {
        [P in keyof T & keyof AggregateTripCostBreakdown]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTripCostBreakdown[P]>
      : GetScalarType<T[P], AggregateTripCostBreakdown[P]>
  }




  export type TripCostBreakdownGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TripCostBreakdownWhereInput
    orderBy?: TripCostBreakdownOrderByWithAggregationInput | TripCostBreakdownOrderByWithAggregationInput[]
    by: TripCostBreakdownScalarFieldEnum[] | TripCostBreakdownScalarFieldEnum
    having?: TripCostBreakdownScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TripCostBreakdownCountAggregateInputType | true
    _avg?: TripCostBreakdownAvgAggregateInputType
    _sum?: TripCostBreakdownSumAggregateInputType
    _min?: TripCostBreakdownMinAggregateInputType
    _max?: TripCostBreakdownMaxAggregateInputType
  }

  export type TripCostBreakdownGroupByOutputType = {
    id: string
    tripId: string
    baseRevenue: Decimal
    mileageRevenue: Decimal
    priorityRevenue: Decimal
    specialRequirementsRevenue: Decimal
    insuranceAdjustment: Decimal
    totalRevenue: Decimal
    crewLaborCost: Decimal
    vehicleCost: Decimal
    fuelCost: Decimal
    maintenanceCost: Decimal
    overheadCost: Decimal
    totalCost: Decimal
    grossProfit: Decimal
    profitMargin: Decimal
    revenuePerMile: Decimal
    costPerMile: Decimal
    loadedMileRatio: Decimal
    deadheadMileRatio: Decimal
    utilizationRate: Decimal
    tripDistance: Decimal
    loadedMiles: Decimal
    deadheadMiles: Decimal
    tripDurationHours: Decimal
    transportLevel: string
    priorityLevel: string
    costCenterId: string | null
    costCenterName: string | null
    calculatedAt: Date
    createdAt: Date
    updatedAt: Date
    _count: TripCostBreakdownCountAggregateOutputType | null
    _avg: TripCostBreakdownAvgAggregateOutputType | null
    _sum: TripCostBreakdownSumAggregateOutputType | null
    _min: TripCostBreakdownMinAggregateOutputType | null
    _max: TripCostBreakdownMaxAggregateOutputType | null
  }

  type GetTripCostBreakdownGroupByPayload<T extends TripCostBreakdownGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TripCostBreakdownGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TripCostBreakdownGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TripCostBreakdownGroupByOutputType[P]>
            : GetScalarType<T[P], TripCostBreakdownGroupByOutputType[P]>
        }
      >
    >


  export type TripCostBreakdownSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tripId?: boolean
    baseRevenue?: boolean
    mileageRevenue?: boolean
    priorityRevenue?: boolean
    specialRequirementsRevenue?: boolean
    insuranceAdjustment?: boolean
    totalRevenue?: boolean
    crewLaborCost?: boolean
    vehicleCost?: boolean
    fuelCost?: boolean
    maintenanceCost?: boolean
    overheadCost?: boolean
    totalCost?: boolean
    grossProfit?: boolean
    profitMargin?: boolean
    revenuePerMile?: boolean
    costPerMile?: boolean
    loadedMileRatio?: boolean
    deadheadMileRatio?: boolean
    utilizationRate?: boolean
    tripDistance?: boolean
    loadedMiles?: boolean
    deadheadMiles?: boolean
    tripDurationHours?: boolean
    transportLevel?: boolean
    priorityLevel?: boolean
    costCenterId?: boolean
    costCenterName?: boolean
    calculatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tripCostBreakdown"]>

  export type TripCostBreakdownSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tripId?: boolean
    baseRevenue?: boolean
    mileageRevenue?: boolean
    priorityRevenue?: boolean
    specialRequirementsRevenue?: boolean
    insuranceAdjustment?: boolean
    totalRevenue?: boolean
    crewLaborCost?: boolean
    vehicleCost?: boolean
    fuelCost?: boolean
    maintenanceCost?: boolean
    overheadCost?: boolean
    totalCost?: boolean
    grossProfit?: boolean
    profitMargin?: boolean
    revenuePerMile?: boolean
    costPerMile?: boolean
    loadedMileRatio?: boolean
    deadheadMileRatio?: boolean
    utilizationRate?: boolean
    tripDistance?: boolean
    loadedMiles?: boolean
    deadheadMiles?: boolean
    tripDurationHours?: boolean
    transportLevel?: boolean
    priorityLevel?: boolean
    costCenterId?: boolean
    costCenterName?: boolean
    calculatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tripCostBreakdown"]>

  export type TripCostBreakdownSelectScalar = {
    id?: boolean
    tripId?: boolean
    baseRevenue?: boolean
    mileageRevenue?: boolean
    priorityRevenue?: boolean
    specialRequirementsRevenue?: boolean
    insuranceAdjustment?: boolean
    totalRevenue?: boolean
    crewLaborCost?: boolean
    vehicleCost?: boolean
    fuelCost?: boolean
    maintenanceCost?: boolean
    overheadCost?: boolean
    totalCost?: boolean
    grossProfit?: boolean
    profitMargin?: boolean
    revenuePerMile?: boolean
    costPerMile?: boolean
    loadedMileRatio?: boolean
    deadheadMileRatio?: boolean
    utilizationRate?: boolean
    tripDistance?: boolean
    loadedMiles?: boolean
    deadheadMiles?: boolean
    tripDurationHours?: boolean
    transportLevel?: boolean
    priorityLevel?: boolean
    costCenterId?: boolean
    costCenterName?: boolean
    calculatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $TripCostBreakdownPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TripCostBreakdown"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tripId: string
      baseRevenue: Prisma.Decimal
      mileageRevenue: Prisma.Decimal
      priorityRevenue: Prisma.Decimal
      specialRequirementsRevenue: Prisma.Decimal
      insuranceAdjustment: Prisma.Decimal
      totalRevenue: Prisma.Decimal
      crewLaborCost: Prisma.Decimal
      vehicleCost: Prisma.Decimal
      fuelCost: Prisma.Decimal
      maintenanceCost: Prisma.Decimal
      overheadCost: Prisma.Decimal
      totalCost: Prisma.Decimal
      grossProfit: Prisma.Decimal
      profitMargin: Prisma.Decimal
      revenuePerMile: Prisma.Decimal
      costPerMile: Prisma.Decimal
      loadedMileRatio: Prisma.Decimal
      deadheadMileRatio: Prisma.Decimal
      utilizationRate: Prisma.Decimal
      tripDistance: Prisma.Decimal
      loadedMiles: Prisma.Decimal
      deadheadMiles: Prisma.Decimal
      tripDurationHours: Prisma.Decimal
      transportLevel: string
      priorityLevel: string
      costCenterId: string | null
      costCenterName: string | null
      calculatedAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tripCostBreakdown"]>
    composites: {}
  }

  type TripCostBreakdownGetPayload<S extends boolean | null | undefined | TripCostBreakdownDefaultArgs> = $Result.GetResult<Prisma.$TripCostBreakdownPayload, S>

  type TripCostBreakdownCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TripCostBreakdownFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TripCostBreakdownCountAggregateInputType | true
    }

  export interface TripCostBreakdownDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TripCostBreakdown'], meta: { name: 'TripCostBreakdown' } }
    /**
     * Find zero or one TripCostBreakdown that matches the filter.
     * @param {TripCostBreakdownFindUniqueArgs} args - Arguments to find a TripCostBreakdown
     * @example
     * // Get one TripCostBreakdown
     * const tripCostBreakdown = await prisma.tripCostBreakdown.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TripCostBreakdownFindUniqueArgs>(args: SelectSubset<T, TripCostBreakdownFindUniqueArgs<ExtArgs>>): Prisma__TripCostBreakdownClient<$Result.GetResult<Prisma.$TripCostBreakdownPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TripCostBreakdown that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TripCostBreakdownFindUniqueOrThrowArgs} args - Arguments to find a TripCostBreakdown
     * @example
     * // Get one TripCostBreakdown
     * const tripCostBreakdown = await prisma.tripCostBreakdown.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TripCostBreakdownFindUniqueOrThrowArgs>(args: SelectSubset<T, TripCostBreakdownFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TripCostBreakdownClient<$Result.GetResult<Prisma.$TripCostBreakdownPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TripCostBreakdown that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripCostBreakdownFindFirstArgs} args - Arguments to find a TripCostBreakdown
     * @example
     * // Get one TripCostBreakdown
     * const tripCostBreakdown = await prisma.tripCostBreakdown.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TripCostBreakdownFindFirstArgs>(args?: SelectSubset<T, TripCostBreakdownFindFirstArgs<ExtArgs>>): Prisma__TripCostBreakdownClient<$Result.GetResult<Prisma.$TripCostBreakdownPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TripCostBreakdown that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripCostBreakdownFindFirstOrThrowArgs} args - Arguments to find a TripCostBreakdown
     * @example
     * // Get one TripCostBreakdown
     * const tripCostBreakdown = await prisma.tripCostBreakdown.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TripCostBreakdownFindFirstOrThrowArgs>(args?: SelectSubset<T, TripCostBreakdownFindFirstOrThrowArgs<ExtArgs>>): Prisma__TripCostBreakdownClient<$Result.GetResult<Prisma.$TripCostBreakdownPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TripCostBreakdowns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripCostBreakdownFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TripCostBreakdowns
     * const tripCostBreakdowns = await prisma.tripCostBreakdown.findMany()
     * 
     * // Get first 10 TripCostBreakdowns
     * const tripCostBreakdowns = await prisma.tripCostBreakdown.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tripCostBreakdownWithIdOnly = await prisma.tripCostBreakdown.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TripCostBreakdownFindManyArgs>(args?: SelectSubset<T, TripCostBreakdownFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripCostBreakdownPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TripCostBreakdown.
     * @param {TripCostBreakdownCreateArgs} args - Arguments to create a TripCostBreakdown.
     * @example
     * // Create one TripCostBreakdown
     * const TripCostBreakdown = await prisma.tripCostBreakdown.create({
     *   data: {
     *     // ... data to create a TripCostBreakdown
     *   }
     * })
     * 
     */
    create<T extends TripCostBreakdownCreateArgs>(args: SelectSubset<T, TripCostBreakdownCreateArgs<ExtArgs>>): Prisma__TripCostBreakdownClient<$Result.GetResult<Prisma.$TripCostBreakdownPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TripCostBreakdowns.
     * @param {TripCostBreakdownCreateManyArgs} args - Arguments to create many TripCostBreakdowns.
     * @example
     * // Create many TripCostBreakdowns
     * const tripCostBreakdown = await prisma.tripCostBreakdown.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TripCostBreakdownCreateManyArgs>(args?: SelectSubset<T, TripCostBreakdownCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TripCostBreakdowns and returns the data saved in the database.
     * @param {TripCostBreakdownCreateManyAndReturnArgs} args - Arguments to create many TripCostBreakdowns.
     * @example
     * // Create many TripCostBreakdowns
     * const tripCostBreakdown = await prisma.tripCostBreakdown.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TripCostBreakdowns and only return the `id`
     * const tripCostBreakdownWithIdOnly = await prisma.tripCostBreakdown.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TripCostBreakdownCreateManyAndReturnArgs>(args?: SelectSubset<T, TripCostBreakdownCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripCostBreakdownPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TripCostBreakdown.
     * @param {TripCostBreakdownDeleteArgs} args - Arguments to delete one TripCostBreakdown.
     * @example
     * // Delete one TripCostBreakdown
     * const TripCostBreakdown = await prisma.tripCostBreakdown.delete({
     *   where: {
     *     // ... filter to delete one TripCostBreakdown
     *   }
     * })
     * 
     */
    delete<T extends TripCostBreakdownDeleteArgs>(args: SelectSubset<T, TripCostBreakdownDeleteArgs<ExtArgs>>): Prisma__TripCostBreakdownClient<$Result.GetResult<Prisma.$TripCostBreakdownPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TripCostBreakdown.
     * @param {TripCostBreakdownUpdateArgs} args - Arguments to update one TripCostBreakdown.
     * @example
     * // Update one TripCostBreakdown
     * const tripCostBreakdown = await prisma.tripCostBreakdown.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TripCostBreakdownUpdateArgs>(args: SelectSubset<T, TripCostBreakdownUpdateArgs<ExtArgs>>): Prisma__TripCostBreakdownClient<$Result.GetResult<Prisma.$TripCostBreakdownPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TripCostBreakdowns.
     * @param {TripCostBreakdownDeleteManyArgs} args - Arguments to filter TripCostBreakdowns to delete.
     * @example
     * // Delete a few TripCostBreakdowns
     * const { count } = await prisma.tripCostBreakdown.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TripCostBreakdownDeleteManyArgs>(args?: SelectSubset<T, TripCostBreakdownDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TripCostBreakdowns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripCostBreakdownUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TripCostBreakdowns
     * const tripCostBreakdown = await prisma.tripCostBreakdown.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TripCostBreakdownUpdateManyArgs>(args: SelectSubset<T, TripCostBreakdownUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TripCostBreakdown.
     * @param {TripCostBreakdownUpsertArgs} args - Arguments to update or create a TripCostBreakdown.
     * @example
     * // Update or create a TripCostBreakdown
     * const tripCostBreakdown = await prisma.tripCostBreakdown.upsert({
     *   create: {
     *     // ... data to create a TripCostBreakdown
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TripCostBreakdown we want to update
     *   }
     * })
     */
    upsert<T extends TripCostBreakdownUpsertArgs>(args: SelectSubset<T, TripCostBreakdownUpsertArgs<ExtArgs>>): Prisma__TripCostBreakdownClient<$Result.GetResult<Prisma.$TripCostBreakdownPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TripCostBreakdowns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripCostBreakdownCountArgs} args - Arguments to filter TripCostBreakdowns to count.
     * @example
     * // Count the number of TripCostBreakdowns
     * const count = await prisma.tripCostBreakdown.count({
     *   where: {
     *     // ... the filter for the TripCostBreakdowns we want to count
     *   }
     * })
    **/
    count<T extends TripCostBreakdownCountArgs>(
      args?: Subset<T, TripCostBreakdownCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TripCostBreakdownCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TripCostBreakdown.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripCostBreakdownAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TripCostBreakdownAggregateArgs>(args: Subset<T, TripCostBreakdownAggregateArgs>): Prisma.PrismaPromise<GetTripCostBreakdownAggregateType<T>>

    /**
     * Group by TripCostBreakdown.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripCostBreakdownGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TripCostBreakdownGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TripCostBreakdownGroupByArgs['orderBy'] }
        : { orderBy?: TripCostBreakdownGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TripCostBreakdownGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTripCostBreakdownGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TripCostBreakdown model
   */
  readonly fields: TripCostBreakdownFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TripCostBreakdown.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TripCostBreakdownClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TripCostBreakdown model
   */ 
  interface TripCostBreakdownFieldRefs {
    readonly id: FieldRef<"TripCostBreakdown", 'String'>
    readonly tripId: FieldRef<"TripCostBreakdown", 'String'>
    readonly baseRevenue: FieldRef<"TripCostBreakdown", 'Decimal'>
    readonly mileageRevenue: FieldRef<"TripCostBreakdown", 'Decimal'>
    readonly priorityRevenue: FieldRef<"TripCostBreakdown", 'Decimal'>
    readonly specialRequirementsRevenue: FieldRef<"TripCostBreakdown", 'Decimal'>
    readonly insuranceAdjustment: FieldRef<"TripCostBreakdown", 'Decimal'>
    readonly totalRevenue: FieldRef<"TripCostBreakdown", 'Decimal'>
    readonly crewLaborCost: FieldRef<"TripCostBreakdown", 'Decimal'>
    readonly vehicleCost: FieldRef<"TripCostBreakdown", 'Decimal'>
    readonly fuelCost: FieldRef<"TripCostBreakdown", 'Decimal'>
    readonly maintenanceCost: FieldRef<"TripCostBreakdown", 'Decimal'>
    readonly overheadCost: FieldRef<"TripCostBreakdown", 'Decimal'>
    readonly totalCost: FieldRef<"TripCostBreakdown", 'Decimal'>
    readonly grossProfit: FieldRef<"TripCostBreakdown", 'Decimal'>
    readonly profitMargin: FieldRef<"TripCostBreakdown", 'Decimal'>
    readonly revenuePerMile: FieldRef<"TripCostBreakdown", 'Decimal'>
    readonly costPerMile: FieldRef<"TripCostBreakdown", 'Decimal'>
    readonly loadedMileRatio: FieldRef<"TripCostBreakdown", 'Decimal'>
    readonly deadheadMileRatio: FieldRef<"TripCostBreakdown", 'Decimal'>
    readonly utilizationRate: FieldRef<"TripCostBreakdown", 'Decimal'>
    readonly tripDistance: FieldRef<"TripCostBreakdown", 'Decimal'>
    readonly loadedMiles: FieldRef<"TripCostBreakdown", 'Decimal'>
    readonly deadheadMiles: FieldRef<"TripCostBreakdown", 'Decimal'>
    readonly tripDurationHours: FieldRef<"TripCostBreakdown", 'Decimal'>
    readonly transportLevel: FieldRef<"TripCostBreakdown", 'String'>
    readonly priorityLevel: FieldRef<"TripCostBreakdown", 'String'>
    readonly costCenterId: FieldRef<"TripCostBreakdown", 'String'>
    readonly costCenterName: FieldRef<"TripCostBreakdown", 'String'>
    readonly calculatedAt: FieldRef<"TripCostBreakdown", 'DateTime'>
    readonly createdAt: FieldRef<"TripCostBreakdown", 'DateTime'>
    readonly updatedAt: FieldRef<"TripCostBreakdown", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TripCostBreakdown findUnique
   */
  export type TripCostBreakdownFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripCostBreakdown
     */
    select?: TripCostBreakdownSelect<ExtArgs> | null
    /**
     * Filter, which TripCostBreakdown to fetch.
     */
    where: TripCostBreakdownWhereUniqueInput
  }

  /**
   * TripCostBreakdown findUniqueOrThrow
   */
  export type TripCostBreakdownFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripCostBreakdown
     */
    select?: TripCostBreakdownSelect<ExtArgs> | null
    /**
     * Filter, which TripCostBreakdown to fetch.
     */
    where: TripCostBreakdownWhereUniqueInput
  }

  /**
   * TripCostBreakdown findFirst
   */
  export type TripCostBreakdownFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripCostBreakdown
     */
    select?: TripCostBreakdownSelect<ExtArgs> | null
    /**
     * Filter, which TripCostBreakdown to fetch.
     */
    where?: TripCostBreakdownWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TripCostBreakdowns to fetch.
     */
    orderBy?: TripCostBreakdownOrderByWithRelationInput | TripCostBreakdownOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TripCostBreakdowns.
     */
    cursor?: TripCostBreakdownWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TripCostBreakdowns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TripCostBreakdowns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TripCostBreakdowns.
     */
    distinct?: TripCostBreakdownScalarFieldEnum | TripCostBreakdownScalarFieldEnum[]
  }

  /**
   * TripCostBreakdown findFirstOrThrow
   */
  export type TripCostBreakdownFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripCostBreakdown
     */
    select?: TripCostBreakdownSelect<ExtArgs> | null
    /**
     * Filter, which TripCostBreakdown to fetch.
     */
    where?: TripCostBreakdownWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TripCostBreakdowns to fetch.
     */
    orderBy?: TripCostBreakdownOrderByWithRelationInput | TripCostBreakdownOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TripCostBreakdowns.
     */
    cursor?: TripCostBreakdownWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TripCostBreakdowns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TripCostBreakdowns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TripCostBreakdowns.
     */
    distinct?: TripCostBreakdownScalarFieldEnum | TripCostBreakdownScalarFieldEnum[]
  }

  /**
   * TripCostBreakdown findMany
   */
  export type TripCostBreakdownFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripCostBreakdown
     */
    select?: TripCostBreakdownSelect<ExtArgs> | null
    /**
     * Filter, which TripCostBreakdowns to fetch.
     */
    where?: TripCostBreakdownWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TripCostBreakdowns to fetch.
     */
    orderBy?: TripCostBreakdownOrderByWithRelationInput | TripCostBreakdownOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TripCostBreakdowns.
     */
    cursor?: TripCostBreakdownWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TripCostBreakdowns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TripCostBreakdowns.
     */
    skip?: number
    distinct?: TripCostBreakdownScalarFieldEnum | TripCostBreakdownScalarFieldEnum[]
  }

  /**
   * TripCostBreakdown create
   */
  export type TripCostBreakdownCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripCostBreakdown
     */
    select?: TripCostBreakdownSelect<ExtArgs> | null
    /**
     * The data needed to create a TripCostBreakdown.
     */
    data: XOR<TripCostBreakdownCreateInput, TripCostBreakdownUncheckedCreateInput>
  }

  /**
   * TripCostBreakdown createMany
   */
  export type TripCostBreakdownCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TripCostBreakdowns.
     */
    data: TripCostBreakdownCreateManyInput | TripCostBreakdownCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TripCostBreakdown createManyAndReturn
   */
  export type TripCostBreakdownCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripCostBreakdown
     */
    select?: TripCostBreakdownSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TripCostBreakdowns.
     */
    data: TripCostBreakdownCreateManyInput | TripCostBreakdownCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TripCostBreakdown update
   */
  export type TripCostBreakdownUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripCostBreakdown
     */
    select?: TripCostBreakdownSelect<ExtArgs> | null
    /**
     * The data needed to update a TripCostBreakdown.
     */
    data: XOR<TripCostBreakdownUpdateInput, TripCostBreakdownUncheckedUpdateInput>
    /**
     * Choose, which TripCostBreakdown to update.
     */
    where: TripCostBreakdownWhereUniqueInput
  }

  /**
   * TripCostBreakdown updateMany
   */
  export type TripCostBreakdownUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TripCostBreakdowns.
     */
    data: XOR<TripCostBreakdownUpdateManyMutationInput, TripCostBreakdownUncheckedUpdateManyInput>
    /**
     * Filter which TripCostBreakdowns to update
     */
    where?: TripCostBreakdownWhereInput
  }

  /**
   * TripCostBreakdown upsert
   */
  export type TripCostBreakdownUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripCostBreakdown
     */
    select?: TripCostBreakdownSelect<ExtArgs> | null
    /**
     * The filter to search for the TripCostBreakdown to update in case it exists.
     */
    where: TripCostBreakdownWhereUniqueInput
    /**
     * In case the TripCostBreakdown found by the `where` argument doesn't exist, create a new TripCostBreakdown with this data.
     */
    create: XOR<TripCostBreakdownCreateInput, TripCostBreakdownUncheckedCreateInput>
    /**
     * In case the TripCostBreakdown was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TripCostBreakdownUpdateInput, TripCostBreakdownUncheckedUpdateInput>
  }

  /**
   * TripCostBreakdown delete
   */
  export type TripCostBreakdownDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripCostBreakdown
     */
    select?: TripCostBreakdownSelect<ExtArgs> | null
    /**
     * Filter which TripCostBreakdown to delete.
     */
    where: TripCostBreakdownWhereUniqueInput
  }

  /**
   * TripCostBreakdown deleteMany
   */
  export type TripCostBreakdownDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TripCostBreakdowns to delete
     */
    where?: TripCostBreakdownWhereInput
  }

  /**
   * TripCostBreakdown without action
   */
  export type TripCostBreakdownDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripCostBreakdown
     */
    select?: TripCostBreakdownSelect<ExtArgs> | null
  }


  /**
   * Model CostCenter
   */

  export type AggregateCostCenter = {
    _count: CostCenterCountAggregateOutputType | null
    _avg: CostCenterAvgAggregateOutputType | null
    _sum: CostCenterSumAggregateOutputType | null
    _min: CostCenterMinAggregateOutputType | null
    _max: CostCenterMaxAggregateOutputType | null
  }

  export type CostCenterAvgAggregateOutputType = {
    overheadRate: Decimal | null
    fixedCosts: Decimal | null
    variableCosts: Decimal | null
  }

  export type CostCenterSumAggregateOutputType = {
    overheadRate: Decimal | null
    fixedCosts: Decimal | null
    variableCosts: Decimal | null
  }

  export type CostCenterMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    code: string | null
    overheadRate: Decimal | null
    fixedCosts: Decimal | null
    variableCosts: Decimal | null
    allocationMethod: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CostCenterMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    code: string | null
    overheadRate: Decimal | null
    fixedCosts: Decimal | null
    variableCosts: Decimal | null
    allocationMethod: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CostCenterCountAggregateOutputType = {
    id: number
    name: number
    description: number
    code: number
    overheadRate: number
    fixedCosts: number
    variableCosts: number
    allocationMethod: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CostCenterAvgAggregateInputType = {
    overheadRate?: true
    fixedCosts?: true
    variableCosts?: true
  }

  export type CostCenterSumAggregateInputType = {
    overheadRate?: true
    fixedCosts?: true
    variableCosts?: true
  }

  export type CostCenterMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    code?: true
    overheadRate?: true
    fixedCosts?: true
    variableCosts?: true
    allocationMethod?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CostCenterMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    code?: true
    overheadRate?: true
    fixedCosts?: true
    variableCosts?: true
    allocationMethod?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CostCenterCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    code?: true
    overheadRate?: true
    fixedCosts?: true
    variableCosts?: true
    allocationMethod?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CostCenterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CostCenter to aggregate.
     */
    where?: CostCenterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostCenters to fetch.
     */
    orderBy?: CostCenterOrderByWithRelationInput | CostCenterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CostCenterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostCenters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostCenters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CostCenters
    **/
    _count?: true | CostCenterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CostCenterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CostCenterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CostCenterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CostCenterMaxAggregateInputType
  }

  export type GetCostCenterAggregateType<T extends CostCenterAggregateArgs> = {
        [P in keyof T & keyof AggregateCostCenter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCostCenter[P]>
      : GetScalarType<T[P], AggregateCostCenter[P]>
  }




  export type CostCenterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CostCenterWhereInput
    orderBy?: CostCenterOrderByWithAggregationInput | CostCenterOrderByWithAggregationInput[]
    by: CostCenterScalarFieldEnum[] | CostCenterScalarFieldEnum
    having?: CostCenterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CostCenterCountAggregateInputType | true
    _avg?: CostCenterAvgAggregateInputType
    _sum?: CostCenterSumAggregateInputType
    _min?: CostCenterMinAggregateInputType
    _max?: CostCenterMaxAggregateInputType
  }

  export type CostCenterGroupByOutputType = {
    id: string
    name: string
    description: string | null
    code: string
    overheadRate: Decimal
    fixedCosts: Decimal
    variableCosts: Decimal
    allocationMethod: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: CostCenterCountAggregateOutputType | null
    _avg: CostCenterAvgAggregateOutputType | null
    _sum: CostCenterSumAggregateOutputType | null
    _min: CostCenterMinAggregateOutputType | null
    _max: CostCenterMaxAggregateOutputType | null
  }

  type GetCostCenterGroupByPayload<T extends CostCenterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CostCenterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CostCenterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CostCenterGroupByOutputType[P]>
            : GetScalarType<T[P], CostCenterGroupByOutputType[P]>
        }
      >
    >


  export type CostCenterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    code?: boolean
    overheadRate?: boolean
    fixedCosts?: boolean
    variableCosts?: boolean
    allocationMethod?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["costCenter"]>

  export type CostCenterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    code?: boolean
    overheadRate?: boolean
    fixedCosts?: boolean
    variableCosts?: boolean
    allocationMethod?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["costCenter"]>

  export type CostCenterSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    code?: boolean
    overheadRate?: boolean
    fixedCosts?: boolean
    variableCosts?: boolean
    allocationMethod?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $CostCenterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CostCenter"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      code: string
      overheadRate: Prisma.Decimal
      fixedCosts: Prisma.Decimal
      variableCosts: Prisma.Decimal
      allocationMethod: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["costCenter"]>
    composites: {}
  }

  type CostCenterGetPayload<S extends boolean | null | undefined | CostCenterDefaultArgs> = $Result.GetResult<Prisma.$CostCenterPayload, S>

  type CostCenterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CostCenterFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CostCenterCountAggregateInputType | true
    }

  export interface CostCenterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CostCenter'], meta: { name: 'CostCenter' } }
    /**
     * Find zero or one CostCenter that matches the filter.
     * @param {CostCenterFindUniqueArgs} args - Arguments to find a CostCenter
     * @example
     * // Get one CostCenter
     * const costCenter = await prisma.costCenter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CostCenterFindUniqueArgs>(args: SelectSubset<T, CostCenterFindUniqueArgs<ExtArgs>>): Prisma__CostCenterClient<$Result.GetResult<Prisma.$CostCenterPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CostCenter that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CostCenterFindUniqueOrThrowArgs} args - Arguments to find a CostCenter
     * @example
     * // Get one CostCenter
     * const costCenter = await prisma.costCenter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CostCenterFindUniqueOrThrowArgs>(args: SelectSubset<T, CostCenterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CostCenterClient<$Result.GetResult<Prisma.$CostCenterPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CostCenter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostCenterFindFirstArgs} args - Arguments to find a CostCenter
     * @example
     * // Get one CostCenter
     * const costCenter = await prisma.costCenter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CostCenterFindFirstArgs>(args?: SelectSubset<T, CostCenterFindFirstArgs<ExtArgs>>): Prisma__CostCenterClient<$Result.GetResult<Prisma.$CostCenterPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CostCenter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostCenterFindFirstOrThrowArgs} args - Arguments to find a CostCenter
     * @example
     * // Get one CostCenter
     * const costCenter = await prisma.costCenter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CostCenterFindFirstOrThrowArgs>(args?: SelectSubset<T, CostCenterFindFirstOrThrowArgs<ExtArgs>>): Prisma__CostCenterClient<$Result.GetResult<Prisma.$CostCenterPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CostCenters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostCenterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CostCenters
     * const costCenters = await prisma.costCenter.findMany()
     * 
     * // Get first 10 CostCenters
     * const costCenters = await prisma.costCenter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const costCenterWithIdOnly = await prisma.costCenter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CostCenterFindManyArgs>(args?: SelectSubset<T, CostCenterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostCenterPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CostCenter.
     * @param {CostCenterCreateArgs} args - Arguments to create a CostCenter.
     * @example
     * // Create one CostCenter
     * const CostCenter = await prisma.costCenter.create({
     *   data: {
     *     // ... data to create a CostCenter
     *   }
     * })
     * 
     */
    create<T extends CostCenterCreateArgs>(args: SelectSubset<T, CostCenterCreateArgs<ExtArgs>>): Prisma__CostCenterClient<$Result.GetResult<Prisma.$CostCenterPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CostCenters.
     * @param {CostCenterCreateManyArgs} args - Arguments to create many CostCenters.
     * @example
     * // Create many CostCenters
     * const costCenter = await prisma.costCenter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CostCenterCreateManyArgs>(args?: SelectSubset<T, CostCenterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CostCenters and returns the data saved in the database.
     * @param {CostCenterCreateManyAndReturnArgs} args - Arguments to create many CostCenters.
     * @example
     * // Create many CostCenters
     * const costCenter = await prisma.costCenter.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CostCenters and only return the `id`
     * const costCenterWithIdOnly = await prisma.costCenter.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CostCenterCreateManyAndReturnArgs>(args?: SelectSubset<T, CostCenterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostCenterPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CostCenter.
     * @param {CostCenterDeleteArgs} args - Arguments to delete one CostCenter.
     * @example
     * // Delete one CostCenter
     * const CostCenter = await prisma.costCenter.delete({
     *   where: {
     *     // ... filter to delete one CostCenter
     *   }
     * })
     * 
     */
    delete<T extends CostCenterDeleteArgs>(args: SelectSubset<T, CostCenterDeleteArgs<ExtArgs>>): Prisma__CostCenterClient<$Result.GetResult<Prisma.$CostCenterPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CostCenter.
     * @param {CostCenterUpdateArgs} args - Arguments to update one CostCenter.
     * @example
     * // Update one CostCenter
     * const costCenter = await prisma.costCenter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CostCenterUpdateArgs>(args: SelectSubset<T, CostCenterUpdateArgs<ExtArgs>>): Prisma__CostCenterClient<$Result.GetResult<Prisma.$CostCenterPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CostCenters.
     * @param {CostCenterDeleteManyArgs} args - Arguments to filter CostCenters to delete.
     * @example
     * // Delete a few CostCenters
     * const { count } = await prisma.costCenter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CostCenterDeleteManyArgs>(args?: SelectSubset<T, CostCenterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CostCenters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostCenterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CostCenters
     * const costCenter = await prisma.costCenter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CostCenterUpdateManyArgs>(args: SelectSubset<T, CostCenterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CostCenter.
     * @param {CostCenterUpsertArgs} args - Arguments to update or create a CostCenter.
     * @example
     * // Update or create a CostCenter
     * const costCenter = await prisma.costCenter.upsert({
     *   create: {
     *     // ... data to create a CostCenter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CostCenter we want to update
     *   }
     * })
     */
    upsert<T extends CostCenterUpsertArgs>(args: SelectSubset<T, CostCenterUpsertArgs<ExtArgs>>): Prisma__CostCenterClient<$Result.GetResult<Prisma.$CostCenterPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CostCenters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostCenterCountArgs} args - Arguments to filter CostCenters to count.
     * @example
     * // Count the number of CostCenters
     * const count = await prisma.costCenter.count({
     *   where: {
     *     // ... the filter for the CostCenters we want to count
     *   }
     * })
    **/
    count<T extends CostCenterCountArgs>(
      args?: Subset<T, CostCenterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CostCenterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CostCenter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostCenterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CostCenterAggregateArgs>(args: Subset<T, CostCenterAggregateArgs>): Prisma.PrismaPromise<GetCostCenterAggregateType<T>>

    /**
     * Group by CostCenter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostCenterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CostCenterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CostCenterGroupByArgs['orderBy'] }
        : { orderBy?: CostCenterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CostCenterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCostCenterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CostCenter model
   */
  readonly fields: CostCenterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CostCenter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CostCenterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CostCenter model
   */ 
  interface CostCenterFieldRefs {
    readonly id: FieldRef<"CostCenter", 'String'>
    readonly name: FieldRef<"CostCenter", 'String'>
    readonly description: FieldRef<"CostCenter", 'String'>
    readonly code: FieldRef<"CostCenter", 'String'>
    readonly overheadRate: FieldRef<"CostCenter", 'Decimal'>
    readonly fixedCosts: FieldRef<"CostCenter", 'Decimal'>
    readonly variableCosts: FieldRef<"CostCenter", 'Decimal'>
    readonly allocationMethod: FieldRef<"CostCenter", 'String'>
    readonly isActive: FieldRef<"CostCenter", 'Boolean'>
    readonly createdAt: FieldRef<"CostCenter", 'DateTime'>
    readonly updatedAt: FieldRef<"CostCenter", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CostCenter findUnique
   */
  export type CostCenterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostCenter
     */
    select?: CostCenterSelect<ExtArgs> | null
    /**
     * Filter, which CostCenter to fetch.
     */
    where: CostCenterWhereUniqueInput
  }

  /**
   * CostCenter findUniqueOrThrow
   */
  export type CostCenterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostCenter
     */
    select?: CostCenterSelect<ExtArgs> | null
    /**
     * Filter, which CostCenter to fetch.
     */
    where: CostCenterWhereUniqueInput
  }

  /**
   * CostCenter findFirst
   */
  export type CostCenterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostCenter
     */
    select?: CostCenterSelect<ExtArgs> | null
    /**
     * Filter, which CostCenter to fetch.
     */
    where?: CostCenterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostCenters to fetch.
     */
    orderBy?: CostCenterOrderByWithRelationInput | CostCenterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CostCenters.
     */
    cursor?: CostCenterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostCenters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostCenters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CostCenters.
     */
    distinct?: CostCenterScalarFieldEnum | CostCenterScalarFieldEnum[]
  }

  /**
   * CostCenter findFirstOrThrow
   */
  export type CostCenterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostCenter
     */
    select?: CostCenterSelect<ExtArgs> | null
    /**
     * Filter, which CostCenter to fetch.
     */
    where?: CostCenterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostCenters to fetch.
     */
    orderBy?: CostCenterOrderByWithRelationInput | CostCenterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CostCenters.
     */
    cursor?: CostCenterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostCenters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostCenters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CostCenters.
     */
    distinct?: CostCenterScalarFieldEnum | CostCenterScalarFieldEnum[]
  }

  /**
   * CostCenter findMany
   */
  export type CostCenterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostCenter
     */
    select?: CostCenterSelect<ExtArgs> | null
    /**
     * Filter, which CostCenters to fetch.
     */
    where?: CostCenterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostCenters to fetch.
     */
    orderBy?: CostCenterOrderByWithRelationInput | CostCenterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CostCenters.
     */
    cursor?: CostCenterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostCenters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostCenters.
     */
    skip?: number
    distinct?: CostCenterScalarFieldEnum | CostCenterScalarFieldEnum[]
  }

  /**
   * CostCenter create
   */
  export type CostCenterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostCenter
     */
    select?: CostCenterSelect<ExtArgs> | null
    /**
     * The data needed to create a CostCenter.
     */
    data: XOR<CostCenterCreateInput, CostCenterUncheckedCreateInput>
  }

  /**
   * CostCenter createMany
   */
  export type CostCenterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CostCenters.
     */
    data: CostCenterCreateManyInput | CostCenterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CostCenter createManyAndReturn
   */
  export type CostCenterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostCenter
     */
    select?: CostCenterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CostCenters.
     */
    data: CostCenterCreateManyInput | CostCenterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CostCenter update
   */
  export type CostCenterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostCenter
     */
    select?: CostCenterSelect<ExtArgs> | null
    /**
     * The data needed to update a CostCenter.
     */
    data: XOR<CostCenterUpdateInput, CostCenterUncheckedUpdateInput>
    /**
     * Choose, which CostCenter to update.
     */
    where: CostCenterWhereUniqueInput
  }

  /**
   * CostCenter updateMany
   */
  export type CostCenterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CostCenters.
     */
    data: XOR<CostCenterUpdateManyMutationInput, CostCenterUncheckedUpdateManyInput>
    /**
     * Filter which CostCenters to update
     */
    where?: CostCenterWhereInput
  }

  /**
   * CostCenter upsert
   */
  export type CostCenterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostCenter
     */
    select?: CostCenterSelect<ExtArgs> | null
    /**
     * The filter to search for the CostCenter to update in case it exists.
     */
    where: CostCenterWhereUniqueInput
    /**
     * In case the CostCenter found by the `where` argument doesn't exist, create a new CostCenter with this data.
     */
    create: XOR<CostCenterCreateInput, CostCenterUncheckedCreateInput>
    /**
     * In case the CostCenter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CostCenterUpdateInput, CostCenterUncheckedUpdateInput>
  }

  /**
   * CostCenter delete
   */
  export type CostCenterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostCenter
     */
    select?: CostCenterSelect<ExtArgs> | null
    /**
     * Filter which CostCenter to delete.
     */
    where: CostCenterWhereUniqueInput
  }

  /**
   * CostCenter deleteMany
   */
  export type CostCenterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CostCenters to delete
     */
    where?: CostCenterWhereInput
  }

  /**
   * CostCenter without action
   */
  export type CostCenterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostCenter
     */
    select?: CostCenterSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const CenterUserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    name: 'name',
    userType: 'userType',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CenterUserScalarFieldEnum = (typeof CenterUserScalarFieldEnum)[keyof typeof CenterUserScalarFieldEnum]


  export const HospitalScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    city: 'city',
    state: 'state',
    zipCode: 'zipCode',
    phone: 'phone',
    email: 'email',
    type: 'type',
    capabilities: 'capabilities',
    region: 'region',
    coordinates: 'coordinates',
    latitude: 'latitude',
    longitude: 'longitude',
    operatingHours: 'operatingHours',
    isActive: 'isActive',
    requiresReview: 'requiresReview',
    approvedAt: 'approvedAt',
    approvedBy: 'approvedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HospitalScalarFieldEnum = (typeof HospitalScalarFieldEnum)[keyof typeof HospitalScalarFieldEnum]


  export const PickupLocationScalarFieldEnum: {
    id: 'id',
    hospitalId: 'hospitalId',
    name: 'name',
    description: 'description',
    contactPhone: 'contactPhone',
    contactEmail: 'contactEmail',
    floor: 'floor',
    room: 'room',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PickupLocationScalarFieldEnum = (typeof PickupLocationScalarFieldEnum)[keyof typeof PickupLocationScalarFieldEnum]


  export const EMSAgencyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    contactName: 'contactName',
    phone: 'phone',
    email: 'email',
    address: 'address',
    city: 'city',
    state: 'state',
    zipCode: 'zipCode',
    serviceArea: 'serviceArea',
    operatingHours: 'operatingHours',
    capabilities: 'capabilities',
    pricingStructure: 'pricingStructure',
    latitude: 'latitude',
    longitude: 'longitude',
    serviceRadius: 'serviceRadius',
    totalUnits: 'totalUnits',
    availableUnits: 'availableUnits',
    lastUpdated: 'lastUpdated',
    acceptsNotifications: 'acceptsNotifications',
    notificationMethods: 'notificationMethods',
    isActive: 'isActive',
    status: 'status',
    requiresReview: 'requiresReview',
    approvedAt: 'approvedAt',
    approvedBy: 'approvedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EMSAgencyScalarFieldEnum = (typeof EMSAgencyScalarFieldEnum)[keyof typeof EMSAgencyScalarFieldEnum]


  export const TripScalarFieldEnum: {
    id: 'id',
    tripNumber: 'tripNumber',
    patientId: 'patientId',
    patientWeight: 'patientWeight',
    specialNeeds: 'specialNeeds',
    insuranceCompany: 'insuranceCompany',
    fromLocation: 'fromLocation',
    pickupLocationId: 'pickupLocationId',
    toLocation: 'toLocation',
    scheduledTime: 'scheduledTime',
    transportLevel: 'transportLevel',
    urgencyLevel: 'urgencyLevel',
    originLatitude: 'originLatitude',
    originLongitude: 'originLongitude',
    destinationLatitude: 'destinationLatitude',
    destinationLongitude: 'destinationLongitude',
    diagnosis: 'diagnosis',
    mobilityLevel: 'mobilityLevel',
    oxygenRequired: 'oxygenRequired',
    monitoringRequired: 'monitoringRequired',
    generateQRCode: 'generateQRCode',
    qrCodeData: 'qrCodeData',
    selectedAgencies: 'selectedAgencies',
    notificationRadius: 'notificationRadius',
    transferRequestTime: 'transferRequestTime',
    transferAcceptedTime: 'transferAcceptedTime',
    emsArrivalTime: 'emsArrivalTime',
    emsDepartureTime: 'emsDepartureTime',
    tripCost: 'tripCost',
    distanceMiles: 'distanceMiles',
    responseTimeMinutes: 'responseTimeMinutes',
    deadheadMiles: 'deadheadMiles',
    insurancePayRate: 'insurancePayRate',
    perMileRate: 'perMileRate',
    requestTimestamp: 'requestTimestamp',
    estimatedTripTimeMinutes: 'estimatedTripTimeMinutes',
    actualTripTimeMinutes: 'actualTripTimeMinutes',
    completionTimeMinutes: 'completionTimeMinutes',
    loadedMiles: 'loadedMiles',
    customerSatisfaction: 'customerSatisfaction',
    efficiency: 'efficiency',
    performanceScore: 'performanceScore',
    revenuePerHour: 'revenuePerHour',
    backhaulOpportunity: 'backhaulOpportunity',
    actualStartTime: 'actualStartTime',
    actualEndTime: 'actualEndTime',
    status: 'status',
    priority: 'priority',
    notes: 'notes',
    assignedTo: 'assignedTo',
    assignedAgencyId: 'assignedAgencyId',
    assignedUnitId: 'assignedUnitId',
    acceptedTimestamp: 'acceptedTimestamp',
    pickupTimestamp: 'pickupTimestamp',
    completionTimestamp: 'completionTimestamp',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TripScalarFieldEnum = (typeof TripScalarFieldEnum)[keyof typeof TripScalarFieldEnum]


  export const SystemAnalyticsScalarFieldEnum: {
    id: 'id',
    metricName: 'metricName',
    metricValue: 'metricValue',
    timestamp: 'timestamp',
    createdAt: 'createdAt',
    userId: 'userId'
  };

  export type SystemAnalyticsScalarFieldEnum = (typeof SystemAnalyticsScalarFieldEnum)[keyof typeof SystemAnalyticsScalarFieldEnum]


  export const PricingModelScalarFieldEnum: {
    id: 'id',
    agencyId: 'agencyId',
    name: 'name',
    isActive: 'isActive',
    baseRates: 'baseRates',
    perMileRates: 'perMileRates',
    priorityMultipliers: 'priorityMultipliers',
    peakHourMultipliers: 'peakHourMultipliers',
    weekendMultipliers: 'weekendMultipliers',
    seasonalMultipliers: 'seasonalMultipliers',
    zoneMultipliers: 'zoneMultipliers',
    distanceTiers: 'distanceTiers',
    specialRequirements: 'specialRequirements',
    isolationPricing: 'isolationPricing',
    bariatricPricing: 'bariatricPricing',
    oxygenPricing: 'oxygenPricing',
    monitoringPricing: 'monitoringPricing',
    insuranceRates: 'insuranceRates',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PricingModelScalarFieldEnum = (typeof PricingModelScalarFieldEnum)[keyof typeof PricingModelScalarFieldEnum]


  export const BackhaulOpportunitiesScalarFieldEnum: {
    id: 'id',
    tripId1: 'tripId1',
    tripId2: 'tripId2',
    revenueBonus: 'revenueBonus',
    efficiency: 'efficiency',
    createdAt: 'createdAt',
    isActive: 'isActive'
  };

  export type BackhaulOpportunitiesScalarFieldEnum = (typeof BackhaulOpportunitiesScalarFieldEnum)[keyof typeof BackhaulOpportunitiesScalarFieldEnum]


  export const UnitAnalyticsScalarFieldEnum: {
    id: 'id',
    unitId: 'unitId',
    performanceScore: 'performanceScore',
    efficiency: 'efficiency',
    totalTrips: 'totalTrips',
    averageResponseTime: 'averageResponseTime',
    lastUpdated: 'lastUpdated'
  };

  export type UnitAnalyticsScalarFieldEnum = (typeof UnitAnalyticsScalarFieldEnum)[keyof typeof UnitAnalyticsScalarFieldEnum]


  export const RouteOptimizationSettingsScalarFieldEnum: {
    id: 'id',
    agencyId: 'agencyId',
    deadheadMileWeight: 'deadheadMileWeight',
    waitTimeWeight: 'waitTimeWeight',
    backhaulBonusWeight: 'backhaulBonusWeight',
    overtimeRiskWeight: 'overtimeRiskWeight',
    revenueWeight: 'revenueWeight',
    maxDeadheadMiles: 'maxDeadheadMiles',
    maxWaitTimeMinutes: 'maxWaitTimeMinutes',
    maxOvertimeHours: 'maxOvertimeHours',
    maxResponseTimeMinutes: 'maxResponseTimeMinutes',
    maxServiceDistance: 'maxServiceDistance',
    backhaulTimeWindow: 'backhaulTimeWindow',
    backhaulDistanceLimit: 'backhaulDistanceLimit',
    backhaulRevenueBonus: 'backhaulRevenueBonus',
    enableBackhaulOptimization: 'enableBackhaulOptimization',
    targetLoadedMileRatio: 'targetLoadedMileRatio',
    targetRevenuePerHour: 'targetRevenuePerHour',
    targetResponseTime: 'targetResponseTime',
    targetEfficiency: 'targetEfficiency',
    optimizationAlgorithm: 'optimizationAlgorithm',
    maxOptimizationTime: 'maxOptimizationTime',
    enableRealTimeOptimization: 'enableRealTimeOptimization',
    crewAvailabilityWeight: 'crewAvailabilityWeight',
    equipmentCompatibilityWeight: 'equipmentCompatibilityWeight',
    patientPriorityWeight: 'patientPriorityWeight',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RouteOptimizationSettingsScalarFieldEnum = (typeof RouteOptimizationSettingsScalarFieldEnum)[keyof typeof RouteOptimizationSettingsScalarFieldEnum]


  export const TripCostBreakdownScalarFieldEnum: {
    id: 'id',
    tripId: 'tripId',
    baseRevenue: 'baseRevenue',
    mileageRevenue: 'mileageRevenue',
    priorityRevenue: 'priorityRevenue',
    specialRequirementsRevenue: 'specialRequirementsRevenue',
    insuranceAdjustment: 'insuranceAdjustment',
    totalRevenue: 'totalRevenue',
    crewLaborCost: 'crewLaborCost',
    vehicleCost: 'vehicleCost',
    fuelCost: 'fuelCost',
    maintenanceCost: 'maintenanceCost',
    overheadCost: 'overheadCost',
    totalCost: 'totalCost',
    grossProfit: 'grossProfit',
    profitMargin: 'profitMargin',
    revenuePerMile: 'revenuePerMile',
    costPerMile: 'costPerMile',
    loadedMileRatio: 'loadedMileRatio',
    deadheadMileRatio: 'deadheadMileRatio',
    utilizationRate: 'utilizationRate',
    tripDistance: 'tripDistance',
    loadedMiles: 'loadedMiles',
    deadheadMiles: 'deadheadMiles',
    tripDurationHours: 'tripDurationHours',
    transportLevel: 'transportLevel',
    priorityLevel: 'priorityLevel',
    costCenterId: 'costCenterId',
    costCenterName: 'costCenterName',
    calculatedAt: 'calculatedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TripCostBreakdownScalarFieldEnum = (typeof TripCostBreakdownScalarFieldEnum)[keyof typeof TripCostBreakdownScalarFieldEnum]


  export const CostCenterScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    code: 'code',
    overheadRate: 'overheadRate',
    fixedCosts: 'fixedCosts',
    variableCosts: 'variableCosts',
    allocationMethod: 'allocationMethod',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CostCenterScalarFieldEnum = (typeof CostCenterScalarFieldEnum)[keyof typeof CostCenterScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    
  /**
   * Deep Input Types
   */


  export type CenterUserWhereInput = {
    AND?: CenterUserWhereInput | CenterUserWhereInput[]
    OR?: CenterUserWhereInput[]
    NOT?: CenterUserWhereInput | CenterUserWhereInput[]
    id?: StringFilter<"CenterUser"> | string
    email?: StringFilter<"CenterUser"> | string
    password?: StringFilter<"CenterUser"> | string
    name?: StringFilter<"CenterUser"> | string
    userType?: StringFilter<"CenterUser"> | string
    isActive?: BoolFilter<"CenterUser"> | boolean
    createdAt?: DateTimeFilter<"CenterUser"> | Date | string
    updatedAt?: DateTimeFilter<"CenterUser"> | Date | string
  }

  export type CenterUserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    userType?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CenterUserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: CenterUserWhereInput | CenterUserWhereInput[]
    OR?: CenterUserWhereInput[]
    NOT?: CenterUserWhereInput | CenterUserWhereInput[]
    password?: StringFilter<"CenterUser"> | string
    name?: StringFilter<"CenterUser"> | string
    userType?: StringFilter<"CenterUser"> | string
    isActive?: BoolFilter<"CenterUser"> | boolean
    createdAt?: DateTimeFilter<"CenterUser"> | Date | string
    updatedAt?: DateTimeFilter<"CenterUser"> | Date | string
  }, "id" | "email">

  export type CenterUserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    userType?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CenterUserCountOrderByAggregateInput
    _max?: CenterUserMaxOrderByAggregateInput
    _min?: CenterUserMinOrderByAggregateInput
  }

  export type CenterUserScalarWhereWithAggregatesInput = {
    AND?: CenterUserScalarWhereWithAggregatesInput | CenterUserScalarWhereWithAggregatesInput[]
    OR?: CenterUserScalarWhereWithAggregatesInput[]
    NOT?: CenterUserScalarWhereWithAggregatesInput | CenterUserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CenterUser"> | string
    email?: StringWithAggregatesFilter<"CenterUser"> | string
    password?: StringWithAggregatesFilter<"CenterUser"> | string
    name?: StringWithAggregatesFilter<"CenterUser"> | string
    userType?: StringWithAggregatesFilter<"CenterUser"> | string
    isActive?: BoolWithAggregatesFilter<"CenterUser"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CenterUser"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CenterUser"> | Date | string
  }

  export type HospitalWhereInput = {
    AND?: HospitalWhereInput | HospitalWhereInput[]
    OR?: HospitalWhereInput[]
    NOT?: HospitalWhereInput | HospitalWhereInput[]
    id?: StringFilter<"Hospital"> | string
    name?: StringFilter<"Hospital"> | string
    address?: StringFilter<"Hospital"> | string
    city?: StringFilter<"Hospital"> | string
    state?: StringFilter<"Hospital"> | string
    zipCode?: StringFilter<"Hospital"> | string
    phone?: StringNullableFilter<"Hospital"> | string | null
    email?: StringNullableFilter<"Hospital"> | string | null
    type?: StringFilter<"Hospital"> | string
    capabilities?: StringNullableListFilter<"Hospital">
    region?: StringFilter<"Hospital"> | string
    coordinates?: JsonNullableFilter<"Hospital">
    latitude?: FloatNullableFilter<"Hospital"> | number | null
    longitude?: FloatNullableFilter<"Hospital"> | number | null
    operatingHours?: StringNullableFilter<"Hospital"> | string | null
    isActive?: BoolFilter<"Hospital"> | boolean
    requiresReview?: BoolFilter<"Hospital"> | boolean
    approvedAt?: DateTimeNullableFilter<"Hospital"> | Date | string | null
    approvedBy?: StringNullableFilter<"Hospital"> | string | null
    createdAt?: DateTimeFilter<"Hospital"> | Date | string
    updatedAt?: DateTimeFilter<"Hospital"> | Date | string
    pickupLocations?: PickupLocationListRelationFilter
  }

  export type HospitalOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    type?: SortOrder
    capabilities?: SortOrder
    region?: SortOrder
    coordinates?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    operatingHours?: SortOrderInput | SortOrder
    isActive?: SortOrder
    requiresReview?: SortOrder
    approvedAt?: SortOrderInput | SortOrder
    approvedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pickupLocations?: PickupLocationOrderByRelationAggregateInput
  }

  export type HospitalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HospitalWhereInput | HospitalWhereInput[]
    OR?: HospitalWhereInput[]
    NOT?: HospitalWhereInput | HospitalWhereInput[]
    name?: StringFilter<"Hospital"> | string
    address?: StringFilter<"Hospital"> | string
    city?: StringFilter<"Hospital"> | string
    state?: StringFilter<"Hospital"> | string
    zipCode?: StringFilter<"Hospital"> | string
    phone?: StringNullableFilter<"Hospital"> | string | null
    email?: StringNullableFilter<"Hospital"> | string | null
    type?: StringFilter<"Hospital"> | string
    capabilities?: StringNullableListFilter<"Hospital">
    region?: StringFilter<"Hospital"> | string
    coordinates?: JsonNullableFilter<"Hospital">
    latitude?: FloatNullableFilter<"Hospital"> | number | null
    longitude?: FloatNullableFilter<"Hospital"> | number | null
    operatingHours?: StringNullableFilter<"Hospital"> | string | null
    isActive?: BoolFilter<"Hospital"> | boolean
    requiresReview?: BoolFilter<"Hospital"> | boolean
    approvedAt?: DateTimeNullableFilter<"Hospital"> | Date | string | null
    approvedBy?: StringNullableFilter<"Hospital"> | string | null
    createdAt?: DateTimeFilter<"Hospital"> | Date | string
    updatedAt?: DateTimeFilter<"Hospital"> | Date | string
    pickupLocations?: PickupLocationListRelationFilter
  }, "id">

  export type HospitalOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    type?: SortOrder
    capabilities?: SortOrder
    region?: SortOrder
    coordinates?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    operatingHours?: SortOrderInput | SortOrder
    isActive?: SortOrder
    requiresReview?: SortOrder
    approvedAt?: SortOrderInput | SortOrder
    approvedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HospitalCountOrderByAggregateInput
    _avg?: HospitalAvgOrderByAggregateInput
    _max?: HospitalMaxOrderByAggregateInput
    _min?: HospitalMinOrderByAggregateInput
    _sum?: HospitalSumOrderByAggregateInput
  }

  export type HospitalScalarWhereWithAggregatesInput = {
    AND?: HospitalScalarWhereWithAggregatesInput | HospitalScalarWhereWithAggregatesInput[]
    OR?: HospitalScalarWhereWithAggregatesInput[]
    NOT?: HospitalScalarWhereWithAggregatesInput | HospitalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Hospital"> | string
    name?: StringWithAggregatesFilter<"Hospital"> | string
    address?: StringWithAggregatesFilter<"Hospital"> | string
    city?: StringWithAggregatesFilter<"Hospital"> | string
    state?: StringWithAggregatesFilter<"Hospital"> | string
    zipCode?: StringWithAggregatesFilter<"Hospital"> | string
    phone?: StringNullableWithAggregatesFilter<"Hospital"> | string | null
    email?: StringNullableWithAggregatesFilter<"Hospital"> | string | null
    type?: StringWithAggregatesFilter<"Hospital"> | string
    capabilities?: StringNullableListFilter<"Hospital">
    region?: StringWithAggregatesFilter<"Hospital"> | string
    coordinates?: JsonNullableWithAggregatesFilter<"Hospital">
    latitude?: FloatNullableWithAggregatesFilter<"Hospital"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"Hospital"> | number | null
    operatingHours?: StringNullableWithAggregatesFilter<"Hospital"> | string | null
    isActive?: BoolWithAggregatesFilter<"Hospital"> | boolean
    requiresReview?: BoolWithAggregatesFilter<"Hospital"> | boolean
    approvedAt?: DateTimeNullableWithAggregatesFilter<"Hospital"> | Date | string | null
    approvedBy?: StringNullableWithAggregatesFilter<"Hospital"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Hospital"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Hospital"> | Date | string
  }

  export type PickupLocationWhereInput = {
    AND?: PickupLocationWhereInput | PickupLocationWhereInput[]
    OR?: PickupLocationWhereInput[]
    NOT?: PickupLocationWhereInput | PickupLocationWhereInput[]
    id?: StringFilter<"PickupLocation"> | string
    hospitalId?: StringFilter<"PickupLocation"> | string
    name?: StringFilter<"PickupLocation"> | string
    description?: StringNullableFilter<"PickupLocation"> | string | null
    contactPhone?: StringNullableFilter<"PickupLocation"> | string | null
    contactEmail?: StringNullableFilter<"PickupLocation"> | string | null
    floor?: StringNullableFilter<"PickupLocation"> | string | null
    room?: StringNullableFilter<"PickupLocation"> | string | null
    isActive?: BoolFilter<"PickupLocation"> | boolean
    createdAt?: DateTimeFilter<"PickupLocation"> | Date | string
    updatedAt?: DateTimeFilter<"PickupLocation"> | Date | string
    hospital?: XOR<HospitalRelationFilter, HospitalWhereInput>
    trips?: TripListRelationFilter
  }

  export type PickupLocationOrderByWithRelationInput = {
    id?: SortOrder
    hospitalId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    contactPhone?: SortOrderInput | SortOrder
    contactEmail?: SortOrderInput | SortOrder
    floor?: SortOrderInput | SortOrder
    room?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hospital?: HospitalOrderByWithRelationInput
    trips?: TripOrderByRelationAggregateInput
  }

  export type PickupLocationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PickupLocationWhereInput | PickupLocationWhereInput[]
    OR?: PickupLocationWhereInput[]
    NOT?: PickupLocationWhereInput | PickupLocationWhereInput[]
    hospitalId?: StringFilter<"PickupLocation"> | string
    name?: StringFilter<"PickupLocation"> | string
    description?: StringNullableFilter<"PickupLocation"> | string | null
    contactPhone?: StringNullableFilter<"PickupLocation"> | string | null
    contactEmail?: StringNullableFilter<"PickupLocation"> | string | null
    floor?: StringNullableFilter<"PickupLocation"> | string | null
    room?: StringNullableFilter<"PickupLocation"> | string | null
    isActive?: BoolFilter<"PickupLocation"> | boolean
    createdAt?: DateTimeFilter<"PickupLocation"> | Date | string
    updatedAt?: DateTimeFilter<"PickupLocation"> | Date | string
    hospital?: XOR<HospitalRelationFilter, HospitalWhereInput>
    trips?: TripListRelationFilter
  }, "id">

  export type PickupLocationOrderByWithAggregationInput = {
    id?: SortOrder
    hospitalId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    contactPhone?: SortOrderInput | SortOrder
    contactEmail?: SortOrderInput | SortOrder
    floor?: SortOrderInput | SortOrder
    room?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PickupLocationCountOrderByAggregateInput
    _max?: PickupLocationMaxOrderByAggregateInput
    _min?: PickupLocationMinOrderByAggregateInput
  }

  export type PickupLocationScalarWhereWithAggregatesInput = {
    AND?: PickupLocationScalarWhereWithAggregatesInput | PickupLocationScalarWhereWithAggregatesInput[]
    OR?: PickupLocationScalarWhereWithAggregatesInput[]
    NOT?: PickupLocationScalarWhereWithAggregatesInput | PickupLocationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PickupLocation"> | string
    hospitalId?: StringWithAggregatesFilter<"PickupLocation"> | string
    name?: StringWithAggregatesFilter<"PickupLocation"> | string
    description?: StringNullableWithAggregatesFilter<"PickupLocation"> | string | null
    contactPhone?: StringNullableWithAggregatesFilter<"PickupLocation"> | string | null
    contactEmail?: StringNullableWithAggregatesFilter<"PickupLocation"> | string | null
    floor?: StringNullableWithAggregatesFilter<"PickupLocation"> | string | null
    room?: StringNullableWithAggregatesFilter<"PickupLocation"> | string | null
    isActive?: BoolWithAggregatesFilter<"PickupLocation"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PickupLocation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PickupLocation"> | Date | string
  }

  export type EMSAgencyWhereInput = {
    AND?: EMSAgencyWhereInput | EMSAgencyWhereInput[]
    OR?: EMSAgencyWhereInput[]
    NOT?: EMSAgencyWhereInput | EMSAgencyWhereInput[]
    id?: StringFilter<"EMSAgency"> | string
    name?: StringFilter<"EMSAgency"> | string
    contactName?: StringFilter<"EMSAgency"> | string
    phone?: StringFilter<"EMSAgency"> | string
    email?: StringFilter<"EMSAgency"> | string
    address?: StringFilter<"EMSAgency"> | string
    city?: StringFilter<"EMSAgency"> | string
    state?: StringFilter<"EMSAgency"> | string
    zipCode?: StringFilter<"EMSAgency"> | string
    serviceArea?: StringNullableListFilter<"EMSAgency">
    operatingHours?: JsonNullableFilter<"EMSAgency">
    capabilities?: StringNullableListFilter<"EMSAgency">
    pricingStructure?: JsonNullableFilter<"EMSAgency">
    latitude?: FloatNullableFilter<"EMSAgency"> | number | null
    longitude?: FloatNullableFilter<"EMSAgency"> | number | null
    serviceRadius?: IntNullableFilter<"EMSAgency"> | number | null
    totalUnits?: IntFilter<"EMSAgency"> | number
    availableUnits?: IntFilter<"EMSAgency"> | number
    lastUpdated?: DateTimeFilter<"EMSAgency"> | Date | string
    acceptsNotifications?: BoolFilter<"EMSAgency"> | boolean
    notificationMethods?: StringNullableListFilter<"EMSAgency">
    isActive?: BoolFilter<"EMSAgency"> | boolean
    status?: StringFilter<"EMSAgency"> | string
    requiresReview?: BoolFilter<"EMSAgency"> | boolean
    approvedAt?: DateTimeNullableFilter<"EMSAgency"> | Date | string | null
    approvedBy?: StringNullableFilter<"EMSAgency"> | string | null
    createdAt?: DateTimeFilter<"EMSAgency"> | Date | string
    updatedAt?: DateTimeFilter<"EMSAgency"> | Date | string
  }

  export type EMSAgencyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    contactName?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    serviceArea?: SortOrder
    operatingHours?: SortOrderInput | SortOrder
    capabilities?: SortOrder
    pricingStructure?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    serviceRadius?: SortOrderInput | SortOrder
    totalUnits?: SortOrder
    availableUnits?: SortOrder
    lastUpdated?: SortOrder
    acceptsNotifications?: SortOrder
    notificationMethods?: SortOrder
    isActive?: SortOrder
    status?: SortOrder
    requiresReview?: SortOrder
    approvedAt?: SortOrderInput | SortOrder
    approvedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EMSAgencyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EMSAgencyWhereInput | EMSAgencyWhereInput[]
    OR?: EMSAgencyWhereInput[]
    NOT?: EMSAgencyWhereInput | EMSAgencyWhereInput[]
    name?: StringFilter<"EMSAgency"> | string
    contactName?: StringFilter<"EMSAgency"> | string
    phone?: StringFilter<"EMSAgency"> | string
    email?: StringFilter<"EMSAgency"> | string
    address?: StringFilter<"EMSAgency"> | string
    city?: StringFilter<"EMSAgency"> | string
    state?: StringFilter<"EMSAgency"> | string
    zipCode?: StringFilter<"EMSAgency"> | string
    serviceArea?: StringNullableListFilter<"EMSAgency">
    operatingHours?: JsonNullableFilter<"EMSAgency">
    capabilities?: StringNullableListFilter<"EMSAgency">
    pricingStructure?: JsonNullableFilter<"EMSAgency">
    latitude?: FloatNullableFilter<"EMSAgency"> | number | null
    longitude?: FloatNullableFilter<"EMSAgency"> | number | null
    serviceRadius?: IntNullableFilter<"EMSAgency"> | number | null
    totalUnits?: IntFilter<"EMSAgency"> | number
    availableUnits?: IntFilter<"EMSAgency"> | number
    lastUpdated?: DateTimeFilter<"EMSAgency"> | Date | string
    acceptsNotifications?: BoolFilter<"EMSAgency"> | boolean
    notificationMethods?: StringNullableListFilter<"EMSAgency">
    isActive?: BoolFilter<"EMSAgency"> | boolean
    status?: StringFilter<"EMSAgency"> | string
    requiresReview?: BoolFilter<"EMSAgency"> | boolean
    approvedAt?: DateTimeNullableFilter<"EMSAgency"> | Date | string | null
    approvedBy?: StringNullableFilter<"EMSAgency"> | string | null
    createdAt?: DateTimeFilter<"EMSAgency"> | Date | string
    updatedAt?: DateTimeFilter<"EMSAgency"> | Date | string
  }, "id">

  export type EMSAgencyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    contactName?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    serviceArea?: SortOrder
    operatingHours?: SortOrderInput | SortOrder
    capabilities?: SortOrder
    pricingStructure?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    serviceRadius?: SortOrderInput | SortOrder
    totalUnits?: SortOrder
    availableUnits?: SortOrder
    lastUpdated?: SortOrder
    acceptsNotifications?: SortOrder
    notificationMethods?: SortOrder
    isActive?: SortOrder
    status?: SortOrder
    requiresReview?: SortOrder
    approvedAt?: SortOrderInput | SortOrder
    approvedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EMSAgencyCountOrderByAggregateInput
    _avg?: EMSAgencyAvgOrderByAggregateInput
    _max?: EMSAgencyMaxOrderByAggregateInput
    _min?: EMSAgencyMinOrderByAggregateInput
    _sum?: EMSAgencySumOrderByAggregateInput
  }

  export type EMSAgencyScalarWhereWithAggregatesInput = {
    AND?: EMSAgencyScalarWhereWithAggregatesInput | EMSAgencyScalarWhereWithAggregatesInput[]
    OR?: EMSAgencyScalarWhereWithAggregatesInput[]
    NOT?: EMSAgencyScalarWhereWithAggregatesInput | EMSAgencyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EMSAgency"> | string
    name?: StringWithAggregatesFilter<"EMSAgency"> | string
    contactName?: StringWithAggregatesFilter<"EMSAgency"> | string
    phone?: StringWithAggregatesFilter<"EMSAgency"> | string
    email?: StringWithAggregatesFilter<"EMSAgency"> | string
    address?: StringWithAggregatesFilter<"EMSAgency"> | string
    city?: StringWithAggregatesFilter<"EMSAgency"> | string
    state?: StringWithAggregatesFilter<"EMSAgency"> | string
    zipCode?: StringWithAggregatesFilter<"EMSAgency"> | string
    serviceArea?: StringNullableListFilter<"EMSAgency">
    operatingHours?: JsonNullableWithAggregatesFilter<"EMSAgency">
    capabilities?: StringNullableListFilter<"EMSAgency">
    pricingStructure?: JsonNullableWithAggregatesFilter<"EMSAgency">
    latitude?: FloatNullableWithAggregatesFilter<"EMSAgency"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"EMSAgency"> | number | null
    serviceRadius?: IntNullableWithAggregatesFilter<"EMSAgency"> | number | null
    totalUnits?: IntWithAggregatesFilter<"EMSAgency"> | number
    availableUnits?: IntWithAggregatesFilter<"EMSAgency"> | number
    lastUpdated?: DateTimeWithAggregatesFilter<"EMSAgency"> | Date | string
    acceptsNotifications?: BoolWithAggregatesFilter<"EMSAgency"> | boolean
    notificationMethods?: StringNullableListFilter<"EMSAgency">
    isActive?: BoolWithAggregatesFilter<"EMSAgency"> | boolean
    status?: StringWithAggregatesFilter<"EMSAgency"> | string
    requiresReview?: BoolWithAggregatesFilter<"EMSAgency"> | boolean
    approvedAt?: DateTimeNullableWithAggregatesFilter<"EMSAgency"> | Date | string | null
    approvedBy?: StringNullableWithAggregatesFilter<"EMSAgency"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EMSAgency"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EMSAgency"> | Date | string
  }

  export type TripWhereInput = {
    AND?: TripWhereInput | TripWhereInput[]
    OR?: TripWhereInput[]
    NOT?: TripWhereInput | TripWhereInput[]
    id?: StringFilter<"Trip"> | string
    tripNumber?: StringFilter<"Trip"> | string
    patientId?: StringFilter<"Trip"> | string
    patientWeight?: StringNullableFilter<"Trip"> | string | null
    specialNeeds?: StringNullableFilter<"Trip"> | string | null
    insuranceCompany?: StringNullableFilter<"Trip"> | string | null
    fromLocation?: StringFilter<"Trip"> | string
    pickupLocationId?: StringNullableFilter<"Trip"> | string | null
    toLocation?: StringFilter<"Trip"> | string
    scheduledTime?: DateTimeFilter<"Trip"> | Date | string
    transportLevel?: StringFilter<"Trip"> | string
    urgencyLevel?: StringFilter<"Trip"> | string
    originLatitude?: FloatNullableFilter<"Trip"> | number | null
    originLongitude?: FloatNullableFilter<"Trip"> | number | null
    destinationLatitude?: FloatNullableFilter<"Trip"> | number | null
    destinationLongitude?: FloatNullableFilter<"Trip"> | number | null
    diagnosis?: StringNullableFilter<"Trip"> | string | null
    mobilityLevel?: StringNullableFilter<"Trip"> | string | null
    oxygenRequired?: BoolFilter<"Trip"> | boolean
    monitoringRequired?: BoolFilter<"Trip"> | boolean
    generateQRCode?: BoolFilter<"Trip"> | boolean
    qrCodeData?: StringNullableFilter<"Trip"> | string | null
    selectedAgencies?: StringNullableListFilter<"Trip">
    notificationRadius?: IntNullableFilter<"Trip"> | number | null
    transferRequestTime?: DateTimeNullableFilter<"Trip"> | Date | string | null
    transferAcceptedTime?: DateTimeNullableFilter<"Trip"> | Date | string | null
    emsArrivalTime?: DateTimeNullableFilter<"Trip"> | Date | string | null
    emsDepartureTime?: DateTimeNullableFilter<"Trip"> | Date | string | null
    tripCost?: DecimalNullableFilter<"Trip"> | Decimal | DecimalJsLike | number | string | null
    distanceMiles?: FloatNullableFilter<"Trip"> | number | null
    responseTimeMinutes?: IntNullableFilter<"Trip"> | number | null
    deadheadMiles?: FloatNullableFilter<"Trip"> | number | null
    insurancePayRate?: DecimalNullableFilter<"Trip"> | Decimal | DecimalJsLike | number | string | null
    perMileRate?: DecimalNullableFilter<"Trip"> | Decimal | DecimalJsLike | number | string | null
    requestTimestamp?: DateTimeNullableFilter<"Trip"> | Date | string | null
    estimatedTripTimeMinutes?: IntNullableFilter<"Trip"> | number | null
    actualTripTimeMinutes?: IntNullableFilter<"Trip"> | number | null
    completionTimeMinutes?: IntNullableFilter<"Trip"> | number | null
    loadedMiles?: DecimalNullableFilter<"Trip"> | Decimal | DecimalJsLike | number | string | null
    customerSatisfaction?: IntNullableFilter<"Trip"> | number | null
    efficiency?: DecimalNullableFilter<"Trip"> | Decimal | DecimalJsLike | number | string | null
    performanceScore?: DecimalNullableFilter<"Trip"> | Decimal | DecimalJsLike | number | string | null
    revenuePerHour?: DecimalNullableFilter<"Trip"> | Decimal | DecimalJsLike | number | string | null
    backhaulOpportunity?: BoolFilter<"Trip"> | boolean
    actualStartTime?: DateTimeNullableFilter<"Trip"> | Date | string | null
    actualEndTime?: DateTimeNullableFilter<"Trip"> | Date | string | null
    status?: StringFilter<"Trip"> | string
    priority?: StringFilter<"Trip"> | string
    notes?: StringNullableFilter<"Trip"> | string | null
    assignedTo?: StringNullableFilter<"Trip"> | string | null
    assignedAgencyId?: StringNullableFilter<"Trip"> | string | null
    assignedUnitId?: StringNullableFilter<"Trip"> | string | null
    acceptedTimestamp?: DateTimeNullableFilter<"Trip"> | Date | string | null
    pickupTimestamp?: DateTimeNullableFilter<"Trip"> | Date | string | null
    completionTimestamp?: DateTimeNullableFilter<"Trip"> | Date | string | null
    createdAt?: DateTimeFilter<"Trip"> | Date | string
    updatedAt?: DateTimeFilter<"Trip"> | Date | string
    pickupLocation?: XOR<PickupLocationNullableRelationFilter, PickupLocationWhereInput> | null
  }

  export type TripOrderByWithRelationInput = {
    id?: SortOrder
    tripNumber?: SortOrder
    patientId?: SortOrder
    patientWeight?: SortOrderInput | SortOrder
    specialNeeds?: SortOrderInput | SortOrder
    insuranceCompany?: SortOrderInput | SortOrder
    fromLocation?: SortOrder
    pickupLocationId?: SortOrderInput | SortOrder
    toLocation?: SortOrder
    scheduledTime?: SortOrder
    transportLevel?: SortOrder
    urgencyLevel?: SortOrder
    originLatitude?: SortOrderInput | SortOrder
    originLongitude?: SortOrderInput | SortOrder
    destinationLatitude?: SortOrderInput | SortOrder
    destinationLongitude?: SortOrderInput | SortOrder
    diagnosis?: SortOrderInput | SortOrder
    mobilityLevel?: SortOrderInput | SortOrder
    oxygenRequired?: SortOrder
    monitoringRequired?: SortOrder
    generateQRCode?: SortOrder
    qrCodeData?: SortOrderInput | SortOrder
    selectedAgencies?: SortOrder
    notificationRadius?: SortOrderInput | SortOrder
    transferRequestTime?: SortOrderInput | SortOrder
    transferAcceptedTime?: SortOrderInput | SortOrder
    emsArrivalTime?: SortOrderInput | SortOrder
    emsDepartureTime?: SortOrderInput | SortOrder
    tripCost?: SortOrderInput | SortOrder
    distanceMiles?: SortOrderInput | SortOrder
    responseTimeMinutes?: SortOrderInput | SortOrder
    deadheadMiles?: SortOrderInput | SortOrder
    insurancePayRate?: SortOrderInput | SortOrder
    perMileRate?: SortOrderInput | SortOrder
    requestTimestamp?: SortOrderInput | SortOrder
    estimatedTripTimeMinutes?: SortOrderInput | SortOrder
    actualTripTimeMinutes?: SortOrderInput | SortOrder
    completionTimeMinutes?: SortOrderInput | SortOrder
    loadedMiles?: SortOrderInput | SortOrder
    customerSatisfaction?: SortOrderInput | SortOrder
    efficiency?: SortOrderInput | SortOrder
    performanceScore?: SortOrderInput | SortOrder
    revenuePerHour?: SortOrderInput | SortOrder
    backhaulOpportunity?: SortOrder
    actualStartTime?: SortOrderInput | SortOrder
    actualEndTime?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    notes?: SortOrderInput | SortOrder
    assignedTo?: SortOrderInput | SortOrder
    assignedAgencyId?: SortOrderInput | SortOrder
    assignedUnitId?: SortOrderInput | SortOrder
    acceptedTimestamp?: SortOrderInput | SortOrder
    pickupTimestamp?: SortOrderInput | SortOrder
    completionTimestamp?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pickupLocation?: PickupLocationOrderByWithRelationInput
  }

  export type TripWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tripNumber?: string
    AND?: TripWhereInput | TripWhereInput[]
    OR?: TripWhereInput[]
    NOT?: TripWhereInput | TripWhereInput[]
    patientId?: StringFilter<"Trip"> | string
    patientWeight?: StringNullableFilter<"Trip"> | string | null
    specialNeeds?: StringNullableFilter<"Trip"> | string | null
    insuranceCompany?: StringNullableFilter<"Trip"> | string | null
    fromLocation?: StringFilter<"Trip"> | string
    pickupLocationId?: StringNullableFilter<"Trip"> | string | null
    toLocation?: StringFilter<"Trip"> | string
    scheduledTime?: DateTimeFilter<"Trip"> | Date | string
    transportLevel?: StringFilter<"Trip"> | string
    urgencyLevel?: StringFilter<"Trip"> | string
    originLatitude?: FloatNullableFilter<"Trip"> | number | null
    originLongitude?: FloatNullableFilter<"Trip"> | number | null
    destinationLatitude?: FloatNullableFilter<"Trip"> | number | null
    destinationLongitude?: FloatNullableFilter<"Trip"> | number | null
    diagnosis?: StringNullableFilter<"Trip"> | string | null
    mobilityLevel?: StringNullableFilter<"Trip"> | string | null
    oxygenRequired?: BoolFilter<"Trip"> | boolean
    monitoringRequired?: BoolFilter<"Trip"> | boolean
    generateQRCode?: BoolFilter<"Trip"> | boolean
    qrCodeData?: StringNullableFilter<"Trip"> | string | null
    selectedAgencies?: StringNullableListFilter<"Trip">
    notificationRadius?: IntNullableFilter<"Trip"> | number | null
    transferRequestTime?: DateTimeNullableFilter<"Trip"> | Date | string | null
    transferAcceptedTime?: DateTimeNullableFilter<"Trip"> | Date | string | null
    emsArrivalTime?: DateTimeNullableFilter<"Trip"> | Date | string | null
    emsDepartureTime?: DateTimeNullableFilter<"Trip"> | Date | string | null
    tripCost?: DecimalNullableFilter<"Trip"> | Decimal | DecimalJsLike | number | string | null
    distanceMiles?: FloatNullableFilter<"Trip"> | number | null
    responseTimeMinutes?: IntNullableFilter<"Trip"> | number | null
    deadheadMiles?: FloatNullableFilter<"Trip"> | number | null
    insurancePayRate?: DecimalNullableFilter<"Trip"> | Decimal | DecimalJsLike | number | string | null
    perMileRate?: DecimalNullableFilter<"Trip"> | Decimal | DecimalJsLike | number | string | null
    requestTimestamp?: DateTimeNullableFilter<"Trip"> | Date | string | null
    estimatedTripTimeMinutes?: IntNullableFilter<"Trip"> | number | null
    actualTripTimeMinutes?: IntNullableFilter<"Trip"> | number | null
    completionTimeMinutes?: IntNullableFilter<"Trip"> | number | null
    loadedMiles?: DecimalNullableFilter<"Trip"> | Decimal | DecimalJsLike | number | string | null
    customerSatisfaction?: IntNullableFilter<"Trip"> | number | null
    efficiency?: DecimalNullableFilter<"Trip"> | Decimal | DecimalJsLike | number | string | null
    performanceScore?: DecimalNullableFilter<"Trip"> | Decimal | DecimalJsLike | number | string | null
    revenuePerHour?: DecimalNullableFilter<"Trip"> | Decimal | DecimalJsLike | number | string | null
    backhaulOpportunity?: BoolFilter<"Trip"> | boolean
    actualStartTime?: DateTimeNullableFilter<"Trip"> | Date | string | null
    actualEndTime?: DateTimeNullableFilter<"Trip"> | Date | string | null
    status?: StringFilter<"Trip"> | string
    priority?: StringFilter<"Trip"> | string
    notes?: StringNullableFilter<"Trip"> | string | null
    assignedTo?: StringNullableFilter<"Trip"> | string | null
    assignedAgencyId?: StringNullableFilter<"Trip"> | string | null
    assignedUnitId?: StringNullableFilter<"Trip"> | string | null
    acceptedTimestamp?: DateTimeNullableFilter<"Trip"> | Date | string | null
    pickupTimestamp?: DateTimeNullableFilter<"Trip"> | Date | string | null
    completionTimestamp?: DateTimeNullableFilter<"Trip"> | Date | string | null
    createdAt?: DateTimeFilter<"Trip"> | Date | string
    updatedAt?: DateTimeFilter<"Trip"> | Date | string
    pickupLocation?: XOR<PickupLocationNullableRelationFilter, PickupLocationWhereInput> | null
  }, "id" | "tripNumber">

  export type TripOrderByWithAggregationInput = {
    id?: SortOrder
    tripNumber?: SortOrder
    patientId?: SortOrder
    patientWeight?: SortOrderInput | SortOrder
    specialNeeds?: SortOrderInput | SortOrder
    insuranceCompany?: SortOrderInput | SortOrder
    fromLocation?: SortOrder
    pickupLocationId?: SortOrderInput | SortOrder
    toLocation?: SortOrder
    scheduledTime?: SortOrder
    transportLevel?: SortOrder
    urgencyLevel?: SortOrder
    originLatitude?: SortOrderInput | SortOrder
    originLongitude?: SortOrderInput | SortOrder
    destinationLatitude?: SortOrderInput | SortOrder
    destinationLongitude?: SortOrderInput | SortOrder
    diagnosis?: SortOrderInput | SortOrder
    mobilityLevel?: SortOrderInput | SortOrder
    oxygenRequired?: SortOrder
    monitoringRequired?: SortOrder
    generateQRCode?: SortOrder
    qrCodeData?: SortOrderInput | SortOrder
    selectedAgencies?: SortOrder
    notificationRadius?: SortOrderInput | SortOrder
    transferRequestTime?: SortOrderInput | SortOrder
    transferAcceptedTime?: SortOrderInput | SortOrder
    emsArrivalTime?: SortOrderInput | SortOrder
    emsDepartureTime?: SortOrderInput | SortOrder
    tripCost?: SortOrderInput | SortOrder
    distanceMiles?: SortOrderInput | SortOrder
    responseTimeMinutes?: SortOrderInput | SortOrder
    deadheadMiles?: SortOrderInput | SortOrder
    insurancePayRate?: SortOrderInput | SortOrder
    perMileRate?: SortOrderInput | SortOrder
    requestTimestamp?: SortOrderInput | SortOrder
    estimatedTripTimeMinutes?: SortOrderInput | SortOrder
    actualTripTimeMinutes?: SortOrderInput | SortOrder
    completionTimeMinutes?: SortOrderInput | SortOrder
    loadedMiles?: SortOrderInput | SortOrder
    customerSatisfaction?: SortOrderInput | SortOrder
    efficiency?: SortOrderInput | SortOrder
    performanceScore?: SortOrderInput | SortOrder
    revenuePerHour?: SortOrderInput | SortOrder
    backhaulOpportunity?: SortOrder
    actualStartTime?: SortOrderInput | SortOrder
    actualEndTime?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    notes?: SortOrderInput | SortOrder
    assignedTo?: SortOrderInput | SortOrder
    assignedAgencyId?: SortOrderInput | SortOrder
    assignedUnitId?: SortOrderInput | SortOrder
    acceptedTimestamp?: SortOrderInput | SortOrder
    pickupTimestamp?: SortOrderInput | SortOrder
    completionTimestamp?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TripCountOrderByAggregateInput
    _avg?: TripAvgOrderByAggregateInput
    _max?: TripMaxOrderByAggregateInput
    _min?: TripMinOrderByAggregateInput
    _sum?: TripSumOrderByAggregateInput
  }

  export type TripScalarWhereWithAggregatesInput = {
    AND?: TripScalarWhereWithAggregatesInput | TripScalarWhereWithAggregatesInput[]
    OR?: TripScalarWhereWithAggregatesInput[]
    NOT?: TripScalarWhereWithAggregatesInput | TripScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Trip"> | string
    tripNumber?: StringWithAggregatesFilter<"Trip"> | string
    patientId?: StringWithAggregatesFilter<"Trip"> | string
    patientWeight?: StringNullableWithAggregatesFilter<"Trip"> | string | null
    specialNeeds?: StringNullableWithAggregatesFilter<"Trip"> | string | null
    insuranceCompany?: StringNullableWithAggregatesFilter<"Trip"> | string | null
    fromLocation?: StringWithAggregatesFilter<"Trip"> | string
    pickupLocationId?: StringNullableWithAggregatesFilter<"Trip"> | string | null
    toLocation?: StringWithAggregatesFilter<"Trip"> | string
    scheduledTime?: DateTimeWithAggregatesFilter<"Trip"> | Date | string
    transportLevel?: StringWithAggregatesFilter<"Trip"> | string
    urgencyLevel?: StringWithAggregatesFilter<"Trip"> | string
    originLatitude?: FloatNullableWithAggregatesFilter<"Trip"> | number | null
    originLongitude?: FloatNullableWithAggregatesFilter<"Trip"> | number | null
    destinationLatitude?: FloatNullableWithAggregatesFilter<"Trip"> | number | null
    destinationLongitude?: FloatNullableWithAggregatesFilter<"Trip"> | number | null
    diagnosis?: StringNullableWithAggregatesFilter<"Trip"> | string | null
    mobilityLevel?: StringNullableWithAggregatesFilter<"Trip"> | string | null
    oxygenRequired?: BoolWithAggregatesFilter<"Trip"> | boolean
    monitoringRequired?: BoolWithAggregatesFilter<"Trip"> | boolean
    generateQRCode?: BoolWithAggregatesFilter<"Trip"> | boolean
    qrCodeData?: StringNullableWithAggregatesFilter<"Trip"> | string | null
    selectedAgencies?: StringNullableListFilter<"Trip">
    notificationRadius?: IntNullableWithAggregatesFilter<"Trip"> | number | null
    transferRequestTime?: DateTimeNullableWithAggregatesFilter<"Trip"> | Date | string | null
    transferAcceptedTime?: DateTimeNullableWithAggregatesFilter<"Trip"> | Date | string | null
    emsArrivalTime?: DateTimeNullableWithAggregatesFilter<"Trip"> | Date | string | null
    emsDepartureTime?: DateTimeNullableWithAggregatesFilter<"Trip"> | Date | string | null
    tripCost?: DecimalNullableWithAggregatesFilter<"Trip"> | Decimal | DecimalJsLike | number | string | null
    distanceMiles?: FloatNullableWithAggregatesFilter<"Trip"> | number | null
    responseTimeMinutes?: IntNullableWithAggregatesFilter<"Trip"> | number | null
    deadheadMiles?: FloatNullableWithAggregatesFilter<"Trip"> | number | null
    insurancePayRate?: DecimalNullableWithAggregatesFilter<"Trip"> | Decimal | DecimalJsLike | number | string | null
    perMileRate?: DecimalNullableWithAggregatesFilter<"Trip"> | Decimal | DecimalJsLike | number | string | null
    requestTimestamp?: DateTimeNullableWithAggregatesFilter<"Trip"> | Date | string | null
    estimatedTripTimeMinutes?: IntNullableWithAggregatesFilter<"Trip"> | number | null
    actualTripTimeMinutes?: IntNullableWithAggregatesFilter<"Trip"> | number | null
    completionTimeMinutes?: IntNullableWithAggregatesFilter<"Trip"> | number | null
    loadedMiles?: DecimalNullableWithAggregatesFilter<"Trip"> | Decimal | DecimalJsLike | number | string | null
    customerSatisfaction?: IntNullableWithAggregatesFilter<"Trip"> | number | null
    efficiency?: DecimalNullableWithAggregatesFilter<"Trip"> | Decimal | DecimalJsLike | number | string | null
    performanceScore?: DecimalNullableWithAggregatesFilter<"Trip"> | Decimal | DecimalJsLike | number | string | null
    revenuePerHour?: DecimalNullableWithAggregatesFilter<"Trip"> | Decimal | DecimalJsLike | number | string | null
    backhaulOpportunity?: BoolWithAggregatesFilter<"Trip"> | boolean
    actualStartTime?: DateTimeNullableWithAggregatesFilter<"Trip"> | Date | string | null
    actualEndTime?: DateTimeNullableWithAggregatesFilter<"Trip"> | Date | string | null
    status?: StringWithAggregatesFilter<"Trip"> | string
    priority?: StringWithAggregatesFilter<"Trip"> | string
    notes?: StringNullableWithAggregatesFilter<"Trip"> | string | null
    assignedTo?: StringNullableWithAggregatesFilter<"Trip"> | string | null
    assignedAgencyId?: StringNullableWithAggregatesFilter<"Trip"> | string | null
    assignedUnitId?: StringNullableWithAggregatesFilter<"Trip"> | string | null
    acceptedTimestamp?: DateTimeNullableWithAggregatesFilter<"Trip"> | Date | string | null
    pickupTimestamp?: DateTimeNullableWithAggregatesFilter<"Trip"> | Date | string | null
    completionTimestamp?: DateTimeNullableWithAggregatesFilter<"Trip"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Trip"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Trip"> | Date | string
  }

  export type SystemAnalyticsWhereInput = {
    AND?: SystemAnalyticsWhereInput | SystemAnalyticsWhereInput[]
    OR?: SystemAnalyticsWhereInput[]
    NOT?: SystemAnalyticsWhereInput | SystemAnalyticsWhereInput[]
    id?: StringFilter<"SystemAnalytics"> | string
    metricName?: StringFilter<"SystemAnalytics"> | string
    metricValue?: JsonFilter<"SystemAnalytics">
    timestamp?: DateTimeFilter<"SystemAnalytics"> | Date | string
    createdAt?: DateTimeFilter<"SystemAnalytics"> | Date | string
    userId?: StringNullableFilter<"SystemAnalytics"> | string | null
  }

  export type SystemAnalyticsOrderByWithRelationInput = {
    id?: SortOrder
    metricName?: SortOrder
    metricValue?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrderInput | SortOrder
  }

  export type SystemAnalyticsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SystemAnalyticsWhereInput | SystemAnalyticsWhereInput[]
    OR?: SystemAnalyticsWhereInput[]
    NOT?: SystemAnalyticsWhereInput | SystemAnalyticsWhereInput[]
    metricName?: StringFilter<"SystemAnalytics"> | string
    metricValue?: JsonFilter<"SystemAnalytics">
    timestamp?: DateTimeFilter<"SystemAnalytics"> | Date | string
    createdAt?: DateTimeFilter<"SystemAnalytics"> | Date | string
    userId?: StringNullableFilter<"SystemAnalytics"> | string | null
  }, "id">

  export type SystemAnalyticsOrderByWithAggregationInput = {
    id?: SortOrder
    metricName?: SortOrder
    metricValue?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    _count?: SystemAnalyticsCountOrderByAggregateInput
    _max?: SystemAnalyticsMaxOrderByAggregateInput
    _min?: SystemAnalyticsMinOrderByAggregateInput
  }

  export type SystemAnalyticsScalarWhereWithAggregatesInput = {
    AND?: SystemAnalyticsScalarWhereWithAggregatesInput | SystemAnalyticsScalarWhereWithAggregatesInput[]
    OR?: SystemAnalyticsScalarWhereWithAggregatesInput[]
    NOT?: SystemAnalyticsScalarWhereWithAggregatesInput | SystemAnalyticsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SystemAnalytics"> | string
    metricName?: StringWithAggregatesFilter<"SystemAnalytics"> | string
    metricValue?: JsonWithAggregatesFilter<"SystemAnalytics">
    timestamp?: DateTimeWithAggregatesFilter<"SystemAnalytics"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"SystemAnalytics"> | Date | string
    userId?: StringNullableWithAggregatesFilter<"SystemAnalytics"> | string | null
  }

  export type pricingModelWhereInput = {
    AND?: pricingModelWhereInput | pricingModelWhereInput[]
    OR?: pricingModelWhereInput[]
    NOT?: pricingModelWhereInput | pricingModelWhereInput[]
    id?: StringFilter<"pricingModel"> | string
    agencyId?: StringNullableFilter<"pricingModel"> | string | null
    name?: StringFilter<"pricingModel"> | string
    isActive?: BoolFilter<"pricingModel"> | boolean
    baseRates?: JsonFilter<"pricingModel">
    perMileRates?: JsonFilter<"pricingModel">
    priorityMultipliers?: JsonFilter<"pricingModel">
    peakHourMultipliers?: JsonFilter<"pricingModel">
    weekendMultipliers?: JsonFilter<"pricingModel">
    seasonalMultipliers?: JsonFilter<"pricingModel">
    zoneMultipliers?: JsonFilter<"pricingModel">
    distanceTiers?: JsonFilter<"pricingModel">
    specialRequirements?: JsonFilter<"pricingModel">
    isolationPricing?: DecimalNullableFilter<"pricingModel"> | Decimal | DecimalJsLike | number | string | null
    bariatricPricing?: DecimalNullableFilter<"pricingModel"> | Decimal | DecimalJsLike | number | string | null
    oxygenPricing?: DecimalNullableFilter<"pricingModel"> | Decimal | DecimalJsLike | number | string | null
    monitoringPricing?: DecimalNullableFilter<"pricingModel"> | Decimal | DecimalJsLike | number | string | null
    insuranceRates?: JsonFilter<"pricingModel">
    createdAt?: DateTimeFilter<"pricingModel"> | Date | string
    updatedAt?: DateTimeFilter<"pricingModel"> | Date | string
  }

  export type pricingModelOrderByWithRelationInput = {
    id?: SortOrder
    agencyId?: SortOrderInput | SortOrder
    name?: SortOrder
    isActive?: SortOrder
    baseRates?: SortOrder
    perMileRates?: SortOrder
    priorityMultipliers?: SortOrder
    peakHourMultipliers?: SortOrder
    weekendMultipliers?: SortOrder
    seasonalMultipliers?: SortOrder
    zoneMultipliers?: SortOrder
    distanceTiers?: SortOrder
    specialRequirements?: SortOrder
    isolationPricing?: SortOrderInput | SortOrder
    bariatricPricing?: SortOrderInput | SortOrder
    oxygenPricing?: SortOrderInput | SortOrder
    monitoringPricing?: SortOrderInput | SortOrder
    insuranceRates?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type pricingModelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: pricingModelWhereInput | pricingModelWhereInput[]
    OR?: pricingModelWhereInput[]
    NOT?: pricingModelWhereInput | pricingModelWhereInput[]
    agencyId?: StringNullableFilter<"pricingModel"> | string | null
    name?: StringFilter<"pricingModel"> | string
    isActive?: BoolFilter<"pricingModel"> | boolean
    baseRates?: JsonFilter<"pricingModel">
    perMileRates?: JsonFilter<"pricingModel">
    priorityMultipliers?: JsonFilter<"pricingModel">
    peakHourMultipliers?: JsonFilter<"pricingModel">
    weekendMultipliers?: JsonFilter<"pricingModel">
    seasonalMultipliers?: JsonFilter<"pricingModel">
    zoneMultipliers?: JsonFilter<"pricingModel">
    distanceTiers?: JsonFilter<"pricingModel">
    specialRequirements?: JsonFilter<"pricingModel">
    isolationPricing?: DecimalNullableFilter<"pricingModel"> | Decimal | DecimalJsLike | number | string | null
    bariatricPricing?: DecimalNullableFilter<"pricingModel"> | Decimal | DecimalJsLike | number | string | null
    oxygenPricing?: DecimalNullableFilter<"pricingModel"> | Decimal | DecimalJsLike | number | string | null
    monitoringPricing?: DecimalNullableFilter<"pricingModel"> | Decimal | DecimalJsLike | number | string | null
    insuranceRates?: JsonFilter<"pricingModel">
    createdAt?: DateTimeFilter<"pricingModel"> | Date | string
    updatedAt?: DateTimeFilter<"pricingModel"> | Date | string
  }, "id">

  export type pricingModelOrderByWithAggregationInput = {
    id?: SortOrder
    agencyId?: SortOrderInput | SortOrder
    name?: SortOrder
    isActive?: SortOrder
    baseRates?: SortOrder
    perMileRates?: SortOrder
    priorityMultipliers?: SortOrder
    peakHourMultipliers?: SortOrder
    weekendMultipliers?: SortOrder
    seasonalMultipliers?: SortOrder
    zoneMultipliers?: SortOrder
    distanceTiers?: SortOrder
    specialRequirements?: SortOrder
    isolationPricing?: SortOrderInput | SortOrder
    bariatricPricing?: SortOrderInput | SortOrder
    oxygenPricing?: SortOrderInput | SortOrder
    monitoringPricing?: SortOrderInput | SortOrder
    insuranceRates?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: pricingModelCountOrderByAggregateInput
    _avg?: pricingModelAvgOrderByAggregateInput
    _max?: pricingModelMaxOrderByAggregateInput
    _min?: pricingModelMinOrderByAggregateInput
    _sum?: pricingModelSumOrderByAggregateInput
  }

  export type pricingModelScalarWhereWithAggregatesInput = {
    AND?: pricingModelScalarWhereWithAggregatesInput | pricingModelScalarWhereWithAggregatesInput[]
    OR?: pricingModelScalarWhereWithAggregatesInput[]
    NOT?: pricingModelScalarWhereWithAggregatesInput | pricingModelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"pricingModel"> | string
    agencyId?: StringNullableWithAggregatesFilter<"pricingModel"> | string | null
    name?: StringWithAggregatesFilter<"pricingModel"> | string
    isActive?: BoolWithAggregatesFilter<"pricingModel"> | boolean
    baseRates?: JsonWithAggregatesFilter<"pricingModel">
    perMileRates?: JsonWithAggregatesFilter<"pricingModel">
    priorityMultipliers?: JsonWithAggregatesFilter<"pricingModel">
    peakHourMultipliers?: JsonWithAggregatesFilter<"pricingModel">
    weekendMultipliers?: JsonWithAggregatesFilter<"pricingModel">
    seasonalMultipliers?: JsonWithAggregatesFilter<"pricingModel">
    zoneMultipliers?: JsonWithAggregatesFilter<"pricingModel">
    distanceTiers?: JsonWithAggregatesFilter<"pricingModel">
    specialRequirements?: JsonWithAggregatesFilter<"pricingModel">
    isolationPricing?: DecimalNullableWithAggregatesFilter<"pricingModel"> | Decimal | DecimalJsLike | number | string | null
    bariatricPricing?: DecimalNullableWithAggregatesFilter<"pricingModel"> | Decimal | DecimalJsLike | number | string | null
    oxygenPricing?: DecimalNullableWithAggregatesFilter<"pricingModel"> | Decimal | DecimalJsLike | number | string | null
    monitoringPricing?: DecimalNullableWithAggregatesFilter<"pricingModel"> | Decimal | DecimalJsLike | number | string | null
    insuranceRates?: JsonWithAggregatesFilter<"pricingModel">
    createdAt?: DateTimeWithAggregatesFilter<"pricingModel"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"pricingModel"> | Date | string
  }

  export type BackhaulOpportunitiesWhereInput = {
    AND?: BackhaulOpportunitiesWhereInput | BackhaulOpportunitiesWhereInput[]
    OR?: BackhaulOpportunitiesWhereInput[]
    NOT?: BackhaulOpportunitiesWhereInput | BackhaulOpportunitiesWhereInput[]
    id?: StringFilter<"BackhaulOpportunities"> | string
    tripId1?: StringFilter<"BackhaulOpportunities"> | string
    tripId2?: StringFilter<"BackhaulOpportunities"> | string
    revenueBonus?: DecimalNullableFilter<"BackhaulOpportunities"> | Decimal | DecimalJsLike | number | string | null
    efficiency?: DecimalNullableFilter<"BackhaulOpportunities"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"BackhaulOpportunities"> | Date | string
    isActive?: BoolFilter<"BackhaulOpportunities"> | boolean
  }

  export type BackhaulOpportunitiesOrderByWithRelationInput = {
    id?: SortOrder
    tripId1?: SortOrder
    tripId2?: SortOrder
    revenueBonus?: SortOrderInput | SortOrder
    efficiency?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    isActive?: SortOrder
  }

  export type BackhaulOpportunitiesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BackhaulOpportunitiesWhereInput | BackhaulOpportunitiesWhereInput[]
    OR?: BackhaulOpportunitiesWhereInput[]
    NOT?: BackhaulOpportunitiesWhereInput | BackhaulOpportunitiesWhereInput[]
    tripId1?: StringFilter<"BackhaulOpportunities"> | string
    tripId2?: StringFilter<"BackhaulOpportunities"> | string
    revenueBonus?: DecimalNullableFilter<"BackhaulOpportunities"> | Decimal | DecimalJsLike | number | string | null
    efficiency?: DecimalNullableFilter<"BackhaulOpportunities"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"BackhaulOpportunities"> | Date | string
    isActive?: BoolFilter<"BackhaulOpportunities"> | boolean
  }, "id">

  export type BackhaulOpportunitiesOrderByWithAggregationInput = {
    id?: SortOrder
    tripId1?: SortOrder
    tripId2?: SortOrder
    revenueBonus?: SortOrderInput | SortOrder
    efficiency?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    isActive?: SortOrder
    _count?: BackhaulOpportunitiesCountOrderByAggregateInput
    _avg?: BackhaulOpportunitiesAvgOrderByAggregateInput
    _max?: BackhaulOpportunitiesMaxOrderByAggregateInput
    _min?: BackhaulOpportunitiesMinOrderByAggregateInput
    _sum?: BackhaulOpportunitiesSumOrderByAggregateInput
  }

  export type BackhaulOpportunitiesScalarWhereWithAggregatesInput = {
    AND?: BackhaulOpportunitiesScalarWhereWithAggregatesInput | BackhaulOpportunitiesScalarWhereWithAggregatesInput[]
    OR?: BackhaulOpportunitiesScalarWhereWithAggregatesInput[]
    NOT?: BackhaulOpportunitiesScalarWhereWithAggregatesInput | BackhaulOpportunitiesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BackhaulOpportunities"> | string
    tripId1?: StringWithAggregatesFilter<"BackhaulOpportunities"> | string
    tripId2?: StringWithAggregatesFilter<"BackhaulOpportunities"> | string
    revenueBonus?: DecimalNullableWithAggregatesFilter<"BackhaulOpportunities"> | Decimal | DecimalJsLike | number | string | null
    efficiency?: DecimalNullableWithAggregatesFilter<"BackhaulOpportunities"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BackhaulOpportunities"> | Date | string
    isActive?: BoolWithAggregatesFilter<"BackhaulOpportunities"> | boolean
  }

  export type UnitAnalyticsWhereInput = {
    AND?: UnitAnalyticsWhereInput | UnitAnalyticsWhereInput[]
    OR?: UnitAnalyticsWhereInput[]
    NOT?: UnitAnalyticsWhereInput | UnitAnalyticsWhereInput[]
    id?: StringFilter<"UnitAnalytics"> | string
    unitId?: StringFilter<"UnitAnalytics"> | string
    performanceScore?: DecimalNullableFilter<"UnitAnalytics"> | Decimal | DecimalJsLike | number | string | null
    efficiency?: DecimalNullableFilter<"UnitAnalytics"> | Decimal | DecimalJsLike | number | string | null
    totalTrips?: IntFilter<"UnitAnalytics"> | number
    averageResponseTime?: DecimalNullableFilter<"UnitAnalytics"> | Decimal | DecimalJsLike | number | string | null
    lastUpdated?: DateTimeFilter<"UnitAnalytics"> | Date | string
  }

  export type UnitAnalyticsOrderByWithRelationInput = {
    id?: SortOrder
    unitId?: SortOrder
    performanceScore?: SortOrderInput | SortOrder
    efficiency?: SortOrderInput | SortOrder
    totalTrips?: SortOrder
    averageResponseTime?: SortOrderInput | SortOrder
    lastUpdated?: SortOrder
  }

  export type UnitAnalyticsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UnitAnalyticsWhereInput | UnitAnalyticsWhereInput[]
    OR?: UnitAnalyticsWhereInput[]
    NOT?: UnitAnalyticsWhereInput | UnitAnalyticsWhereInput[]
    unitId?: StringFilter<"UnitAnalytics"> | string
    performanceScore?: DecimalNullableFilter<"UnitAnalytics"> | Decimal | DecimalJsLike | number | string | null
    efficiency?: DecimalNullableFilter<"UnitAnalytics"> | Decimal | DecimalJsLike | number | string | null
    totalTrips?: IntFilter<"UnitAnalytics"> | number
    averageResponseTime?: DecimalNullableFilter<"UnitAnalytics"> | Decimal | DecimalJsLike | number | string | null
    lastUpdated?: DateTimeFilter<"UnitAnalytics"> | Date | string
  }, "id">

  export type UnitAnalyticsOrderByWithAggregationInput = {
    id?: SortOrder
    unitId?: SortOrder
    performanceScore?: SortOrderInput | SortOrder
    efficiency?: SortOrderInput | SortOrder
    totalTrips?: SortOrder
    averageResponseTime?: SortOrderInput | SortOrder
    lastUpdated?: SortOrder
    _count?: UnitAnalyticsCountOrderByAggregateInput
    _avg?: UnitAnalyticsAvgOrderByAggregateInput
    _max?: UnitAnalyticsMaxOrderByAggregateInput
    _min?: UnitAnalyticsMinOrderByAggregateInput
    _sum?: UnitAnalyticsSumOrderByAggregateInput
  }

  export type UnitAnalyticsScalarWhereWithAggregatesInput = {
    AND?: UnitAnalyticsScalarWhereWithAggregatesInput | UnitAnalyticsScalarWhereWithAggregatesInput[]
    OR?: UnitAnalyticsScalarWhereWithAggregatesInput[]
    NOT?: UnitAnalyticsScalarWhereWithAggregatesInput | UnitAnalyticsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UnitAnalytics"> | string
    unitId?: StringWithAggregatesFilter<"UnitAnalytics"> | string
    performanceScore?: DecimalNullableWithAggregatesFilter<"UnitAnalytics"> | Decimal | DecimalJsLike | number | string | null
    efficiency?: DecimalNullableWithAggregatesFilter<"UnitAnalytics"> | Decimal | DecimalJsLike | number | string | null
    totalTrips?: IntWithAggregatesFilter<"UnitAnalytics"> | number
    averageResponseTime?: DecimalNullableWithAggregatesFilter<"UnitAnalytics"> | Decimal | DecimalJsLike | number | string | null
    lastUpdated?: DateTimeWithAggregatesFilter<"UnitAnalytics"> | Date | string
  }

  export type RouteOptimizationSettingsWhereInput = {
    AND?: RouteOptimizationSettingsWhereInput | RouteOptimizationSettingsWhereInput[]
    OR?: RouteOptimizationSettingsWhereInput[]
    NOT?: RouteOptimizationSettingsWhereInput | RouteOptimizationSettingsWhereInput[]
    id?: StringFilter<"RouteOptimizationSettings"> | string
    agencyId?: StringNullableFilter<"RouteOptimizationSettings"> | string | null
    deadheadMileWeight?: DecimalFilter<"RouteOptimizationSettings"> | Decimal | DecimalJsLike | number | string
    waitTimeWeight?: DecimalFilter<"RouteOptimizationSettings"> | Decimal | DecimalJsLike | number | string
    backhaulBonusWeight?: DecimalFilter<"RouteOptimizationSettings"> | Decimal | DecimalJsLike | number | string
    overtimeRiskWeight?: DecimalFilter<"RouteOptimizationSettings"> | Decimal | DecimalJsLike | number | string
    revenueWeight?: DecimalFilter<"RouteOptimizationSettings"> | Decimal | DecimalJsLike | number | string
    maxDeadheadMiles?: DecimalFilter<"RouteOptimizationSettings"> | Decimal | DecimalJsLike | number | string
    maxWaitTimeMinutes?: IntFilter<"RouteOptimizationSettings"> | number
    maxOvertimeHours?: DecimalFilter<"RouteOptimizationSettings"> | Decimal | DecimalJsLike | number | string
    maxResponseTimeMinutes?: IntFilter<"RouteOptimizationSettings"> | number
    maxServiceDistance?: DecimalFilter<"RouteOptimizationSettings"> | Decimal | DecimalJsLike | number | string
    backhaulTimeWindow?: IntFilter<"RouteOptimizationSettings"> | number
    backhaulDistanceLimit?: DecimalFilter<"RouteOptimizationSettings"> | Decimal | DecimalJsLike | number | string
    backhaulRevenueBonus?: DecimalFilter<"RouteOptimizationSettings"> | Decimal | DecimalJsLike | number | string
    enableBackhaulOptimization?: BoolFilter<"RouteOptimizationSettings"> | boolean
    targetLoadedMileRatio?: DecimalFilter<"RouteOptimizationSettings"> | Decimal | DecimalJsLike | number | string
    targetRevenuePerHour?: DecimalFilter<"RouteOptimizationSettings"> | Decimal | DecimalJsLike | number | string
    targetResponseTime?: IntFilter<"RouteOptimizationSettings"> | number
    targetEfficiency?: DecimalFilter<"RouteOptimizationSettings"> | Decimal | DecimalJsLike | number | string
    optimizationAlgorithm?: StringFilter<"RouteOptimizationSettings"> | string
    maxOptimizationTime?: IntFilter<"RouteOptimizationSettings"> | number
    enableRealTimeOptimization?: BoolFilter<"RouteOptimizationSettings"> | boolean
    crewAvailabilityWeight?: DecimalFilter<"RouteOptimizationSettings"> | Decimal | DecimalJsLike | number | string
    equipmentCompatibilityWeight?: DecimalFilter<"RouteOptimizationSettings"> | Decimal | DecimalJsLike | number | string
    patientPriorityWeight?: DecimalFilter<"RouteOptimizationSettings"> | Decimal | DecimalJsLike | number | string
    isActive?: BoolFilter<"RouteOptimizationSettings"> | boolean
    createdAt?: DateTimeFilter<"RouteOptimizationSettings"> | Date | string
    updatedAt?: DateTimeFilter<"RouteOptimizationSettings"> | Date | string
  }

  export type RouteOptimizationSettingsOrderByWithRelationInput = {
    id?: SortOrder
    agencyId?: SortOrderInput | SortOrder
    deadheadMileWeight?: SortOrder
    waitTimeWeight?: SortOrder
    backhaulBonusWeight?: SortOrder
    overtimeRiskWeight?: SortOrder
    revenueWeight?: SortOrder
    maxDeadheadMiles?: SortOrder
    maxWaitTimeMinutes?: SortOrder
    maxOvertimeHours?: SortOrder
    maxResponseTimeMinutes?: SortOrder
    maxServiceDistance?: SortOrder
    backhaulTimeWindow?: SortOrder
    backhaulDistanceLimit?: SortOrder
    backhaulRevenueBonus?: SortOrder
    enableBackhaulOptimization?: SortOrder
    targetLoadedMileRatio?: SortOrder
    targetRevenuePerHour?: SortOrder
    targetResponseTime?: SortOrder
    targetEfficiency?: SortOrder
    optimizationAlgorithm?: SortOrder
    maxOptimizationTime?: SortOrder
    enableRealTimeOptimization?: SortOrder
    crewAvailabilityWeight?: SortOrder
    equipmentCompatibilityWeight?: SortOrder
    patientPriorityWeight?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RouteOptimizationSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RouteOptimizationSettingsWhereInput | RouteOptimizationSettingsWhereInput[]
    OR?: RouteOptimizationSettingsWhereInput[]
    NOT?: RouteOptimizationSettingsWhereInput | RouteOptimizationSettingsWhereInput[]
    agencyId?: StringNullableFilter<"RouteOptimizationSettings"> | string | null
    deadheadMileWeight?: DecimalFilter<"RouteOptimizationSettings"> | Decimal | DecimalJsLike | number | string
    waitTimeWeight?: DecimalFilter<"RouteOptimizationSettings"> | Decimal | DecimalJsLike | number | string
    backhaulBonusWeight?: DecimalFilter<"RouteOptimizationSettings"> | Decimal | DecimalJsLike | number | string
    overtimeRiskWeight?: DecimalFilter<"RouteOptimizationSettings"> | Decimal | DecimalJsLike | number | string
    revenueWeight?: DecimalFilter<"RouteOptimizationSettings"> | Decimal | DecimalJsLike | number | string
    maxDeadheadMiles?: DecimalFilter<"RouteOptimizationSettings"> | Decimal | DecimalJsLike | number | string
    maxWaitTimeMinutes?: IntFilter<"RouteOptimizationSettings"> | number
    maxOvertimeHours?: DecimalFilter<"RouteOptimizationSettings"> | Decimal | DecimalJsLike | number | string
    maxResponseTimeMinutes?: IntFilter<"RouteOptimizationSettings"> | number
    maxServiceDistance?: DecimalFilter<"RouteOptimizationSettings"> | Decimal | DecimalJsLike | number | string
    backhaulTimeWindow?: IntFilter<"RouteOptimizationSettings"> | number
    backhaulDistanceLimit?: DecimalFilter<"RouteOptimizationSettings"> | Decimal | DecimalJsLike | number | string
    backhaulRevenueBonus?: DecimalFilter<"RouteOptimizationSettings"> | Decimal | DecimalJsLike | number | string
    enableBackhaulOptimization?: BoolFilter<"RouteOptimizationSettings"> | boolean
    targetLoadedMileRatio?: DecimalFilter<"RouteOptimizationSettings"> | Decimal | DecimalJsLike | number | string
    targetRevenuePerHour?: DecimalFilter<"RouteOptimizationSettings"> | Decimal | DecimalJsLike | number | string
    targetResponseTime?: IntFilter<"RouteOptimizationSettings"> | number
    targetEfficiency?: DecimalFilter<"RouteOptimizationSettings"> | Decimal | DecimalJsLike | number | string
    optimizationAlgorithm?: StringFilter<"RouteOptimizationSettings"> | string
    maxOptimizationTime?: IntFilter<"RouteOptimizationSettings"> | number
    enableRealTimeOptimization?: BoolFilter<"RouteOptimizationSettings"> | boolean
    crewAvailabilityWeight?: DecimalFilter<"RouteOptimizationSettings"> | Decimal | DecimalJsLike | number | string
    equipmentCompatibilityWeight?: DecimalFilter<"RouteOptimizationSettings"> | Decimal | DecimalJsLike | number | string
    patientPriorityWeight?: DecimalFilter<"RouteOptimizationSettings"> | Decimal | DecimalJsLike | number | string
    isActive?: BoolFilter<"RouteOptimizationSettings"> | boolean
    createdAt?: DateTimeFilter<"RouteOptimizationSettings"> | Date | string
    updatedAt?: DateTimeFilter<"RouteOptimizationSettings"> | Date | string
  }, "id">

  export type RouteOptimizationSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    agencyId?: SortOrderInput | SortOrder
    deadheadMileWeight?: SortOrder
    waitTimeWeight?: SortOrder
    backhaulBonusWeight?: SortOrder
    overtimeRiskWeight?: SortOrder
    revenueWeight?: SortOrder
    maxDeadheadMiles?: SortOrder
    maxWaitTimeMinutes?: SortOrder
    maxOvertimeHours?: SortOrder
    maxResponseTimeMinutes?: SortOrder
    maxServiceDistance?: SortOrder
    backhaulTimeWindow?: SortOrder
    backhaulDistanceLimit?: SortOrder
    backhaulRevenueBonus?: SortOrder
    enableBackhaulOptimization?: SortOrder
    targetLoadedMileRatio?: SortOrder
    targetRevenuePerHour?: SortOrder
    targetResponseTime?: SortOrder
    targetEfficiency?: SortOrder
    optimizationAlgorithm?: SortOrder
    maxOptimizationTime?: SortOrder
    enableRealTimeOptimization?: SortOrder
    crewAvailabilityWeight?: SortOrder
    equipmentCompatibilityWeight?: SortOrder
    patientPriorityWeight?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RouteOptimizationSettingsCountOrderByAggregateInput
    _avg?: RouteOptimizationSettingsAvgOrderByAggregateInput
    _max?: RouteOptimizationSettingsMaxOrderByAggregateInput
    _min?: RouteOptimizationSettingsMinOrderByAggregateInput
    _sum?: RouteOptimizationSettingsSumOrderByAggregateInput
  }

  export type RouteOptimizationSettingsScalarWhereWithAggregatesInput = {
    AND?: RouteOptimizationSettingsScalarWhereWithAggregatesInput | RouteOptimizationSettingsScalarWhereWithAggregatesInput[]
    OR?: RouteOptimizationSettingsScalarWhereWithAggregatesInput[]
    NOT?: RouteOptimizationSettingsScalarWhereWithAggregatesInput | RouteOptimizationSettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RouteOptimizationSettings"> | string
    agencyId?: StringNullableWithAggregatesFilter<"RouteOptimizationSettings"> | string | null
    deadheadMileWeight?: DecimalWithAggregatesFilter<"RouteOptimizationSettings"> | Decimal | DecimalJsLike | number | string
    waitTimeWeight?: DecimalWithAggregatesFilter<"RouteOptimizationSettings"> | Decimal | DecimalJsLike | number | string
    backhaulBonusWeight?: DecimalWithAggregatesFilter<"RouteOptimizationSettings"> | Decimal | DecimalJsLike | number | string
    overtimeRiskWeight?: DecimalWithAggregatesFilter<"RouteOptimizationSettings"> | Decimal | DecimalJsLike | number | string
    revenueWeight?: DecimalWithAggregatesFilter<"RouteOptimizationSettings"> | Decimal | DecimalJsLike | number | string
    maxDeadheadMiles?: DecimalWithAggregatesFilter<"RouteOptimizationSettings"> | Decimal | DecimalJsLike | number | string
    maxWaitTimeMinutes?: IntWithAggregatesFilter<"RouteOptimizationSettings"> | number
    maxOvertimeHours?: DecimalWithAggregatesFilter<"RouteOptimizationSettings"> | Decimal | DecimalJsLike | number | string
    maxResponseTimeMinutes?: IntWithAggregatesFilter<"RouteOptimizationSettings"> | number
    maxServiceDistance?: DecimalWithAggregatesFilter<"RouteOptimizationSettings"> | Decimal | DecimalJsLike | number | string
    backhaulTimeWindow?: IntWithAggregatesFilter<"RouteOptimizationSettings"> | number
    backhaulDistanceLimit?: DecimalWithAggregatesFilter<"RouteOptimizationSettings"> | Decimal | DecimalJsLike | number | string
    backhaulRevenueBonus?: DecimalWithAggregatesFilter<"RouteOptimizationSettings"> | Decimal | DecimalJsLike | number | string
    enableBackhaulOptimization?: BoolWithAggregatesFilter<"RouteOptimizationSettings"> | boolean
    targetLoadedMileRatio?: DecimalWithAggregatesFilter<"RouteOptimizationSettings"> | Decimal | DecimalJsLike | number | string
    targetRevenuePerHour?: DecimalWithAggregatesFilter<"RouteOptimizationSettings"> | Decimal | DecimalJsLike | number | string
    targetResponseTime?: IntWithAggregatesFilter<"RouteOptimizationSettings"> | number
    targetEfficiency?: DecimalWithAggregatesFilter<"RouteOptimizationSettings"> | Decimal | DecimalJsLike | number | string
    optimizationAlgorithm?: StringWithAggregatesFilter<"RouteOptimizationSettings"> | string
    maxOptimizationTime?: IntWithAggregatesFilter<"RouteOptimizationSettings"> | number
    enableRealTimeOptimization?: BoolWithAggregatesFilter<"RouteOptimizationSettings"> | boolean
    crewAvailabilityWeight?: DecimalWithAggregatesFilter<"RouteOptimizationSettings"> | Decimal | DecimalJsLike | number | string
    equipmentCompatibilityWeight?: DecimalWithAggregatesFilter<"RouteOptimizationSettings"> | Decimal | DecimalJsLike | number | string
    patientPriorityWeight?: DecimalWithAggregatesFilter<"RouteOptimizationSettings"> | Decimal | DecimalJsLike | number | string
    isActive?: BoolWithAggregatesFilter<"RouteOptimizationSettings"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"RouteOptimizationSettings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RouteOptimizationSettings"> | Date | string
  }

  export type TripCostBreakdownWhereInput = {
    AND?: TripCostBreakdownWhereInput | TripCostBreakdownWhereInput[]
    OR?: TripCostBreakdownWhereInput[]
    NOT?: TripCostBreakdownWhereInput | TripCostBreakdownWhereInput[]
    id?: StringFilter<"TripCostBreakdown"> | string
    tripId?: StringFilter<"TripCostBreakdown"> | string
    baseRevenue?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    mileageRevenue?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    priorityRevenue?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    specialRequirementsRevenue?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    insuranceAdjustment?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    totalRevenue?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    crewLaborCost?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    vehicleCost?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    fuelCost?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    maintenanceCost?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    overheadCost?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    grossProfit?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    profitMargin?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    revenuePerMile?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    costPerMile?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    loadedMileRatio?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    deadheadMileRatio?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    utilizationRate?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    tripDistance?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    loadedMiles?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    deadheadMiles?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    tripDurationHours?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    transportLevel?: StringFilter<"TripCostBreakdown"> | string
    priorityLevel?: StringFilter<"TripCostBreakdown"> | string
    costCenterId?: StringNullableFilter<"TripCostBreakdown"> | string | null
    costCenterName?: StringNullableFilter<"TripCostBreakdown"> | string | null
    calculatedAt?: DateTimeFilter<"TripCostBreakdown"> | Date | string
    createdAt?: DateTimeFilter<"TripCostBreakdown"> | Date | string
    updatedAt?: DateTimeFilter<"TripCostBreakdown"> | Date | string
  }

  export type TripCostBreakdownOrderByWithRelationInput = {
    id?: SortOrder
    tripId?: SortOrder
    baseRevenue?: SortOrder
    mileageRevenue?: SortOrder
    priorityRevenue?: SortOrder
    specialRequirementsRevenue?: SortOrder
    insuranceAdjustment?: SortOrder
    totalRevenue?: SortOrder
    crewLaborCost?: SortOrder
    vehicleCost?: SortOrder
    fuelCost?: SortOrder
    maintenanceCost?: SortOrder
    overheadCost?: SortOrder
    totalCost?: SortOrder
    grossProfit?: SortOrder
    profitMargin?: SortOrder
    revenuePerMile?: SortOrder
    costPerMile?: SortOrder
    loadedMileRatio?: SortOrder
    deadheadMileRatio?: SortOrder
    utilizationRate?: SortOrder
    tripDistance?: SortOrder
    loadedMiles?: SortOrder
    deadheadMiles?: SortOrder
    tripDurationHours?: SortOrder
    transportLevel?: SortOrder
    priorityLevel?: SortOrder
    costCenterId?: SortOrderInput | SortOrder
    costCenterName?: SortOrderInput | SortOrder
    calculatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TripCostBreakdownWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TripCostBreakdownWhereInput | TripCostBreakdownWhereInput[]
    OR?: TripCostBreakdownWhereInput[]
    NOT?: TripCostBreakdownWhereInput | TripCostBreakdownWhereInput[]
    tripId?: StringFilter<"TripCostBreakdown"> | string
    baseRevenue?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    mileageRevenue?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    priorityRevenue?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    specialRequirementsRevenue?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    insuranceAdjustment?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    totalRevenue?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    crewLaborCost?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    vehicleCost?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    fuelCost?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    maintenanceCost?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    overheadCost?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    grossProfit?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    profitMargin?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    revenuePerMile?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    costPerMile?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    loadedMileRatio?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    deadheadMileRatio?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    utilizationRate?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    tripDistance?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    loadedMiles?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    deadheadMiles?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    tripDurationHours?: DecimalFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    transportLevel?: StringFilter<"TripCostBreakdown"> | string
    priorityLevel?: StringFilter<"TripCostBreakdown"> | string
    costCenterId?: StringNullableFilter<"TripCostBreakdown"> | string | null
    costCenterName?: StringNullableFilter<"TripCostBreakdown"> | string | null
    calculatedAt?: DateTimeFilter<"TripCostBreakdown"> | Date | string
    createdAt?: DateTimeFilter<"TripCostBreakdown"> | Date | string
    updatedAt?: DateTimeFilter<"TripCostBreakdown"> | Date | string
  }, "id">

  export type TripCostBreakdownOrderByWithAggregationInput = {
    id?: SortOrder
    tripId?: SortOrder
    baseRevenue?: SortOrder
    mileageRevenue?: SortOrder
    priorityRevenue?: SortOrder
    specialRequirementsRevenue?: SortOrder
    insuranceAdjustment?: SortOrder
    totalRevenue?: SortOrder
    crewLaborCost?: SortOrder
    vehicleCost?: SortOrder
    fuelCost?: SortOrder
    maintenanceCost?: SortOrder
    overheadCost?: SortOrder
    totalCost?: SortOrder
    grossProfit?: SortOrder
    profitMargin?: SortOrder
    revenuePerMile?: SortOrder
    costPerMile?: SortOrder
    loadedMileRatio?: SortOrder
    deadheadMileRatio?: SortOrder
    utilizationRate?: SortOrder
    tripDistance?: SortOrder
    loadedMiles?: SortOrder
    deadheadMiles?: SortOrder
    tripDurationHours?: SortOrder
    transportLevel?: SortOrder
    priorityLevel?: SortOrder
    costCenterId?: SortOrderInput | SortOrder
    costCenterName?: SortOrderInput | SortOrder
    calculatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TripCostBreakdownCountOrderByAggregateInput
    _avg?: TripCostBreakdownAvgOrderByAggregateInput
    _max?: TripCostBreakdownMaxOrderByAggregateInput
    _min?: TripCostBreakdownMinOrderByAggregateInput
    _sum?: TripCostBreakdownSumOrderByAggregateInput
  }

  export type TripCostBreakdownScalarWhereWithAggregatesInput = {
    AND?: TripCostBreakdownScalarWhereWithAggregatesInput | TripCostBreakdownScalarWhereWithAggregatesInput[]
    OR?: TripCostBreakdownScalarWhereWithAggregatesInput[]
    NOT?: TripCostBreakdownScalarWhereWithAggregatesInput | TripCostBreakdownScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TripCostBreakdown"> | string
    tripId?: StringWithAggregatesFilter<"TripCostBreakdown"> | string
    baseRevenue?: DecimalWithAggregatesFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    mileageRevenue?: DecimalWithAggregatesFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    priorityRevenue?: DecimalWithAggregatesFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    specialRequirementsRevenue?: DecimalWithAggregatesFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    insuranceAdjustment?: DecimalWithAggregatesFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    totalRevenue?: DecimalWithAggregatesFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    crewLaborCost?: DecimalWithAggregatesFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    vehicleCost?: DecimalWithAggregatesFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    fuelCost?: DecimalWithAggregatesFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    maintenanceCost?: DecimalWithAggregatesFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    overheadCost?: DecimalWithAggregatesFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalWithAggregatesFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    grossProfit?: DecimalWithAggregatesFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    profitMargin?: DecimalWithAggregatesFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    revenuePerMile?: DecimalWithAggregatesFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    costPerMile?: DecimalWithAggregatesFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    loadedMileRatio?: DecimalWithAggregatesFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    deadheadMileRatio?: DecimalWithAggregatesFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    utilizationRate?: DecimalWithAggregatesFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    tripDistance?: DecimalWithAggregatesFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    loadedMiles?: DecimalWithAggregatesFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    deadheadMiles?: DecimalWithAggregatesFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    tripDurationHours?: DecimalWithAggregatesFilter<"TripCostBreakdown"> | Decimal | DecimalJsLike | number | string
    transportLevel?: StringWithAggregatesFilter<"TripCostBreakdown"> | string
    priorityLevel?: StringWithAggregatesFilter<"TripCostBreakdown"> | string
    costCenterId?: StringNullableWithAggregatesFilter<"TripCostBreakdown"> | string | null
    costCenterName?: StringNullableWithAggregatesFilter<"TripCostBreakdown"> | string | null
    calculatedAt?: DateTimeWithAggregatesFilter<"TripCostBreakdown"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"TripCostBreakdown"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TripCostBreakdown"> | Date | string
  }

  export type CostCenterWhereInput = {
    AND?: CostCenterWhereInput | CostCenterWhereInput[]
    OR?: CostCenterWhereInput[]
    NOT?: CostCenterWhereInput | CostCenterWhereInput[]
    id?: StringFilter<"CostCenter"> | string
    name?: StringFilter<"CostCenter"> | string
    description?: StringNullableFilter<"CostCenter"> | string | null
    code?: StringFilter<"CostCenter"> | string
    overheadRate?: DecimalFilter<"CostCenter"> | Decimal | DecimalJsLike | number | string
    fixedCosts?: DecimalFilter<"CostCenter"> | Decimal | DecimalJsLike | number | string
    variableCosts?: DecimalFilter<"CostCenter"> | Decimal | DecimalJsLike | number | string
    allocationMethod?: StringFilter<"CostCenter"> | string
    isActive?: BoolFilter<"CostCenter"> | boolean
    createdAt?: DateTimeFilter<"CostCenter"> | Date | string
    updatedAt?: DateTimeFilter<"CostCenter"> | Date | string
  }

  export type CostCenterOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    code?: SortOrder
    overheadRate?: SortOrder
    fixedCosts?: SortOrder
    variableCosts?: SortOrder
    allocationMethod?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CostCenterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: CostCenterWhereInput | CostCenterWhereInput[]
    OR?: CostCenterWhereInput[]
    NOT?: CostCenterWhereInput | CostCenterWhereInput[]
    name?: StringFilter<"CostCenter"> | string
    description?: StringNullableFilter<"CostCenter"> | string | null
    overheadRate?: DecimalFilter<"CostCenter"> | Decimal | DecimalJsLike | number | string
    fixedCosts?: DecimalFilter<"CostCenter"> | Decimal | DecimalJsLike | number | string
    variableCosts?: DecimalFilter<"CostCenter"> | Decimal | DecimalJsLike | number | string
    allocationMethod?: StringFilter<"CostCenter"> | string
    isActive?: BoolFilter<"CostCenter"> | boolean
    createdAt?: DateTimeFilter<"CostCenter"> | Date | string
    updatedAt?: DateTimeFilter<"CostCenter"> | Date | string
  }, "id" | "code">

  export type CostCenterOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    code?: SortOrder
    overheadRate?: SortOrder
    fixedCosts?: SortOrder
    variableCosts?: SortOrder
    allocationMethod?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CostCenterCountOrderByAggregateInput
    _avg?: CostCenterAvgOrderByAggregateInput
    _max?: CostCenterMaxOrderByAggregateInput
    _min?: CostCenterMinOrderByAggregateInput
    _sum?: CostCenterSumOrderByAggregateInput
  }

  export type CostCenterScalarWhereWithAggregatesInput = {
    AND?: CostCenterScalarWhereWithAggregatesInput | CostCenterScalarWhereWithAggregatesInput[]
    OR?: CostCenterScalarWhereWithAggregatesInput[]
    NOT?: CostCenterScalarWhereWithAggregatesInput | CostCenterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CostCenter"> | string
    name?: StringWithAggregatesFilter<"CostCenter"> | string
    description?: StringNullableWithAggregatesFilter<"CostCenter"> | string | null
    code?: StringWithAggregatesFilter<"CostCenter"> | string
    overheadRate?: DecimalWithAggregatesFilter<"CostCenter"> | Decimal | DecimalJsLike | number | string
    fixedCosts?: DecimalWithAggregatesFilter<"CostCenter"> | Decimal | DecimalJsLike | number | string
    variableCosts?: DecimalWithAggregatesFilter<"CostCenter"> | Decimal | DecimalJsLike | number | string
    allocationMethod?: StringWithAggregatesFilter<"CostCenter"> | string
    isActive?: BoolWithAggregatesFilter<"CostCenter"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CostCenter"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CostCenter"> | Date | string
  }

  export type CenterUserCreateInput = {
    id?: string
    email: string
    password: string
    name: string
    userType: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CenterUserUncheckedCreateInput = {
    id?: string
    email: string
    password: string
    name: string
    userType: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CenterUserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CenterUserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CenterUserCreateManyInput = {
    id?: string
    email: string
    password: string
    name: string
    userType: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CenterUserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CenterUserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HospitalCreateInput = {
    id?: string
    name: string
    address: string
    city: string
    state: string
    zipCode: string
    phone?: string | null
    email?: string | null
    type: string
    capabilities?: HospitalCreatecapabilitiesInput | string[]
    region: string
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    latitude?: number | null
    longitude?: number | null
    operatingHours?: string | null
    isActive?: boolean
    requiresReview?: boolean
    approvedAt?: Date | string | null
    approvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pickupLocations?: PickupLocationCreateNestedManyWithoutHospitalInput
  }

  export type HospitalUncheckedCreateInput = {
    id?: string
    name: string
    address: string
    city: string
    state: string
    zipCode: string
    phone?: string | null
    email?: string | null
    type: string
    capabilities?: HospitalCreatecapabilitiesInput | string[]
    region: string
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    latitude?: number | null
    longitude?: number | null
    operatingHours?: string | null
    isActive?: boolean
    requiresReview?: boolean
    approvedAt?: Date | string | null
    approvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pickupLocations?: PickupLocationUncheckedCreateNestedManyWithoutHospitalInput
  }

  export type HospitalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    capabilities?: HospitalUpdatecapabilitiesInput | string[]
    region?: StringFieldUpdateOperationsInput | string
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    operatingHours?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requiresReview?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pickupLocations?: PickupLocationUpdateManyWithoutHospitalNestedInput
  }

  export type HospitalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    capabilities?: HospitalUpdatecapabilitiesInput | string[]
    region?: StringFieldUpdateOperationsInput | string
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    operatingHours?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requiresReview?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pickupLocations?: PickupLocationUncheckedUpdateManyWithoutHospitalNestedInput
  }

  export type HospitalCreateManyInput = {
    id?: string
    name: string
    address: string
    city: string
    state: string
    zipCode: string
    phone?: string | null
    email?: string | null
    type: string
    capabilities?: HospitalCreatecapabilitiesInput | string[]
    region: string
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    latitude?: number | null
    longitude?: number | null
    operatingHours?: string | null
    isActive?: boolean
    requiresReview?: boolean
    approvedAt?: Date | string | null
    approvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HospitalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    capabilities?: HospitalUpdatecapabilitiesInput | string[]
    region?: StringFieldUpdateOperationsInput | string
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    operatingHours?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requiresReview?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HospitalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    capabilities?: HospitalUpdatecapabilitiesInput | string[]
    region?: StringFieldUpdateOperationsInput | string
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    operatingHours?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requiresReview?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PickupLocationCreateInput = {
    id?: string
    name: string
    description?: string | null
    contactPhone?: string | null
    contactEmail?: string | null
    floor?: string | null
    room?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    hospital: HospitalCreateNestedOneWithoutPickupLocationsInput
    trips?: TripCreateNestedManyWithoutPickupLocationInput
  }

  export type PickupLocationUncheckedCreateInput = {
    id?: string
    hospitalId: string
    name: string
    description?: string | null
    contactPhone?: string | null
    contactEmail?: string | null
    floor?: string | null
    room?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    trips?: TripUncheckedCreateNestedManyWithoutPickupLocationInput
  }

  export type PickupLocationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hospital?: HospitalUpdateOneRequiredWithoutPickupLocationsNestedInput
    trips?: TripUpdateManyWithoutPickupLocationNestedInput
  }

  export type PickupLocationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hospitalId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trips?: TripUncheckedUpdateManyWithoutPickupLocationNestedInput
  }

  export type PickupLocationCreateManyInput = {
    id?: string
    hospitalId: string
    name: string
    description?: string | null
    contactPhone?: string | null
    contactEmail?: string | null
    floor?: string | null
    room?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PickupLocationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PickupLocationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    hospitalId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EMSAgencyCreateInput = {
    id?: string
    name: string
    contactName: string
    phone: string
    email: string
    address: string
    city: string
    state: string
    zipCode: string
    serviceArea?: EMSAgencyCreateserviceAreaInput | string[]
    operatingHours?: NullableJsonNullValueInput | InputJsonValue
    capabilities?: EMSAgencyCreatecapabilitiesInput | string[]
    pricingStructure?: NullableJsonNullValueInput | InputJsonValue
    latitude?: number | null
    longitude?: number | null
    serviceRadius?: number | null
    totalUnits?: number
    availableUnits?: number
    lastUpdated?: Date | string
    acceptsNotifications?: boolean
    notificationMethods?: EMSAgencyCreatenotificationMethodsInput | string[]
    isActive?: boolean
    status?: string
    requiresReview?: boolean
    approvedAt?: Date | string | null
    approvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EMSAgencyUncheckedCreateInput = {
    id?: string
    name: string
    contactName: string
    phone: string
    email: string
    address: string
    city: string
    state: string
    zipCode: string
    serviceArea?: EMSAgencyCreateserviceAreaInput | string[]
    operatingHours?: NullableJsonNullValueInput | InputJsonValue
    capabilities?: EMSAgencyCreatecapabilitiesInput | string[]
    pricingStructure?: NullableJsonNullValueInput | InputJsonValue
    latitude?: number | null
    longitude?: number | null
    serviceRadius?: number | null
    totalUnits?: number
    availableUnits?: number
    lastUpdated?: Date | string
    acceptsNotifications?: boolean
    notificationMethods?: EMSAgencyCreatenotificationMethodsInput | string[]
    isActive?: boolean
    status?: string
    requiresReview?: boolean
    approvedAt?: Date | string | null
    approvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EMSAgencyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    serviceArea?: EMSAgencyUpdateserviceAreaInput | string[]
    operatingHours?: NullableJsonNullValueInput | InputJsonValue
    capabilities?: EMSAgencyUpdatecapabilitiesInput | string[]
    pricingStructure?: NullableJsonNullValueInput | InputJsonValue
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceRadius?: NullableIntFieldUpdateOperationsInput | number | null
    totalUnits?: IntFieldUpdateOperationsInput | number
    availableUnits?: IntFieldUpdateOperationsInput | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptsNotifications?: BoolFieldUpdateOperationsInput | boolean
    notificationMethods?: EMSAgencyUpdatenotificationMethodsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    requiresReview?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EMSAgencyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    serviceArea?: EMSAgencyUpdateserviceAreaInput | string[]
    operatingHours?: NullableJsonNullValueInput | InputJsonValue
    capabilities?: EMSAgencyUpdatecapabilitiesInput | string[]
    pricingStructure?: NullableJsonNullValueInput | InputJsonValue
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceRadius?: NullableIntFieldUpdateOperationsInput | number | null
    totalUnits?: IntFieldUpdateOperationsInput | number
    availableUnits?: IntFieldUpdateOperationsInput | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptsNotifications?: BoolFieldUpdateOperationsInput | boolean
    notificationMethods?: EMSAgencyUpdatenotificationMethodsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    requiresReview?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EMSAgencyCreateManyInput = {
    id?: string
    name: string
    contactName: string
    phone: string
    email: string
    address: string
    city: string
    state: string
    zipCode: string
    serviceArea?: EMSAgencyCreateserviceAreaInput | string[]
    operatingHours?: NullableJsonNullValueInput | InputJsonValue
    capabilities?: EMSAgencyCreatecapabilitiesInput | string[]
    pricingStructure?: NullableJsonNullValueInput | InputJsonValue
    latitude?: number | null
    longitude?: number | null
    serviceRadius?: number | null
    totalUnits?: number
    availableUnits?: number
    lastUpdated?: Date | string
    acceptsNotifications?: boolean
    notificationMethods?: EMSAgencyCreatenotificationMethodsInput | string[]
    isActive?: boolean
    status?: string
    requiresReview?: boolean
    approvedAt?: Date | string | null
    approvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EMSAgencyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    serviceArea?: EMSAgencyUpdateserviceAreaInput | string[]
    operatingHours?: NullableJsonNullValueInput | InputJsonValue
    capabilities?: EMSAgencyUpdatecapabilitiesInput | string[]
    pricingStructure?: NullableJsonNullValueInput | InputJsonValue
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceRadius?: NullableIntFieldUpdateOperationsInput | number | null
    totalUnits?: IntFieldUpdateOperationsInput | number
    availableUnits?: IntFieldUpdateOperationsInput | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptsNotifications?: BoolFieldUpdateOperationsInput | boolean
    notificationMethods?: EMSAgencyUpdatenotificationMethodsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    requiresReview?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EMSAgencyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    serviceArea?: EMSAgencyUpdateserviceAreaInput | string[]
    operatingHours?: NullableJsonNullValueInput | InputJsonValue
    capabilities?: EMSAgencyUpdatecapabilitiesInput | string[]
    pricingStructure?: NullableJsonNullValueInput | InputJsonValue
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceRadius?: NullableIntFieldUpdateOperationsInput | number | null
    totalUnits?: IntFieldUpdateOperationsInput | number
    availableUnits?: IntFieldUpdateOperationsInput | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptsNotifications?: BoolFieldUpdateOperationsInput | boolean
    notificationMethods?: EMSAgencyUpdatenotificationMethodsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    requiresReview?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TripCreateInput = {
    id?: string
    tripNumber: string
    patientId: string
    patientWeight?: string | null
    specialNeeds?: string | null
    insuranceCompany?: string | null
    fromLocation: string
    toLocation: string
    scheduledTime: Date | string
    transportLevel: string
    urgencyLevel: string
    originLatitude?: number | null
    originLongitude?: number | null
    destinationLatitude?: number | null
    destinationLongitude?: number | null
    diagnosis?: string | null
    mobilityLevel?: string | null
    oxygenRequired?: boolean
    monitoringRequired?: boolean
    generateQRCode?: boolean
    qrCodeData?: string | null
    selectedAgencies?: TripCreateselectedAgenciesInput | string[]
    notificationRadius?: number | null
    transferRequestTime?: Date | string | null
    transferAcceptedTime?: Date | string | null
    emsArrivalTime?: Date | string | null
    emsDepartureTime?: Date | string | null
    tripCost?: Decimal | DecimalJsLike | number | string | null
    distanceMiles?: number | null
    responseTimeMinutes?: number | null
    deadheadMiles?: number | null
    insurancePayRate?: Decimal | DecimalJsLike | number | string | null
    perMileRate?: Decimal | DecimalJsLike | number | string | null
    requestTimestamp?: Date | string | null
    estimatedTripTimeMinutes?: number | null
    actualTripTimeMinutes?: number | null
    completionTimeMinutes?: number | null
    loadedMiles?: Decimal | DecimalJsLike | number | string | null
    customerSatisfaction?: number | null
    efficiency?: Decimal | DecimalJsLike | number | string | null
    performanceScore?: Decimal | DecimalJsLike | number | string | null
    revenuePerHour?: Decimal | DecimalJsLike | number | string | null
    backhaulOpportunity?: boolean
    actualStartTime?: Date | string | null
    actualEndTime?: Date | string | null
    status: string
    priority: string
    notes?: string | null
    assignedTo?: string | null
    assignedAgencyId?: string | null
    assignedUnitId?: string | null
    acceptedTimestamp?: Date | string | null
    pickupTimestamp?: Date | string | null
    completionTimestamp?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pickupLocation?: PickupLocationCreateNestedOneWithoutTripsInput
  }

  export type TripUncheckedCreateInput = {
    id?: string
    tripNumber: string
    patientId: string
    patientWeight?: string | null
    specialNeeds?: string | null
    insuranceCompany?: string | null
    fromLocation: string
    pickupLocationId?: string | null
    toLocation: string
    scheduledTime: Date | string
    transportLevel: string
    urgencyLevel: string
    originLatitude?: number | null
    originLongitude?: number | null
    destinationLatitude?: number | null
    destinationLongitude?: number | null
    diagnosis?: string | null
    mobilityLevel?: string | null
    oxygenRequired?: boolean
    monitoringRequired?: boolean
    generateQRCode?: boolean
    qrCodeData?: string | null
    selectedAgencies?: TripCreateselectedAgenciesInput | string[]
    notificationRadius?: number | null
    transferRequestTime?: Date | string | null
    transferAcceptedTime?: Date | string | null
    emsArrivalTime?: Date | string | null
    emsDepartureTime?: Date | string | null
    tripCost?: Decimal | DecimalJsLike | number | string | null
    distanceMiles?: number | null
    responseTimeMinutes?: number | null
    deadheadMiles?: number | null
    insurancePayRate?: Decimal | DecimalJsLike | number | string | null
    perMileRate?: Decimal | DecimalJsLike | number | string | null
    requestTimestamp?: Date | string | null
    estimatedTripTimeMinutes?: number | null
    actualTripTimeMinutes?: number | null
    completionTimeMinutes?: number | null
    loadedMiles?: Decimal | DecimalJsLike | number | string | null
    customerSatisfaction?: number | null
    efficiency?: Decimal | DecimalJsLike | number | string | null
    performanceScore?: Decimal | DecimalJsLike | number | string | null
    revenuePerHour?: Decimal | DecimalJsLike | number | string | null
    backhaulOpportunity?: boolean
    actualStartTime?: Date | string | null
    actualEndTime?: Date | string | null
    status: string
    priority: string
    notes?: string | null
    assignedTo?: string | null
    assignedAgencyId?: string | null
    assignedUnitId?: string | null
    acceptedTimestamp?: Date | string | null
    pickupTimestamp?: Date | string | null
    completionTimestamp?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TripUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripNumber?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    patientWeight?: NullableStringFieldUpdateOperationsInput | string | null
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceCompany?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocation?: StringFieldUpdateOperationsInput | string
    toLocation?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    transportLevel?: StringFieldUpdateOperationsInput | string
    urgencyLevel?: StringFieldUpdateOperationsInput | string
    originLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    originLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    mobilityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    oxygenRequired?: BoolFieldUpdateOperationsInput | boolean
    monitoringRequired?: BoolFieldUpdateOperationsInput | boolean
    generateQRCode?: BoolFieldUpdateOperationsInput | boolean
    qrCodeData?: NullableStringFieldUpdateOperationsInput | string | null
    selectedAgencies?: TripUpdateselectedAgenciesInput | string[]
    notificationRadius?: NullableIntFieldUpdateOperationsInput | number | null
    transferRequestTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferAcceptedTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emsArrivalTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emsDepartureTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tripCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    distanceMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    responseTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    deadheadMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    insurancePayRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    perMileRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    requestTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedTripTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    actualTripTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    completionTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    loadedMiles?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    customerSatisfaction?: NullableIntFieldUpdateOperationsInput | number | null
    efficiency?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    performanceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    revenuePerHour?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    backhaulOpportunity?: BoolFieldUpdateOperationsInput | boolean
    actualStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAgencyId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pickupLocation?: PickupLocationUpdateOneWithoutTripsNestedInput
  }

  export type TripUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripNumber?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    patientWeight?: NullableStringFieldUpdateOperationsInput | string | null
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceCompany?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocation?: StringFieldUpdateOperationsInput | string
    pickupLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    toLocation?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    transportLevel?: StringFieldUpdateOperationsInput | string
    urgencyLevel?: StringFieldUpdateOperationsInput | string
    originLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    originLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    mobilityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    oxygenRequired?: BoolFieldUpdateOperationsInput | boolean
    monitoringRequired?: BoolFieldUpdateOperationsInput | boolean
    generateQRCode?: BoolFieldUpdateOperationsInput | boolean
    qrCodeData?: NullableStringFieldUpdateOperationsInput | string | null
    selectedAgencies?: TripUpdateselectedAgenciesInput | string[]
    notificationRadius?: NullableIntFieldUpdateOperationsInput | number | null
    transferRequestTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferAcceptedTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emsArrivalTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emsDepartureTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tripCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    distanceMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    responseTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    deadheadMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    insurancePayRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    perMileRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    requestTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedTripTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    actualTripTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    completionTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    loadedMiles?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    customerSatisfaction?: NullableIntFieldUpdateOperationsInput | number | null
    efficiency?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    performanceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    revenuePerHour?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    backhaulOpportunity?: BoolFieldUpdateOperationsInput | boolean
    actualStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAgencyId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TripCreateManyInput = {
    id?: string
    tripNumber: string
    patientId: string
    patientWeight?: string | null
    specialNeeds?: string | null
    insuranceCompany?: string | null
    fromLocation: string
    pickupLocationId?: string | null
    toLocation: string
    scheduledTime: Date | string
    transportLevel: string
    urgencyLevel: string
    originLatitude?: number | null
    originLongitude?: number | null
    destinationLatitude?: number | null
    destinationLongitude?: number | null
    diagnosis?: string | null
    mobilityLevel?: string | null
    oxygenRequired?: boolean
    monitoringRequired?: boolean
    generateQRCode?: boolean
    qrCodeData?: string | null
    selectedAgencies?: TripCreateselectedAgenciesInput | string[]
    notificationRadius?: number | null
    transferRequestTime?: Date | string | null
    transferAcceptedTime?: Date | string | null
    emsArrivalTime?: Date | string | null
    emsDepartureTime?: Date | string | null
    tripCost?: Decimal | DecimalJsLike | number | string | null
    distanceMiles?: number | null
    responseTimeMinutes?: number | null
    deadheadMiles?: number | null
    insurancePayRate?: Decimal | DecimalJsLike | number | string | null
    perMileRate?: Decimal | DecimalJsLike | number | string | null
    requestTimestamp?: Date | string | null
    estimatedTripTimeMinutes?: number | null
    actualTripTimeMinutes?: number | null
    completionTimeMinutes?: number | null
    loadedMiles?: Decimal | DecimalJsLike | number | string | null
    customerSatisfaction?: number | null
    efficiency?: Decimal | DecimalJsLike | number | string | null
    performanceScore?: Decimal | DecimalJsLike | number | string | null
    revenuePerHour?: Decimal | DecimalJsLike | number | string | null
    backhaulOpportunity?: boolean
    actualStartTime?: Date | string | null
    actualEndTime?: Date | string | null
    status: string
    priority: string
    notes?: string | null
    assignedTo?: string | null
    assignedAgencyId?: string | null
    assignedUnitId?: string | null
    acceptedTimestamp?: Date | string | null
    pickupTimestamp?: Date | string | null
    completionTimestamp?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TripUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripNumber?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    patientWeight?: NullableStringFieldUpdateOperationsInput | string | null
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceCompany?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocation?: StringFieldUpdateOperationsInput | string
    toLocation?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    transportLevel?: StringFieldUpdateOperationsInput | string
    urgencyLevel?: StringFieldUpdateOperationsInput | string
    originLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    originLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    mobilityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    oxygenRequired?: BoolFieldUpdateOperationsInput | boolean
    monitoringRequired?: BoolFieldUpdateOperationsInput | boolean
    generateQRCode?: BoolFieldUpdateOperationsInput | boolean
    qrCodeData?: NullableStringFieldUpdateOperationsInput | string | null
    selectedAgencies?: TripUpdateselectedAgenciesInput | string[]
    notificationRadius?: NullableIntFieldUpdateOperationsInput | number | null
    transferRequestTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferAcceptedTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emsArrivalTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emsDepartureTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tripCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    distanceMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    responseTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    deadheadMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    insurancePayRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    perMileRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    requestTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedTripTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    actualTripTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    completionTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    loadedMiles?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    customerSatisfaction?: NullableIntFieldUpdateOperationsInput | number | null
    efficiency?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    performanceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    revenuePerHour?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    backhaulOpportunity?: BoolFieldUpdateOperationsInput | boolean
    actualStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAgencyId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TripUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripNumber?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    patientWeight?: NullableStringFieldUpdateOperationsInput | string | null
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceCompany?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocation?: StringFieldUpdateOperationsInput | string
    pickupLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    toLocation?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    transportLevel?: StringFieldUpdateOperationsInput | string
    urgencyLevel?: StringFieldUpdateOperationsInput | string
    originLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    originLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    mobilityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    oxygenRequired?: BoolFieldUpdateOperationsInput | boolean
    monitoringRequired?: BoolFieldUpdateOperationsInput | boolean
    generateQRCode?: BoolFieldUpdateOperationsInput | boolean
    qrCodeData?: NullableStringFieldUpdateOperationsInput | string | null
    selectedAgencies?: TripUpdateselectedAgenciesInput | string[]
    notificationRadius?: NullableIntFieldUpdateOperationsInput | number | null
    transferRequestTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferAcceptedTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emsArrivalTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emsDepartureTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tripCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    distanceMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    responseTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    deadheadMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    insurancePayRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    perMileRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    requestTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedTripTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    actualTripTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    completionTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    loadedMiles?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    customerSatisfaction?: NullableIntFieldUpdateOperationsInput | number | null
    efficiency?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    performanceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    revenuePerHour?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    backhaulOpportunity?: BoolFieldUpdateOperationsInput | boolean
    actualStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAgencyId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemAnalyticsCreateInput = {
    id?: string
    metricName: string
    metricValue: JsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    createdAt?: Date | string
    userId?: string | null
  }

  export type SystemAnalyticsUncheckedCreateInput = {
    id?: string
    metricName: string
    metricValue: JsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    createdAt?: Date | string
    userId?: string | null
  }

  export type SystemAnalyticsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    metricName?: StringFieldUpdateOperationsInput | string
    metricValue?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SystemAnalyticsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    metricName?: StringFieldUpdateOperationsInput | string
    metricValue?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SystemAnalyticsCreateManyInput = {
    id?: string
    metricName: string
    metricValue: JsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    createdAt?: Date | string
    userId?: string | null
  }

  export type SystemAnalyticsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    metricName?: StringFieldUpdateOperationsInput | string
    metricValue?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SystemAnalyticsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    metricName?: StringFieldUpdateOperationsInput | string
    metricValue?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type pricingModelCreateInput = {
    id?: string
    agencyId?: string | null
    name: string
    isActive?: boolean
    baseRates: JsonNullValueInput | InputJsonValue
    perMileRates: JsonNullValueInput | InputJsonValue
    priorityMultipliers: JsonNullValueInput | InputJsonValue
    peakHourMultipliers: JsonNullValueInput | InputJsonValue
    weekendMultipliers: JsonNullValueInput | InputJsonValue
    seasonalMultipliers: JsonNullValueInput | InputJsonValue
    zoneMultipliers: JsonNullValueInput | InputJsonValue
    distanceTiers: JsonNullValueInput | InputJsonValue
    specialRequirements: JsonNullValueInput | InputJsonValue
    isolationPricing?: Decimal | DecimalJsLike | number | string | null
    bariatricPricing?: Decimal | DecimalJsLike | number | string | null
    oxygenPricing?: Decimal | DecimalJsLike | number | string | null
    monitoringPricing?: Decimal | DecimalJsLike | number | string | null
    insuranceRates: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type pricingModelUncheckedCreateInput = {
    id?: string
    agencyId?: string | null
    name: string
    isActive?: boolean
    baseRates: JsonNullValueInput | InputJsonValue
    perMileRates: JsonNullValueInput | InputJsonValue
    priorityMultipliers: JsonNullValueInput | InputJsonValue
    peakHourMultipliers: JsonNullValueInput | InputJsonValue
    weekendMultipliers: JsonNullValueInput | InputJsonValue
    seasonalMultipliers: JsonNullValueInput | InputJsonValue
    zoneMultipliers: JsonNullValueInput | InputJsonValue
    distanceTiers: JsonNullValueInput | InputJsonValue
    specialRequirements: JsonNullValueInput | InputJsonValue
    isolationPricing?: Decimal | DecimalJsLike | number | string | null
    bariatricPricing?: Decimal | DecimalJsLike | number | string | null
    oxygenPricing?: Decimal | DecimalJsLike | number | string | null
    monitoringPricing?: Decimal | DecimalJsLike | number | string | null
    insuranceRates: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type pricingModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    baseRates?: JsonNullValueInput | InputJsonValue
    perMileRates?: JsonNullValueInput | InputJsonValue
    priorityMultipliers?: JsonNullValueInput | InputJsonValue
    peakHourMultipliers?: JsonNullValueInput | InputJsonValue
    weekendMultipliers?: JsonNullValueInput | InputJsonValue
    seasonalMultipliers?: JsonNullValueInput | InputJsonValue
    zoneMultipliers?: JsonNullValueInput | InputJsonValue
    distanceTiers?: JsonNullValueInput | InputJsonValue
    specialRequirements?: JsonNullValueInput | InputJsonValue
    isolationPricing?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    bariatricPricing?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    oxygenPricing?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    monitoringPricing?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    insuranceRates?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pricingModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    baseRates?: JsonNullValueInput | InputJsonValue
    perMileRates?: JsonNullValueInput | InputJsonValue
    priorityMultipliers?: JsonNullValueInput | InputJsonValue
    peakHourMultipliers?: JsonNullValueInput | InputJsonValue
    weekendMultipliers?: JsonNullValueInput | InputJsonValue
    seasonalMultipliers?: JsonNullValueInput | InputJsonValue
    zoneMultipliers?: JsonNullValueInput | InputJsonValue
    distanceTiers?: JsonNullValueInput | InputJsonValue
    specialRequirements?: JsonNullValueInput | InputJsonValue
    isolationPricing?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    bariatricPricing?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    oxygenPricing?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    monitoringPricing?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    insuranceRates?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pricingModelCreateManyInput = {
    id?: string
    agencyId?: string | null
    name: string
    isActive?: boolean
    baseRates: JsonNullValueInput | InputJsonValue
    perMileRates: JsonNullValueInput | InputJsonValue
    priorityMultipliers: JsonNullValueInput | InputJsonValue
    peakHourMultipliers: JsonNullValueInput | InputJsonValue
    weekendMultipliers: JsonNullValueInput | InputJsonValue
    seasonalMultipliers: JsonNullValueInput | InputJsonValue
    zoneMultipliers: JsonNullValueInput | InputJsonValue
    distanceTiers: JsonNullValueInput | InputJsonValue
    specialRequirements: JsonNullValueInput | InputJsonValue
    isolationPricing?: Decimal | DecimalJsLike | number | string | null
    bariatricPricing?: Decimal | DecimalJsLike | number | string | null
    oxygenPricing?: Decimal | DecimalJsLike | number | string | null
    monitoringPricing?: Decimal | DecimalJsLike | number | string | null
    insuranceRates: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type pricingModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    baseRates?: JsonNullValueInput | InputJsonValue
    perMileRates?: JsonNullValueInput | InputJsonValue
    priorityMultipliers?: JsonNullValueInput | InputJsonValue
    peakHourMultipliers?: JsonNullValueInput | InputJsonValue
    weekendMultipliers?: JsonNullValueInput | InputJsonValue
    seasonalMultipliers?: JsonNullValueInput | InputJsonValue
    zoneMultipliers?: JsonNullValueInput | InputJsonValue
    distanceTiers?: JsonNullValueInput | InputJsonValue
    specialRequirements?: JsonNullValueInput | InputJsonValue
    isolationPricing?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    bariatricPricing?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    oxygenPricing?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    monitoringPricing?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    insuranceRates?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pricingModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    baseRates?: JsonNullValueInput | InputJsonValue
    perMileRates?: JsonNullValueInput | InputJsonValue
    priorityMultipliers?: JsonNullValueInput | InputJsonValue
    peakHourMultipliers?: JsonNullValueInput | InputJsonValue
    weekendMultipliers?: JsonNullValueInput | InputJsonValue
    seasonalMultipliers?: JsonNullValueInput | InputJsonValue
    zoneMultipliers?: JsonNullValueInput | InputJsonValue
    distanceTiers?: JsonNullValueInput | InputJsonValue
    specialRequirements?: JsonNullValueInput | InputJsonValue
    isolationPricing?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    bariatricPricing?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    oxygenPricing?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    monitoringPricing?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    insuranceRates?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BackhaulOpportunitiesCreateInput = {
    id?: string
    tripId1: string
    tripId2: string
    revenueBonus?: Decimal | DecimalJsLike | number | string | null
    efficiency?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    isActive?: boolean
  }

  export type BackhaulOpportunitiesUncheckedCreateInput = {
    id?: string
    tripId1: string
    tripId2: string
    revenueBonus?: Decimal | DecimalJsLike | number | string | null
    efficiency?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    isActive?: boolean
  }

  export type BackhaulOpportunitiesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId1?: StringFieldUpdateOperationsInput | string
    tripId2?: StringFieldUpdateOperationsInput | string
    revenueBonus?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    efficiency?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BackhaulOpportunitiesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId1?: StringFieldUpdateOperationsInput | string
    tripId2?: StringFieldUpdateOperationsInput | string
    revenueBonus?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    efficiency?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BackhaulOpportunitiesCreateManyInput = {
    id?: string
    tripId1: string
    tripId2: string
    revenueBonus?: Decimal | DecimalJsLike | number | string | null
    efficiency?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    isActive?: boolean
  }

  export type BackhaulOpportunitiesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId1?: StringFieldUpdateOperationsInput | string
    tripId2?: StringFieldUpdateOperationsInput | string
    revenueBonus?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    efficiency?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BackhaulOpportunitiesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId1?: StringFieldUpdateOperationsInput | string
    tripId2?: StringFieldUpdateOperationsInput | string
    revenueBonus?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    efficiency?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UnitAnalyticsCreateInput = {
    id?: string
    unitId: string
    performanceScore?: Decimal | DecimalJsLike | number | string | null
    efficiency?: Decimal | DecimalJsLike | number | string | null
    totalTrips?: number
    averageResponseTime?: Decimal | DecimalJsLike | number | string | null
    lastUpdated?: Date | string
  }

  export type UnitAnalyticsUncheckedCreateInput = {
    id?: string
    unitId: string
    performanceScore?: Decimal | DecimalJsLike | number | string | null
    efficiency?: Decimal | DecimalJsLike | number | string | null
    totalTrips?: number
    averageResponseTime?: Decimal | DecimalJsLike | number | string | null
    lastUpdated?: Date | string
  }

  export type UnitAnalyticsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    performanceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    efficiency?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalTrips?: IntFieldUpdateOperationsInput | number
    averageResponseTime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitAnalyticsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    performanceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    efficiency?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalTrips?: IntFieldUpdateOperationsInput | number
    averageResponseTime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitAnalyticsCreateManyInput = {
    id?: string
    unitId: string
    performanceScore?: Decimal | DecimalJsLike | number | string | null
    efficiency?: Decimal | DecimalJsLike | number | string | null
    totalTrips?: number
    averageResponseTime?: Decimal | DecimalJsLike | number | string | null
    lastUpdated?: Date | string
  }

  export type UnitAnalyticsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    performanceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    efficiency?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalTrips?: IntFieldUpdateOperationsInput | number
    averageResponseTime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitAnalyticsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    performanceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    efficiency?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalTrips?: IntFieldUpdateOperationsInput | number
    averageResponseTime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RouteOptimizationSettingsCreateInput = {
    id?: string
    agencyId?: string | null
    deadheadMileWeight?: Decimal | DecimalJsLike | number | string
    waitTimeWeight?: Decimal | DecimalJsLike | number | string
    backhaulBonusWeight?: Decimal | DecimalJsLike | number | string
    overtimeRiskWeight?: Decimal | DecimalJsLike | number | string
    revenueWeight?: Decimal | DecimalJsLike | number | string
    maxDeadheadMiles?: Decimal | DecimalJsLike | number | string
    maxWaitTimeMinutes?: number
    maxOvertimeHours?: Decimal | DecimalJsLike | number | string
    maxResponseTimeMinutes?: number
    maxServiceDistance?: Decimal | DecimalJsLike | number | string
    backhaulTimeWindow?: number
    backhaulDistanceLimit?: Decimal | DecimalJsLike | number | string
    backhaulRevenueBonus?: Decimal | DecimalJsLike | number | string
    enableBackhaulOptimization?: boolean
    targetLoadedMileRatio?: Decimal | DecimalJsLike | number | string
    targetRevenuePerHour?: Decimal | DecimalJsLike | number | string
    targetResponseTime?: number
    targetEfficiency?: Decimal | DecimalJsLike | number | string
    optimizationAlgorithm?: string
    maxOptimizationTime?: number
    enableRealTimeOptimization?: boolean
    crewAvailabilityWeight?: Decimal | DecimalJsLike | number | string
    equipmentCompatibilityWeight?: Decimal | DecimalJsLike | number | string
    patientPriorityWeight?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RouteOptimizationSettingsUncheckedCreateInput = {
    id?: string
    agencyId?: string | null
    deadheadMileWeight?: Decimal | DecimalJsLike | number | string
    waitTimeWeight?: Decimal | DecimalJsLike | number | string
    backhaulBonusWeight?: Decimal | DecimalJsLike | number | string
    overtimeRiskWeight?: Decimal | DecimalJsLike | number | string
    revenueWeight?: Decimal | DecimalJsLike | number | string
    maxDeadheadMiles?: Decimal | DecimalJsLike | number | string
    maxWaitTimeMinutes?: number
    maxOvertimeHours?: Decimal | DecimalJsLike | number | string
    maxResponseTimeMinutes?: number
    maxServiceDistance?: Decimal | DecimalJsLike | number | string
    backhaulTimeWindow?: number
    backhaulDistanceLimit?: Decimal | DecimalJsLike | number | string
    backhaulRevenueBonus?: Decimal | DecimalJsLike | number | string
    enableBackhaulOptimization?: boolean
    targetLoadedMileRatio?: Decimal | DecimalJsLike | number | string
    targetRevenuePerHour?: Decimal | DecimalJsLike | number | string
    targetResponseTime?: number
    targetEfficiency?: Decimal | DecimalJsLike | number | string
    optimizationAlgorithm?: string
    maxOptimizationTime?: number
    enableRealTimeOptimization?: boolean
    crewAvailabilityWeight?: Decimal | DecimalJsLike | number | string
    equipmentCompatibilityWeight?: Decimal | DecimalJsLike | number | string
    patientPriorityWeight?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RouteOptimizationSettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
    deadheadMileWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    waitTimeWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    backhaulBonusWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overtimeRiskWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    revenueWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxDeadheadMiles?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxWaitTimeMinutes?: IntFieldUpdateOperationsInput | number
    maxOvertimeHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxResponseTimeMinutes?: IntFieldUpdateOperationsInput | number
    maxServiceDistance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    backhaulTimeWindow?: IntFieldUpdateOperationsInput | number
    backhaulDistanceLimit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    backhaulRevenueBonus?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    enableBackhaulOptimization?: BoolFieldUpdateOperationsInput | boolean
    targetLoadedMileRatio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    targetRevenuePerHour?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    targetResponseTime?: IntFieldUpdateOperationsInput | number
    targetEfficiency?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    optimizationAlgorithm?: StringFieldUpdateOperationsInput | string
    maxOptimizationTime?: IntFieldUpdateOperationsInput | number
    enableRealTimeOptimization?: BoolFieldUpdateOperationsInput | boolean
    crewAvailabilityWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    equipmentCompatibilityWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    patientPriorityWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RouteOptimizationSettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
    deadheadMileWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    waitTimeWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    backhaulBonusWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overtimeRiskWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    revenueWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxDeadheadMiles?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxWaitTimeMinutes?: IntFieldUpdateOperationsInput | number
    maxOvertimeHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxResponseTimeMinutes?: IntFieldUpdateOperationsInput | number
    maxServiceDistance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    backhaulTimeWindow?: IntFieldUpdateOperationsInput | number
    backhaulDistanceLimit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    backhaulRevenueBonus?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    enableBackhaulOptimization?: BoolFieldUpdateOperationsInput | boolean
    targetLoadedMileRatio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    targetRevenuePerHour?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    targetResponseTime?: IntFieldUpdateOperationsInput | number
    targetEfficiency?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    optimizationAlgorithm?: StringFieldUpdateOperationsInput | string
    maxOptimizationTime?: IntFieldUpdateOperationsInput | number
    enableRealTimeOptimization?: BoolFieldUpdateOperationsInput | boolean
    crewAvailabilityWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    equipmentCompatibilityWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    patientPriorityWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RouteOptimizationSettingsCreateManyInput = {
    id?: string
    agencyId?: string | null
    deadheadMileWeight?: Decimal | DecimalJsLike | number | string
    waitTimeWeight?: Decimal | DecimalJsLike | number | string
    backhaulBonusWeight?: Decimal | DecimalJsLike | number | string
    overtimeRiskWeight?: Decimal | DecimalJsLike | number | string
    revenueWeight?: Decimal | DecimalJsLike | number | string
    maxDeadheadMiles?: Decimal | DecimalJsLike | number | string
    maxWaitTimeMinutes?: number
    maxOvertimeHours?: Decimal | DecimalJsLike | number | string
    maxResponseTimeMinutes?: number
    maxServiceDistance?: Decimal | DecimalJsLike | number | string
    backhaulTimeWindow?: number
    backhaulDistanceLimit?: Decimal | DecimalJsLike | number | string
    backhaulRevenueBonus?: Decimal | DecimalJsLike | number | string
    enableBackhaulOptimization?: boolean
    targetLoadedMileRatio?: Decimal | DecimalJsLike | number | string
    targetRevenuePerHour?: Decimal | DecimalJsLike | number | string
    targetResponseTime?: number
    targetEfficiency?: Decimal | DecimalJsLike | number | string
    optimizationAlgorithm?: string
    maxOptimizationTime?: number
    enableRealTimeOptimization?: boolean
    crewAvailabilityWeight?: Decimal | DecimalJsLike | number | string
    equipmentCompatibilityWeight?: Decimal | DecimalJsLike | number | string
    patientPriorityWeight?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RouteOptimizationSettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
    deadheadMileWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    waitTimeWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    backhaulBonusWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overtimeRiskWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    revenueWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxDeadheadMiles?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxWaitTimeMinutes?: IntFieldUpdateOperationsInput | number
    maxOvertimeHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxResponseTimeMinutes?: IntFieldUpdateOperationsInput | number
    maxServiceDistance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    backhaulTimeWindow?: IntFieldUpdateOperationsInput | number
    backhaulDistanceLimit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    backhaulRevenueBonus?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    enableBackhaulOptimization?: BoolFieldUpdateOperationsInput | boolean
    targetLoadedMileRatio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    targetRevenuePerHour?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    targetResponseTime?: IntFieldUpdateOperationsInput | number
    targetEfficiency?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    optimizationAlgorithm?: StringFieldUpdateOperationsInput | string
    maxOptimizationTime?: IntFieldUpdateOperationsInput | number
    enableRealTimeOptimization?: BoolFieldUpdateOperationsInput | boolean
    crewAvailabilityWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    equipmentCompatibilityWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    patientPriorityWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RouteOptimizationSettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
    deadheadMileWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    waitTimeWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    backhaulBonusWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overtimeRiskWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    revenueWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxDeadheadMiles?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxWaitTimeMinutes?: IntFieldUpdateOperationsInput | number
    maxOvertimeHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxResponseTimeMinutes?: IntFieldUpdateOperationsInput | number
    maxServiceDistance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    backhaulTimeWindow?: IntFieldUpdateOperationsInput | number
    backhaulDistanceLimit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    backhaulRevenueBonus?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    enableBackhaulOptimization?: BoolFieldUpdateOperationsInput | boolean
    targetLoadedMileRatio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    targetRevenuePerHour?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    targetResponseTime?: IntFieldUpdateOperationsInput | number
    targetEfficiency?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    optimizationAlgorithm?: StringFieldUpdateOperationsInput | string
    maxOptimizationTime?: IntFieldUpdateOperationsInput | number
    enableRealTimeOptimization?: BoolFieldUpdateOperationsInput | boolean
    crewAvailabilityWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    equipmentCompatibilityWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    patientPriorityWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TripCostBreakdownCreateInput = {
    id?: string
    tripId: string
    baseRevenue: Decimal | DecimalJsLike | number | string
    mileageRevenue: Decimal | DecimalJsLike | number | string
    priorityRevenue: Decimal | DecimalJsLike | number | string
    specialRequirementsRevenue: Decimal | DecimalJsLike | number | string
    insuranceAdjustment: Decimal | DecimalJsLike | number | string
    totalRevenue: Decimal | DecimalJsLike | number | string
    crewLaborCost: Decimal | DecimalJsLike | number | string
    vehicleCost: Decimal | DecimalJsLike | number | string
    fuelCost: Decimal | DecimalJsLike | number | string
    maintenanceCost: Decimal | DecimalJsLike | number | string
    overheadCost: Decimal | DecimalJsLike | number | string
    totalCost: Decimal | DecimalJsLike | number | string
    grossProfit: Decimal | DecimalJsLike | number | string
    profitMargin: Decimal | DecimalJsLike | number | string
    revenuePerMile: Decimal | DecimalJsLike | number | string
    costPerMile: Decimal | DecimalJsLike | number | string
    loadedMileRatio: Decimal | DecimalJsLike | number | string
    deadheadMileRatio: Decimal | DecimalJsLike | number | string
    utilizationRate: Decimal | DecimalJsLike | number | string
    tripDistance: Decimal | DecimalJsLike | number | string
    loadedMiles: Decimal | DecimalJsLike | number | string
    deadheadMiles: Decimal | DecimalJsLike | number | string
    tripDurationHours: Decimal | DecimalJsLike | number | string
    transportLevel: string
    priorityLevel: string
    costCenterId?: string | null
    costCenterName?: string | null
    calculatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TripCostBreakdownUncheckedCreateInput = {
    id?: string
    tripId: string
    baseRevenue: Decimal | DecimalJsLike | number | string
    mileageRevenue: Decimal | DecimalJsLike | number | string
    priorityRevenue: Decimal | DecimalJsLike | number | string
    specialRequirementsRevenue: Decimal | DecimalJsLike | number | string
    insuranceAdjustment: Decimal | DecimalJsLike | number | string
    totalRevenue: Decimal | DecimalJsLike | number | string
    crewLaborCost: Decimal | DecimalJsLike | number | string
    vehicleCost: Decimal | DecimalJsLike | number | string
    fuelCost: Decimal | DecimalJsLike | number | string
    maintenanceCost: Decimal | DecimalJsLike | number | string
    overheadCost: Decimal | DecimalJsLike | number | string
    totalCost: Decimal | DecimalJsLike | number | string
    grossProfit: Decimal | DecimalJsLike | number | string
    profitMargin: Decimal | DecimalJsLike | number | string
    revenuePerMile: Decimal | DecimalJsLike | number | string
    costPerMile: Decimal | DecimalJsLike | number | string
    loadedMileRatio: Decimal | DecimalJsLike | number | string
    deadheadMileRatio: Decimal | DecimalJsLike | number | string
    utilizationRate: Decimal | DecimalJsLike | number | string
    tripDistance: Decimal | DecimalJsLike | number | string
    loadedMiles: Decimal | DecimalJsLike | number | string
    deadheadMiles: Decimal | DecimalJsLike | number | string
    tripDurationHours: Decimal | DecimalJsLike | number | string
    transportLevel: string
    priorityLevel: string
    costCenterId?: string | null
    costCenterName?: string | null
    calculatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TripCostBreakdownUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    baseRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    mileageRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priorityRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    specialRequirementsRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    insuranceAdjustment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    crewLaborCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vehicleCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fuelCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maintenanceCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overheadCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grossProfit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    profitMargin?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    revenuePerMile?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPerMile?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loadedMileRatio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deadheadMileRatio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    utilizationRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tripDistance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loadedMiles?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deadheadMiles?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tripDurationHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    transportLevel?: StringFieldUpdateOperationsInput | string
    priorityLevel?: StringFieldUpdateOperationsInput | string
    costCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    costCenterName?: NullableStringFieldUpdateOperationsInput | string | null
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TripCostBreakdownUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    baseRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    mileageRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priorityRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    specialRequirementsRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    insuranceAdjustment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    crewLaborCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vehicleCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fuelCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maintenanceCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overheadCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grossProfit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    profitMargin?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    revenuePerMile?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPerMile?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loadedMileRatio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deadheadMileRatio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    utilizationRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tripDistance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loadedMiles?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deadheadMiles?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tripDurationHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    transportLevel?: StringFieldUpdateOperationsInput | string
    priorityLevel?: StringFieldUpdateOperationsInput | string
    costCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    costCenterName?: NullableStringFieldUpdateOperationsInput | string | null
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TripCostBreakdownCreateManyInput = {
    id?: string
    tripId: string
    baseRevenue: Decimal | DecimalJsLike | number | string
    mileageRevenue: Decimal | DecimalJsLike | number | string
    priorityRevenue: Decimal | DecimalJsLike | number | string
    specialRequirementsRevenue: Decimal | DecimalJsLike | number | string
    insuranceAdjustment: Decimal | DecimalJsLike | number | string
    totalRevenue: Decimal | DecimalJsLike | number | string
    crewLaborCost: Decimal | DecimalJsLike | number | string
    vehicleCost: Decimal | DecimalJsLike | number | string
    fuelCost: Decimal | DecimalJsLike | number | string
    maintenanceCost: Decimal | DecimalJsLike | number | string
    overheadCost: Decimal | DecimalJsLike | number | string
    totalCost: Decimal | DecimalJsLike | number | string
    grossProfit: Decimal | DecimalJsLike | number | string
    profitMargin: Decimal | DecimalJsLike | number | string
    revenuePerMile: Decimal | DecimalJsLike | number | string
    costPerMile: Decimal | DecimalJsLike | number | string
    loadedMileRatio: Decimal | DecimalJsLike | number | string
    deadheadMileRatio: Decimal | DecimalJsLike | number | string
    utilizationRate: Decimal | DecimalJsLike | number | string
    tripDistance: Decimal | DecimalJsLike | number | string
    loadedMiles: Decimal | DecimalJsLike | number | string
    deadheadMiles: Decimal | DecimalJsLike | number | string
    tripDurationHours: Decimal | DecimalJsLike | number | string
    transportLevel: string
    priorityLevel: string
    costCenterId?: string | null
    costCenterName?: string | null
    calculatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TripCostBreakdownUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    baseRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    mileageRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priorityRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    specialRequirementsRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    insuranceAdjustment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    crewLaborCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vehicleCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fuelCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maintenanceCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overheadCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grossProfit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    profitMargin?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    revenuePerMile?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPerMile?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loadedMileRatio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deadheadMileRatio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    utilizationRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tripDistance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loadedMiles?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deadheadMiles?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tripDurationHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    transportLevel?: StringFieldUpdateOperationsInput | string
    priorityLevel?: StringFieldUpdateOperationsInput | string
    costCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    costCenterName?: NullableStringFieldUpdateOperationsInput | string | null
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TripCostBreakdownUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    baseRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    mileageRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priorityRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    specialRequirementsRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    insuranceAdjustment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    crewLaborCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vehicleCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fuelCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maintenanceCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overheadCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grossProfit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    profitMargin?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    revenuePerMile?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPerMile?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loadedMileRatio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deadheadMileRatio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    utilizationRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tripDistance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loadedMiles?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deadheadMiles?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tripDurationHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    transportLevel?: StringFieldUpdateOperationsInput | string
    priorityLevel?: StringFieldUpdateOperationsInput | string
    costCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    costCenterName?: NullableStringFieldUpdateOperationsInput | string | null
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CostCenterCreateInput = {
    id?: string
    name: string
    description?: string | null
    code: string
    overheadRate?: Decimal | DecimalJsLike | number | string
    fixedCosts?: Decimal | DecimalJsLike | number | string
    variableCosts?: Decimal | DecimalJsLike | number | string
    allocationMethod?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CostCenterUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    code: string
    overheadRate?: Decimal | DecimalJsLike | number | string
    fixedCosts?: Decimal | DecimalJsLike | number | string
    variableCosts?: Decimal | DecimalJsLike | number | string
    allocationMethod?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CostCenterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    overheadRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fixedCosts?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    variableCosts?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allocationMethod?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CostCenterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    overheadRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fixedCosts?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    variableCosts?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allocationMethod?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CostCenterCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    code: string
    overheadRate?: Decimal | DecimalJsLike | number | string
    fixedCosts?: Decimal | DecimalJsLike | number | string
    variableCosts?: Decimal | DecimalJsLike | number | string
    allocationMethod?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CostCenterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    overheadRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fixedCosts?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    variableCosts?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allocationMethod?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CostCenterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    overheadRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fixedCosts?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    variableCosts?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allocationMethod?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type CenterUserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    userType?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CenterUserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    userType?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CenterUserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    userType?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type PickupLocationListRelationFilter = {
    every?: PickupLocationWhereInput
    some?: PickupLocationWhereInput
    none?: PickupLocationWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type PickupLocationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HospitalCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    type?: SortOrder
    capabilities?: SortOrder
    region?: SortOrder
    coordinates?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    operatingHours?: SortOrder
    isActive?: SortOrder
    requiresReview?: SortOrder
    approvedAt?: SortOrder
    approvedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HospitalAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type HospitalMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    type?: SortOrder
    region?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    operatingHours?: SortOrder
    isActive?: SortOrder
    requiresReview?: SortOrder
    approvedAt?: SortOrder
    approvedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HospitalMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    type?: SortOrder
    region?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    operatingHours?: SortOrder
    isActive?: SortOrder
    requiresReview?: SortOrder
    approvedAt?: SortOrder
    approvedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HospitalSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type HospitalRelationFilter = {
    is?: HospitalWhereInput
    isNot?: HospitalWhereInput
  }

  export type TripListRelationFilter = {
    every?: TripWhereInput
    some?: TripWhereInput
    none?: TripWhereInput
  }

  export type TripOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PickupLocationCountOrderByAggregateInput = {
    id?: SortOrder
    hospitalId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    contactPhone?: SortOrder
    contactEmail?: SortOrder
    floor?: SortOrder
    room?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PickupLocationMaxOrderByAggregateInput = {
    id?: SortOrder
    hospitalId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    contactPhone?: SortOrder
    contactEmail?: SortOrder
    floor?: SortOrder
    room?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PickupLocationMinOrderByAggregateInput = {
    id?: SortOrder
    hospitalId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    contactPhone?: SortOrder
    contactEmail?: SortOrder
    floor?: SortOrder
    room?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EMSAgencyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contactName?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    serviceArea?: SortOrder
    operatingHours?: SortOrder
    capabilities?: SortOrder
    pricingStructure?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    serviceRadius?: SortOrder
    totalUnits?: SortOrder
    availableUnits?: SortOrder
    lastUpdated?: SortOrder
    acceptsNotifications?: SortOrder
    notificationMethods?: SortOrder
    isActive?: SortOrder
    status?: SortOrder
    requiresReview?: SortOrder
    approvedAt?: SortOrder
    approvedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EMSAgencyAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    serviceRadius?: SortOrder
    totalUnits?: SortOrder
    availableUnits?: SortOrder
  }

  export type EMSAgencyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contactName?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    serviceRadius?: SortOrder
    totalUnits?: SortOrder
    availableUnits?: SortOrder
    lastUpdated?: SortOrder
    acceptsNotifications?: SortOrder
    isActive?: SortOrder
    status?: SortOrder
    requiresReview?: SortOrder
    approvedAt?: SortOrder
    approvedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EMSAgencyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contactName?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    serviceRadius?: SortOrder
    totalUnits?: SortOrder
    availableUnits?: SortOrder
    lastUpdated?: SortOrder
    acceptsNotifications?: SortOrder
    isActive?: SortOrder
    status?: SortOrder
    requiresReview?: SortOrder
    approvedAt?: SortOrder
    approvedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EMSAgencySumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    serviceRadius?: SortOrder
    totalUnits?: SortOrder
    availableUnits?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type PickupLocationNullableRelationFilter = {
    is?: PickupLocationWhereInput | null
    isNot?: PickupLocationWhereInput | null
  }

  export type TripCountOrderByAggregateInput = {
    id?: SortOrder
    tripNumber?: SortOrder
    patientId?: SortOrder
    patientWeight?: SortOrder
    specialNeeds?: SortOrder
    insuranceCompany?: SortOrder
    fromLocation?: SortOrder
    pickupLocationId?: SortOrder
    toLocation?: SortOrder
    scheduledTime?: SortOrder
    transportLevel?: SortOrder
    urgencyLevel?: SortOrder
    originLatitude?: SortOrder
    originLongitude?: SortOrder
    destinationLatitude?: SortOrder
    destinationLongitude?: SortOrder
    diagnosis?: SortOrder
    mobilityLevel?: SortOrder
    oxygenRequired?: SortOrder
    monitoringRequired?: SortOrder
    generateQRCode?: SortOrder
    qrCodeData?: SortOrder
    selectedAgencies?: SortOrder
    notificationRadius?: SortOrder
    transferRequestTime?: SortOrder
    transferAcceptedTime?: SortOrder
    emsArrivalTime?: SortOrder
    emsDepartureTime?: SortOrder
    tripCost?: SortOrder
    distanceMiles?: SortOrder
    responseTimeMinutes?: SortOrder
    deadheadMiles?: SortOrder
    insurancePayRate?: SortOrder
    perMileRate?: SortOrder
    requestTimestamp?: SortOrder
    estimatedTripTimeMinutes?: SortOrder
    actualTripTimeMinutes?: SortOrder
    completionTimeMinutes?: SortOrder
    loadedMiles?: SortOrder
    customerSatisfaction?: SortOrder
    efficiency?: SortOrder
    performanceScore?: SortOrder
    revenuePerHour?: SortOrder
    backhaulOpportunity?: SortOrder
    actualStartTime?: SortOrder
    actualEndTime?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    notes?: SortOrder
    assignedTo?: SortOrder
    assignedAgencyId?: SortOrder
    assignedUnitId?: SortOrder
    acceptedTimestamp?: SortOrder
    pickupTimestamp?: SortOrder
    completionTimestamp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TripAvgOrderByAggregateInput = {
    originLatitude?: SortOrder
    originLongitude?: SortOrder
    destinationLatitude?: SortOrder
    destinationLongitude?: SortOrder
    notificationRadius?: SortOrder
    tripCost?: SortOrder
    distanceMiles?: SortOrder
    responseTimeMinutes?: SortOrder
    deadheadMiles?: SortOrder
    insurancePayRate?: SortOrder
    perMileRate?: SortOrder
    estimatedTripTimeMinutes?: SortOrder
    actualTripTimeMinutes?: SortOrder
    completionTimeMinutes?: SortOrder
    loadedMiles?: SortOrder
    customerSatisfaction?: SortOrder
    efficiency?: SortOrder
    performanceScore?: SortOrder
    revenuePerHour?: SortOrder
  }

  export type TripMaxOrderByAggregateInput = {
    id?: SortOrder
    tripNumber?: SortOrder
    patientId?: SortOrder
    patientWeight?: SortOrder
    specialNeeds?: SortOrder
    insuranceCompany?: SortOrder
    fromLocation?: SortOrder
    pickupLocationId?: SortOrder
    toLocation?: SortOrder
    scheduledTime?: SortOrder
    transportLevel?: SortOrder
    urgencyLevel?: SortOrder
    originLatitude?: SortOrder
    originLongitude?: SortOrder
    destinationLatitude?: SortOrder
    destinationLongitude?: SortOrder
    diagnosis?: SortOrder
    mobilityLevel?: SortOrder
    oxygenRequired?: SortOrder
    monitoringRequired?: SortOrder
    generateQRCode?: SortOrder
    qrCodeData?: SortOrder
    notificationRadius?: SortOrder
    transferRequestTime?: SortOrder
    transferAcceptedTime?: SortOrder
    emsArrivalTime?: SortOrder
    emsDepartureTime?: SortOrder
    tripCost?: SortOrder
    distanceMiles?: SortOrder
    responseTimeMinutes?: SortOrder
    deadheadMiles?: SortOrder
    insurancePayRate?: SortOrder
    perMileRate?: SortOrder
    requestTimestamp?: SortOrder
    estimatedTripTimeMinutes?: SortOrder
    actualTripTimeMinutes?: SortOrder
    completionTimeMinutes?: SortOrder
    loadedMiles?: SortOrder
    customerSatisfaction?: SortOrder
    efficiency?: SortOrder
    performanceScore?: SortOrder
    revenuePerHour?: SortOrder
    backhaulOpportunity?: SortOrder
    actualStartTime?: SortOrder
    actualEndTime?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    notes?: SortOrder
    assignedTo?: SortOrder
    assignedAgencyId?: SortOrder
    assignedUnitId?: SortOrder
    acceptedTimestamp?: SortOrder
    pickupTimestamp?: SortOrder
    completionTimestamp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TripMinOrderByAggregateInput = {
    id?: SortOrder
    tripNumber?: SortOrder
    patientId?: SortOrder
    patientWeight?: SortOrder
    specialNeeds?: SortOrder
    insuranceCompany?: SortOrder
    fromLocation?: SortOrder
    pickupLocationId?: SortOrder
    toLocation?: SortOrder
    scheduledTime?: SortOrder
    transportLevel?: SortOrder
    urgencyLevel?: SortOrder
    originLatitude?: SortOrder
    originLongitude?: SortOrder
    destinationLatitude?: SortOrder
    destinationLongitude?: SortOrder
    diagnosis?: SortOrder
    mobilityLevel?: SortOrder
    oxygenRequired?: SortOrder
    monitoringRequired?: SortOrder
    generateQRCode?: SortOrder
    qrCodeData?: SortOrder
    notificationRadius?: SortOrder
    transferRequestTime?: SortOrder
    transferAcceptedTime?: SortOrder
    emsArrivalTime?: SortOrder
    emsDepartureTime?: SortOrder
    tripCost?: SortOrder
    distanceMiles?: SortOrder
    responseTimeMinutes?: SortOrder
    deadheadMiles?: SortOrder
    insurancePayRate?: SortOrder
    perMileRate?: SortOrder
    requestTimestamp?: SortOrder
    estimatedTripTimeMinutes?: SortOrder
    actualTripTimeMinutes?: SortOrder
    completionTimeMinutes?: SortOrder
    loadedMiles?: SortOrder
    customerSatisfaction?: SortOrder
    efficiency?: SortOrder
    performanceScore?: SortOrder
    revenuePerHour?: SortOrder
    backhaulOpportunity?: SortOrder
    actualStartTime?: SortOrder
    actualEndTime?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    notes?: SortOrder
    assignedTo?: SortOrder
    assignedAgencyId?: SortOrder
    assignedUnitId?: SortOrder
    acceptedTimestamp?: SortOrder
    pickupTimestamp?: SortOrder
    completionTimestamp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TripSumOrderByAggregateInput = {
    originLatitude?: SortOrder
    originLongitude?: SortOrder
    destinationLatitude?: SortOrder
    destinationLongitude?: SortOrder
    notificationRadius?: SortOrder
    tripCost?: SortOrder
    distanceMiles?: SortOrder
    responseTimeMinutes?: SortOrder
    deadheadMiles?: SortOrder
    insurancePayRate?: SortOrder
    perMileRate?: SortOrder
    estimatedTripTimeMinutes?: SortOrder
    actualTripTimeMinutes?: SortOrder
    completionTimeMinutes?: SortOrder
    loadedMiles?: SortOrder
    customerSatisfaction?: SortOrder
    efficiency?: SortOrder
    performanceScore?: SortOrder
    revenuePerHour?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type SystemAnalyticsCountOrderByAggregateInput = {
    id?: SortOrder
    metricName?: SortOrder
    metricValue?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type SystemAnalyticsMaxOrderByAggregateInput = {
    id?: SortOrder
    metricName?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type SystemAnalyticsMinOrderByAggregateInput = {
    id?: SortOrder
    metricName?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type pricingModelCountOrderByAggregateInput = {
    id?: SortOrder
    agencyId?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    baseRates?: SortOrder
    perMileRates?: SortOrder
    priorityMultipliers?: SortOrder
    peakHourMultipliers?: SortOrder
    weekendMultipliers?: SortOrder
    seasonalMultipliers?: SortOrder
    zoneMultipliers?: SortOrder
    distanceTiers?: SortOrder
    specialRequirements?: SortOrder
    isolationPricing?: SortOrder
    bariatricPricing?: SortOrder
    oxygenPricing?: SortOrder
    monitoringPricing?: SortOrder
    insuranceRates?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type pricingModelAvgOrderByAggregateInput = {
    isolationPricing?: SortOrder
    bariatricPricing?: SortOrder
    oxygenPricing?: SortOrder
    monitoringPricing?: SortOrder
  }

  export type pricingModelMaxOrderByAggregateInput = {
    id?: SortOrder
    agencyId?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    isolationPricing?: SortOrder
    bariatricPricing?: SortOrder
    oxygenPricing?: SortOrder
    monitoringPricing?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type pricingModelMinOrderByAggregateInput = {
    id?: SortOrder
    agencyId?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    isolationPricing?: SortOrder
    bariatricPricing?: SortOrder
    oxygenPricing?: SortOrder
    monitoringPricing?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type pricingModelSumOrderByAggregateInput = {
    isolationPricing?: SortOrder
    bariatricPricing?: SortOrder
    oxygenPricing?: SortOrder
    monitoringPricing?: SortOrder
  }

  export type BackhaulOpportunitiesCountOrderByAggregateInput = {
    id?: SortOrder
    tripId1?: SortOrder
    tripId2?: SortOrder
    revenueBonus?: SortOrder
    efficiency?: SortOrder
    createdAt?: SortOrder
    isActive?: SortOrder
  }

  export type BackhaulOpportunitiesAvgOrderByAggregateInput = {
    revenueBonus?: SortOrder
    efficiency?: SortOrder
  }

  export type BackhaulOpportunitiesMaxOrderByAggregateInput = {
    id?: SortOrder
    tripId1?: SortOrder
    tripId2?: SortOrder
    revenueBonus?: SortOrder
    efficiency?: SortOrder
    createdAt?: SortOrder
    isActive?: SortOrder
  }

  export type BackhaulOpportunitiesMinOrderByAggregateInput = {
    id?: SortOrder
    tripId1?: SortOrder
    tripId2?: SortOrder
    revenueBonus?: SortOrder
    efficiency?: SortOrder
    createdAt?: SortOrder
    isActive?: SortOrder
  }

  export type BackhaulOpportunitiesSumOrderByAggregateInput = {
    revenueBonus?: SortOrder
    efficiency?: SortOrder
  }

  export type UnitAnalyticsCountOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    performanceScore?: SortOrder
    efficiency?: SortOrder
    totalTrips?: SortOrder
    averageResponseTime?: SortOrder
    lastUpdated?: SortOrder
  }

  export type UnitAnalyticsAvgOrderByAggregateInput = {
    performanceScore?: SortOrder
    efficiency?: SortOrder
    totalTrips?: SortOrder
    averageResponseTime?: SortOrder
  }

  export type UnitAnalyticsMaxOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    performanceScore?: SortOrder
    efficiency?: SortOrder
    totalTrips?: SortOrder
    averageResponseTime?: SortOrder
    lastUpdated?: SortOrder
  }

  export type UnitAnalyticsMinOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    performanceScore?: SortOrder
    efficiency?: SortOrder
    totalTrips?: SortOrder
    averageResponseTime?: SortOrder
    lastUpdated?: SortOrder
  }

  export type UnitAnalyticsSumOrderByAggregateInput = {
    performanceScore?: SortOrder
    efficiency?: SortOrder
    totalTrips?: SortOrder
    averageResponseTime?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type RouteOptimizationSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    agencyId?: SortOrder
    deadheadMileWeight?: SortOrder
    waitTimeWeight?: SortOrder
    backhaulBonusWeight?: SortOrder
    overtimeRiskWeight?: SortOrder
    revenueWeight?: SortOrder
    maxDeadheadMiles?: SortOrder
    maxWaitTimeMinutes?: SortOrder
    maxOvertimeHours?: SortOrder
    maxResponseTimeMinutes?: SortOrder
    maxServiceDistance?: SortOrder
    backhaulTimeWindow?: SortOrder
    backhaulDistanceLimit?: SortOrder
    backhaulRevenueBonus?: SortOrder
    enableBackhaulOptimization?: SortOrder
    targetLoadedMileRatio?: SortOrder
    targetRevenuePerHour?: SortOrder
    targetResponseTime?: SortOrder
    targetEfficiency?: SortOrder
    optimizationAlgorithm?: SortOrder
    maxOptimizationTime?: SortOrder
    enableRealTimeOptimization?: SortOrder
    crewAvailabilityWeight?: SortOrder
    equipmentCompatibilityWeight?: SortOrder
    patientPriorityWeight?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RouteOptimizationSettingsAvgOrderByAggregateInput = {
    deadheadMileWeight?: SortOrder
    waitTimeWeight?: SortOrder
    backhaulBonusWeight?: SortOrder
    overtimeRiskWeight?: SortOrder
    revenueWeight?: SortOrder
    maxDeadheadMiles?: SortOrder
    maxWaitTimeMinutes?: SortOrder
    maxOvertimeHours?: SortOrder
    maxResponseTimeMinutes?: SortOrder
    maxServiceDistance?: SortOrder
    backhaulTimeWindow?: SortOrder
    backhaulDistanceLimit?: SortOrder
    backhaulRevenueBonus?: SortOrder
    targetLoadedMileRatio?: SortOrder
    targetRevenuePerHour?: SortOrder
    targetResponseTime?: SortOrder
    targetEfficiency?: SortOrder
    maxOptimizationTime?: SortOrder
    crewAvailabilityWeight?: SortOrder
    equipmentCompatibilityWeight?: SortOrder
    patientPriorityWeight?: SortOrder
  }

  export type RouteOptimizationSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    agencyId?: SortOrder
    deadheadMileWeight?: SortOrder
    waitTimeWeight?: SortOrder
    backhaulBonusWeight?: SortOrder
    overtimeRiskWeight?: SortOrder
    revenueWeight?: SortOrder
    maxDeadheadMiles?: SortOrder
    maxWaitTimeMinutes?: SortOrder
    maxOvertimeHours?: SortOrder
    maxResponseTimeMinutes?: SortOrder
    maxServiceDistance?: SortOrder
    backhaulTimeWindow?: SortOrder
    backhaulDistanceLimit?: SortOrder
    backhaulRevenueBonus?: SortOrder
    enableBackhaulOptimization?: SortOrder
    targetLoadedMileRatio?: SortOrder
    targetRevenuePerHour?: SortOrder
    targetResponseTime?: SortOrder
    targetEfficiency?: SortOrder
    optimizationAlgorithm?: SortOrder
    maxOptimizationTime?: SortOrder
    enableRealTimeOptimization?: SortOrder
    crewAvailabilityWeight?: SortOrder
    equipmentCompatibilityWeight?: SortOrder
    patientPriorityWeight?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RouteOptimizationSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    agencyId?: SortOrder
    deadheadMileWeight?: SortOrder
    waitTimeWeight?: SortOrder
    backhaulBonusWeight?: SortOrder
    overtimeRiskWeight?: SortOrder
    revenueWeight?: SortOrder
    maxDeadheadMiles?: SortOrder
    maxWaitTimeMinutes?: SortOrder
    maxOvertimeHours?: SortOrder
    maxResponseTimeMinutes?: SortOrder
    maxServiceDistance?: SortOrder
    backhaulTimeWindow?: SortOrder
    backhaulDistanceLimit?: SortOrder
    backhaulRevenueBonus?: SortOrder
    enableBackhaulOptimization?: SortOrder
    targetLoadedMileRatio?: SortOrder
    targetRevenuePerHour?: SortOrder
    targetResponseTime?: SortOrder
    targetEfficiency?: SortOrder
    optimizationAlgorithm?: SortOrder
    maxOptimizationTime?: SortOrder
    enableRealTimeOptimization?: SortOrder
    crewAvailabilityWeight?: SortOrder
    equipmentCompatibilityWeight?: SortOrder
    patientPriorityWeight?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RouteOptimizationSettingsSumOrderByAggregateInput = {
    deadheadMileWeight?: SortOrder
    waitTimeWeight?: SortOrder
    backhaulBonusWeight?: SortOrder
    overtimeRiskWeight?: SortOrder
    revenueWeight?: SortOrder
    maxDeadheadMiles?: SortOrder
    maxWaitTimeMinutes?: SortOrder
    maxOvertimeHours?: SortOrder
    maxResponseTimeMinutes?: SortOrder
    maxServiceDistance?: SortOrder
    backhaulTimeWindow?: SortOrder
    backhaulDistanceLimit?: SortOrder
    backhaulRevenueBonus?: SortOrder
    targetLoadedMileRatio?: SortOrder
    targetRevenuePerHour?: SortOrder
    targetResponseTime?: SortOrder
    targetEfficiency?: SortOrder
    maxOptimizationTime?: SortOrder
    crewAvailabilityWeight?: SortOrder
    equipmentCompatibilityWeight?: SortOrder
    patientPriorityWeight?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type TripCostBreakdownCountOrderByAggregateInput = {
    id?: SortOrder
    tripId?: SortOrder
    baseRevenue?: SortOrder
    mileageRevenue?: SortOrder
    priorityRevenue?: SortOrder
    specialRequirementsRevenue?: SortOrder
    insuranceAdjustment?: SortOrder
    totalRevenue?: SortOrder
    crewLaborCost?: SortOrder
    vehicleCost?: SortOrder
    fuelCost?: SortOrder
    maintenanceCost?: SortOrder
    overheadCost?: SortOrder
    totalCost?: SortOrder
    grossProfit?: SortOrder
    profitMargin?: SortOrder
    revenuePerMile?: SortOrder
    costPerMile?: SortOrder
    loadedMileRatio?: SortOrder
    deadheadMileRatio?: SortOrder
    utilizationRate?: SortOrder
    tripDistance?: SortOrder
    loadedMiles?: SortOrder
    deadheadMiles?: SortOrder
    tripDurationHours?: SortOrder
    transportLevel?: SortOrder
    priorityLevel?: SortOrder
    costCenterId?: SortOrder
    costCenterName?: SortOrder
    calculatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TripCostBreakdownAvgOrderByAggregateInput = {
    baseRevenue?: SortOrder
    mileageRevenue?: SortOrder
    priorityRevenue?: SortOrder
    specialRequirementsRevenue?: SortOrder
    insuranceAdjustment?: SortOrder
    totalRevenue?: SortOrder
    crewLaborCost?: SortOrder
    vehicleCost?: SortOrder
    fuelCost?: SortOrder
    maintenanceCost?: SortOrder
    overheadCost?: SortOrder
    totalCost?: SortOrder
    grossProfit?: SortOrder
    profitMargin?: SortOrder
    revenuePerMile?: SortOrder
    costPerMile?: SortOrder
    loadedMileRatio?: SortOrder
    deadheadMileRatio?: SortOrder
    utilizationRate?: SortOrder
    tripDistance?: SortOrder
    loadedMiles?: SortOrder
    deadheadMiles?: SortOrder
    tripDurationHours?: SortOrder
  }

  export type TripCostBreakdownMaxOrderByAggregateInput = {
    id?: SortOrder
    tripId?: SortOrder
    baseRevenue?: SortOrder
    mileageRevenue?: SortOrder
    priorityRevenue?: SortOrder
    specialRequirementsRevenue?: SortOrder
    insuranceAdjustment?: SortOrder
    totalRevenue?: SortOrder
    crewLaborCost?: SortOrder
    vehicleCost?: SortOrder
    fuelCost?: SortOrder
    maintenanceCost?: SortOrder
    overheadCost?: SortOrder
    totalCost?: SortOrder
    grossProfit?: SortOrder
    profitMargin?: SortOrder
    revenuePerMile?: SortOrder
    costPerMile?: SortOrder
    loadedMileRatio?: SortOrder
    deadheadMileRatio?: SortOrder
    utilizationRate?: SortOrder
    tripDistance?: SortOrder
    loadedMiles?: SortOrder
    deadheadMiles?: SortOrder
    tripDurationHours?: SortOrder
    transportLevel?: SortOrder
    priorityLevel?: SortOrder
    costCenterId?: SortOrder
    costCenterName?: SortOrder
    calculatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TripCostBreakdownMinOrderByAggregateInput = {
    id?: SortOrder
    tripId?: SortOrder
    baseRevenue?: SortOrder
    mileageRevenue?: SortOrder
    priorityRevenue?: SortOrder
    specialRequirementsRevenue?: SortOrder
    insuranceAdjustment?: SortOrder
    totalRevenue?: SortOrder
    crewLaborCost?: SortOrder
    vehicleCost?: SortOrder
    fuelCost?: SortOrder
    maintenanceCost?: SortOrder
    overheadCost?: SortOrder
    totalCost?: SortOrder
    grossProfit?: SortOrder
    profitMargin?: SortOrder
    revenuePerMile?: SortOrder
    costPerMile?: SortOrder
    loadedMileRatio?: SortOrder
    deadheadMileRatio?: SortOrder
    utilizationRate?: SortOrder
    tripDistance?: SortOrder
    loadedMiles?: SortOrder
    deadheadMiles?: SortOrder
    tripDurationHours?: SortOrder
    transportLevel?: SortOrder
    priorityLevel?: SortOrder
    costCenterId?: SortOrder
    costCenterName?: SortOrder
    calculatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TripCostBreakdownSumOrderByAggregateInput = {
    baseRevenue?: SortOrder
    mileageRevenue?: SortOrder
    priorityRevenue?: SortOrder
    specialRequirementsRevenue?: SortOrder
    insuranceAdjustment?: SortOrder
    totalRevenue?: SortOrder
    crewLaborCost?: SortOrder
    vehicleCost?: SortOrder
    fuelCost?: SortOrder
    maintenanceCost?: SortOrder
    overheadCost?: SortOrder
    totalCost?: SortOrder
    grossProfit?: SortOrder
    profitMargin?: SortOrder
    revenuePerMile?: SortOrder
    costPerMile?: SortOrder
    loadedMileRatio?: SortOrder
    deadheadMileRatio?: SortOrder
    utilizationRate?: SortOrder
    tripDistance?: SortOrder
    loadedMiles?: SortOrder
    deadheadMiles?: SortOrder
    tripDurationHours?: SortOrder
  }

  export type CostCenterCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    code?: SortOrder
    overheadRate?: SortOrder
    fixedCosts?: SortOrder
    variableCosts?: SortOrder
    allocationMethod?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CostCenterAvgOrderByAggregateInput = {
    overheadRate?: SortOrder
    fixedCosts?: SortOrder
    variableCosts?: SortOrder
  }

  export type CostCenterMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    code?: SortOrder
    overheadRate?: SortOrder
    fixedCosts?: SortOrder
    variableCosts?: SortOrder
    allocationMethod?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CostCenterMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    code?: SortOrder
    overheadRate?: SortOrder
    fixedCosts?: SortOrder
    variableCosts?: SortOrder
    allocationMethod?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CostCenterSumOrderByAggregateInput = {
    overheadRate?: SortOrder
    fixedCosts?: SortOrder
    variableCosts?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type HospitalCreatecapabilitiesInput = {
    set: string[]
  }

  export type PickupLocationCreateNestedManyWithoutHospitalInput = {
    create?: XOR<PickupLocationCreateWithoutHospitalInput, PickupLocationUncheckedCreateWithoutHospitalInput> | PickupLocationCreateWithoutHospitalInput[] | PickupLocationUncheckedCreateWithoutHospitalInput[]
    connectOrCreate?: PickupLocationCreateOrConnectWithoutHospitalInput | PickupLocationCreateOrConnectWithoutHospitalInput[]
    createMany?: PickupLocationCreateManyHospitalInputEnvelope
    connect?: PickupLocationWhereUniqueInput | PickupLocationWhereUniqueInput[]
  }

  export type PickupLocationUncheckedCreateNestedManyWithoutHospitalInput = {
    create?: XOR<PickupLocationCreateWithoutHospitalInput, PickupLocationUncheckedCreateWithoutHospitalInput> | PickupLocationCreateWithoutHospitalInput[] | PickupLocationUncheckedCreateWithoutHospitalInput[]
    connectOrCreate?: PickupLocationCreateOrConnectWithoutHospitalInput | PickupLocationCreateOrConnectWithoutHospitalInput[]
    createMany?: PickupLocationCreateManyHospitalInputEnvelope
    connect?: PickupLocationWhereUniqueInput | PickupLocationWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type HospitalUpdatecapabilitiesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type PickupLocationUpdateManyWithoutHospitalNestedInput = {
    create?: XOR<PickupLocationCreateWithoutHospitalInput, PickupLocationUncheckedCreateWithoutHospitalInput> | PickupLocationCreateWithoutHospitalInput[] | PickupLocationUncheckedCreateWithoutHospitalInput[]
    connectOrCreate?: PickupLocationCreateOrConnectWithoutHospitalInput | PickupLocationCreateOrConnectWithoutHospitalInput[]
    upsert?: PickupLocationUpsertWithWhereUniqueWithoutHospitalInput | PickupLocationUpsertWithWhereUniqueWithoutHospitalInput[]
    createMany?: PickupLocationCreateManyHospitalInputEnvelope
    set?: PickupLocationWhereUniqueInput | PickupLocationWhereUniqueInput[]
    disconnect?: PickupLocationWhereUniqueInput | PickupLocationWhereUniqueInput[]
    delete?: PickupLocationWhereUniqueInput | PickupLocationWhereUniqueInput[]
    connect?: PickupLocationWhereUniqueInput | PickupLocationWhereUniqueInput[]
    update?: PickupLocationUpdateWithWhereUniqueWithoutHospitalInput | PickupLocationUpdateWithWhereUniqueWithoutHospitalInput[]
    updateMany?: PickupLocationUpdateManyWithWhereWithoutHospitalInput | PickupLocationUpdateManyWithWhereWithoutHospitalInput[]
    deleteMany?: PickupLocationScalarWhereInput | PickupLocationScalarWhereInput[]
  }

  export type PickupLocationUncheckedUpdateManyWithoutHospitalNestedInput = {
    create?: XOR<PickupLocationCreateWithoutHospitalInput, PickupLocationUncheckedCreateWithoutHospitalInput> | PickupLocationCreateWithoutHospitalInput[] | PickupLocationUncheckedCreateWithoutHospitalInput[]
    connectOrCreate?: PickupLocationCreateOrConnectWithoutHospitalInput | PickupLocationCreateOrConnectWithoutHospitalInput[]
    upsert?: PickupLocationUpsertWithWhereUniqueWithoutHospitalInput | PickupLocationUpsertWithWhereUniqueWithoutHospitalInput[]
    createMany?: PickupLocationCreateManyHospitalInputEnvelope
    set?: PickupLocationWhereUniqueInput | PickupLocationWhereUniqueInput[]
    disconnect?: PickupLocationWhereUniqueInput | PickupLocationWhereUniqueInput[]
    delete?: PickupLocationWhereUniqueInput | PickupLocationWhereUniqueInput[]
    connect?: PickupLocationWhereUniqueInput | PickupLocationWhereUniqueInput[]
    update?: PickupLocationUpdateWithWhereUniqueWithoutHospitalInput | PickupLocationUpdateWithWhereUniqueWithoutHospitalInput[]
    updateMany?: PickupLocationUpdateManyWithWhereWithoutHospitalInput | PickupLocationUpdateManyWithWhereWithoutHospitalInput[]
    deleteMany?: PickupLocationScalarWhereInput | PickupLocationScalarWhereInput[]
  }

  export type HospitalCreateNestedOneWithoutPickupLocationsInput = {
    create?: XOR<HospitalCreateWithoutPickupLocationsInput, HospitalUncheckedCreateWithoutPickupLocationsInput>
    connectOrCreate?: HospitalCreateOrConnectWithoutPickupLocationsInput
    connect?: HospitalWhereUniqueInput
  }

  export type TripCreateNestedManyWithoutPickupLocationInput = {
    create?: XOR<TripCreateWithoutPickupLocationInput, TripUncheckedCreateWithoutPickupLocationInput> | TripCreateWithoutPickupLocationInput[] | TripUncheckedCreateWithoutPickupLocationInput[]
    connectOrCreate?: TripCreateOrConnectWithoutPickupLocationInput | TripCreateOrConnectWithoutPickupLocationInput[]
    createMany?: TripCreateManyPickupLocationInputEnvelope
    connect?: TripWhereUniqueInput | TripWhereUniqueInput[]
  }

  export type TripUncheckedCreateNestedManyWithoutPickupLocationInput = {
    create?: XOR<TripCreateWithoutPickupLocationInput, TripUncheckedCreateWithoutPickupLocationInput> | TripCreateWithoutPickupLocationInput[] | TripUncheckedCreateWithoutPickupLocationInput[]
    connectOrCreate?: TripCreateOrConnectWithoutPickupLocationInput | TripCreateOrConnectWithoutPickupLocationInput[]
    createMany?: TripCreateManyPickupLocationInputEnvelope
    connect?: TripWhereUniqueInput | TripWhereUniqueInput[]
  }

  export type HospitalUpdateOneRequiredWithoutPickupLocationsNestedInput = {
    create?: XOR<HospitalCreateWithoutPickupLocationsInput, HospitalUncheckedCreateWithoutPickupLocationsInput>
    connectOrCreate?: HospitalCreateOrConnectWithoutPickupLocationsInput
    upsert?: HospitalUpsertWithoutPickupLocationsInput
    connect?: HospitalWhereUniqueInput
    update?: XOR<XOR<HospitalUpdateToOneWithWhereWithoutPickupLocationsInput, HospitalUpdateWithoutPickupLocationsInput>, HospitalUncheckedUpdateWithoutPickupLocationsInput>
  }

  export type TripUpdateManyWithoutPickupLocationNestedInput = {
    create?: XOR<TripCreateWithoutPickupLocationInput, TripUncheckedCreateWithoutPickupLocationInput> | TripCreateWithoutPickupLocationInput[] | TripUncheckedCreateWithoutPickupLocationInput[]
    connectOrCreate?: TripCreateOrConnectWithoutPickupLocationInput | TripCreateOrConnectWithoutPickupLocationInput[]
    upsert?: TripUpsertWithWhereUniqueWithoutPickupLocationInput | TripUpsertWithWhereUniqueWithoutPickupLocationInput[]
    createMany?: TripCreateManyPickupLocationInputEnvelope
    set?: TripWhereUniqueInput | TripWhereUniqueInput[]
    disconnect?: TripWhereUniqueInput | TripWhereUniqueInput[]
    delete?: TripWhereUniqueInput | TripWhereUniqueInput[]
    connect?: TripWhereUniqueInput | TripWhereUniqueInput[]
    update?: TripUpdateWithWhereUniqueWithoutPickupLocationInput | TripUpdateWithWhereUniqueWithoutPickupLocationInput[]
    updateMany?: TripUpdateManyWithWhereWithoutPickupLocationInput | TripUpdateManyWithWhereWithoutPickupLocationInput[]
    deleteMany?: TripScalarWhereInput | TripScalarWhereInput[]
  }

  export type TripUncheckedUpdateManyWithoutPickupLocationNestedInput = {
    create?: XOR<TripCreateWithoutPickupLocationInput, TripUncheckedCreateWithoutPickupLocationInput> | TripCreateWithoutPickupLocationInput[] | TripUncheckedCreateWithoutPickupLocationInput[]
    connectOrCreate?: TripCreateOrConnectWithoutPickupLocationInput | TripCreateOrConnectWithoutPickupLocationInput[]
    upsert?: TripUpsertWithWhereUniqueWithoutPickupLocationInput | TripUpsertWithWhereUniqueWithoutPickupLocationInput[]
    createMany?: TripCreateManyPickupLocationInputEnvelope
    set?: TripWhereUniqueInput | TripWhereUniqueInput[]
    disconnect?: TripWhereUniqueInput | TripWhereUniqueInput[]
    delete?: TripWhereUniqueInput | TripWhereUniqueInput[]
    connect?: TripWhereUniqueInput | TripWhereUniqueInput[]
    update?: TripUpdateWithWhereUniqueWithoutPickupLocationInput | TripUpdateWithWhereUniqueWithoutPickupLocationInput[]
    updateMany?: TripUpdateManyWithWhereWithoutPickupLocationInput | TripUpdateManyWithWhereWithoutPickupLocationInput[]
    deleteMany?: TripScalarWhereInput | TripScalarWhereInput[]
  }

  export type EMSAgencyCreateserviceAreaInput = {
    set: string[]
  }

  export type EMSAgencyCreatecapabilitiesInput = {
    set: string[]
  }

  export type EMSAgencyCreatenotificationMethodsInput = {
    set: string[]
  }

  export type EMSAgencyUpdateserviceAreaInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EMSAgencyUpdatecapabilitiesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EMSAgencyUpdatenotificationMethodsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TripCreateselectedAgenciesInput = {
    set: string[]
  }

  export type PickupLocationCreateNestedOneWithoutTripsInput = {
    create?: XOR<PickupLocationCreateWithoutTripsInput, PickupLocationUncheckedCreateWithoutTripsInput>
    connectOrCreate?: PickupLocationCreateOrConnectWithoutTripsInput
    connect?: PickupLocationWhereUniqueInput
  }

  export type TripUpdateselectedAgenciesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type PickupLocationUpdateOneWithoutTripsNestedInput = {
    create?: XOR<PickupLocationCreateWithoutTripsInput, PickupLocationUncheckedCreateWithoutTripsInput>
    connectOrCreate?: PickupLocationCreateOrConnectWithoutTripsInput
    upsert?: PickupLocationUpsertWithoutTripsInput
    disconnect?: PickupLocationWhereInput | boolean
    delete?: PickupLocationWhereInput | boolean
    connect?: PickupLocationWhereUniqueInput
    update?: XOR<XOR<PickupLocationUpdateToOneWithWhereWithoutTripsInput, PickupLocationUpdateWithoutTripsInput>, PickupLocationUncheckedUpdateWithoutTripsInput>
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type PickupLocationCreateWithoutHospitalInput = {
    id?: string
    name: string
    description?: string | null
    contactPhone?: string | null
    contactEmail?: string | null
    floor?: string | null
    room?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    trips?: TripCreateNestedManyWithoutPickupLocationInput
  }

  export type PickupLocationUncheckedCreateWithoutHospitalInput = {
    id?: string
    name: string
    description?: string | null
    contactPhone?: string | null
    contactEmail?: string | null
    floor?: string | null
    room?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    trips?: TripUncheckedCreateNestedManyWithoutPickupLocationInput
  }

  export type PickupLocationCreateOrConnectWithoutHospitalInput = {
    where: PickupLocationWhereUniqueInput
    create: XOR<PickupLocationCreateWithoutHospitalInput, PickupLocationUncheckedCreateWithoutHospitalInput>
  }

  export type PickupLocationCreateManyHospitalInputEnvelope = {
    data: PickupLocationCreateManyHospitalInput | PickupLocationCreateManyHospitalInput[]
    skipDuplicates?: boolean
  }

  export type PickupLocationUpsertWithWhereUniqueWithoutHospitalInput = {
    where: PickupLocationWhereUniqueInput
    update: XOR<PickupLocationUpdateWithoutHospitalInput, PickupLocationUncheckedUpdateWithoutHospitalInput>
    create: XOR<PickupLocationCreateWithoutHospitalInput, PickupLocationUncheckedCreateWithoutHospitalInput>
  }

  export type PickupLocationUpdateWithWhereUniqueWithoutHospitalInput = {
    where: PickupLocationWhereUniqueInput
    data: XOR<PickupLocationUpdateWithoutHospitalInput, PickupLocationUncheckedUpdateWithoutHospitalInput>
  }

  export type PickupLocationUpdateManyWithWhereWithoutHospitalInput = {
    where: PickupLocationScalarWhereInput
    data: XOR<PickupLocationUpdateManyMutationInput, PickupLocationUncheckedUpdateManyWithoutHospitalInput>
  }

  export type PickupLocationScalarWhereInput = {
    AND?: PickupLocationScalarWhereInput | PickupLocationScalarWhereInput[]
    OR?: PickupLocationScalarWhereInput[]
    NOT?: PickupLocationScalarWhereInput | PickupLocationScalarWhereInput[]
    id?: StringFilter<"PickupLocation"> | string
    hospitalId?: StringFilter<"PickupLocation"> | string
    name?: StringFilter<"PickupLocation"> | string
    description?: StringNullableFilter<"PickupLocation"> | string | null
    contactPhone?: StringNullableFilter<"PickupLocation"> | string | null
    contactEmail?: StringNullableFilter<"PickupLocation"> | string | null
    floor?: StringNullableFilter<"PickupLocation"> | string | null
    room?: StringNullableFilter<"PickupLocation"> | string | null
    isActive?: BoolFilter<"PickupLocation"> | boolean
    createdAt?: DateTimeFilter<"PickupLocation"> | Date | string
    updatedAt?: DateTimeFilter<"PickupLocation"> | Date | string
  }

  export type HospitalCreateWithoutPickupLocationsInput = {
    id?: string
    name: string
    address: string
    city: string
    state: string
    zipCode: string
    phone?: string | null
    email?: string | null
    type: string
    capabilities?: HospitalCreatecapabilitiesInput | string[]
    region: string
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    latitude?: number | null
    longitude?: number | null
    operatingHours?: string | null
    isActive?: boolean
    requiresReview?: boolean
    approvedAt?: Date | string | null
    approvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HospitalUncheckedCreateWithoutPickupLocationsInput = {
    id?: string
    name: string
    address: string
    city: string
    state: string
    zipCode: string
    phone?: string | null
    email?: string | null
    type: string
    capabilities?: HospitalCreatecapabilitiesInput | string[]
    region: string
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    latitude?: number | null
    longitude?: number | null
    operatingHours?: string | null
    isActive?: boolean
    requiresReview?: boolean
    approvedAt?: Date | string | null
    approvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HospitalCreateOrConnectWithoutPickupLocationsInput = {
    where: HospitalWhereUniqueInput
    create: XOR<HospitalCreateWithoutPickupLocationsInput, HospitalUncheckedCreateWithoutPickupLocationsInput>
  }

  export type TripCreateWithoutPickupLocationInput = {
    id?: string
    tripNumber: string
    patientId: string
    patientWeight?: string | null
    specialNeeds?: string | null
    insuranceCompany?: string | null
    fromLocation: string
    toLocation: string
    scheduledTime: Date | string
    transportLevel: string
    urgencyLevel: string
    originLatitude?: number | null
    originLongitude?: number | null
    destinationLatitude?: number | null
    destinationLongitude?: number | null
    diagnosis?: string | null
    mobilityLevel?: string | null
    oxygenRequired?: boolean
    monitoringRequired?: boolean
    generateQRCode?: boolean
    qrCodeData?: string | null
    selectedAgencies?: TripCreateselectedAgenciesInput | string[]
    notificationRadius?: number | null
    transferRequestTime?: Date | string | null
    transferAcceptedTime?: Date | string | null
    emsArrivalTime?: Date | string | null
    emsDepartureTime?: Date | string | null
    tripCost?: Decimal | DecimalJsLike | number | string | null
    distanceMiles?: number | null
    responseTimeMinutes?: number | null
    deadheadMiles?: number | null
    insurancePayRate?: Decimal | DecimalJsLike | number | string | null
    perMileRate?: Decimal | DecimalJsLike | number | string | null
    requestTimestamp?: Date | string | null
    estimatedTripTimeMinutes?: number | null
    actualTripTimeMinutes?: number | null
    completionTimeMinutes?: number | null
    loadedMiles?: Decimal | DecimalJsLike | number | string | null
    customerSatisfaction?: number | null
    efficiency?: Decimal | DecimalJsLike | number | string | null
    performanceScore?: Decimal | DecimalJsLike | number | string | null
    revenuePerHour?: Decimal | DecimalJsLike | number | string | null
    backhaulOpportunity?: boolean
    actualStartTime?: Date | string | null
    actualEndTime?: Date | string | null
    status: string
    priority: string
    notes?: string | null
    assignedTo?: string | null
    assignedAgencyId?: string | null
    assignedUnitId?: string | null
    acceptedTimestamp?: Date | string | null
    pickupTimestamp?: Date | string | null
    completionTimestamp?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TripUncheckedCreateWithoutPickupLocationInput = {
    id?: string
    tripNumber: string
    patientId: string
    patientWeight?: string | null
    specialNeeds?: string | null
    insuranceCompany?: string | null
    fromLocation: string
    toLocation: string
    scheduledTime: Date | string
    transportLevel: string
    urgencyLevel: string
    originLatitude?: number | null
    originLongitude?: number | null
    destinationLatitude?: number | null
    destinationLongitude?: number | null
    diagnosis?: string | null
    mobilityLevel?: string | null
    oxygenRequired?: boolean
    monitoringRequired?: boolean
    generateQRCode?: boolean
    qrCodeData?: string | null
    selectedAgencies?: TripCreateselectedAgenciesInput | string[]
    notificationRadius?: number | null
    transferRequestTime?: Date | string | null
    transferAcceptedTime?: Date | string | null
    emsArrivalTime?: Date | string | null
    emsDepartureTime?: Date | string | null
    tripCost?: Decimal | DecimalJsLike | number | string | null
    distanceMiles?: number | null
    responseTimeMinutes?: number | null
    deadheadMiles?: number | null
    insurancePayRate?: Decimal | DecimalJsLike | number | string | null
    perMileRate?: Decimal | DecimalJsLike | number | string | null
    requestTimestamp?: Date | string | null
    estimatedTripTimeMinutes?: number | null
    actualTripTimeMinutes?: number | null
    completionTimeMinutes?: number | null
    loadedMiles?: Decimal | DecimalJsLike | number | string | null
    customerSatisfaction?: number | null
    efficiency?: Decimal | DecimalJsLike | number | string | null
    performanceScore?: Decimal | DecimalJsLike | number | string | null
    revenuePerHour?: Decimal | DecimalJsLike | number | string | null
    backhaulOpportunity?: boolean
    actualStartTime?: Date | string | null
    actualEndTime?: Date | string | null
    status: string
    priority: string
    notes?: string | null
    assignedTo?: string | null
    assignedAgencyId?: string | null
    assignedUnitId?: string | null
    acceptedTimestamp?: Date | string | null
    pickupTimestamp?: Date | string | null
    completionTimestamp?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TripCreateOrConnectWithoutPickupLocationInput = {
    where: TripWhereUniqueInput
    create: XOR<TripCreateWithoutPickupLocationInput, TripUncheckedCreateWithoutPickupLocationInput>
  }

  export type TripCreateManyPickupLocationInputEnvelope = {
    data: TripCreateManyPickupLocationInput | TripCreateManyPickupLocationInput[]
    skipDuplicates?: boolean
  }

  export type HospitalUpsertWithoutPickupLocationsInput = {
    update: XOR<HospitalUpdateWithoutPickupLocationsInput, HospitalUncheckedUpdateWithoutPickupLocationsInput>
    create: XOR<HospitalCreateWithoutPickupLocationsInput, HospitalUncheckedCreateWithoutPickupLocationsInput>
    where?: HospitalWhereInput
  }

  export type HospitalUpdateToOneWithWhereWithoutPickupLocationsInput = {
    where?: HospitalWhereInput
    data: XOR<HospitalUpdateWithoutPickupLocationsInput, HospitalUncheckedUpdateWithoutPickupLocationsInput>
  }

  export type HospitalUpdateWithoutPickupLocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    capabilities?: HospitalUpdatecapabilitiesInput | string[]
    region?: StringFieldUpdateOperationsInput | string
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    operatingHours?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requiresReview?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HospitalUncheckedUpdateWithoutPickupLocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    capabilities?: HospitalUpdatecapabilitiesInput | string[]
    region?: StringFieldUpdateOperationsInput | string
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    operatingHours?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requiresReview?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TripUpsertWithWhereUniqueWithoutPickupLocationInput = {
    where: TripWhereUniqueInput
    update: XOR<TripUpdateWithoutPickupLocationInput, TripUncheckedUpdateWithoutPickupLocationInput>
    create: XOR<TripCreateWithoutPickupLocationInput, TripUncheckedCreateWithoutPickupLocationInput>
  }

  export type TripUpdateWithWhereUniqueWithoutPickupLocationInput = {
    where: TripWhereUniqueInput
    data: XOR<TripUpdateWithoutPickupLocationInput, TripUncheckedUpdateWithoutPickupLocationInput>
  }

  export type TripUpdateManyWithWhereWithoutPickupLocationInput = {
    where: TripScalarWhereInput
    data: XOR<TripUpdateManyMutationInput, TripUncheckedUpdateManyWithoutPickupLocationInput>
  }

  export type TripScalarWhereInput = {
    AND?: TripScalarWhereInput | TripScalarWhereInput[]
    OR?: TripScalarWhereInput[]
    NOT?: TripScalarWhereInput | TripScalarWhereInput[]
    id?: StringFilter<"Trip"> | string
    tripNumber?: StringFilter<"Trip"> | string
    patientId?: StringFilter<"Trip"> | string
    patientWeight?: StringNullableFilter<"Trip"> | string | null
    specialNeeds?: StringNullableFilter<"Trip"> | string | null
    insuranceCompany?: StringNullableFilter<"Trip"> | string | null
    fromLocation?: StringFilter<"Trip"> | string
    pickupLocationId?: StringNullableFilter<"Trip"> | string | null
    toLocation?: StringFilter<"Trip"> | string
    scheduledTime?: DateTimeFilter<"Trip"> | Date | string
    transportLevel?: StringFilter<"Trip"> | string
    urgencyLevel?: StringFilter<"Trip"> | string
    originLatitude?: FloatNullableFilter<"Trip"> | number | null
    originLongitude?: FloatNullableFilter<"Trip"> | number | null
    destinationLatitude?: FloatNullableFilter<"Trip"> | number | null
    destinationLongitude?: FloatNullableFilter<"Trip"> | number | null
    diagnosis?: StringNullableFilter<"Trip"> | string | null
    mobilityLevel?: StringNullableFilter<"Trip"> | string | null
    oxygenRequired?: BoolFilter<"Trip"> | boolean
    monitoringRequired?: BoolFilter<"Trip"> | boolean
    generateQRCode?: BoolFilter<"Trip"> | boolean
    qrCodeData?: StringNullableFilter<"Trip"> | string | null
    selectedAgencies?: StringNullableListFilter<"Trip">
    notificationRadius?: IntNullableFilter<"Trip"> | number | null
    transferRequestTime?: DateTimeNullableFilter<"Trip"> | Date | string | null
    transferAcceptedTime?: DateTimeNullableFilter<"Trip"> | Date | string | null
    emsArrivalTime?: DateTimeNullableFilter<"Trip"> | Date | string | null
    emsDepartureTime?: DateTimeNullableFilter<"Trip"> | Date | string | null
    tripCost?: DecimalNullableFilter<"Trip"> | Decimal | DecimalJsLike | number | string | null
    distanceMiles?: FloatNullableFilter<"Trip"> | number | null
    responseTimeMinutes?: IntNullableFilter<"Trip"> | number | null
    deadheadMiles?: FloatNullableFilter<"Trip"> | number | null
    insurancePayRate?: DecimalNullableFilter<"Trip"> | Decimal | DecimalJsLike | number | string | null
    perMileRate?: DecimalNullableFilter<"Trip"> | Decimal | DecimalJsLike | number | string | null
    requestTimestamp?: DateTimeNullableFilter<"Trip"> | Date | string | null
    estimatedTripTimeMinutes?: IntNullableFilter<"Trip"> | number | null
    actualTripTimeMinutes?: IntNullableFilter<"Trip"> | number | null
    completionTimeMinutes?: IntNullableFilter<"Trip"> | number | null
    loadedMiles?: DecimalNullableFilter<"Trip"> | Decimal | DecimalJsLike | number | string | null
    customerSatisfaction?: IntNullableFilter<"Trip"> | number | null
    efficiency?: DecimalNullableFilter<"Trip"> | Decimal | DecimalJsLike | number | string | null
    performanceScore?: DecimalNullableFilter<"Trip"> | Decimal | DecimalJsLike | number | string | null
    revenuePerHour?: DecimalNullableFilter<"Trip"> | Decimal | DecimalJsLike | number | string | null
    backhaulOpportunity?: BoolFilter<"Trip"> | boolean
    actualStartTime?: DateTimeNullableFilter<"Trip"> | Date | string | null
    actualEndTime?: DateTimeNullableFilter<"Trip"> | Date | string | null
    status?: StringFilter<"Trip"> | string
    priority?: StringFilter<"Trip"> | string
    notes?: StringNullableFilter<"Trip"> | string | null
    assignedTo?: StringNullableFilter<"Trip"> | string | null
    assignedAgencyId?: StringNullableFilter<"Trip"> | string | null
    assignedUnitId?: StringNullableFilter<"Trip"> | string | null
    acceptedTimestamp?: DateTimeNullableFilter<"Trip"> | Date | string | null
    pickupTimestamp?: DateTimeNullableFilter<"Trip"> | Date | string | null
    completionTimestamp?: DateTimeNullableFilter<"Trip"> | Date | string | null
    createdAt?: DateTimeFilter<"Trip"> | Date | string
    updatedAt?: DateTimeFilter<"Trip"> | Date | string
  }

  export type PickupLocationCreateWithoutTripsInput = {
    id?: string
    name: string
    description?: string | null
    contactPhone?: string | null
    contactEmail?: string | null
    floor?: string | null
    room?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    hospital: HospitalCreateNestedOneWithoutPickupLocationsInput
  }

  export type PickupLocationUncheckedCreateWithoutTripsInput = {
    id?: string
    hospitalId: string
    name: string
    description?: string | null
    contactPhone?: string | null
    contactEmail?: string | null
    floor?: string | null
    room?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PickupLocationCreateOrConnectWithoutTripsInput = {
    where: PickupLocationWhereUniqueInput
    create: XOR<PickupLocationCreateWithoutTripsInput, PickupLocationUncheckedCreateWithoutTripsInput>
  }

  export type PickupLocationUpsertWithoutTripsInput = {
    update: XOR<PickupLocationUpdateWithoutTripsInput, PickupLocationUncheckedUpdateWithoutTripsInput>
    create: XOR<PickupLocationCreateWithoutTripsInput, PickupLocationUncheckedCreateWithoutTripsInput>
    where?: PickupLocationWhereInput
  }

  export type PickupLocationUpdateToOneWithWhereWithoutTripsInput = {
    where?: PickupLocationWhereInput
    data: XOR<PickupLocationUpdateWithoutTripsInput, PickupLocationUncheckedUpdateWithoutTripsInput>
  }

  export type PickupLocationUpdateWithoutTripsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hospital?: HospitalUpdateOneRequiredWithoutPickupLocationsNestedInput
  }

  export type PickupLocationUncheckedUpdateWithoutTripsInput = {
    id?: StringFieldUpdateOperationsInput | string
    hospitalId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PickupLocationCreateManyHospitalInput = {
    id?: string
    name: string
    description?: string | null
    contactPhone?: string | null
    contactEmail?: string | null
    floor?: string | null
    room?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PickupLocationUpdateWithoutHospitalInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trips?: TripUpdateManyWithoutPickupLocationNestedInput
  }

  export type PickupLocationUncheckedUpdateWithoutHospitalInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trips?: TripUncheckedUpdateManyWithoutPickupLocationNestedInput
  }

  export type PickupLocationUncheckedUpdateManyWithoutHospitalInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TripCreateManyPickupLocationInput = {
    id?: string
    tripNumber: string
    patientId: string
    patientWeight?: string | null
    specialNeeds?: string | null
    insuranceCompany?: string | null
    fromLocation: string
    toLocation: string
    scheduledTime: Date | string
    transportLevel: string
    urgencyLevel: string
    originLatitude?: number | null
    originLongitude?: number | null
    destinationLatitude?: number | null
    destinationLongitude?: number | null
    diagnosis?: string | null
    mobilityLevel?: string | null
    oxygenRequired?: boolean
    monitoringRequired?: boolean
    generateQRCode?: boolean
    qrCodeData?: string | null
    selectedAgencies?: TripCreateselectedAgenciesInput | string[]
    notificationRadius?: number | null
    transferRequestTime?: Date | string | null
    transferAcceptedTime?: Date | string | null
    emsArrivalTime?: Date | string | null
    emsDepartureTime?: Date | string | null
    tripCost?: Decimal | DecimalJsLike | number | string | null
    distanceMiles?: number | null
    responseTimeMinutes?: number | null
    deadheadMiles?: number | null
    insurancePayRate?: Decimal | DecimalJsLike | number | string | null
    perMileRate?: Decimal | DecimalJsLike | number | string | null
    requestTimestamp?: Date | string | null
    estimatedTripTimeMinutes?: number | null
    actualTripTimeMinutes?: number | null
    completionTimeMinutes?: number | null
    loadedMiles?: Decimal | DecimalJsLike | number | string | null
    customerSatisfaction?: number | null
    efficiency?: Decimal | DecimalJsLike | number | string | null
    performanceScore?: Decimal | DecimalJsLike | number | string | null
    revenuePerHour?: Decimal | DecimalJsLike | number | string | null
    backhaulOpportunity?: boolean
    actualStartTime?: Date | string | null
    actualEndTime?: Date | string | null
    status: string
    priority: string
    notes?: string | null
    assignedTo?: string | null
    assignedAgencyId?: string | null
    assignedUnitId?: string | null
    acceptedTimestamp?: Date | string | null
    pickupTimestamp?: Date | string | null
    completionTimestamp?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TripUpdateWithoutPickupLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripNumber?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    patientWeight?: NullableStringFieldUpdateOperationsInput | string | null
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceCompany?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocation?: StringFieldUpdateOperationsInput | string
    toLocation?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    transportLevel?: StringFieldUpdateOperationsInput | string
    urgencyLevel?: StringFieldUpdateOperationsInput | string
    originLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    originLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    mobilityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    oxygenRequired?: BoolFieldUpdateOperationsInput | boolean
    monitoringRequired?: BoolFieldUpdateOperationsInput | boolean
    generateQRCode?: BoolFieldUpdateOperationsInput | boolean
    qrCodeData?: NullableStringFieldUpdateOperationsInput | string | null
    selectedAgencies?: TripUpdateselectedAgenciesInput | string[]
    notificationRadius?: NullableIntFieldUpdateOperationsInput | number | null
    transferRequestTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferAcceptedTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emsArrivalTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emsDepartureTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tripCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    distanceMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    responseTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    deadheadMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    insurancePayRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    perMileRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    requestTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedTripTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    actualTripTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    completionTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    loadedMiles?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    customerSatisfaction?: NullableIntFieldUpdateOperationsInput | number | null
    efficiency?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    performanceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    revenuePerHour?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    backhaulOpportunity?: BoolFieldUpdateOperationsInput | boolean
    actualStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAgencyId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TripUncheckedUpdateWithoutPickupLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripNumber?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    patientWeight?: NullableStringFieldUpdateOperationsInput | string | null
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceCompany?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocation?: StringFieldUpdateOperationsInput | string
    toLocation?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    transportLevel?: StringFieldUpdateOperationsInput | string
    urgencyLevel?: StringFieldUpdateOperationsInput | string
    originLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    originLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    mobilityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    oxygenRequired?: BoolFieldUpdateOperationsInput | boolean
    monitoringRequired?: BoolFieldUpdateOperationsInput | boolean
    generateQRCode?: BoolFieldUpdateOperationsInput | boolean
    qrCodeData?: NullableStringFieldUpdateOperationsInput | string | null
    selectedAgencies?: TripUpdateselectedAgenciesInput | string[]
    notificationRadius?: NullableIntFieldUpdateOperationsInput | number | null
    transferRequestTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferAcceptedTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emsArrivalTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emsDepartureTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tripCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    distanceMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    responseTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    deadheadMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    insurancePayRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    perMileRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    requestTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedTripTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    actualTripTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    completionTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    loadedMiles?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    customerSatisfaction?: NullableIntFieldUpdateOperationsInput | number | null
    efficiency?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    performanceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    revenuePerHour?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    backhaulOpportunity?: BoolFieldUpdateOperationsInput | boolean
    actualStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAgencyId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TripUncheckedUpdateManyWithoutPickupLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripNumber?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    patientWeight?: NullableStringFieldUpdateOperationsInput | string | null
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceCompany?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocation?: StringFieldUpdateOperationsInput | string
    toLocation?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    transportLevel?: StringFieldUpdateOperationsInput | string
    urgencyLevel?: StringFieldUpdateOperationsInput | string
    originLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    originLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    mobilityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    oxygenRequired?: BoolFieldUpdateOperationsInput | boolean
    monitoringRequired?: BoolFieldUpdateOperationsInput | boolean
    generateQRCode?: BoolFieldUpdateOperationsInput | boolean
    qrCodeData?: NullableStringFieldUpdateOperationsInput | string | null
    selectedAgencies?: TripUpdateselectedAgenciesInput | string[]
    notificationRadius?: NullableIntFieldUpdateOperationsInput | number | null
    transferRequestTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferAcceptedTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emsArrivalTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emsDepartureTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tripCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    distanceMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    responseTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    deadheadMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    insurancePayRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    perMileRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    requestTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedTripTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    actualTripTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    completionTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    loadedMiles?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    customerSatisfaction?: NullableIntFieldUpdateOperationsInput | number | null
    efficiency?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    performanceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    revenuePerHour?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    backhaulOpportunity?: BoolFieldUpdateOperationsInput | boolean
    actualStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAgencyId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use HospitalCountOutputTypeDefaultArgs instead
     */
    export type HospitalCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HospitalCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PickupLocationCountOutputTypeDefaultArgs instead
     */
    export type PickupLocationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PickupLocationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CenterUserDefaultArgs instead
     */
    export type CenterUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CenterUserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HospitalDefaultArgs instead
     */
    export type HospitalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HospitalDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PickupLocationDefaultArgs instead
     */
    export type PickupLocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PickupLocationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EMSAgencyDefaultArgs instead
     */
    export type EMSAgencyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EMSAgencyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TripDefaultArgs instead
     */
    export type TripArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TripDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SystemAnalyticsDefaultArgs instead
     */
    export type SystemAnalyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SystemAnalyticsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use pricingModelDefaultArgs instead
     */
    export type pricingModelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = pricingModelDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BackhaulOpportunitiesDefaultArgs instead
     */
    export type BackhaulOpportunitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BackhaulOpportunitiesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UnitAnalyticsDefaultArgs instead
     */
    export type UnitAnalyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UnitAnalyticsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RouteOptimizationSettingsDefaultArgs instead
     */
    export type RouteOptimizationSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RouteOptimizationSettingsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TripCostBreakdownDefaultArgs instead
     */
    export type TripCostBreakdownArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TripCostBreakdownDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CostCenterDefaultArgs instead
     */
    export type CostCenterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CostCenterDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}